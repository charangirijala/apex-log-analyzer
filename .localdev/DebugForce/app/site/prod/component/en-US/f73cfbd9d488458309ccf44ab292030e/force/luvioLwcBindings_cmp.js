(function() { LWR.define("force/luvioLwcBindings",["exports"],function(t){class e extends Error{}class n extends e{}class i extends e{}class s extends e{}class r extends e{}class a extends e{}function o(t,c,h="$"){if(!0===c)return;if(!1===c)throw new e(`Data at ${h} has schema 'false'`);const u=typeof t,l=null===t?"null":Array.isArray(t)?"array":u,f=new s(`Data type at path '${h}' does not match JSONSchema. Expected ${c.type}, got ${l}.`);if("anyOf"in c)!function(t,n,i){let s=!1;if(n.anyOf.forEach(e=>{try{o(t,e),s=!0}catch(t){}}),!s)throw new e(`Data at ${i} did not match any subschema in anyOf.`)}(t,c,h);else if("object"===c.type){if("object"!==l)throw f;!function(t,e,n){const i=Object.keys(e.properties),s=new Set(e.required);if(!e.additionalProperties){const e=new Set(i),s=Object.keys(t).filter(t=>!e.has(t));if(s.length>0)throw new r(`Object at path '${n}' contains unallowed additionalProperties: ${s}.`)}for(let r=0,c=i.length;r<c;r++){const c=i[r],h=c in t&&void 0!==t[c];if(s.has(c)&&!h)throw new a(`Object at path '${n}' is missing required property '${c}'.`);h&&o(t[c],e.properties[c],`${n}.${c}`)}}(t,c,h)}else if("array"===c.type){if("array"!==l)throw f;!function(t,e,s){if(void 0!==e.minItems&&t.length<e.minItems)throw new n(`Array at path '${s}' fails minItems constraint. Has ${t.length} items, needs at least ${e.minItems}.`);if(void 0!==e.maxItems&&t.length>e.maxItems)throw new i(`Array at path '${s}' fails maxItems constraint. Has ${t.length} items, needs at most ${e.maxItems}.`);t.forEach((t,n)=>o(t,e.items,`${s}[${n}]`))}(t,c,h)}else!function(t,e,n){const i=e.type,r=typeof t,a=new s(`Expected type ${i} at path '${n}'. Got type ${r}.`);if("integer"===i){if("number"!==r||!Number.isInteger(t))throw a}else if("number"===i){if("number"!==r)throw a}else if("string"===i){if("string"!==r)throw a}else if("boolean"===i){if("boolean"!==r)throw a}else{if("null"!==i)throw new s(`Unknown schema data type: ${i}.`);if(null!==t)throw a}}(t,c,h)}class c{constructor(t){this.obj=t,this.copy={},this.currentPath={key:"",value:t,parent:null,data:this.copy}}sanitize(){const t=this;return JSON.stringify(this.obj,function(e,n){if(""===e)return n;const i=this;return i!==t.currentPath.value&&t.exit(i),"object"==typeof n&&null!==n?(t.enter(e,n),n):(t.currentPath.data[e]=n,n)}),this.copy}enter(t,e){const{currentPath:n}=this,i=n.data[t]=Array.isArray(e)?[]:{};this.currentPath={key:t,value:e,parent:n,data:i}}exit(t){for(;this.currentPath.value!==t;)this.currentPath=this.currentPath.parent||this.currentPath}}t.CommandWireAdapterConstructor=class{constructor(t){this.callback=t,this.connected=!1,this.emit()}connect(){this.connected=!0,this.invokeAdapter()}disconnect(){this.unsubscribe(),this.connected=!1}update(t,e){this.unsubscribe(),this.config=new c(t).sanitize(),this.invokeAdapter()}emit(t){try{void 0===t?this.callback({data:void 0,error:void 0}):this.callback({data:t.data,error:t.errors.length>0?t.errors[0]:void 0})}catch(t){throw(e=t)instanceof Error?e:new Error(`${e}`)}var e}invokeAdapter(){if(!this.connected||void 0===this.config)return;const t=this.config,e=this.getCommand();try{o(this.config,e.configJsonSchema)}catch(t){return}e.execute().then(e=>{this.connected&&this.config===t&&(this.emit(e),"subscribe"in e&&(this.unsubscriber=e.subscribe(e=>{this.connected&&this.config===t?this.emit(e):this.unsubscribe()})))})}unsubscribe(){this.unsubscriber&&(this.unsubscriber(),delete this.unsubscriber)}},Object.defineProperty(t,"__esModule",{value:!0})});
})();