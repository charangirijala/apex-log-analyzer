LWR.define('@salesforce/community/basePath', ['@app/basePath'], function(m) { return m && typeof m === 'object' && 'default' in m ? m.default : m; });
LWR.define('@salesforce/community/Id', [], function() { return "0DBHy0000005ZrLOAU"; });
(function() { LWR.define('dxp_util/common', ['exports'], (function (exports) {

    /**
     * Creates a debounced function that delays invoking `func` until after
     * `delay` milliseconds have elapsed since the last time the debounced function was invoked.
     *
     * @function debounce
     * @param {Function} func - The function to debounce
     * @param {number} delay - The number of milliseconds to delay
     * @param {object} options - The options object
     * @param {boolean} options.leading - Specify invoking on the leading edge of the timeout
     * @returns {Function} - debounced function
     */
    function debounce(func, delay, options) {
      const _options = options || {};
      let invokeLeading = _options.leading;
      let timer;
      return function debounced() {
        const args = Array.prototype.slice.apply(arguments);
        if (invokeLeading) {
          func.apply(this, args);
          invokeLeading = false;
        }
        clearTimeout(timer);
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        timer = setTimeout(function () {
          func.apply(this, args);
          invokeLeading = _options.leading; // reset for next debounce sequence
        }, delay);
      };
    }

    const KeyCodes = {
      tab: 9,
      backspace: 8,
      enter: 13,
      escape: 27,
      space: 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      delete: 46,
      shift: 16
    };

    /**
     * Functional Try/Catch handler
     *
     * @param {Function} tryFunc function may throw exception
     * @param {Function} catchFunc function to handle exception
     * @returns {object} result
     */
    function tryCatch(tryFunc, catchFunc) {
      return function fpTryCatch() {
        try {
          return tryFunc.apply(this, arguments);
        } catch (error) {
          return catchFunc?.apply(this, [error].concat(arguments));
        }
      };
    }

    /**
     * Safe parse a json string
     * JSON.parse => https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
     *
     * @param {string} json The string to parse as JSON. See the JSON object for a description of JSON syntax.
     * @param {boolean} fallBackInput if fallBackInput is true, then return the input.
     * @param {Function} reviver If a function, this prescribes how the value originally produced by parsing is transformed, before being returned.
     * @returns {object} The Object, Array, string, number, boolean, or null value corresponding to the given JSON text.
     */
    function safeParseJson(json, reviver) {
      if (typeof json !== "string") {
        return json ?? {};
      }
      return tryCatch(JSON.parse, reviver)(json) ?? {};
    }

    /**
     * Stringify object and remove empty values
     *
     * @param {object} obj object to stringify
     * @returns {string} stringified object
     */
    function stringify(obj) {
      return JSON.stringify(obj, (key, value) => value ? value : undefined);
    }

    /**
     * Create a deep copy of an object or array (borrow from base components)
     *
     * @param {object|Array} obj - item to be copied
     * @returns {object|Array} copy of the item
     */
    function deepCopy(obj) {
      if (Object(obj) !== obj) {
        // primitives
        return obj;
      }
      if (obj instanceof Set) {
        return new Set(obj);
      }
      if (obj instanceof Date) {
        return new Date(obj);
      }
      if (typeof obj === "function") {
        return obj.bind({});
      }
      if (Array.isArray(obj)) {
        const obj2 = [];
        const len = obj.length;
        for (let i = 0; i < len; i++) {
          obj2.push(deepCopy(obj[i]));
        }
        return obj2;
      }
      const result = Object.create({});
      let keys = Object.keys(obj);
      if (obj instanceof Error) {
        // Error properties are non-enumerable
        keys = Object.getOwnPropertyNames(obj);
      }
      const len = keys.length;
      for (let i = 0; i < len; i++) {
        const key = keys[i];
        result[key] = deepCopy(obj[key]);
      }
      return result;
    }

    /**
     * Deep merge two objects
     *
     * e.g. deepMerge({a: {a: 1}}, {a: {b: 2}}
     * should return {a: {a: 1, b: 2}}
     *
     * Object.assign does not do deep merge
     * and returns {a: {b: 2}}
     *
     * We could have use lodash merge method but
     * security locker is not allowing it to be
     *
     * @param {object} target target object where merge needed
     * @param {object} sources objects that need to be merged
     * @returns {object} deep merged object
     */
    function deepMerge(target, ...sources) {
      if (!sources.length) {
        return target;
      }
      const source = sources.shift();
      if (isObject(target) && isObject(source)) {
        for (const key in source) {
          if (isObject(source[key])) {
            if (!target[key]) {
              Object.assign(target, {
                [key]: {}
              });
            }
            deepMerge(target[key], source[key]);
          } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
            target[key] = [...target[key], ...source[key]];
          } else {
            Object.assign(target, {
              [key]: source[key]
            });
          }
        }
      }
      return deepMerge(target, ...sources);
    }

    /**
     * Returns if passed value is an object or not
     *
     * @param {object} key
     * @returns true/false
     */
    function isObject(key) {
      return key && typeof key === "object" && !Array.isArray(key);
    }

    /**
     * Simple pipe functional operator
     *
     * @example
     *      pipe(f, g)(v) ===  g(f(v))
     *
     * @param  {...Function} functions functions to be connected
     * @returns {Function} piped function sequence
     */
    const pipe = (...functions) => value => {
      return functions.filter(func => typeof func === "function") // filter out non function
      .reduce((currentValue, currentFunction) => {
        return currentFunction(currentValue);
      }, value);
    };

    /**
     * Simple compose functional operator
     *
     * @example
     *      compose(f, g)(v) ===  f(g(v))
     *
     * @param  {...Function} functions functions to be connected
     * @returns {Function} composed function sequence
     */
    const compose = (...functions) => value => functions.filter(func => typeof func === "function") // filter out non function
    .reduceRight((currentValue, currentFunction) => currentFunction(currentValue), value);

    /**
     * Build forEach functional operator with given function for array
     *
     * @param {Function} action action to be executed in forEach
     * @returns {Function} forEach operator tied to given action
     */
    const forEach = action => items => items.forEach(action);

    /**
     * Build find functional operator with given function for array
     *
     * @param {Function} action action to be executed in find
     * @returns {Function} find operator tied to given action
     */
    const find = action => items => items.find(action);

    /**
     * Build filter functional operator with given function for array
     *
     * @param {Function} action action to be executed in filter
     * @returns {Function} filter operator tied to given action
     */
    const filter = action => items => items.filter(action);

    /**
     * Build map functional operator with given function for array
     *
     * @param {Function} action action to be executed in map
     * @returns {Function} map operator tied to given action
     */
    const map = action => items => items.map(action);

    /**
     * Build every functional operator with given function for array
     *
     * @param {Function} action action to be executed in map
     * @returns {Function} every operator tied to given action
     */
    const every = action => items => items.every(action);

    /**
     * Enumerate all keys of given object
     *
     * @param {Function} action action to be executed
     * @returns {Function} forEachKey operator tied to given action
     */
    const forEachKey = action => items => Object.keys(items).forEach(action);

    /**
     * Every key of given object
     *
     * @param {Function} action action to be executed
     * @returns {Function} everyKey operator tied to given action
     */
    const everyKey = action => items => compose(every(action), Object.keys)(items);

    /**
     * Merge two records and return the merged record with unique items
     *
     * @param {object[]} firstRecord First record
     * @param {object[]} secondRecord Second record
     * @param {string} identifier key based on which the records uniqueness is determined
     * @returns {object[]} Array of merged records
     */
    function mergeUniqueRecords(firstRecord, secondRecord, identifier) {
      const left = Array.isArray(firstRecord) ? firstRecord : [];
      const right = Array.isArray(secondRecord) ? secondRecord : [];
      const nonDups = right.filter(record => {
        const duplicateIndex = left.findIndex(item => item[identifier] === record[identifier]);
        if (duplicateIndex >= 0) {
          left[duplicateIndex] = record;
        }
        return duplicateIndex < 0;
      });
      return left.concat(nonDups);
    }

    /**
     * Takes a function with n arguments and transforms it into n functions that each take a single argument aka curried function.
     *
     * @param {Function} func with n arguments
     * @returns {Function}the result of applied function or a function that accepts remaining arguments
     */
    const curry = func => {
      return function curried(...args) {
        if (args.length >= func.length) {
          return func.apply(this, args);
        }
        return (...args2) => {
          return curried.apply(this, args.concat(args2));
        };
      };
    };

    /**
     * Check if given statement is a function
     *
     * @param {string} statement statement to be checked
     * @returns {boolean} whether given value is a function
     */
    function isFunction(statement) {
      return typeof statement === "function";
    }

    /**
     * Call statement if it is a function, or return the statement
     *
     * @param {Function|boolean} statement statement to be called
     * @returns {any} result of the statement
     */
    const callOrReturn = statement => {
      return isFunction(statement) ? statement() : statement;
    };

    /**
     * Execute then function or else function based on value of the condition
     *
     * @param {Function|boolean} fnCondition condition to be checked
     * @param {Function|any} fnThen then function to be executed
     * @param {Function|any} fnElse else function to be executed
     * @returns {any}
     */
    const ifElse = curry((fnCondition, fnThen, fnElse) => {
      return callOrReturn(fnCondition) ? callOrReturn(fnThen) : callOrReturn(fnElse);
    });

    /**
     * Execute given function if given statement is a function
     *
     * @param {Function|boolean} fnCondition condition to be checked
     * @param {Function|object} fnThen statement to be executed if condition is true
     * @returns {any} statement or function result
     */
    const ifVal = curry((fnCondition, fnThen) => {
      return ifElse(fnCondition, fnThen, null);
    });
    const apply$1 = value => func => func(value);

    /**
     * Execute functions return true if one of them is passed
     *
     * @param {...Function} funcs funcs to be applied
     * @returns {boolean} true one function is passed
     */
    const or = (...funcs) => value => funcs?.filter(isFunction).some(apply$1(value));

    /**
     * Execute functions return true if all are passed
     *
     * @param {Function[]} funcs funcs to be applied
     * @returns {boolean} true when all  are passed
     */
    const and = (...funcs) => value => funcs?.filter(isFunction).every(apply$1(value));

    /**
     * Detects the Data Type and returns if its Primitive Type or not
     * https://developer.mozilla.org/en-US/docs/Glossary/Primitive
     *
     * @param {*} data input Data
     * @returns {boolean} returns true if Primitive Data Type else false
     */
    function isPrimitive(data) {
      return data !== Object(data);
    }

    /**
     * Custom Typeof method to determine the data type of an array rather an object.
     *
     * @param {*} data input Data
     * @returns {string} the type of the data
     */
    function typeOf(data) {
      return Array.isArray(data) ? "array" : typeof data;
    }

    /**
     * Get value of given key from given object
     *
     * @param {object} obj object to be searched
     * @param {string} path path to be searched
     * @returns {any} value of given key
     */
    const get = curry((obj, path) => {
      if (empty(path)) {
        return obj;
      }
      const steps = path.split(".");
      let current = obj ?? {};
      let i = 0;
      for (i = 0; i < steps.length - 1; i++) {
        if (empty(current[steps[i]])) {
          return null;
        }
        current = current[steps[i]];
      }
      return current[steps[i]];
    });

    /**
     * Set value of given key in given object
     *
     * @param {object} obj object to be searched
     * @param {string} path path to be searched
     * @param {any} value value of given key
     */
    const set = curry((obj, path, value) => {
      if (empty(path)) {
        return;
      }
      const steps = path.split(".");
      let current = obj;
      let i = 0;
      for (i = 0; i < steps.length - 1; i++) {
        current[steps[i]] = current[steps[i]] || {};
        current = current[steps[i]];
      }
      current[steps[i]] = value;
    });

    /**
     * Set value of given key in src object to value of given key in dest object
     *
     * @param {object} src source object
     * @param {object} dest destination object
     * @param {string} srcKey source key
     * @param {string} destKey destination key
     */
    const mapping = curry((src, dest, srcKey, destKey) => {
      const value = get(src, srcKey);
      set(dest, destKey, value);
    });

    /**
     * Merge src object's path value to dest object's path value
     *
     * @param {object} src source object
     * @param {object} dest destination object
     * @param {object} mapper mapper of attribtues
     * @param {boolean}  reverseMapper whether to use value/key instead of key/value
     * @returns {object} updated dest object
     */
    function mapObject(src, dest, mapper, reverseMapper) {
      forEachKey(key => {
        if (reverseMapper) {
          mapping(src, dest, mapper[key], key);
        } else {
          mapping(src, dest, key, mapper[key]);
        }
      })(mapper ?? {});
      return dest;
    }

    /**
     * Invoke a method on given object
     *
     * @param  {...any} args arguments to be passed to the method
     * @returns {object} returned from method or null
     */
    function apply(...args) {
      const [obj, method, ...rest] = args;
      return obj?.[method]?.apply(obj, rest);
    }

    /**
     * Create index array from given count
     *
     * @param {number} count how many index
     * @returns {number[]} [1, 2, 3, ... count]
     */
    const toIndexes = count => [...Array(count).keys()];
    const notEmpty = value => !empty(value);

    /**
     * Check if given value is empty
     *  "", [], null, undefined, {} is treated as empty
     *
     * @param {any} value value to check
     * @returns {boolean} whether value is empty
     */
    function empty(value) {
      if (Array.isArray(value)) {
        return value.length === 0;
      }
      const type = typeof value;
      switch (type) {
        case "string":
          return value === "";
        case "boolean":
        case "number":
        case "function":
          return false;
        case "object":
          return Object.keys(value ?? {}).length === 0;
        default:
          return value == null;
      }
    }

    /**
     * Check if given property is defined in given object
     *
     * @param {object} object object to evaluate
     * @param {string} property property name
     * @returns {boolean} whether property is defined on object
     */
    function hasOwnProperty(object, property = "") {
      return Object.prototype.hasOwnProperty.call(object ?? {}, property);
    }
    const SFDC_DEFAULT = "__sfdc_default__";
    /**
     * Path given resolve, to avoid empty function
     *
     * @param {object} resolver give resolver
     * @returns {object} patched resolver
     */
    function patchResolver(resolver) {
      return {
        patchRecord: true,
        getter: (target, key) => () => get(target, key),
        ...resolver
      };
    }
    /**
     * Check if given field is spanning field
     *
     * @param {object} field field to check
     * @returns {boolean} true if field is spanning field
     */
    function isSpanningField(field) {
      return notEmpty(field?.value?.fields);
    }

    /**
     * Return field displayValue or value or field itself
     *
     * @param {object} field field to get value
     * @returns {any} field displayValue or value or field itself
     */
    function fieldToValue(field) {
      return field?.displayValue || field?.value || field;
    }

    /**
     * Return field value or empty string
     *
     * @param {object} field target field to get value
     * @param {any} value field's value
     * @returns {any} when field's displayValue and value are both null return empty string
     *                otherwise return value
     */
    function safeFieldValue(field, value) {
      if (isField(field)) {
        return value ?? "";
      }
      return value;
    }

    /**
     * Check if field has null value
     *
     * @param {object} propertyValue field value
     * @returns {boolean} whether it's a null value of field
     */
    function isField(propertyValue) {
      return typeof propertyValue === "object" && !Array.isArray(propertyValue) && hasOwnProperty(propertyValue, "value") && hasOwnProperty(propertyValue, "displayValue");
    }

    /**
     * Convert a plain object to getify
     *
     * @param {object} object to be getified
     * @param {object} resolver getter/setter resolver
     * @param {object} parent parent object to apply property
     * @returns {object} getified object
     */
    function getify(object, resolver, parent = {}) {
      if (empty(object) || isPrimitive(object) || isFunction(object)) {
        return object;
      }
      resolver = patchResolver(resolver);
      if (Array.isArray(object)) {
        return object.map(item => getify(item, resolver));
      }
      return Object.entries(object).reduce((initial, entry) => {
        const [key, value] = entry;
        const type = typeof value;
        if (isPrimitive(value)) {
          Object.defineProperty(initial, key, {
            get() {
              return resolver.getter(object, key)();
            },
            enumerable: true
          });
        } else if (Array.isArray(value)) {
          initial[key] = value.map(item => getify(item, resolver));
        } else if (isFunction(value)) {
          initial[key] = value;
        }
        // istanbul ignore else
        else if (type === "object") {
          const obj = {};
          if (resolver.patchRecord) {
            Object.defineProperties(obj, {
              [SFDC_DEFAULT]: {
                get() {
                  return safeFieldValue(value, resolver.getter(object, key)());
                },
                enumerable: true
              },
              _rawValue: {
                get() {
                  return resolver.getter(obj, "value")();
                },
                enumerable: true
              },
              _displayValue: {
                get() {
                  return resolver.getter(obj, "displayValue")();
                },
                enumerable: true
              }
            });
          }
          getify(value, resolver, obj);
          if (isSpanningField(obj)) {
            const fields = obj.value.fields;
            Object.entries(fields).forEach(field => {
              const [fieldName, fieldInfo] = field;

              // Don't override existing property
              if (!hasOwnProperty(obj, fieldName)) {
                Object.defineProperty(obj, fieldName, {
                  get() {
                    // if field is spanning field, return itself
                    if (isSpanningField(fieldInfo)) {
                      return fieldInfo;
                    }

                    // if field is not spanning field, return displayValue or value or itself
                    return fieldToValue(fieldInfo);
                  },
                  enumerable: true
                });
              }
            });
          }
          // Lock will block defineProperties from return value. Or it's proxied, can use defineProperties at all
          // But for argument locker didn't touch it, so we can still use defineProperties on it.
          initial[key] = obj;
        }
        return initial;
      }, parent);
    }

    /**
     * Returns the number in the range of the min and the max value
     * If the input value is less than min, returns the min
     * If the input value is greater than max, returns the max.
     *
     * @function range
     * @param {number} value - The input value to range
     * @param {number} min -  The minimum number
     * @param {number} max - The maximum number
     * @returns {number} - returns the number in the range
     */
    function range(value, min, max) {
      const number = Number.parseInt(value, 10);
      if (number < min) {
        return min;
      }
      if (number > max) {
        return max;
      }
      return number;
    }

    /**
     * Validates if the given value is a number
     * The function supports the validation of
     * decimal, binary and hexadecimal numbers
     *
     * @param {any} value The value to be validated
     * @returns {boolean} True if the value is a number, otherwise False
     */
    function isNumber(value) {
      return value !== "" && !isNaN(Number(value)) && /^-?[0-9a-fA-Fx.]*$/.exec(value);
    }

    const VALID_UNITS = ["%", "cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh"];

    /**
     * The value and unit of a unit value [number][px|%|rem|...]
     * E.g.: { value: "100", unit: "px" }
     *
     * @typedef {object} UnitValue
     * @property {number} value - The unit value
     * @property {string} unit - The unit
     */

    /**
     * Parse the given size in its numeric and unit parts
     * Expected pattern [number][px|%|rem|...]
     *
     * @param {string} unitValue The size value to be parsed
     * @param {string[]} acceptedUnits The list of accepted units.
     * @returns {UnitValue} An object with the numeric value and unit
     */
    function parseUnit(unitValue, acceptedUnits = VALID_UNITS) {
      const parsedValues = /^([^a-z%]*)(.*)/.exec(unitValue);
      let value = parsedValues[1];
      let unit = parsedValues[2];
      if (!isNumber(value) || !acceptedUnits.includes(unit)) {
        value = "";
        unit = "";
      }
      return {
        value,
        unit
      };
    }

    const propertyNamesHash = properties => {
      return typeof properties === "object" ? properties : {};
    };
    const proto = {
      toString() {
        return Object.keys(this).map(key => {
          const [name, unit] = key.split(":");
          const parsedValue = parseUnit(this[key]);
          let value;
          if (notEmpty(parsedValue.unit)) {
            value = this[key];
          } else {
            value = notEmpty(this[key]) ? `${this[key]}${unit ?? ""}` : "initial";
          }
          return `${name}: ${value};`;
        }).join(" ");
      }
    };

    /**
     * A CSS Custom Property Utility
     *
     * @example
     *   const styles = propertySet({
     *       "--dxp-c-card-content-width:%": this.contentWidth,
     *       "--dxp-c-card-content-height:px": this.contentHeight,
     *   }).toString();
     *
     *   When value is undefined/null/“”, the property is ignored. Such as contentWidth is undefined
     *   contentHeight is 0.
     *      "--dxp-c-card-content-height: 0px"
     *
     *   When contentWidth is 100, contentHeight is 100
     *
     *      "--dxp-c-card-content-width: 100%;--dxp-c-card-content-height: 0px;"
     *
     * @param {object} config a plain configuration, use as shallow copy.
     * @returns {object} A PropertySet object
     */
    function propertySet(config) {
      return Object.assign(Object.create(proto), propertyNamesHash(config));
    }

    /**
     * Static Content for placeholder datauri
     */
    const PLACEHOLDER_DATA_URI = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQwNiIgaGVpZ2h0PSI0NDEiIHZpZXdCb3g9IjAgMCAxNDA2IDQ0MSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgb3BhY2l0eT0iMC4yODMxNTgiIHk9IjAuMzMwMDc4IiB3aWR0aD0iMTQwNiIgaGVpZ2h0PSI0NDAiIGZpbGw9IiNGM0YzRjMiLz4KPHBhdGggZD0iTTY3OCAyNTJDNjcxLjkyIDI1MiA2NjcgMjQ3LjA4IDY2NyAyNDFWMTk5QzY2NyAxOTIuOTIgNjcxLjkyIDE4OCA2NzggMTg4SDcyOEM3MzQuMDggMTg4IDczOSAxOTIuOTIgNzM5IDE5OVYyNDFDNzM5IDI0Ny4wOCA3MzQuMDggMjUyIDcyOCAyNTJINjc4VjI1MlpNNjczIDIzMS43Nkw2ODEuODggMjI0LjhDNjgyLjU2IDIyNC4yOCA2ODMuMjggMjI0IDY4NC4wNCAyMjRDNjg0LjggMjI0IDY4NS41NiAyMjQuMjggNjg2LjIgMjI0LjhMNjk2LjY0IDIzMy4yNEw3MTQuMDggMjE4LjhDNzE0Ljc2IDIxOC4yNCA3MTUuNDggMjE4IDcxNi4yNCAyMThDNzE3IDIxOCA3MTcuNzYgMjE4LjI4IDcxOC40IDIxOC44TDczMyAyMzAuNDhWMTk5QzczMyAxOTYuMjQgNzMwLjc2IDE5NCA3MjggMTk0SDY3OEM2NzUuMjQgMTk0IDY3MyAxOTYuMjQgNjczIDE5OVYyMzEuNzZWMjMxLjc2Wk02OTUgMjIwQzY4OS40OCAyMjAgNjg1IDIxNS41MiA2ODUgMjEwQzY4NSAyMDQuNDggNjg5LjQ4IDIwMCA2OTUgMjAwQzcwMC41MiAyMDAgNzA1IDIwNC40OCA3MDUgMjEwQzcwNSAyMTUuNTIgNzAwLjUyIDIyMCA2OTUgMjIwWk02OTUgMjE0QzY5Ny4yIDIxNCA2OTkgMjEyLjIgNjk5IDIxMEM2OTkgMjA3LjggNjk3LjIgMjA2IDY5NSAyMDZDNjkyLjggMjA2IDY5MSAyMDcuOCA2OTEgMjEwQzY5MSAyMTIuMiA2OTIuOCAyMTQgNjk1IDIxNFpNNjc4IDI0Nkg3MjhDNzMwLjc2IDI0NiA3MzMgMjQzLjc2IDczMyAyNDFWMjM5LjY0QzczMyAyMzguNjggNzMyLjYgMjM3Ljg0IDczMS44NCAyMzcuMjRMNzE2LjI0IDIyNC43Nkw2OTguOCAyMzkuMjRDNjk4LjE2IDIzOS43NiA2OTcuNCAyNDAgNjk2LjY0IDI0MEM2OTUuODggMjQwIDY5NS4xNiAyMzkuOCA2OTQuNDggMjM5LjI0TDY4NC4wNCAyMzAuNzZMNjc0LjE2IDIzOC41MkM2NzMuNCAyMzkuMTIgNjczIDIzOS45NiA2NzMgMjQwLjkyVjI0MUM2NzMgMjQzLjc2IDY3NS4yNCAyNDYgNjc4IDI0NlYyNDZaIiBmaWxsPSIjQUJBQ0FEIi8+Cjwvc3ZnPg==";

    /**
     * Static Content for video placeholder datauri
     */
    const VIDEO_PLACEHOLDER_DATA_URI = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMxMiIgaGVpZ2h0PSI0NDAiIHZpZXdCb3g9IjAgMCAxMzEyIDQ0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgb3BhY2l0eT0iMC4yODMxNTgiIHdpZHRoPSIxMzEyIiBoZWlnaHQ9IjQ0MCIgZmlsbD0iI0YzRjNGMyIvPgo8cGF0aCBkPSJNNjM5LjA4IDE5MkM2NDAuNzYgMTkyIDY0Mi42OCAxOTIuNTYgNjQ0LjY4IDE5My42OEw2NzguNzYgMjEyLjg0QzY4Mi4yOCAyMTQuOCA2ODQgMjE3LjQgNjg0IDIyMEM2ODQgMjIyLjYgNjgyLjMyIDIyNS4xNiA2NzguNzYgMjI3LjE2TDY0NC42OCAyNDYuMzJDNjQyLjY4IDI0Ny40NCA2NDAuNzYgMjQ4IDYzOS4wOCAyNDhDNjM0Ljg4IDI0OCA2MzIgMjQ0LjY0IDYzMiAyMzguOTJWMjAxLjA4QzYzMiAxOTUuMzYgNjM0Ljg4IDE5MiA2MzkuMDggMTkyVjE5MloiIGZpbGw9IiNBQkFDQUQiLz4KPC9zdmc+";
    const LOGO_PLACEHOLDER_DATA_URI = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUwIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgMTUwIDUwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSIyNSIgY3k9IjI1IiByPSIyNSIgZmlsbD0iIzc3NzU3QSIvPgo8cGF0aCBkPSJNNjUuNTI4NyAzOS41VjEyLjAzMkg3MC40MDA3VjM1LjM4NEg4MS44MjQ3VjM5LjVINjUuNTI4N1pNOTQuMDk5NSA0MC4wMDRDOTIuMzkxNSA0MC4wMDQgOTAuNzk1NSAzOS41ODQgODkuMzExNSAzOC43NDRDODcuODI3NSAzNy44NzYgODYuNjIzNSAzNi42NDQgODUuNjk5NSAzNS4wNDhDODQuNzc1NSAzMy40MjQgODQuMzEzNSAzMS40NzggODQuMzEzNSAyOS4yMUM4NC4zMTM1IDI2LjkxNCA4NC43NzU1IDI0Ljk2OCA4NS42OTk1IDIzLjM3MkM4Ni42MjM1IDIxLjc0OCA4Ny44Mjc1IDIwLjUxNiA4OS4zMTE1IDE5LjY3NkM5MC43OTU1IDE4LjgwOCA5Mi4zOTE1IDE4LjM3NCA5NC4wOTk1IDE4LjM3NEM5NS44MzU1IDE4LjM3NCA5Ny40NDU1IDE4LjgwOCA5OC45Mjk1IDE5LjY3NkMxMDAuNDE0IDIwLjUxNiAxMDEuNjE4IDIxLjc0OCAxMDIuNTQyIDIzLjM3MkMxMDMuNDY2IDI0Ljk2OCAxMDMuOTI4IDI2LjkxNCAxMDMuOTI4IDI5LjIxQzEwMy45MjggMzEuNDc4IDEwMy40NjYgMzMuNDI0IDEwMi41NDIgMzUuMDQ4QzEwMS42MTggMzYuNjQ0IDEwMC40MTQgMzcuODc2IDk4LjkyOTUgMzguNzQ0Qzk3LjQ0NTUgMzkuNTg0IDk1LjgzNTUgNDAuMDA0IDk0LjA5OTUgNDAuMDA0Wk05NC4wOTk1IDM2LjA1NkM5NS42MTE1IDM2LjA1NiA5Ni44MDE1IDM1LjQyNiA5Ny42Njk1IDM0LjE2NkM5OC41Mzc1IDMyLjkwNiA5OC45NzE1IDMxLjI1NCA5OC45NzE1IDI5LjIxQzk4Ljk3MTUgMjcuMTM4IDk4LjUzNzUgMjUuNDcyIDk3LjY2OTUgMjQuMjEyQzk2LjgwMTUgMjIuOTUyIDk1LjYxMTUgMjIuMzIyIDk0LjA5OTUgMjIuMzIyQzkyLjU4NzUgMjIuMzIyIDkxLjM5NzUgMjIuOTUyIDkwLjUyOTUgMjQuMjEyQzg5LjY4OTUgMjUuNDcyIDg5LjI2OTUgMjcuMTM4IDg5LjI2OTUgMjkuMjFDODkuMjY5NSAzMS4yNTQgODkuNjg5NSAzMi45MDYgOTAuNTI5NSAzNC4xNjZDOTEuMzk3NSAzNS40MjYgOTIuNTg3NSAzNi4wNTYgOTQuMDk5NSAzNi4wNTZaTTExNS44OSA0OC42MTRDMTE0LjI2NiA0OC42MTQgMTEyLjc5NiA0OC40MTggMTExLjQ4IDQ4LjAyNkMxMTAuMTkyIDQ3LjYzNCAxMDkuMTcgNDcuMDMyIDEwOC40MTQgNDYuMjJDMTA3LjY4NiA0NS40MzYgMTA3LjMyMiA0NC40NDIgMTA3LjMyMiA0My4yMzhDMTA3LjMyMiA0MS41MyAxMDguMzAyIDQwLjA2IDExMC4yNjIgMzguODI4VjM4LjY2QzEwOS43MyAzOC4zMjQgMTA5LjI4MiAzNy44NzYgMTA4LjkxOCAzNy4zMTZDMTA4LjU4MiAzNi43NTYgMTA4LjQxNCAzNi4wNTYgMTA4LjQxNCAzNS4yMTZDMTA4LjQxNCAzNC40MDQgMTA4LjYzOCAzMy42NzYgMTA5LjA4NiAzMy4wMzJDMTA5LjU2MiAzMi4zNiAxMTAuMDk0IDMxLjgxNCAxMTAuNjgyIDMxLjM5NFYzMS4yMjZDMTA5Ljk4MiAzMC42OTQgMTA5LjM1MiAyOS45NTIgMTA4Ljc5MiAyOUMxMDguMjYgMjguMDQ4IDEwNy45OTQgMjYuOTcgMTA3Ljk5NCAyNS43NjZDMTA3Ljk5NCAyNC4xNyAxMDguMzcyIDIyLjgyNiAxMDkuMTI4IDIxLjczNEMxMDkuODg0IDIwLjY0MiAxMTAuODc4IDE5LjgxNiAxMTIuMTEgMTkuMjU2QzExMy4zNyAxOC42NjggMTE0LjcxNCAxOC4zNzQgMTE2LjE0MiAxOC4zNzRDMTE2LjcwMiAxOC4zNzQgMTE3LjIzNCAxOC40MyAxMTcuNzM4IDE4LjU0MkMxMTguMjcgMTguNjI2IDExOC43NDYgMTguNzM4IDExOS4xNjYgMTguODc4SDEyNi41NThWMjIuNDQ4SDEyMi43NzhDMTIzLjExNCAyMi44NCAxMjMuMzk0IDIzLjM0NCAxMjMuNjE4IDIzLjk2QzEyMy44NDIgMjQuNTQ4IDEyMy45NTQgMjUuMjA2IDEyMy45NTQgMjUuOTM0QzEyMy45NTQgMjcuNDQ2IDEyMy42MDQgMjguNzM0IDEyMi45MDQgMjkuNzk4QzEyMi4yMDQgMzAuODM0IDEyMS4yNjYgMzEuNjE4IDEyMC4wOSAzMi4xNUMxMTguOTE0IDMyLjY4MiAxMTcuNTk4IDMyLjk0OCAxMTYuMTQyIDMyLjk0OEMxMTUuNjk0IDMyLjk0OCAxMTUuMjMyIDMyLjkwNiAxMTQuNzU2IDMyLjgyMkMxMTQuMjggMzIuNzM4IDExMy44MDQgMzIuNTk4IDExMy4zMjggMzIuNDAyQzExMy4wMiAzMi42ODIgMTEyLjc2OCAzMi45NjIgMTEyLjU3MiAzMy4yNDJDMTEyLjQwNCAzMy41MjIgMTEyLjMyIDMzLjkgMTEyLjMyIDM0LjM3NkMxMTIuMzIgMzQuOTY0IDExMi41NTggMzUuNDI2IDExMy4wMzQgMzUuNzYyQzExMy41MzggMzYuMDk4IDExNC40MiAzNi4yNjYgMTE1LjY4IDM2LjI2NkgxMTkuMzM0QzEyMS44MjYgMzYuMjY2IDEyMy43MDIgMzYuNjcyIDEyNC45NjIgMzcuNDg0QzEyNi4yNSAzOC4yNjggMTI2Ljg5NCAzOS41NTYgMTI2Ljg5NCA0MS4zNDhDMTI2Ljg5NCA0Mi42OTIgMTI2LjQ0NiA0My45MSAxMjUuNTUgNDUuMDAyQzEyNC42NTQgNDYuMTIyIDEyMy4zOCA0Ny4wMDQgMTIxLjcyOCA0Ny42NDhDMTIwLjA3NiA0OC4yOTIgMTE4LjEzIDQ4LjYxNCAxMTUuODkgNDguNjE0Wk0xMTYuMTQyIDI5LjkyNEMxMTcuMTIyIDI5LjkyNCAxMTcuOTYyIDI5LjU2IDExOC42NjIgMjguODMyQzExOS4zNjIgMjguMTA0IDExOS43MTIgMjcuMDgyIDExOS43MTIgMjUuNzY2QzExOS43MTIgMjQuNDc4IDExOS4zNjIgMjMuNDg0IDExOC42NjIgMjIuNzg0QzExNy45OSAyMi4wNTYgMTE3LjE1IDIxLjY5MiAxMTYuMTQyIDIxLjY5MkMxMTUuMTM0IDIxLjY5MiAxMTQuMjggMjIuMDQyIDExMy41OCAyMi43NDJDMTEyLjg4IDIzLjQ0MiAxMTIuNTMgMjQuNDUgMTEyLjUzIDI1Ljc2NkMxMTIuNTMgMjcuMDgyIDExMi44OCAyOC4xMDQgMTEzLjU4IDI4LjgzMkMxMTQuMjggMjkuNTYgMTE1LjEzNCAyOS45MjQgMTE2LjE0MiAyOS45MjRaTTExNi42NDYgNDUuNDY0QzExOC4yOTggNDUuNDY0IDExOS42NDIgNDUuMTI4IDEyMC42NzggNDQuNDU2QzEyMS43MTQgNDMuNzg0IDEyMi4yMzIgNDMuMDE0IDEyMi4yMzIgNDIuMTQ2QzEyMi4yMzIgNDEuMzM0IDEyMS45MSA0MC43ODggMTIxLjI2NiA0MC41MDhDMTIwLjY1IDQwLjIyOCAxMTkuNzU0IDQwLjA4OCAxMTguNTc4IDQwLjA4OEgxMTUuNzY0QzExNC42NDQgNDAuMDg4IDExMy43MDYgMzkuOTkgMTEyLjk1IDM5Ljc5NEMxMTEuODg2IDQwLjYwNiAxMTEuMzU0IDQxLjUxNiAxMTEuMzU0IDQyLjUyNEMxMTEuMzU0IDQzLjQ0OCAxMTEuODMgNDQuMTYyIDExMi43ODIgNDQuNjY2QzExMy43MzQgNDUuMTk4IDExNS4wMjIgNDUuNDY0IDExNi42NDYgNDUuNDY0Wk0xMzguMzE0IDQwLjAwNEMxMzYuNjA2IDQwLjAwNCAxMzUuMDEgMzkuNTg0IDEzMy41MjYgMzguNzQ0QzEzMi4wNDIgMzcuODc2IDEzMC44MzggMzYuNjQ0IDEyOS45MTQgMzUuMDQ4QzEyOC45OSAzMy40MjQgMTI4LjUyOCAzMS40NzggMTI4LjUyOCAyOS4yMUMxMjguNTI4IDI2LjkxNCAxMjguOTkgMjQuOTY4IDEyOS45MTQgMjMuMzcyQzEzMC44MzggMjEuNzQ4IDEzMi4wNDIgMjAuNTE2IDEzMy41MjYgMTkuNjc2QzEzNS4wMSAxOC44MDggMTM2LjYwNiAxOC4zNzQgMTM4LjMxNCAxOC4zNzRDMTQwLjA1IDE4LjM3NCAxNDEuNjYgMTguODA4IDE0My4xNDQgMTkuNjc2QzE0NC42MjggMjAuNTE2IDE0NS44MzIgMjEuNzQ4IDE0Ni43NTYgMjMuMzcyQzE0Ny42OCAyNC45NjggMTQ4LjE0MiAyNi45MTQgMTQ4LjE0MiAyOS4yMUMxNDguMTQyIDMxLjQ3OCAxNDcuNjggMzMuNDI0IDE0Ni43NTYgMzUuMDQ4QzE0NS44MzIgMzYuNjQ0IDE0NC42MjggMzcuODc2IDE0My4xNDQgMzguNzQ0QzE0MS42NiAzOS41ODQgMTQwLjA1IDQwLjAwNCAxMzguMzE0IDQwLjAwNFpNMTM4LjMxNCAzNi4wNTZDMTM5LjgyNiAzNi4wNTYgMTQxLjAxNiAzNS40MjYgMTQxLjg4NCAzNC4xNjZDMTQyLjc1MiAzMi45MDYgMTQzLjE4NiAzMS4yNTQgMTQzLjE4NiAyOS4yMUMxNDMuMTg2IDI3LjEzOCAxNDIuNzUyIDI1LjQ3MiAxNDEuODg0IDI0LjIxMkMxNDEuMDE2IDIyLjk1MiAxMzkuODI2IDIyLjMyMiAxMzguMzE0IDIyLjMyMkMxMzYuODAyIDIyLjMyMiAxMzUuNjEyIDIyLjk1MiAxMzQuNzQ0IDI0LjIxMkMxMzMuOTA0IDI1LjQ3MiAxMzMuNDg0IDI3LjEzOCAxMzMuNDg0IDI5LjIxQzEzMy40ODQgMzEuMjU0IDEzMy45MDQgMzIuOTA2IDEzNC43NDQgMzQuMTY2QzEzNS42MTIgMzUuNDI2IDEzNi44MDIgMzYuMDU2IDEzOC4zMTQgMzYuMDU2WiIgZmlsbD0iIzcwNkU2QiIvPgo8L3N2Zz4K";

    /**
     * Whether uri has content.
     *
     * @param {string} uri uri to check
     * @returns {boolean} true if uri has content, instead of nullish or empty string
     */
    function hasUri(uri) {
      return uri && uri !== "";
    }

    /**
     * Transform uri to css url('uri')
     *
     * @example
     *      toCssUrl("https://example") => url('https://example')
     *
     * @param {string} uri source uri
     * @returns {string} css url string
     */
    function toCssUrl(uri) {
      return hasUri(uri) ? `url("${uri}")` : "";
    }

    /**
     * Normalize url, if url is empty, return fallback placeholder url
     *
     * @param {string} url image url
     * @returns {string} url value
     */
    function safeCssUrl(url) {
      return pipe(safeImageSrc, toCssUrl)(url);
    }

    /**
     * Return normalized image uri
     *
     * @param {string} uri image uri
     * @returns {string} if empty return default placeholder data uri.
     */
    function safeImageSrc(uri) {
      return hasUri(uri) ? uri : PLACEHOLDER_DATA_URI;
    }

    /**
     * Build a querySelectorAll functional operator with given selector
     *
     * @param {string} selector A css selector
     * @returns {Function} querySelectorAll operator tied to selector
     */
    const querySelectorAll = selector => element => Array.from(element?.querySelectorAll(selector));
    const focusableElementsSelector = "a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]";

    /**
     * Returns the first focusable element inside the given element.
     * NOTE: Only works for elements that have open shadow root!
     *
     * @param {Element} element - element to search inside
     * @returns {Element|null}  - first focusable element inside the given element
     */
    const findFirstFocusable = element => {
      if (!element) {
        return null;
      }
      if (element.matches && element.matches(focusableElementsSelector)) {
        return element;
      }

      // eslint-disable-next-line @locker/locker/distorted-element-shadow-root-getter
      const shadowRoot = element.shadowRoot;
      if (shadowRoot) {
        // if element is in shadow dom
        return findFirstFocusable(shadowRoot);
      } else if (element.assignedElements) {
        // if the element is a slot with assigned elements
        for (const assignedElement of element.assignedElements()) {
          const focusableInAssigned = findFirstFocusable(assignedElement);
          if (focusableInAssigned) {
            return focusableInAssigned;
          }
        }
      } else {
        // if element is in light dom
        for (const child of element.children) {
          const focusableChild = findFirstFocusable(child);
          if (focusableChild) {
            return focusableChild;
          }
        }
      }
      return null;
    };

    /**
     * Split string into array of words and remove empty words
     *
     * @param {string} separator
     * @param {string} string
     * @returns
     */
    const split = curry((separator, string) => {
      return string?.toString().split(separator) ?? [];
    });

    /**
     * Capitalize given string, such as from hello to Hello
     *
     * @param {string} string String to be capitalized
     * @returns {string} capitalized string
     */
    function toCapitalized(string = "") {
      string = string?.toString();
      return isNonEmptyString(string) ? `${string.charAt(0).toUpperCase()}${string.slice(1)}` : "";
    }

    /**
     * Check if given value is a string
     *
     * @param {*} str value to be checked
     * @returns {boolean} flag indicating if the value is string type
     */
    function isString(str) {
      return typeof str === "string";
    }

    /**
     * Check if given string is non empty
     *
     * @param {string} str string to be checked
     * @returns {boolean} whether string is non empty
     */
    function isNonEmptyString(str) {
      return isString(str) && notEmpty(str);
    }

    /**
     * Split url into array of words and remove empty words
     *
     * @param {*} url url to be split
     * @returns {string[]} array of words
     */
    function splitUrl(url) {
      return compose(filter(item => item?.length > 0), split("/"))(url);
    }

    /**
     * Return a promise resolved when time is out.
     *
     * @param {number} interval timeout value
     * @returns {object} A promise
     */
    function timeout(interval = 0) {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(resolve, interval);
      });
    }

    /**
     * Return a promise resolved when requestAnimationFrame is called.
     *
     * @returns {object} A promise
     */
    function nextFrame() {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(resolve);
      });
    }

    const LARGE_FORMFACTOR = "l";
    const MEDIUM_FORMFACTOR = "m";
    const SMALL_FORMFACTOR = "s";
    const FORMFACTOR_ARRAY = [LARGE_FORMFACTOR, MEDIUM_FORMFACTOR, SMALL_FORMFACTOR];

    // Content position value to flexbox alignment property mapping
    const AlignmentMap = {
      top: "flex-start",
      left: "flex-start",
      bottom: "flex-end",
      right: "flex-end",
      center: "center"
    };

    /**
     * Create attributes for all the form factors to be fed to the propertySet
     *
     * @param {object} attributeMap
     * @param {string} keyPrefix
     * @param {object} attributeValues
     * @returns {object} { "key:unit" : "value" }
     * @example {name: "height", unit: "px"},'--dxp-c', {"--dxp-c-l-height": "10", "--dxp-c-m-height": "20", "--dxp-c-s-height": "30" } =>
     *  {"--dxp-c-l-height:px": "10", "--dxp-c-m-height:px": "20", "--dxp-c-s-height:px": "30" }
     */
    function prependFormFactor(attributeMap, keyPrefix, attributeValues) {
      const response = {};
      FORMFACTOR_ARRAY.forEach(formFactor => {
        attributeMap.forEach(prop => {
          const propKeyWithCustomTitle = `${keyPrefix}-${formFactor}-${prop.customTitle || prop.name}`;
          const propKey = `${keyPrefix}-${formFactor}-${prop.name}`;
          response[`${propKeyWithCustomTitle}:${prop.unit}`] = prop.name.match(/alignment/gi) && Object.keys(attributeValues).includes(propKey) ? AlignmentMap[attributeValues[propKey]] : attributeValues[propKey];
        });
      });
      return response;
    }

    /**
     * Convert `class` attribute value to a selector
     *
     * @param {string} classAttributeValue value passed in class attribute of the element
     * @returns {string} selector which could be passed to query selector to select that element
     */
    function convertClassAttributeToSelector(classAttributeValue) {
      return ifElse(!classAttributeValue || typeof classAttributeValue !== "string", null, () => `.${classAttributeValue.split(" ").join(".")}`);
    }

    /**
     * Split string into object of key value pairs
     * ex: "--dxp-c-l-width: 30; --dxp-c-l-height: 30;"
     * response : { --dxp-c-l-width: 30, --dxp-c-l-height: 30};
     * here attributeSeparator is ;, and keyValSeparator is :
     *
     * @param {string} attributeSeparator
     * @param {string} keyValSeparator
     * @param {string} string
     * @returns {object}
     */
    function splitStringToObj(attributeSeparator, keyValSeparator, string) {
      const response = {};
      if (!string || !attributeSeparator || !keyValSeparator) {
        return {};
      }
      const stringArray = string.split(attributeSeparator);
      stringArray.filter(keyValue => {
        const kvm = keyValue.match(new RegExp(keyValSeparator, "g")) || [];
        return keyValue && kvm.length === 1 && kvm[0] === keyValSeparator;
      }).forEach(keyValue => {
        const [key, value] = keyValue.split(keyValSeparator);
        response[key.trim()] = value.trim();
      });
      return response;
    }

    /**
     * Define the debounce timeout
     * Why choose 150ms for debounce delay, below link has some good explanation.
     * https://www.nngroup.com/articles/response-times-3-important-limits/
     * https://icons8.com/articles/ui-design-user-interface-illustrations/
     */
    const DEBOUNCE_TIMEOUT = 150;

    /**
     * Define a empty client rect.
     */
    const EMPTY_RECT = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };

    /**
     * Parses strings that use dynamic values
     * Strings should follow this format: "Hello {0}, welcome to {1}"
     * Use for interally supplied text and values only
     *
     * @param {string} text The string to be parsed
     * @param {...string} values the strings to be inserted
     * @returns {string} The original string with the values inserted
     */
    function formatString(text, ...values) {
      return values.reduce((t, value, index) => t?.replaceAll(`{${index}}`, value), text);
    }

    exports.AlignmentMap = AlignmentMap;
    exports.DEBOUNCE_TIMEOUT = DEBOUNCE_TIMEOUT;
    exports.EMPTY_RECT = EMPTY_RECT;
    exports.KeyCodes = KeyCodes;
    exports.LOGO_PLACEHOLDER_DATA_URI = LOGO_PLACEHOLDER_DATA_URI;
    exports.PLACEHOLDER_DATA_URI = PLACEHOLDER_DATA_URI;
    exports.SFDC_DEFAULT = SFDC_DEFAULT;
    exports.VIDEO_PLACEHOLDER_DATA_URI = VIDEO_PLACEHOLDER_DATA_URI;
    exports.and = and;
    exports.apply = apply;
    exports.compose = compose;
    exports.convertClassAttributeToSelector = convertClassAttributeToSelector;
    exports.curry = curry;
    exports.debounce = debounce;
    exports.deepCopy = deepCopy;
    exports.deepMerge = deepMerge;
    exports.empty = empty;
    exports.every = every;
    exports.everyKey = everyKey;
    exports.fieldToValue = fieldToValue;
    exports.filter = filter;
    exports.find = find;
    exports.findFirstFocusable = findFirstFocusable;
    exports.forEach = forEach;
    exports.forEachKey = forEachKey;
    exports.formatString = formatString;
    exports.get = get;
    exports.getify = getify;
    exports.hasOwnProperty = hasOwnProperty;
    exports.hasUri = hasUri;
    exports.ifElse = ifElse;
    exports.ifVal = ifVal;
    exports.isField = isField;
    exports.isFunction = isFunction;
    exports.isNonEmptyString = isNonEmptyString;
    exports.isNumber = isNumber;
    exports.isPrimitive = isPrimitive;
    exports.isString = isString;
    exports.map = map;
    exports.mapObject = mapObject;
    exports.mapping = mapping;
    exports.mergeUniqueRecords = mergeUniqueRecords;
    exports.nextFrame = nextFrame;
    exports.notEmpty = notEmpty;
    exports.or = or;
    exports.parseUnit = parseUnit;
    exports.pipe = pipe;
    exports.prependFormFactor = prependFormFactor;
    exports.propertySet = propertySet;
    exports.querySelectorAll = querySelectorAll;
    exports.range = range;
    exports.safeCssUrl = safeCssUrl;
    exports.safeFieldValue = safeFieldValue;
    exports.safeImageSrc = safeImageSrc;
    exports.safeParseJson = safeParseJson;
    exports.set = set;
    exports.split = split;
    exports.splitStringToObj = splitStringToObj;
    exports.splitUrl = splitUrl;
    exports.stringify = stringify;
    exports.timeout = timeout;
    exports.toCapitalized = toCapitalized;
    exports.toCssUrl = toCssUrl;
    exports.toIndexes = toIndexes;
    exports.tryCatch = tryCatch;
    exports.typeOf = typeOf;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_util/siteInfo', ['exports', '@salesforce/community/basePath', 'dxp_util/common', '@salesforce/i18n/lang', '@salesforce/community/Id', '@salesforce/site/Id'], (function (exports, basePath, common, CurrentLocale, CommunityId, SiteId) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var basePath__default = /*#__PURE__*/_interopDefaultCompat(basePath);
    var CurrentLocale__default = /*#__PURE__*/_interopDefaultCompat(CurrentLocale);
    var CommunityId__default = /*#__PURE__*/_interopDefaultCompat(CommunityId);
    var SiteId__default = /*#__PURE__*/_interopDefaultCompat(SiteId);

    const CMS_PATH_PREFIX = "/sfsites/c";
    const SITE_CMS_PATH_PREFIX = `${basePath__default.default}${CMS_PATH_PREFIX}`;
    const constructUrlPath = common.curry((prefix, isExternal, url) => {
      return isExternal ? url : `${basePath__default.default}${prefix ?? ""}${prefixWithLeadingSlash(url)}`;
    });
    const constructCmsPath = constructUrlPath(CMS_PATH_PREFIX);
    const constructSitePath = constructUrlPath("");
    const SiteInfo = {
      // curr locale is sometimes not formated to the correct syntax for locale, needs to be en_US, not en-US
      CurrentLanguage: CurrentLocale__default.default.replace("-", "_"),
      CommunityId: CommunityId__default.default,
      CurrentLocale: CurrentLocale__default.default,
      SiteId: SiteId__default.default
    };

    /**
     * Return cms path prefix.
     *
     * @returns {string} path prefix
     */
    function getPathPrefix() {
      return SITE_CMS_PATH_PREFIX;
    }

    /**
     * Construct url with site path
     *
     * @param {string} url relative url
     * @param {boolean} isExternal whether isExternal url.
     * @returns {string} content url
     */
    function buildSitePath(url, isExternal = false) {
      return constructSitePath(isExternal, url);
    }

    /**
     * Construct url with site path
     *
     * @param {string} url relative url
     * @param {boolean} isExternal whether isExternal url.
     * @returns {string} content url
     */
    function buildSiteCmsPath(url, isExternal = false) {
      return constructCmsPath(isExternal, url);
    }

    /**
     * Check if given url is site url
     *
     * @param {string} url url to check
     * @returns {boolean} whether url is a site url
     */
    function isSitePath(url) {
      return url?.startsWith(basePath__default.default);
    }

    /**
     * Checks if a URL string starts with either "http://", "https://", or "data:image".
     *
     * @param {string} url - The URL string to check.
     * @returns {boolean} Returns true if the URL starts with "http://", "https://", or "data:image"; otherwise, returns false.
     */
    function isValidImageUrl(url) {
      const regex = /^(https?|data:image\/[a-z]+)/i;
      return regex.test(url);
    }

    /**
     * Prefixes a URL segment with a leading slash if needed.
     * If the URL segment starts with a slash, it is returned unchanged.
     * If the URL segment does not start with a slash, a leading slash is added.
     *
     * @param {string} urlSegment - The URL segment to be prefixed.
     * @returns {string} The URL segment with a leading slash if needed.
     */
    function prefixWithLeadingSlash(urlSegment) {
      return urlSegment && !/^\/.*/.test(urlSegment) ? `/${urlSegment}` : urlSegment;
    }

    /**
     * Returns the image URL based on the provided URL.
     *
     * @param {string} url - The input URL.
     * @returns {string} The image URL.
     */
    function getImageUrl(url) {
      return isSitePath(url) ? url : buildSitePath(url, isValidImageUrl(url));
    }

    exports.CMS_PATH_PREFIX = CMS_PATH_PREFIX;
    exports.SiteInfo = SiteInfo;
    exports.buildSiteCmsPath = buildSiteCmsPath;
    exports.buildSitePath = buildSitePath;
    exports.constructUrlPath = constructUrlPath;
    exports.getImageUrl = getImageUrl;
    exports.getPathPrefix = getPathPrefix;
    exports.isSitePath = isSitePath;
    exports.isValidImageUrl = isValidImageUrl;
    exports.prefixWithLeadingSlash = prefixWithLeadingSlash;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_util/normalizer', ['exports'], (function (exports) {

    /**
     * A boolean normalization utility for attributes.
     *
     * @param {object} value - The value to normalize.
     * @returns {boolean} - The normalized value.
     */
    function normalizeBoolean(value) {
      return typeof value === "string" || !!value;
    }

    /**
     * A string normalization utility for attributes.
     *
     * @param {string} value - The value to normalize.
     * @param {object} config - The optional configuration object.
     * @param {string} [config.fallbackValue] - The optional fallback value to use if the given value is not provided or invalid. Defaults to an empty string.
     * @param {Array} [config.caseSensitive] - Whether it's caseSensitive comparing.
     * @param {Array} [config.validValues] - An optional array of valid values. Assumes all input is valid if not provided.
     * @returns {string} - The normalized value.
     */
    function normalizeString(value, config = {}) {
      const {
        fallbackValue = "",
        validValues,
        caseSensitive = false
      } = config;
      let normalized = typeof value === "string" && value.trim() || "";
      if (!caseSensitive) {
        normalized = normalized.toLowerCase();
      }
      if (validValues && validValues.indexOf(normalized) === -1) {
        normalized = fallbackValue;
      }
      return normalized;
    }

    /**
     * Normalize given string to size option
     *
     * @param {string} value string value
     * @returns {string} normalized size value
     */
    function normalizeSize(value) {
      return normalizeString(value, {
        fallbackValue: "small",
        validValues: ["small", "medium", "large"]
      });
    }

    /**
     * Normalize given string to alignment option
     *
     * @param {string} value string value
     * @returns {string} normalized alignment value
     */
    function normalizeAlignment(value) {
      return normalizeString(value, {
        fallbackValue: "left",
        validValues: ["left", "center", "right"]
      });
    }

    /**
     * Normalize given string to order (ltr or rtl)
     *
     * @param {string} value string value
     * @returns {string} normalized alignment value
     */
    function normalizeDirection(value) {
      return normalizeString(value, {
        fallbackValue: "left",
        validValues: ["left", "right"]
      });
    }
    const ACTION_TYPE = {
      SHOW_INLINE_MESSAGE: "inline",
      REDIRECT_TO_EXISTING_PAGE: "redirect"
    };

    /**
     * Normalize given string to action option
     *
     * @param {string} value string value
     * @returns {string} normalized action value
     */
    function normalizeAction(value) {
      return normalizeString(value, {
        caseSensitive: true,
        fallbackValue: ACTION_TYPE.SHOW_INLINE_MESSAGE,
        validValues: [ACTION_TYPE.SHOW_INLINE_MESSAGE, ACTION_TYPE.REDIRECT_TO_EXISTING_PAGE]
      });
    }

    const COLUMN_PORTION_MAP = Object.freeze({
      "50%": {
        left: 1,
        right: 1
      },
      "16.67%": {
        left: 1,
        right: 5
      },
      "33.33%": {
        left: 1,
        right: 2
      },
      "66.67%": {
        left: 2,
        right: 1
      }
    });
    const COLUMN_PORTION_OPTIONS = Object.keys(COLUMN_PORTION_MAP);
    const DEFAULT_COLUMN_PORTION = COLUMN_PORTION_OPTIONS[0];

    /**
     * Normalize portion options
     *
     * @param {string} value value to normalize
     * @returns {string} accepted value
     */
    function normalizePortion(value) {
      return normalizeString(value, {
        fallbackValue: DEFAULT_COLUMN_PORTION,
        validValues: COLUMN_PORTION_OPTIONS
      });
    }

    exports.ACTION_TYPE = ACTION_TYPE;
    exports.COLUMN_PORTION_MAP = COLUMN_PORTION_MAP;
    exports.COLUMN_PORTION_OPTIONS = COLUMN_PORTION_OPTIONS;
    exports.DEFAULT_COLUMN_PORTION = DEFAULT_COLUMN_PORTION;
    exports.normalizeAction = normalizeAction;
    exports.normalizeAlignment = normalizeAlignment;
    exports.normalizeBoolean = normalizeBoolean;
    exports.normalizeDirection = normalizeDirection;
    exports.normalizePortion = normalizePortion;
    exports.normalizeSize = normalizeSize;
    exports.normalizeString = normalizeString;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_util/contentInfo', ['exports', 'dxp_util/siteInfo', 'dxp_util/normalizer'], (function (exports, siteInfo, normalizer) {

    /**
     * Regular expressions for CMS resources and for static image resources.
     */
    const cmsResourceUrlPattern = /^\/cms\//;
    const staticImageResourcePattern = /^\/img\//; // Static app resources referenced (e.g. the "no image" image")
    const staticCmsAssetPattern = /^\/assets\//; // Static (LWR-specific) app resources referenced

    /**
     * Check if given url is a cms resource url
     *
     * @param {string} url url to check
     * @returns {boolean} true if url contains /cms/ part
     */
    function isCmsResource(url) {
      return cmsResourceUrlPattern.test(url);
    }

    /**
     * Check if given url is a static image resource url
     *
     * @param {string} url url to check
     * @returns {boolean} true if url contains /img/ part
     */
    function isStaticImageResource(url) {
      return staticImageResourcePattern.test(url);
    }

    /**
     * Check if given url is a cms asset url
     *
     * @param {string} url url to check
     * @returns {boolean} true if url contains /assets/ part
     */
    function isCmsAsset(url) {
      return staticCmsAssetPattern.test(url);
    }

    /**
     * Check if given url is a resource url
     *
     * @param {string} url url to check
     * @returns {boolean} true if url is cms or image url
     */
    function isResource(url) {
      return isCmsResource(url) || isStaticImageResource(url);
    }

    /**
     * Resolves a cms assets/resource URL - that may (or may not) be managed by Salesforce CMS - to a canonical, routable URL.
     *
     * @param {string} url
     *  A URL of a resource. This may - or may not - be a Salesforce-hosted CMS resource.
     *
     * @returns {string}
     *  If {@see url} represents a CMS-hosted resource, then a resolved CMS resource URL;
     *  otherwise, the unaltered {@see url}.
     */
    function resolveUrl(url) {
      // If the URL is a CMS URL, transform it; otherwise, leave it alone.
      return isCmsAsset(url) ? siteInfo.buildSitePath(url) : isResource(url) ? siteInfo.buildSiteCmsPath(url) : url;
    }

    const CMS_MEDIA_BASE_PATH = "/cms/delivery/media";

    /**
     * A simple image info representation
     *
     * @typedef {object} ImageInfo
     *
     * @property {string} url image url
     * @property {string} altText alternative text
     */

    /**
     * A simple url info representation
     *
     * @typedef {object} UrlInfo
     *
     * @property {string} url image url
     * @property {boolean} isExternal whether url is external url
     */

    /**
     * Return cms content url *
     *
     * @param {object} config { url, isExternal }
     * @returns {string} content url
     */
    function getCMSContentUrl(config) {
      const {
        url,
        isExternal
      } = config;
      return siteInfo.buildSiteCmsPath(url, isExternal);
    }

    /**
     * Convert a cms item to url info
     *
     * @param {object} item cms content item
     * @returns {UrlInfo} url info
     */
    function toUrlInfo(item) {
      return {
        url: item.contentNodes?.source?.url ?? "",
        isExternal: !!item.contentNodes?.source?.isExternal,
        altText: item.contentNodes?.altText?.value ?? ""
      };
    }
    /**
     * Convert items to key map
     *
     * @param {Array} cmsContentItems Content Items
     * @returns {object} Content Key Map
     */
    function convertItemsToContentKeyMap(cmsContentItems = []) {
      return cmsContentItems.filter(item => item.contentKey && item.contentNodes).reduce((acc, item) => {
        acc.set(item.contentKey, toUrlInfo(item));
        return acc;
      }, new Map());
    }

    /**
     * Extract image info from cms content
     *
     * @param {object} data cms content data
     * @param {string[]} contentKeys a array of content key
     * @returns {ImageInfo} extracted image info
     */
    function extractImageInfo(data, contentKeys) {
      const contentKeyUrlMap = convertItemsToContentKeyMap(data?.items ?? []);
      const [key] = contentKeys;
      const urlInfo = contentKeyUrlMap.get(key);
      const imageInfo = urlInfo ? {
        url: getCMSContentUrl(urlInfo),
        altText: urlInfo.altText
      } : {};
      return imageInfo;
    }

    /**
     * Extract image info from cms v2 content
     *
     * @param {object} data cms content data
     * @returns {ImageInfo} extracted image info
     */
    function extractImageInfoV2(data) {
      const content = data?.contentBody ?? {};
      const media = content["sfdc_cms:media"] ?? {};
      const imageInfo = {
        url: siteInfo.buildSiteCmsPath(media.url ?? "", media.source?.type === "url"),
        altText: content.altText ?? ""
      };
      return imageInfo;
    }

    /**
     * Get Different Form Factors URLs from Image Info
     *
     * @param {object} imageInfo image info object
     * @returns {object} URLs for Mobile, Tablet and Desktop Form Factors
     */
    function getImageSrcSetUrls(imageInfo) {
      const mobileUrl = normalizer.normalizeString(imageInfo?.SrcSet?.[0]?.srcSet?.[0] || imageInfo?.Url, {
        fallbackValue: "initial",
        caseSensitive: true
      });
      const tabletUrl = normalizer.normalizeString(imageInfo?.SrcSet?.[1]?.srcSet?.[0] || imageInfo?.Url, {
        fallbackValue: "initial",
        caseSensitive: true
      });
      const desktopUrl = normalizer.normalizeString(imageInfo?.SrcSet?.[2]?.srcSet?.[0] || imageInfo?.Url, {
        fallbackValue: "initial",
        caseSensitive: true
      });
      return {
        mobileUrl,
        tabletUrl,
        desktopUrl
      };
    }

    /**
     * Extract Content Key from CMS Resource URL
     *
     * @param {string} url raw url
     * @returns {string} content key
     */
    function getContentKey(url) {
      if (!url || !url.includes(CMS_MEDIA_BASE_PATH)) {
        return null;
      }
      const start = url.indexOf(CMS_MEDIA_BASE_PATH) + CMS_MEDIA_BASE_PATH.length + 1;
      return url.substring(start) || null;
    }

    exports.convertItemsToContentKeyMap = convertItemsToContentKeyMap;
    exports.extractImageInfo = extractImageInfo;
    exports.extractImageInfoV2 = extractImageInfoV2;
    exports.getCMSContentUrl = getCMSContentUrl;
    exports.getContentKey = getContentKey;
    exports.getImageSrcSetUrls = getImageSrcSetUrls;
    exports.isCmsAsset = isCmsAsset;
    exports.isCmsResource = isCmsResource;
    exports.isResource = isResource;
    exports.isStaticImageResource = isStaticImageResource;
    exports.resolveUrl = resolveUrl;
    exports.toUrlInfo = toUrlInfo;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_util/idGenerator', ['exports', 'dxp_util/common'], (function (exports, common) {

    const ones = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"];
    const tens = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"];

    /**
     * Convert a number to a word string in english
     *
     * @param {number} num Number to be converted words
     * @returns {string} A string which describe the number in english
     */
    function numberToWord(num = 0) {
      if (typeof num === "string") {
        num = parseInt(num, 10);
      }
      if (num < 0) {
        throw new Error("Negative numbers are not supported.");
      }
      if (num === 0) {
        return "zero";
      }

      //the case of 1 - 20
      if (num < 20) {
        return ones[num];
      }
      const numString = num.toString();
      if (numString.length === 2) {
        return `${tens[numString[0]]}${ones[numString[1]] ? "-" + ones[numString[1]] : ""}`;
      }

      // 100 +
      if (numString.length === 3) {
        if (numString[1] === "0" && numString[2] === "0") {
          return `${ones[numString[0]]}-hundred`;
        }
        const result = numberToWord(+(numString[1] + numString[2]));
        return `${ones[numString[0]]}-hundred-${result}`;
      }

      // 1000 +
      if (numString.length === 4) {
        const end = +(numString[1] + numString[2] + numString[3]);
        if (end === 0) {
          return ones[numString[0]] + "-thousand";
        }
        if (end < 100) {
          return `${ones[numString[0]]}-thousand-${numberToWord(end)}`;
        }
        return `${ones[numString[0]]}-thousand-${numberToWord(end)}`;
      }
      throw new Error(`${num} are not supported.`);
    }

    const indexToWord = baseIndex => index => numberToWord(index + baseIndex);
    const capitalize = capitalCase => string => capitalCase ?? false ? common.toCapitalized(string) : string;
    const appendPrefix = prefix => string => `${prefix}${string}`;

    /**
     * Generate id per given prefix
     *
     * @param {number} baseIndex base index such as start with 0, 1
     * @param {string} capitalCase whether use capital case
     * @param {string} prefix Prefix for each id
     * @param {number} index Index to generate id
     * @returns {string} such as CustomFieldOne or custom-field-twenty
     */
    function generateId(baseIndex, capitalCase, prefix, index) {
      return common.compose(appendPrefix(prefix), capitalize(capitalCase), indexToWord(baseIndex))(index);
    }
    const fnGenerateId = common.curry(generateId);

    /**
     * Generate ids per given prefix and total count
     *
     * @param {string} prefix Prefix for each id
     * @param {number} count How many ids are required
     * @param {object} options Options for generating id
     * @returns {Array} ids A array if generated ids
     */
    function generateIds(prefix, count, options = {
      baseIndex: 0,
      capitalCase: false
    }) {
      return common.compose(common.map(fnGenerateId(options.baseIndex, options.capitalCase, prefix)), common.toIndexes)(count);
    }

    /**
     * Generate unique number
     *
     * @returns {number} unique number
     */
    function generateUniqueNumber() {
      return Math.floor(new Date().valueOf() * Math.random());
    }

    exports.fnGenerateId = fnGenerateId;
    exports.generateId = generateId;
    exports.generateIds = generateIds;
    exports.generateUniqueNumber = generateUniqueNumber;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_data_provider/dataProviderUtils', ['exports', 'dxp_util/contentInfo', '@app/isDesignMode', 'dxp_util/idGenerator'], (function (exports, contentInfo, isDesignMode, idGenerator) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var isDesignMode__default = /*#__PURE__*/_interopDefaultCompat(isDesignMode);

    /**
     * Genereate a mock collection when it's in design mode
     *
     * @param {number} count how many items to generate
     * @returns {Array} mock collection or empty array
     */
    function generateMockCollection(count) {
      return isDesignMode__default.default ? idGenerator.generateIds("", count).map(id => ({
        key: id,
        data: {}
      })) : [];
    }

    const DATA_BIND_REGEX = /\{!Item\.(.+?)\}/g;
    const DATA_PROVIDER_GET_FIELD_DATA_EVENT_NAME = "dxp_data_provider__getfielddata";
    const DATA_PROVIDER_FIELD_METADATA_PREFIX = "_";
    const DATA_PROVIDER_DATA_ACCESS = `${DATA_PROVIDER_FIELD_METADATA_PREFIX}data`;
    const MASTER_RECORD_TYPE_ID = "012000000000000AAA";
    const SFDC_TYPES = {
      RECORD: "sfdc_record__",
      CMS: "sfdc_cms__"
    };
    const getFieldAndMetadata = fieldAndMetadata => {
      const fieldParts = fieldAndMetadata.split(".");
      if (fieldParts.length > 0 && fieldParts[fieldParts.length - 1].startsWith("_")) {
        // if a metadata access, determine if on data or on a field. ex. {!Item._data} vs {!Item.field._displayValue}
        const metadata = fieldParts[fieldParts.length - 1];
        const field = fieldParts.slice(0, fieldParts.length - 1);
        if (fieldParts.length === 1) {
          return [null, metadata];
        }
        return [field, metadata];
      }
      return [fieldAndMetadata, null];
    };

    /**
     * Normalize the content key
     *
     * @param {string} key content key to normalize
     * @returns {string} normalized content key
     */
    function normalizeContentKey(key) {
      // If content key has '-', then comes from the expression {!urlAlias} -> route param
      if (key?.includes("-")) {
        // content key is the last value divided by '-', (ex. we-still-meeting-today-MCKABCDYJW4ZCE5IECPBVBBLQY5I)
        return key.split("-").slice(-1)[0];
      }
      return key;
    }

    /**
     * Build field path with existing path and incoming field
     *
     * @param {string} existingPath current field path
     * @param {string} field appended field
     * @returns {string} combined path from existingPath and new path
     */
    function buildFieldPath(existingPath, field) {
      return !existingPath ? field : `${existingPath}.${field}`;
    }

    Object.defineProperty(exports, 'resolve', {
        enumerable: true,
        get: function () { return contentInfo.resolveUrl; }
    });
    exports.DATA_BIND_REGEX = DATA_BIND_REGEX;
    exports.DATA_PROVIDER_DATA_ACCESS = DATA_PROVIDER_DATA_ACCESS;
    exports.DATA_PROVIDER_FIELD_METADATA_PREFIX = DATA_PROVIDER_FIELD_METADATA_PREFIX;
    exports.DATA_PROVIDER_GET_FIELD_DATA_EVENT_NAME = DATA_PROVIDER_GET_FIELD_DATA_EVENT_NAME;
    exports.MASTER_RECORD_TYPE_ID = MASTER_RECORD_TYPE_ID;
    exports.SFDC_TYPES = SFDC_TYPES;
    exports.buildFieldPath = buildFieldPath;
    exports.generateMockCollection = generateMockCollection;
    exports.getFieldAndMetadata = getFieldAndMetadata;
    exports.normalizeContentKey = normalizeContentKey;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('force/ldsBindings', ['exports', 'lwc'], (function (exports, lwc) {

    // instrumentation keys to be imported by ldsInstrumentation
    const REFRESH_ADAPTER_EVENT = 'refresh-adapter-event';
    const ADAPTER_UNFULFILLED_ERROR = 'adapter-unfulfilled-error';
    const USERLAND_PROVISION_ERROR_MESSAGE = "LWC component's @wire target property or method threw an error during value provisioning. Original error:";
    const ADAPTER_SNAPSHOT_REJECTED_MESSAGE = 'Luvio wire adapter Promise<Snapshot> rejected. Original error:';
    const USERLAND_GRAPHQL_PARSER_ERROR_MESSAGE = 'Use `gql` parser to parse your "query" string';

    // map of emitted object -> [ adapter name, snapshot ]; snapshot is only undefined for the
    // initially-emitted { data: undefined, error: undefined } value
    const dataToTupleWeakMap = new WeakMap();
    var SnapshotState$1;
    (function (SnapshotState) {
      SnapshotState["Fulfilled"] = "Fulfilled";
      SnapshotState["Unfulfilled"] = "Unfulfilled";
      SnapshotState["Error"] = "Error";
      SnapshotState["Pending"] = "Pending";
      SnapshotState["Stale"] = "Stale";
    })(SnapshotState$1 || (SnapshotState$1 = {}));
    function isErrorSnapshot$1(snapshot) {
      return snapshot.state === SnapshotState$1.Error;
    }
    function isFulfilledSnapshot(snapshot) {
      return snapshot.state === SnapshotState$1.Fulfilled;
    }
    function isStaleSnapshot(snapshot) {
      return snapshot.state === SnapshotState$1.Stale;
    }
    function isUnfulfilledSnapshot(snapshot) {
      return snapshot.state === SnapshotState$1.Unfulfilled;
    }
    /**
     * Transform a Snapshot into a payload suitable for passing to a DataCallback.
     *
     * @param snapshot Snapshot
     */
    function snapshotToPayload$1(snapshot) {
      if (snapshot === undefined) {
        return {
          data: undefined,
          error: undefined
        };
      }
      if (isErrorSnapshot$1(snapshot)) {
        return {
          data: undefined,
          error: snapshot.error
        };
      }
      // fulfilled or stale
      return {
        data: snapshot.data,
        error: undefined
      };
    }
    function bindWireRefresh$1(luvio) {
      return function refresh(data) {
        return refreshData(data, dataToTupleWeakMap, luvio);
      };
    }
    function refreshData(data, dataToTuple, luvio) {
      const tuple = dataToTuple.get(lwc.unwrap(data));
      if (tuple === undefined) {
        {
          throw new Error('Refresh failed because resolved configuration is not available.');
        }
      }
      const [adapterName, snapshot] = tuple;
      luvio.instrument(() => {
        return {
          [REFRESH_ADAPTER_EVENT]: true,
          adapterName
        };
      });
      // snapshot is undefined when a caller refreshes the initial
      // { data: undefined, error: undefined } object that we emitted
      if (snapshot === undefined) {
        return Promise.resolve(undefined);
      }
      return luvio.refreshSnapshot(snapshot).then(refreshed => {
        if (isErrorSnapshot$1(refreshed)) {
          throw refreshed.error;
        }
        {
          if (isUnfulfilledSnapshot(refreshed)) {
            throw new Error('Refresh resulted in unfulfilled snapshot');
          }
        }
        return undefined;
      });
    }
    function isPromise$1(value) {
      // check for Thenable due to test frameworks using custom Promise impls
      return value.then !== undefined;
    }
    const {
      isArray
    } = Array;
    const {
      stringify
    } = JSON;

    /**
     * (Re)throws an error after adding a prefix to the message.
     *
     * @param error Error
     * @param messagePrefix prefix to add to error's message
     */
    function throwAnnotatedError(error, messagePrefix) {
      if (error instanceof Error) {
        error.message = `${messagePrefix}\n[${error.message}]`;
        throw error;
      }
      throw new Error(`${messagePrefix}\n[${stringify(error)}]`);
    }
    class Sanitizer {
      constructor(obj) {
        this.obj = obj;
        this.copy = {};
        this.currentPath = {
          key: '',
          value: obj,
          parent: null,
          data: this.copy
        };
      }
      sanitize() {
        const sanitizer = this;
        stringify(this.obj, function (key, value) {
          if (key === '') {
            return value;
          }
          const parent = this;
          if (parent !== sanitizer.currentPath.value) {
            sanitizer.exit(parent);
          }
          if (typeof value === 'object' && value !== null) {
            sanitizer.enter(key, value);
            return value;
          }
          sanitizer.currentPath.data[key] = value;
          return value;
        });
        return this.copy;
      }
      enter(key, value) {
        const {
          currentPath: parentPath
        } = this;
        const data = parentPath.data[key] = isArray(value) ? [] : {};
        this.currentPath = {
          key,
          value,
          parent: parentPath,
          data
        };
      }
      exit(parent) {
        while (this.currentPath.value !== parent) {
          this.currentPath = this.currentPath.parent || this.currentPath;
        }
      }
    }
    /**
     * Returns a sanitized version of an object by recursively unwrapping the Proxies.
     *
     * In order to keep luvio performance optimal on IE11, we need to make sure that luvio code gets
     * transformed by the es5-proxy-compat. At the same time we need to ensure that no ProxyCompat leaks
     * into the luvio engine code nor into the adapters. All the data coming from LWC-land need to be
     * sanitized first.
     */
    function sanitize(obj) {
      return new Sanitizer(obj).sanitize();
    }
    class LWCLuvioWireAdapter {
      /**
       * Constructs a new wire adapter instance for the given adapter.
       *
       * @param callback callback to be invoked with new values
       */
      constructor(adapter, name, luvio, callback, sourceContext) {
        // a component can be connected-disconnected-reconnected multiple times during its
        // life but we only want to keep subscriptions active while it is connected; the
        // connect/disconnect methods below keep this value updated to reflect the current
        // state
        this.connected = false;
        this.adapter = adapter;
        this.name = name;
        this.luvio = luvio;
        this.callback = callback;
        this.sourceContext = sourceContext;
        // initialize the wired property with a properly shaped object so cmps can use <template if:true={wiredProperty.data}>
        this.emit();
      }
      // WireAdapter interface methods
      /**
       * Called when the component associated with the wire adapter is connected.
       */
      connect() {
        this.connected = true;
        this.callAdapter(this.generateAdapterRequestContext());
      }
      /**
       * Called when the component associated with the wire adapter is disconnected.
       */
      disconnect() {
        this.unsubscribe();
        this.connected = false;
      }
      /**
       * Called when new or updated config is supplied to the wire adapter.
       *
       * @param config new config parameters for the wire adapter
       * @param _context not used
       */
      update(config, context) {
        this.unsubscribe();
        this.config = sanitize(config);
        this.callAdapter(this.generateAdapterRequestContext(context));
      }
      // private and protected utility methods
      /**
       * Accepts a WireContext and generates corresponding AdapterRequestContext
       */
      generateAdapterRequestContext(_context) {
        if (!this.sourceContext) {
          return {};
        }
        return {
          sourceContext: {
            ...this.sourceContext
          }
        };
      }
      /**
       * Calls the adapter if config has been set and the component is connected.
       */
      callAdapter(context) {
        if (!this.connected || this.config === undefined) {
          return;
        }
        const snapshotOrPromise = this.adapter(this.config, context);
        this.processAdapterResponse(snapshotOrPromise);
      }
      processAdapterResponse(snapshotOrPromise) {
        // insufficient config, wait for new config from component
        if (snapshotOrPromise === null) {
          return;
        }
        const configForSnapshot = this.config;
        const emitAndSubscribe = snapshot => {
          // adapters leveraging adapter context could asynchronously
          // return null (due to invalid config)
          if (snapshot === null) {
            return;
          }
          // We should never broadcast an unfulfilled snapshot to a component
          if (isUnfulfilledSnapshot(snapshot)) {
            {
              throw new Error(`Unfulfilled snapshot emitted to component from subscription, missingPaths: ${snapshot.missingPaths.keysAsArray()}`);
            }
          }
          // if config has changed before the snapshot arrives then ignore snapshot
          if (this.config !== configForSnapshot) {
            return;
          }
          // emit unless snapshot is pending
          if (isFulfilledSnapshot(snapshot) || isErrorSnapshot$1(snapshot) || isStaleSnapshot(snapshot)) {
            this.emit(snapshot);
          }
          // subscribe to the new snapshot
          this.subscribe(snapshot);
        };
        // Data resolved sync
        if (!isPromise$1(snapshotOrPromise)) {
          emitAndSubscribe(snapshotOrPromise);
        } else {
          // We want to let errors from this promise propagate to the app container,
          // which is why we do not have a reject handler here.
          // If an error is thrown here, it means that there was an error somewhere
          // inside an adapter which means that there was a mistake by the implementor.
          // Errors that come from the network should never hit this block because
          // they are treated like regular snapshots, not true error paths.
          snapshotOrPromise.then(emitAndSubscribe, error => throwAnnotatedError(error, ADAPTER_SNAPSHOT_REJECTED_MESSAGE));
        }
      }
      /**
       * Emits new values to the callback.
       *
       * @param snapshot Snapshot to be emitted, if omitted then undefineds will be emitted
       */
      emit(snapshot) {
        const payload = snapshotToPayload$1(snapshot);
        dataToTupleWeakMap.set(payload, [this.name, snapshot]);
        try {
          this.callback(payload);
        } catch (error) {
          if (error instanceof Error) {
            throwAnnotatedError(error, USERLAND_PROVISION_ERROR_MESSAGE);
          }
        }
      }
      /**
       * Subscribes this wire adapter to future changes to the specified snapshot. Any changes
       * to the snapshot will be automatically emitted to the component.
       *
       * @param snapshot Snapshot
       * @param subscriptionCallback callback
       */
      subscribe(snapshot) {
        // always clean up any old subscription that we might have
        this.unsubscribe();
        // but only subscribe if component is currently connected
        if (this.connected) {
          this.unsubscriber = this.luvio.storeSubscribe(snapshot, this.emit.bind(this));
        }
      }
      /**
       * Deletes this wire adapter's snapshot subscription (if any).
       */
      unsubscribe() {
        // clean up subscription
        if (this.unsubscriber !== undefined) {
          this.unsubscriber();
          this.unsubscriber = undefined;
        }
      }
    }
    /**
     * Wraps a luvio Adapter in a WireAdapterConstructor that conforms to https://rfcs.lwc.dev/rfcs/lwc/0000-wire-reform#wire-adapter-protocol.
     *
     * @param adapter Adapter
     * @param name name to assign to the generated constructor
     * @param luvio Luvio
     */
    function createWireAdapterConstructor$1(adapter, name, luvio) {
      const constructor = function (callback, sourceContext) {
        const delegate = new LWCLuvioWireAdapter(adapter, name, luvio, callback, sourceContext);
        this.connect = () => delegate.connect();
        this.disconnect = () => delegate.disconnect();
        this.update = (config, context) => delegate.update(config, context);
      };
      Object.defineProperty(constructor, 'name', {
        value: name
      });
      return constructor;
    }
    class LWCInfinteScrollingLuvioWireAdapter extends LWCLuvioWireAdapter {
      /**
       * Called when the component associated with the wire adapter is connected.
       */
      connect() {
        this.connectTimestamp = Date.now();
        super.connect();
      }
      /**
       * Called when the component associated with the wire adapter is disconnected.
       */
      disconnect() {
        this.connectTimestamp = undefined;
        super.disconnect();
      }
      /**
       * Called when new or updated config is supplied to the wire adapter.
       *
       * @param config new config parameters for the wire adapter
       * @param context context for the wire adapter
       */
      update(config, context) {
        if (this.connectTimestamp) {
          const adapterRequestContext = this.generateAdapterRequestContext(context);
          super.unsubscribe();
          this.config = sanitize(config);
          // this.callAdapterWithContext(mergedContext);
          super.callAdapter(adapterRequestContext);
        } else {
          super.update(config, context);
        }
      }
      generateAdapterRequestContext(context) {
        const baseContext = super.generateAdapterRequestContext(context);
        // this code-path is only called when the wire adapter is connected
        // and the connectTimestamp is set
        return {
          ...baseContext,
          cachePolicy: {
            type: 'valid-at',
            timestamp: this.connectTimestamp
          }
        };
      }
      subscribe(snapshot) {
        var _a;
        super.subscribe(snapshot);
        // if the snapshot is refreshed we should stop using data from before the refresh
        if (this.connected && ((_a = snapshot.refresh) === null || _a === void 0 ? void 0 : _a.resolve)) {
          const originalResolve = snapshot.refresh.resolve;
          snapshot.refresh.resolve = config => {
            this.connectTimestamp = Date.now();
            return originalResolve(config);
          };
        }
      }
      /*LWC compiler v7.1.5*/
    }
    function createInfiniteScrollingWireAdapterConstructor$1(adapter, name, luvio) {
      const constructor = function (callback, sourceContext) {
        const delegate = new LWCInfinteScrollingLuvioWireAdapter(adapter, name, luvio, callback, sourceContext);
        this.connect = () => delegate.connect();
        this.disconnect = () => delegate.disconnect();
        this.update = (config, context) => delegate.update(config, context);
      };
      Object.defineProperty(constructor, 'name', {
        value: name
      });
      return constructor;
    }
    function snapshotToPayload(snapshot) {
      const payload = {
        data: undefined,
        errors: undefined
      };
      if (snapshot === undefined) {
        return payload;
      }
      payload.data = extractSnapshotData(snapshot);
      // TODO handle batch error scenarios.
      if ('error' in snapshot && snapshot.error !== undefined) {
        if (Array.isArray(snapshot.error)) {
          payload.errors = snapshot.error;
        } else {
          payload.errors = [snapshot.error];
        }
      }
      return payload;
    }
    class LWCGraphQLLuvioWireAdapter extends LWCLuvioWireAdapter {
      constructor(adapter, name, luvio, astResolver, callback, sourceContext) {
        super(adapter, name, luvio, callback, sourceContext);
        this.astResolver = astResolver;
      }
      update(config, context) {
        this.unsubscribe();
        if (config.batchQuery) {
          this.config = {
            batchQuery: config.batchQuery.map(individualConfig => safeSanitizeGraphQLConfigObject(individualConfig))
          };
        } else {
          this.config = safeSanitizeGraphQLConfigObject(config);
        }
        this.callAdapter(super.generateAdapterRequestContext(context));
      }
      /**
       * Emits new values to the callback.
       *
       * @param snapshot Snapshot to be emitted, if omitted then undefineds will be emitted
       */
      emit(snapshot) {
        const payload = snapshotToPayload(snapshot);
        dataToTupleWeakMap.set(payload, [this.name, snapshot]);
        try {
          this.callback(payload);
        } catch (error) {
          if (error instanceof Error) {
            throwAnnotatedError(error, USERLAND_PROVISION_ERROR_MESSAGE);
          }
        }
      }
      /**
       * Coerce config before calling the adapter, preserve current behavior otherwise
       */
      callAdapter(context) {
        if (!this.connected || this.config === undefined) {
          return;
        }
        const config = this.config;
        if ('batchQuery' in config) {
          const batchConfig = {
            batchQuery: config.batchQuery.map(individualConfig => this.resolveQueryAst(individualConfig))
          };
          // If any of the configurations are invalid, we bail out of calling the adapter.
          if (batchConfig.batchQuery.some(val => val === undefined)) {
            return;
          }
          const snapshotOrPromise = this.adapter(batchConfig, context);
          this.processAdapterResponse(snapshotOrPromise);
        } else if ('query' in config) {
          const singleConfig = this.resolveQueryAst(config);
          if (singleConfig !== undefined) {
            const snapshotOrPromise = this.adapter(singleConfig, context);
            this.processAdapterResponse(snapshotOrPromise);
          }
        }
      }
      resolveQueryAst(config) {
        if (config.query === null) {
          return;
        }
        const ast = this.astResolver(config.query);
        if (ast === undefined && config.query !== undefined) {
          // this should only happen if the user didn't parse the query
          {
            throw new Error(USERLAND_GRAPHQL_PARSER_ERROR_MESSAGE);
          }
        }
        const resolvedAdapterConfig = {
          ...config,
          query: ast
        };
        return resolvedAdapterConfig;
      }
      /*LWC compiler v7.1.5*/
    }
    function extractSnapshotData(snapshot) {
      if ('data' in snapshot && snapshot.data !== undefined) {
        const isSingleGraphQLData = 'data' in snapshot.data && snapshot.data.data !== undefined;
        const isBatchGraphQLData = 'results' in snapshot.data && snapshot.data.results !== undefined;
        if (isSingleGraphQLData) return snapshot.data.data;
        if (isBatchGraphQLData) return snapshot.data;
      }
    }
    /**
     * Wraps a luvio Adapter in a WireAdapterConstructor that conforms to https://rfcs.lwc.dev/rfcs/lwc/0000-wire-reform#wire-adapter-protocol.
     *
     * @param adapter Adapter
     * @param name name to assign to the generated constructor
     * @param luvio Luvio
     */
    function createGraphQLWireAdapterConstructor$1(adapter, name, luvio, astResolver) {
      const constructor = function (callback, sourceContext) {
        const delegate = new LWCGraphQLLuvioWireAdapter(adapter, name, luvio, astResolver, callback, sourceContext);
        this.connect = () => delegate.connect();
        this.disconnect = () => delegate.disconnect();
        this.update = (config, context) => delegate.update(config, context);
      };
      Object.defineProperty(constructor, 'name', {
        value: name
      });
      return constructor;
    }
    function safeSanitizeGraphQLConfigObject(config) {
      // graphql query AST is passed by reference
      // sanitizing it makes a copy and we lose that reference
      // so we avoid sanitizing it
      return {
        ...sanitize(config),
        query: config.query
      };
    }

    // For use by callers within this module to instrument interesting things.
    let instrumentation = {
      refreshCalled: _fromSource => {},
      instrumentAdapter: (adapter, _metadata) => {
        return adapter;
      }
    };
    /**
     * Allows external modules (typically a runtime environment) to set
     * instrumentation hooks for this module. Note that the hooks are
     * incremental - hooks not suppiled in newInstrumentation will retain
     * their previous values. The default instrumentation hooks are no-ops.
     *
     * @param newInstrumentation instrumentation hooks to be overridden
     */
    function instrument(newInstrumentation) {
      instrumentation = Object.assign(instrumentation, newInstrumentation);
    }
    exports.refresh = void 0;
    function bindWireRefresh(luvio) {
      const wireRefresh = bindWireRefresh$1(luvio);
      exports.refresh = (data, apiFamily) => {
        instrumentation.refreshCalled(apiFamily);
        return wireRefresh(data);
      };
    }
    function createInstrumentedAdapter(adapter, metadata) {
      return instrumentation.instrumentAdapter(adapter, metadata);
    }
    function createLDSAdapter(luvio, name, factory) {
      return factory(luvio);
    }
    const {
      create,
      defineProperty,
      defineProperties
    } = Object;
    var SnapshotState;
    (function (SnapshotState) {
      SnapshotState["Fulfilled"] = "Fulfilled";
      SnapshotState["Unfulfilled"] = "Unfulfilled";
      SnapshotState["Error"] = "Error";
      SnapshotState["Pending"] = "Pending";
      SnapshotState["Stale"] = "Stale";
    })(SnapshotState || (SnapshotState = {}));
    function isErrorSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Error;
    }
    function isPendingSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Pending;
    }
    function isPromise(value) {
      // check for Thenable due to test frameworks using custom Promise impls
      return value !== null && value.then !== undefined;
    }
    function snapshotToTuple$1(snapshot) {
      if (isErrorSnapshot(snapshot)) {
        return {
          data: undefined,
          error: snapshot.error
        };
      }
      // We might still get pending snapshot here from invoke calls here
      return {
        data: snapshot.data,
        error: undefined
      };
    }
    function createInvalidConfigError$1() {
      return {
        data: undefined,
        error: {
          ok: false,
          status: 400,
          statusText: 'INVALID_CONFIG',
          body: undefined,
          headers: {},
          errorType: 'fetchResponse'
        }
      };
    }
    /**
     * Creates an imperative adapter
     *
     * @param luvio Luvio
     * @param adapter luvio adapter
     * @param metadata AdapterMetadata
     * @returns Imperative adapter object with invoke and subscribe functions
     */
    function createImperativeAdapter(luvio, adapter, metadata) {
      const {
        name
      } = metadata;
      const imperativeAdapterInvoke = (config, requestContext, callback) => {
        const snapshotOrPromise = adapter(config, requestContext);
        if (snapshotOrPromise === null) {
          callback(createInvalidConfigError$1());
          return;
        }
        if (!isPromise(snapshotOrPromise)) {
          callback(snapshotToTuple$1(snapshotOrPromise));
          return;
        }
        snapshotOrPromise.then(snapshot => {
          if (snapshot === null) {
            callback(createInvalidConfigError$1());
            return;
          }
          callback(snapshotToTuple$1(snapshot));
        }).finally(() => {
          luvio.storeCleanup();
        });
      };
      defineProperty(imperativeAdapterInvoke, 'name', {
        value: `${name}_invoke`
      });
      // Invokes the adapter and subscribes to the received snapshot
      // Returns an unsubscribe function to the consumer
      const imperativeAdapterSubscribe = (config, requestContext, callback) => {
        let subscriberCallback = callback;
        let unsub;
        const snapshotOrPromise = adapter(config, requestContext);
        if (snapshotOrPromise === null) {
          subscriberCallback(createInvalidConfigError$1());
          return () => {};
        }
        // Can rebuild lead to pending snapshots?
        const luvioStoreSubscribe = snapshot => {
          unsub = luvio.storeSubscribe(snapshot, snapshotFromRebuild => {
            if (subscriberCallback !== null && !isPendingSnapshot(snapshotFromRebuild)) {
              subscriberCallback(snapshotToTuple$1(snapshotFromRebuild));
            }
          });
        };
        if (!isPromise(snapshotOrPromise)) {
          // We don't want to return pending snapshots to user-land
          // Instead we just subscribe to it
          if (!isPendingSnapshot(snapshotOrPromise)) {
            subscriberCallback(snapshotToTuple$1(snapshotOrPromise));
          }
          luvioStoreSubscribe(snapshotOrPromise);
        } else {
          snapshotOrPromise.then(snapshot => {
            if (subscriberCallback !== null) {
              if (snapshot === null) {
                subscriberCallback(createInvalidConfigError$1());
                return;
              }
              // We don't want to return pending snapshots to user-land
              // Instead we just subscribe to it
              if (!isPendingSnapshot(snapshot)) {
                subscriberCallback(snapshotToTuple$1(snapshot));
              }
              luvioStoreSubscribe(snapshot);
            }
          });
        }
        return () => {
          if (subscriberCallback !== null && unsub !== undefined) {
            unsub();
          }
          subscriberCallback = null;
          unsub = undefined;
        };
      };
      defineProperty(imperativeAdapterSubscribe, 'name', {
        value: `${name}_subscribe`
      });
      return {
        invoke: imperativeAdapterInvoke,
        subscribe: imperativeAdapterSubscribe
      };
    }
    function snapshotToTuple(snapshot) {
      if (isErrorSnapshot(snapshot)) {
        if (snapshot.error.errorType === 'adapterError') {
          // GraphQL can return 200 with an errors array
          return {
            data: undefined,
            errors: snapshot.error.error
          };
        } else {
          // This is a network error or some other error - usually with a single error bubled up.
          return {
            data: undefined,
            errors: [snapshot.error]
          };
        }
      }
      // cast any PendingSnapshot to FulfilledSnapshot here,
      //  we shouldn't get anything pending at this point
      const payload = {};
      const dataSnapshot = snapshot;
      if ('data' in dataSnapshot.data && dataSnapshot.data.data !== undefined) {
        payload.data = dataSnapshot.data.data;
      }
      if (dataSnapshot.data.errors !== undefined) {
        payload.errors = dataSnapshot.data.errors;
      }
      return payload;
    }
    function createInvalidConfigError() {
      return {
        data: undefined,
        errors: [{
          ok: false,
          status: 400,
          statusText: 'INVALID_CONFIG',
          body: undefined,
          headers: {},
          errorType: 'fetchResponse'
        }]
      };
    }
    /**
     * Creates an imperative adapter
     *
     * @param luvio Luvio
     * @param adapter luvio adapter
     * @param metadata AdapterMetadata
     * @returns Imperative adapter object with invoke and subscribe functions
     */
    function createGraphQLImperativeAdapter(luvio, adapter, metadata, astResolver) {
      const {
        name
      } = metadata;
      const imperativeAdapterInvoke = (config, requestContext, callback) => {
        let coercedConfig = null;
        if ('batchQuery' in config) {
          coercedConfig = {
            batchQuery: config.batchQuery.map(individualConfig => ({
              ...individualConfig,
              query: astResolver(individualConfig.query)
            }))
          };
          // If any of the configurations are invalid, we bail out of calling the adapter.
          if (coercedConfig.batchQuery.some(individualConfig => individualConfig.query === undefined)) {
            callback(createInvalidConfigError());
            return;
          }
        } else if ('query' in config) {
          const ast = astResolver(config.query);
          if (ast === undefined) {
            callback(createInvalidConfigError());
            return;
          }
          coercedConfig = {
            ...config,
            query: ast
          };
        }
        const snapshotOrPromise = adapter(coercedConfig, requestContext);
        if (snapshotOrPromise === null) {
          callback(createInvalidConfigError());
          return;
        }
        if (!isPromise(snapshotOrPromise)) {
          callback(snapshotToTuple(snapshotOrPromise));
          return;
        }
        snapshotOrPromise.then(snapshot => {
          if (snapshot === null) {
            callback(createInvalidConfigError());
            return;
          }
          callback(snapshotToTuple(snapshot));
        });
      };
      defineProperty(imperativeAdapterInvoke, 'name', {
        value: `${name}_invoke`
      });
      // Invokes the adapter and subscribes to the received snapshot
      // Returns an unsubscribe function to the consumer
      const imperativeAdapterSubscribe = (config, requestContext, callback) => {
        let subscriberCallback = callback;
        let unsub;
        let coercedConfig = null;
        if ('batchQuery' in config) {
          coercedConfig = {
            batchQuery: config.batchQuery.map(individualConfig => ({
              ...individualConfig,
              query: astResolver(individualConfig.query)
            }))
          };
          // If any of the configurations are invalid, we bail out of calling the adapter.
          if (coercedConfig.batchQuery.some(individualConfig => individualConfig.query === undefined)) {
            callback(createInvalidConfigError());
            return () => {};
          }
        } else if ('query' in config) {
          const ast = astResolver(config.query);
          if (ast === undefined) {
            callback(createInvalidConfigError());
            return () => {};
          }
          coercedConfig = {
            ...config,
            query: ast
          };
        }
        const snapshotOrPromise = adapter(coercedConfig, requestContext);
        if (snapshotOrPromise === null) {
          subscriberCallback(createInvalidConfigError());
          return () => {};
        }
        // Can rebuild lead to pending snapshots?
        const luvioStoreSubscribe = snapshot => {
          unsub = luvio.storeSubscribe(snapshot, snapshotFromRebuild => {
            if (subscriberCallback !== null && !isPendingSnapshot(snapshotFromRebuild)) {
              subscriberCallback(snapshotToTuple(snapshotFromRebuild));
            }
          });
        };
        if (!isPromise(snapshotOrPromise)) {
          // We don't want to return pending snapshots to user-land
          // Instead we just subscribe to it
          if (!isPendingSnapshot(snapshotOrPromise)) {
            subscriberCallback(snapshotToTuple(snapshotOrPromise));
          }
          luvioStoreSubscribe(snapshotOrPromise);
        } else {
          snapshotOrPromise.then(snapshot => {
            if (subscriberCallback !== null) {
              if (snapshot === null) {
                subscriberCallback(createInvalidConfigError());
                return;
              }
              // TODO [W-11370904]: revisit this. Does GraphQL need to worry about pending?
              // We don't want to return pending snapshots to user-land
              // Instead we just subscribe to it
              if (!isPendingSnapshot(snapshot)) {
                subscriberCallback(snapshotToTuple(snapshot));
              }
              luvioStoreSubscribe(snapshot);
            }
          });
        }
        return () => {
          if (subscriberCallback !== null && unsub !== undefined) {
            unsub();
          }
          subscriberCallback = null;
          unsub = undefined;
        };
      };
      defineProperty(imperativeAdapterSubscribe, 'name', {
        value: `${name}_subscribe`
      });
      return {
        invoke: imperativeAdapterInvoke,
        subscribe: imperativeAdapterSubscribe
      };
    }
    function createWireAdapterConstructor(luvio, adapter, metadata) {
      const {
        apiFamily,
        name
      } = metadata;
      return createWireAdapterConstructor$1(adapter, `${apiFamily}.${name}`, luvio);
    }
    function createInfiniteScrollingWireAdapterConstructor(luvio, adapter, metadata) {
      const {
        apiFamily,
        name
      } = metadata;
      return createInfiniteScrollingWireAdapterConstructor$1(adapter, `${apiFamily}.${name}`, luvio);
    }
    function createGraphQLWireAdapterConstructor(luvio, adapter, metadata, astResolver) {
      const {
        apiFamily,
        name
      } = metadata;
      return createGraphQLWireAdapterConstructor$1(adapter, `${apiFamily}.${name}`, luvio, astResolver);
    }
    // version: 1.309.0-dev21-4baf03ecaf
    const __lwc_hmr_context = { moduleHash : '98b357084df1318c8344ddb799ce6fda' };
    if (lwc.hot) {
        lwc.hot.register('force/ldsBindings/ldsBindings.js', '98b357084df1318c8344ddb799ce6fda', {"name":"ldsBindings","namespace":"force","enableLightningWebSecurityTransforms":false,"experimentalDynamicComponent":{"loader":"@salesforce/loader","strictSpecifier":false},"experimentalDynamicDirective":false,"enableDynamicComponents":true,"enableStaticContentOptimization":true,"outputConfig":{"sourcemap":false}});
    }

    exports.ADAPTER_UNFULFILLED_ERROR = ADAPTER_UNFULFILLED_ERROR;
    exports.REFRESH_ADAPTER_EVENT = REFRESH_ADAPTER_EVENT;
    exports.__lwc_hmr_context = __lwc_hmr_context;
    exports.bindWireRefresh = bindWireRefresh;
    exports.createGraphQLImperativeAdapter = createGraphQLImperativeAdapter;
    exports.createGraphQLWireAdapterConstructor = createGraphQLWireAdapterConstructor;
    exports.createImperativeAdapter = createImperativeAdapter;
    exports.createInfiniteScrollingWireAdapterConstructor = createInfiniteScrollingWireAdapterConstructor;
    exports.createInstrumentedAdapter = createInstrumentedAdapter;
    exports.createLDSAdapter = createLDSAdapter;
    exports.createWireAdapterConstructor = createWireAdapterConstructor;
    exports.instrument = instrument;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('force/luvioEngine', ['exports', 'lwc'], (function (exports, lwc) {

    /**
     * Copyright (c) 2022, Salesforce, Inc.,
     * All rights reserved.
     * For full license text, see the LICENSE.txt file
     */

    /*
     *  ATTENTION!
     *  THIS IS A GENERATED FILE FROM https://github.com/salesforce-experience-platform-emu/lds-lightning-platform
     *  If you would like to contribute to LDS, please follow the steps outlined in the git repo.
     *  Any changes made to this file in p4 will be automatically overwritten.
     *  *******************************************************************************************
     */
    /* proxy-compat-disable */
    var SnapshotState;
    (function (SnapshotState) {
      SnapshotState["Fulfilled"] = "Fulfilled";
      SnapshotState["Unfulfilled"] = "Unfulfilled";
      SnapshotState["Error"] = "Error";
      SnapshotState["Pending"] = "Pending";
      SnapshotState["Stale"] = "Stale";
    })(SnapshotState || (SnapshotState = {}));
    const {
      create,
      entries,
      freeze,
      keys,
      values,
      assign
    } = Object;
    const {
      hasOwnProperty
    } = Object.prototype;
    const {
      isArray
    } = Array;
    const {
      push,
      indexOf,
      slice
    } = Array.prototype;
    const {
      parse,
      stringify
    } = JSON;
    const WeakSetCtor = WeakSet;
    const deeplyFrozen = new WeakSetCtor();
    // Allow custom environments to bypass deep freeze for performance reasons
    let bypassDeepFreeze = false;
    function setBypassDeepFreeze(value) {
      bypassDeepFreeze = value;
    }
    function deepFreeze(value) {
      // No need to freeze primitives or already frozen stuff
      if (bypassDeepFreeze || typeof value !== 'object' || value === null || deeplyFrozen.has(value)) {
        return;
      }
      deeplyFrozen.add(value);
      if (isArray(value)) {
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepFreeze(value[i]);
        }
      } else {
        const keys$1 = keys(value);
        for (let i = 0, len = keys$1.length; i < len; i += 1) {
          deepFreeze(value[keys$1[i]]);
        }
      }
      freeze(value);
    }
    function isErrorSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Error;
    }
    function isFulfilledSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Fulfilled;
    }
    function isStaleSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Stale;
    }
    function isUnfulfilledSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Unfulfilled;
    }
    function isPendingSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Pending;
    }
    function createErrorSnapshot(error, refresh) {
      deepFreeze(error);
      const snap = {
        error,
        state: SnapshotState.Error,
        data: undefined,
        refresh
      };
      return snap;
    }
    function isPromise(value) {
      if (value === undefined) {
        return false;
      }
      // check for Thenable due to test frameworks using custom Promise impls
      return value.then !== undefined;
    }
    function isNonError(obj, isError) {
      return isError === false;
    }
    function cachePolicyImplWithEvents(cachePolicyImplementation, cachePolicyType, eventObservers) {
      return wrapFunctionInEvents(cachePolicyImplementation, eventObservers, {
        type: 'adapter-lookup-start',
        cachePolicy: cachePolicyType,
        timestamp: Date.now()
      }, (_result, wasError, _, startEvent) => {
        const timestamp = Date.now();
        return {
          type: 'adapter-lookup-end',
          hasError: wasError,
          timestamp,
          duration: timestamp - startEvent.timestamp
        };
      });
    }
    function buildCachedSnapshotWithEvents(buildCachedSnapshot, eventObservers) {
      return wrapFunctionInEvents(buildCachedSnapshot, eventObservers, {
        type: 'cache-lookup-start',
        timestamp: Date.now()
      }, (result, wasError, wasAsync, startEvent) => {
        const timestamp = Date.now();
        return {
          type: 'cache-lookup-end',
          hasError: wasError,
          wasResultAsync: wasAsync,
          snapshotState: result !== undefined && isNonError(result, wasError) ? result.state : undefined,
          timestamp,
          duration: timestamp - startEvent.timestamp
        };
      });
    }
    function buildNetworkSnapshotWithEvents(buildNetworkSnapshot, eventObservers) {
      return wrapFunctionInEvents(buildNetworkSnapshot, eventObservers, {
        type: 'network-lookup-start',
        timestamp: Date.now()
      }, (_result, wasError, _, startEvent) => {
        const timestamp = Date.now();
        return {
          type: 'network-lookup-end',
          hasError: wasError,
          timestamp,
          duration: timestamp - startEvent.timestamp
        };
      });
    }
    function emitLuvioStoreEvent(event, observers = []) {
      for (const observer of observers) {
        switch (event.type) {
          case 'cache-miss-out-of-ttl':
            if (observer.onCacheMissOutOfTtl) {
              observer.onCacheMissOutOfTtl(event);
            }
            break;
          case 'data-out-of-ttl-duration-update':
            if (observer.onDataOutOfTtlDurationUpdate) {
              observer.onDataOutOfTtlDurationUpdate(event);
            }
            break;
          case 'store-reset':
            if (observer.onStoreReset) {
              observer.onStoreReset(event);
            }
            break;
          case 'store-publish':
            if (observer.onStorePublish) {
              observer.onStorePublish(event);
            }
            break;
          case 'store-snapshot-emit':
          case 'store-snapshot-rebuild':
          case 'store-snapshot-refresh':
          case 'store-snapshot-subscribe':
          case 'store-snapshot-unsubscribe':
            if (observer.onStoreSnapshotEvent) {
              observer.onStoreSnapshotEvent(event);
            }
            break;
        }
      }
    }
    function emitAdapterEvent(event, observers = []) {
      for (const observer of observers) {
        switch (event.type) {
          case 'custom':
            if (observer.onCustomAdapterEvent) {
              observer.onCustomAdapterEvent(event);
            }
            break;
          case 'environment':
            if (observer.onEnvironmentEvent) {
              observer.onEnvironmentEvent(event);
            }
            break;
          default:
            if (observer.onAdapterEvent) {
              observer.onAdapterEvent(event);
            }
            break;
        }
      }
    }
    const createCustomAdapterEventEmitter = (namespace, observers = []) => eventData => {
      emitAdapterEvent({
        type: 'custom',
        namespace,
        timestamp: Date.now(),
        data: eventData
      }, observers);
    };
    function wrapFunctionInEvents(fn, eventObservers, startEvent, buildResultEvent) {
      return function (...args) {
        emitAdapterEvent(startEvent, eventObservers);
        try {
          const result = fn(...args);
          if (isPromise(result)) {
            return result.then(x => {
              //emit async end event
              emitAdapterEvent(buildResultEvent(x, false, true, startEvent), eventObservers);
              return x;
            }).catch(e => {
              // emit async error
              emitAdapterEvent(buildResultEvent(e, true, true, startEvent), eventObservers);
              throw e;
            });
          } else {
            // emit sync success
            emitAdapterEvent(buildResultEvent(result, false, false, startEvent), eventObservers);
            return result;
          }
        } catch (e) {
          // emit sync error
          emitAdapterEvent(buildResultEvent(e, true, false, startEvent), eventObservers);
          throw e;
        }
      };
    }
    const resolvedPromise = Promise.resolve();
    function throwNext(error) {
      setTimeout(() => {
        throw error;
      }, 0);
    }
    /**
     * An alternative to flushPromises based on Promise.
     */
    function resolveImmediate(callback) {
      resolvedPromise.then(callback).catch(throwNext);
    }
    const TRIM_DEBOUNCE_TIME_MS = 5000;
    function buildDefaultScheduler() {
      let timeSinceLastTrim = Date.now() - (TRIM_DEBOUNCE_TIME_MS + 1);
      const defaultScheduler = (task, done) => {
        const now = Date.now();
        if (timeSinceLastTrim + TRIM_DEBOUNCE_TIME_MS < now) {
          timeSinceLastTrim = now;
          resolveImmediate(task);
          return done();
        }
        done();
      };
      return defaultScheduler;
    }
    var StoreErrorStatus;
    (function (StoreErrorStatus) {
      StoreErrorStatus[StoreErrorStatus["RESOURCE_NOT_FOUND"] = 404] = "RESOURCE_NOT_FOUND";
    })(StoreErrorStatus || (StoreErrorStatus = {}));
    var StoreRecordType;
    (function (StoreRecordType) {
      StoreRecordType["Error"] = "error";
    })(StoreRecordType || (StoreRecordType = {}));
    var StoreLinkStateValues$1;
    (function (StoreLinkStateValues) {
      StoreLinkStateValues[StoreLinkStateValues["NotPresent"] = 0] = "NotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefNotPresent"] = 1] = "RefNotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefPresent"] = 2] = "RefPresent";
      StoreLinkStateValues[StoreLinkStateValues["Null"] = 3] = "Null";
      StoreLinkStateValues[StoreLinkStateValues["Missing"] = 4] = "Missing";
      StoreLinkStateValues[StoreLinkStateValues["Pending"] = 5] = "Pending";
    })(StoreLinkStateValues$1 || (StoreLinkStateValues$1 = {}));
    exports.StoreResolveResultState = void 0;
    (function (StoreResolveResultState) {
      StoreResolveResultState[StoreResolveResultState["Found"] = 0] = "Found";
      StoreResolveResultState[StoreResolveResultState["Error"] = 1] = "Error";
      StoreResolveResultState[StoreResolveResultState["Null"] = 2] = "Null";
      StoreResolveResultState[StoreResolveResultState["NotPresent"] = 3] = "NotPresent";
      StoreResolveResultState[StoreResolveResultState["Stale"] = 4] = "Stale";
    })(exports.StoreResolveResultState || (exports.StoreResolveResultState = {}));

    /**
     * A deterministic JSON stringify implementation. Heavily adapted from https://github.com/epoberezkin/fast-json-stable-stringify.
     * This is needed because insertion order for JSON.stringify(object) affects output:
     * JSON.stringify({a: 1, b: 2})
     *      "{"a":1,"b":2}"
     * JSON.stringify({b: 2, a: 1})
     *      "{"b":2,"a":1}"
     * @param data Data to be JSON-stringified.
     * @returns JSON.stringified value with consistent ordering of keys.
     */
    function stableJSONStringify(node) {
      // This is for Date values.
      if (node && node.toJSON && typeof node.toJSON === 'function') {
        // eslint-disable-next-line no-param-reassign
        node = node.toJSON();
      }
      if (node === undefined) {
        return;
      }
      if (typeof node === 'number') {
        return isFinite(node) ? '' + node : 'null';
      }
      if (typeof node !== 'object') {
        return stringify(node);
      }
      let i;
      let out;
      if (isArray(node)) {
        out = '[';
        for (i = 0; i < node.length; i++) {
          if (i) {
            out += ',';
          }
          out += stableJSONStringify(node[i]) || 'null';
        }
        return out + ']';
      }
      if (node === null) {
        return 'null';
      }
      const keys$1 = keys(node).sort();
      out = '';
      for (i = 0; i < keys$1.length; i++) {
        const key = keys$1[i];
        const value = stableJSONStringify(node[key]);
        if (!value) {
          continue;
        }
        if (out) {
          out += ',';
        }
        out += stringify(key) + ':' + value;
      }
      return '{' + out + '}';
    }
    function isStoreRecordError(storeRecord) {
      return storeRecord.__type === StoreRecordType.Error;
    }
    const structuredKeySerializationCache = new WeakMap();
    function serializeStructuredKey(key) {
      if (typeof key === 'string') {
        return key;
      }
      const cacheValue = structuredKeySerializationCache.get(key);
      if (cacheValue === undefined) {
        const value = stableJSONStringify(key);
        structuredKeySerializationCache.set(key, value);
        return value;
      }
      return cacheValue;
    }
    const undefinedKeyError$1 = 'Undefined value used in StoreKeyMap operation';
    class StoreKeyMap {
      constructor() {
        this.keyMap = new Map();
        this.valueMap = new Map();
      }
      clear() {
        this.valueMap.clear();
        this.keyMap.clear();
      }
      delete(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          this.keyMap.delete(stringifiedKey);
          return this.valueMap.delete(stringifiedKey);
        } else {
          throw new Error(`${undefinedKeyError$1}: delete`);
        }
      }
      entries() {
        const recordEntries = this.valueMap.entries();
        const keyRecordArray = [];
        for (const [stringifiedKey, value] of Array.from(recordEntries)) {
          const structuredKey = this.keyMap.get(stringifiedKey);
          if (structuredKey !== undefined) {
            keyRecordArray.push([structuredKey, value]);
          }
        }
        return keyRecordArray.values();
      }
      forEachKey(callbackFn, thisArg) {
        return this.keyMap.forEach(callbackFn, thisArg);
      }
      forEachValue(callbackFn, thisArg) {
        return this.valueMap.forEach(callbackFn, thisArg);
      }
      get(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          return this.valueMap.get(stringifiedKey);
        } else {
          throw new Error(`${undefinedKeyError$1}: get`);
        }
      }
      has(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          return this.valueMap.has(stringifiedKey);
        } else {
          throw new Error(`${undefinedKeyError$1}: has`);
        }
      }
      keys() {
        return this.keyMap.values();
      }
      keysAsArray() {
        return Array.from(this.keys());
      }
      keysAsStrings() {
        return this.keyMap.keys();
      }
      /**
       * Merges in the values of the passed-in StoreKeyMap. Overwrites existing values.
       * @param sourceSet - The StoreKeyMap to merge in.
       */
      merge(sourceMap) {
        sourceMap.keyMap.forEach((value, key) => {
          this.keyMap.set(key, value);
        });
        sourceMap.valueMap.forEach((value, key) => {
          this.valueMap.set(key, value);
        });
      }
      set(key, value) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          this.keyMap.set(stringifiedKey, key);
          return this.valueMap.set(stringifiedKey, value);
        } else {
          throw new Error(`${undefinedKeyError$1}: set`);
        }
      }
      size() {
        return this.valueMap.size;
      }
      values() {
        return this.valueMap.values();
      }
    }
    const undefinedKeyError = 'Undefined value used in StoreKeySet operation';
    class StoreKeySet {
      constructor() {
        this.set = new Set();
        this.valueMap = new Map();
      }
      add(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          this.set.add(stringifiedKey);
          this.valueMap.set(stringifiedKey, key);
        } else {
          throw new Error(`${undefinedKeyError}: add`);
        }
        return this;
      }
      clear() {
        this.set.clear();
        this.valueMap.clear();
      }
      delete(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          this.set.delete(stringifiedKey);
          return this.valueMap.delete(stringifiedKey);
        } else {
          throw new Error(`${undefinedKeyError}: delete`);
        }
      }
      entries() {
        return this.valueMap.entries();
      }
      forEach(callbackFn, thisArg) {
        return this.valueMap.forEach(callbackFn, thisArg);
      }
      has(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          return this.set.has(stringifiedKey);
        } else {
          throw new Error(`${undefinedKeyError}: has`);
        }
      }
      keys() {
        return this.valueMap.values();
      }
      keysAsArray() {
        return Array.from(this.keys());
      }
      keysAsStrings() {
        return this.set.keys();
      }
      /**
       * Merges in the values of the passed-in StoreKeySet. Overwrites existing values.
       * @param sourceSet - The StoreKeySet to merge in.
       */
      merge(sourceSet) {
        sourceSet.set.forEach(value => {
          this.set.add(value);
        });
        sourceSet.valueMap.forEach((value, key) => {
          this.valueMap.set(key, value);
        });
      }
      size() {
        return this.set.size;
      }
      values() {
        return this.valueMap.values();
      }
    }
    function defaultTrimPolicy(data, deallocateFn) {
      return new Promise(resolve => {
        let deallocatedCount = 0;
        const {
          pendingTrimKeys,
          retainedIds,
          metadata
        } = data;
        const now = Date.now();
        pendingTrimKeys.forEach(key => {
          const recordExpiration = metadata[key];
          if (retainedIds[key] !== undefined || recordExpiration === undefined || recordExpiration !== undefined && recordExpiration.expirationTimestamp >= now) {
            return;
          }
          deallocateFn(key);
          deallocatedCount++;
        });
        resolve({
          deallocatedCount
        });
      });
    }
    const Serialized_StringKey_Version = '1';
    function hasOverlappingIds$1(snapshot, visitedIds) {
      const {
        length: len
      } = visitedIds;
      const {
        seenRecords
      } = snapshot;
      for (let i = 0; i < len; i += 1) {
        const id = visitedIds[i];
        if (seenRecords.has(id) || id === snapshot.recordId) {
          return true;
        }
      }
      return false;
    }
    function isNonPendingSnapshotWithNoOverlappingIds$1(snapshot, visitedIds) {
      return isPendingSnapshot(snapshot) === false && hasOverlappingIds$1(snapshot, visitedIds) === false;
    }
    function isPendingSnapshotWithNoOverlappingIds$1(snapshot, visitedIds, refreshedIds) {
      // pending snapshot need to check both visited and refreshed IDs
      // because the top-level record might only be refreshed (if it was
      // already in the store after a TTL expired then storePublish won't
      // be called).  And it's not enough to just check refreshed because
      // some records don't have TTLs so refreshedIds would be empty.
      return isPendingSnapshot(snapshot) === true && hasOverlappingIds$1(snapshot, refreshedIds) === false && hasOverlappingIds$1(snapshot, visitedIds) === false;
    }
    function getMatchingIds$1(prefix, visitedIds) {
      const matchingIds = [];
      for (let i = 0, len = visitedIds.length; i < len; i++) {
        const visitedId = visitedIds[i];
        if (visitedId.indexOf(prefix) === 0) {
          push.call(matchingIds, visitedId);
        }
      }
      return matchingIds;
    }
    const OVERRIDE_TTL_KEY_SEPARATOR = '::';
    function getTTLOverrideKey(namespace, representationName) {
      return `${namespace}${OVERRIDE_TTL_KEY_SEPARATOR}${representationName}`;
    }
    function getTTLOverride$1(ttlOverrideKey, ttlOverrides, defaultTTLOverride) {
      const override = ttlOverrides[ttlOverrideKey];
      const ttlOverride = override === undefined ? defaultTTLOverride : override;
      return ttlOverride;
    }
    class StringKeyInMemoryStore {
      constructor(options = {}) {
        // public, in memory properties
        this.records = create(null);
        this.metadata = create(null);
        this.visitedIds = create(null);
        this.refreshedIds = create(null);
        this.redirectKeys = create(null);
        this.retainedIds = create(null);
        this.ttlOverrides = create(null);
        this.snapshotSubscriptions = [];
        this.trimTask = null;
        this.pendingTrimKeys = new Set();
        this.defaultTTLOverride = undefined;
        this.watchSubscriptions = [];
        this.eventObservers = [];
        // private/protected
        this.insertedIds = create(null);
        this.reverseRedirectKeys = create(null);
        this.currentSnapshotId = 0;
        this.scheduler = options.scheduler || buildDefaultScheduler();
        if (options.initialData) {
          this.deserialize(options.initialData, options.resetInitialDataTtls);
        }
        this.trimPolicy = options.customTrimPolicy || defaultTrimPolicy;
      }
      // interface methods
      readEntry(key) {
        return this.records[this.getCanonicalRecordId(key)];
      }
      getNumEntries() {
        return keys(this.records).length;
      }
      readMetadata(key) {
        return this.metadata[this.getCanonicalRecordId(key)];
      }
      readMetadataWhere(query) {
        const keys$1 = keys(this.metadata);
        const results = [];
        const hasNamespaceQuery = hasOwnProperty.call(query, 'namespace');
        const hasRepresentationNameQuery = hasOwnProperty.call(query, 'representationName');
        const hasTtlOverrideQuery = hasOwnProperty.call(query, 'ttlOverride');
        for (let i = 0, length = keys$1.length; i < length; i++) {
          const key = keys$1[i];
          const storeMetadata = this.metadata[key];
          if (hasNamespaceQuery && storeMetadata.namespace !== query.namespace) {
            continue;
          }
          if (hasRepresentationNameQuery && storeMetadata.representationName !== query.representationName) {
            continue;
          }
          if (hasTtlOverrideQuery) {
            const ttlOverride = this.ttlOverrides[getTTLOverrideKey(storeMetadata.namespace, storeMetadata.representationName)];
            if (ttlOverride !== query.ttlOverride) {
              continue;
            }
          }
          results.push({
            metadata: storeMetadata,
            key
          });
        }
        return results;
      }
      put(recordId, record) {
        const {
          records,
          insertedIds,
          pendingTrimKeys,
          retainedIds
        } = this;
        const canonicalKey = this.getCanonicalRecordId(recordId);
        if (hasOwnProperty.call(records, canonicalKey) === false) {
          insertedIds[canonicalKey] = true;
        }
        records[canonicalKey] = record;
        // if this id is not retained, add it to the pendingTrim collection.
        // this does not mean it will be trimmed right away, it still needs to be expired
        // and if this key is subsequently subscribed to it will be retained and no longer considered for
        // trim
        if (retainedIds[canonicalKey] === undefined) {
          pendingTrimKeys.add(canonicalKey);
        }
        {
          freeze(record);
        }
      }
      publish(recordId, record) {
        // make sure we publish to the canonical record id in case it's been redirected
        const canonicalKey = this.getCanonicalRecordId(recordId);
        this.put(canonicalKey, record);
        this.markVisited(canonicalKey);
        // TODO: Emit event for store publish once structured keys are used everywhere.
      }
      /**
       * Given a record id, this method returns the key where the corresponding data is actually stored.
       * It could be that this record id has been redirected, so this method will follow the redirects, if applicable,
       * and return the canonical key for the record
       * @param recordId The original location of the record
       * @returns The canonical key where the record is stored
       */
      getCanonicalRecordId(recordId) {
        let canonicalKey = recordId;
        const {
          redirectKeys
        } = this;
        while (redirectKeys[canonicalKey]) {
          canonicalKey = redirectKeys[canonicalKey];
        }
        return canonicalKey;
      }
      getRedirectLineage(key) {
        const {
          redirectKeys
        } = this;
        const lineage = [];
        if (redirectKeys[key] === undefined) {
          return [];
        }
        let canonicalKey = key;
        while (redirectKeys[canonicalKey] !== undefined) {
          push.call(lineage, canonicalKey);
          canonicalKey = redirectKeys[canonicalKey];
        }
        return lineage;
      }
      redirect(key, canonicalKey) {
        const {
          redirectKeys,
          reverseRedirectKeys
        } = this;
        if (key === canonicalKey) {
          throw new Error('cannot redirect a key to itself');
        }
        if (reverseRedirectKeys[canonicalKey] !== undefined && reverseRedirectKeys[canonicalKey] !== key) {
          throw new Error('cannot have multiple redirects keys point to the same canonical key');
        }
        if (redirectKeys[canonicalKey] !== undefined) {
          throw new Error('the canonical key must be terminal and cannot already be part of a redirect chain');
        }
        redirectKeys[key] = canonicalKey;
        reverseRedirectKeys[canonicalKey] = key;
        // evict key at original location as it now lives at the canonical key
        delete this.records[key];
        this.visitedIds[key] = true;
      }
      broadcast(rebuildSnapshot, snapshotAvailable) {
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions,
          watchSubscriptions,
          visitedIds,
          refreshedIds,
          insertedIds
        } = this;
        const allVisitedIds = keys(visitedIds);
        const allRefreshedIds = keys(refreshedIds);
        // Early exit if nothing has changed
        if (allVisitedIds.length === 0 && allRefreshedIds.length === 0) {
          return Promise.resolve();
        }
        // Process snapshot subscriptions
        const snapshotSubPromises = [];
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot
          } = subscription;
          // Don't re-emit the snapshot if there is no overlap between the visited keys and the
          // snapshot seen keys.
          if (isErrorSnapshot(snapshot) || isNonPendingSnapshotWithNoOverlappingIds$1(snapshot, allVisitedIds) || isPendingSnapshotWithNoOverlappingIds$1(snapshot, allVisitedIds, allRefreshedIds)) {
            continue;
          }
          snapshotSubPromises.push(new Promise(resolve => {
            rebuildSnapshot(snapshot, rebuiltSnapshot => {
              emitLuvioStoreEvent({
                type: 'store-snapshot-rebuild',
                timestamp: Date.now(),
                snapshot: rebuiltSnapshot,
                subscriptionId: subscription.id
              }, this.eventObservers);
              this.emitOrRefreshRebuiltSnapshot(rebuiltSnapshot, subscription, snapshotAvailable).then(() => resolve());
            });
          }));
        }
        // Process watch subscriptions
        for (let i = 0, len = watchSubscriptions.length; i < len; i++) {
          const {
            prefix,
            callback
          } = watchSubscriptions[i];
          const matchingIds = getMatchingIds$1(prefix, allVisitedIds);
          if (matchingIds.length > 0) {
            const watchCallbackEntries = [];
            for (let i = 0, len = matchingIds.length; i < len; i++) {
              const id = matchingIds[i];
              const inserted = insertedIds[id] || false;
              push.call(watchCallbackEntries, {
                id,
                inserted
              });
            }
            callback(watchCallbackEntries);
          }
        }
        this.visitedIds = create(null);
        this.refreshedIds = create(null);
        this.insertedIds = create(null);
        // the .then removes the return of an array of voids to a single void
        return Promise.all(snapshotSubPromises).then(() => {});
      }
      /**
       * Broadcasts an ErrorSnapshot to any Pending snapshots for the given
       * recordId.
       */
      broadcastNonCachedSnapshot(recordId, errorSnapshot) {
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions
        } = this;
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot,
            callback
          } = subscription;
          // if the subscriber is pending and its recordId matches then emit
          // the error to it
          if (isPendingSnapshot(snapshot) && snapshot.recordId === recordId) {
            subscription.snapshot = errorSnapshot;
            callback(errorSnapshot);
          }
        }
      }
      lookup(selector, createSnapshot, refresh, ttlStrategy) {
        return createSnapshot(selector, refresh, ttlStrategy);
      }
      subscribe(snapshot, callback) {
        const subscription = {
          id: this.currentSnapshotId++,
          snapshot,
          callback
        };
        emitLuvioStoreEvent({
          type: 'store-snapshot-subscribe',
          subscriptionId: subscription.id,
          snapshot,
          timestamp: Date.now()
        }, this.eventObservers);
        this.snapshotSubscriptions = [...this.snapshotSubscriptions, subscription];
        if (!isErrorSnapshot(snapshot)) {
          this.retainSnapshotIds(snapshot);
        }
        return () => {
          const {
            snapshotSubscriptions
          } = this;
          const index = indexOf.call(snapshotSubscriptions, subscription);
          // only attempt to slice if the subscription is in the list (in case someone
          // calls unsubscribe multiple times)
          if (index > -1) {
            this.snapshotSubscriptions = [...slice.call(snapshotSubscriptions, 0, index), ...slice.call(snapshotSubscriptions, index + 1)];
            {
              this.snapshotSubscriptions = freeze(this.snapshotSubscriptions);
            }
            // need to re-gather snapshot associated Ids to capture latest refs
            const {
              snapshot,
              id: uuid
            } = subscription;
            emitLuvioStoreEvent({
              type: 'store-snapshot-unsubscribe',
              subscriptionId: uuid,
              snapshot,
              timestamp: Date.now()
            }, this.eventObservers);
            if (!isErrorSnapshot(snapshot)) {
              this.releaseSnapshotIds(snapshot);
            }
          }
        };
      }
      updateAvailable(keys) {
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions
        } = this;
        // read metadata for each key, and mark as expired
        this.expirePossibleStaleRecords(keys);
        // Process snapshot subscriptions
        const pendingPromises = [];
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot,
            id
          } = subscription;
          if (isErrorSnapshot(snapshot)) {
            // TODO: If we want to support refreshing Error Snapshots, we will need
            // to update the ErrorSnapshot interface to include the recordId, or
            // resolve the snapshot through its refresh.config property
            continue;
          }
          if (!hasOverlappingIds$1(snapshot, keys)) {
            continue;
          }
          pendingPromises.push(this.refreshSnapshot(snapshot, id, 'update-available'));
        }
        // resolves after all snapshots refresh resolve
        // for now catch in case of reject and resolve
        return Promise.all(pendingPromises).then(_promises => undefined).catch(_err => Promise.resolve(undefined));
      }
      retain(keys) {
        const keysLength = keys.length;
        for (let i = 0; i < keysLength; i++) {
          const key = keys[i];
          this.increaseRetentionCount(key);
        }
        return () => {
          this.release(keys);
        };
      }
      watch(prefix, callback) {
        const subscription = {
          prefix,
          callback
        };
        this.watchSubscriptions = [...this.watchSubscriptions, subscription];
        return () => {
          const {
            watchSubscriptions
          } = this;
          const index = indexOf.call(watchSubscriptions, subscription);
          this.watchSubscriptions = [...slice.call(watchSubscriptions, 0, index), ...slice.call(watchSubscriptions, index + 1)];
          {
            this.watchSubscriptions = freeze(this.watchSubscriptions);
          }
        };
      }
      /**
       * Evicts data at the canonical key location and marks any redirects (if applicable)
       * to the key as visited
       * @param key key to evict
       */
      evict(key) {
        // find and evict the canonical key
        const canonicalKey = this.getCanonicalRecordId(key);
        delete this.records[canonicalKey];
        this.markVisited(canonicalKey);
      }
      cleanup() {
        this.scheduleTrim();
      }
      /**
       * Deallocates data at the canonical key location for in-memory (L1) cache
       * @param key key to deallocate
       */
      dealloc(key) {
        // find and deallocate the canonical key
        const canonicalKey = this.getCanonicalRecordId(key);
        delete this.records[canonicalKey];
      }
      keyExistsInStore(key) {
        return this.records[key] !== undefined;
      }
      publishMetadata(key, storeMetadata) {
        this.putMetadata(key, storeMetadata, true);
        const canonicalKey = this.getCanonicalRecordId(key);
        this.markRefreshed(canonicalKey);
      }
      putMetadata(key, storeMetadata, adjustTTLOverride) {
        const {
          namespace,
          representationName,
          ingestionTimestamp
        } = storeMetadata;
        const ttlOverrideKey = getTTLOverrideKey(namespace, representationName);
        const ttlOverride = getTTLOverride$1(ttlOverrideKey, this.ttlOverrides, this.defaultTTLOverride);
        const canonicalKey = this.getCanonicalRecordId(key);
        if (ttlOverride !== undefined && adjustTTLOverride === true) {
          const newExpiration = ingestionTimestamp + ttlOverride;
          // Create a new StoreMetadata object and publish the new object to storeMetadata.
          const metaDataOverride = {
            ...storeMetadata,
            expirationTimestamp: newExpiration
          };
          this.metadata[canonicalKey] = metaDataOverride;
        } else {
          // If it does not exist, publish the user passed StoreMetadata into the storeMetadata map.
          this.metadata[canonicalKey] = storeMetadata;
        }
      }
      expirePossibleStaleRecords(keys) {
        const expirationTimestamp = Date.now() - 1;
        for (let i = 0, len = keys.length; i < len; i++) {
          const key = keys[i];
          const metadata = this.readMetadata(key);
          if (metadata !== undefined) {
            this.publishMetadata(key, {
              ...metadata,
              expirationTimestamp
            });
          }
        }
      }
      setTTLOverride(namespace, representationName, ttl) {
        this.ttlOverrides[getTTLOverrideKey(namespace, representationName)] = ttl;
      }
      getTTLOverride(namespace, representationName) {
        return this.ttlOverrides[getTTLOverrideKey(namespace, representationName)];
      }
      getTTLOverrides() {
        return this.ttlOverrides;
      }
      setDefaultTTLOverride(ttl) {
        this.defaultTTLOverride = ttl;
      }
      getDefaultTTLOverride() {
        return this.defaultTTLOverride;
      }
      reset() {
        this.records = create(null);
        this.snapshotSubscriptions = [];
        this.watchSubscriptions = [];
        this.visitedIds = create(null);
        this.refreshedIds = create(null);
        this.insertedIds = create(null);
        this.redirectKeys = create(null);
        this.reverseRedirectKeys = create(null);
        this.retainedIds = create(null);
        this.ttlOverrides = create(null);
        this.trimTask = null;
        this.metadata = create(null);
        this.defaultTTLOverride = undefined;
        emitLuvioStoreEvent({
          type: 'store-reset',
          timestamp: Date.now()
        }, this.eventObservers);
      }
      addStoreEventObserver(storeEventObserver) {
        this.eventObservers.push(storeEventObserver);
        return () => {
          const {
            eventObservers
          } = this;
          const index = this.eventObservers.indexOf(storeEventObserver);
          if (index > -1) {
            this.eventObservers = [...slice.call(eventObservers, 0, index), ...slice.call(eventObservers, index + 1)];
          }
        };
      }
      // public in memory methods
      scheduleTrim() {
        if (this.trimTask === null) {
          this.trimTask = () => {
            const {
              metadata,
              pendingTrimKeys,
              retainedIds,
              records: storeRecords,
              dealloc
            } = this;
            return this.trimPolicy({
              metadata,
              pendingTrimKeys,
              retainedIds,
              storeRecords
            }, dealloc.bind(this)).then(result => {
              this.pendingTrimKeys.clear();
              const {
                trimKeysSkipped
              } = result;
              if (trimKeysSkipped !== undefined) {
                this.pendingTrimKeys = trimKeysSkipped;
              }
              return result;
            });
          };
          this.scheduler(this.trimTask, () => {
            this.trimTask = null;
          });
        }
      }
      buildIngestionStagingStore() {
        const stagingStore = new StringKeyInMemoryStore();
        const upstreamStore = this;
        const originalReadEntry = stagingStore.readEntry.bind(stagingStore);
        const originalReadMetadata = stagingStore.readMetadata.bind(stagingStore);
        const originalEvict = stagingStore.evict.bind(stagingStore);
        // the staging store will read from the upstream store if it doesn't have the data
        // this is because some adapters will only do partial ingests if they determine data
        // is already in L1 prior to ingestion
        stagingStore.readEntry = key => {
          const entry = originalReadEntry(key);
          if (entry === undefined) {
            return upstreamStore.readEntry(key);
          }
          return entry;
        };
        stagingStore.readMetadata = key => {
          const metadata = originalReadMetadata(key);
          if (!metadata) {
            return upstreamStore.readMetadata(key);
          }
          return metadata;
        };
        stagingStore.evict = key => {
          originalEvict(key);
          upstreamStore.evict(key);
        };
        stagingStore.ttlOverrides = upstreamStore.ttlOverrides;
        stagingStore.defaultTTLOverride = upstreamStore.defaultTTLOverride;
        stagingStore.redirectKeys = upstreamStore.redirectKeys;
        stagingStore.reverseRedirectKeys = upstreamStore.reverseRedirectKeys;
        return stagingStore;
      }
      // private/protected methodss
      /**
       * Updates a subscription with a new snapshot and performs retention book-keeping
       * on the existing and new snapshot.
       */
      updateSubscriptionSnapshot(subscription, newSnapshot) {
        const {
          snapshot: oldSnapshot
        } = subscription;
        if (oldSnapshot === newSnapshot) {
          return;
        }
        subscription.snapshot = newSnapshot;
        if (!isErrorSnapshot(newSnapshot)) {
          this.retainSnapshotIds(newSnapshot);
        }
        if (!isErrorSnapshot(oldSnapshot)) {
          this.releaseSnapshotIds(oldSnapshot);
        }
      }
      refreshSnapshot(snapshot, subscriptionId, reason) {
        const {
          refresh
        } = snapshot;
        if (refresh !== undefined) {
          emitLuvioStoreEvent({
            type: 'store-snapshot-refresh',
            subscriptionId,
            reason,
            snapshot,
            timestamp: Date.now()
          }, this.eventObservers);
          return refresh.resolve(refresh.config);
        }
        return Promise.resolve(undefined);
      }
      instrumentIngestedNewData(snapshot, rebuiltSnapshot) {
        const recordId = rebuiltSnapshot.recordId;
        {
          if (typeof recordId !== 'string') {
            throw new Error(`Received invalid snapshot.recordId value: ${snapshot.recordId}`);
          }
        }
        const recordMetadata = this.metadata[recordId];
        // Non-batch scenario
        if (recordMetadata) {
          emitLuvioStoreEvent({
            type: 'cache-miss-out-of-ttl',
            oldSnapshot: snapshot,
            newSnapshot: rebuiltSnapshot,
            recordId,
            recordMetadata,
            timestamp: Date.now()
          }, this.eventObservers);
        } else {
          rebuiltSnapshot.seenRecords.keysAsArray().forEach(seenRecordId => {
            const seenRecordMetadata = this.metadata[seenRecordId];
            if (seenRecordMetadata) {
              emitLuvioStoreEvent({
                type: 'cache-miss-out-of-ttl',
                oldSnapshot: snapshot,
                newSnapshot: rebuiltSnapshot,
                recordId: seenRecordId,
                recordMetadata: seenRecordMetadata,
                timestamp: Date.now()
              }, this.eventObservers);
            }
          });
        }
      }
      emitOrRefreshRebuiltSnapshot(rebuiltSnapshot, subscription, snapshotAvailable) {
        const {
          snapshot,
          callback,
          id: subscriptionId
        } = subscription;
        // if the rebuilt snapshot is pending then continue on, broadcast will get
        // called again once the pending snapshot is resolved
        if (isPendingSnapshot(rebuiltSnapshot)) {
          if (isPendingSnapshot(snapshot)) {
            this.updateSubscriptionSnapshot(subscription, rebuiltSnapshot);
          }
          return Promise.resolve();
        }
        this.updateSubscriptionSnapshot(subscription, rebuiltSnapshot);
        if (snapshotAvailable(rebuiltSnapshot)) {
          // TODO [W-10186366]: revisit if we want to handle errors thrown in user-land callback
          if (rebuiltSnapshot !== snapshot) {
            emitLuvioStoreEvent({
              type: 'store-snapshot-emit',
              snapshot: rebuiltSnapshot,
              timestamp: Date.now(),
              subscriptionId
            }, this.eventObservers);
            callback(rebuiltSnapshot);
          }
          this.instrumentIngestedNewDataOnFulfilledSnapshots(snapshot, rebuiltSnapshot);
        } else if (isUnfulfilledSnapshot(rebuiltSnapshot)) {
          return this.refreshSnapshot(rebuiltSnapshot, subscriptionId, 'rebuild-unfulfilled').then();
        }
        return Promise.resolve();
      }
      instrumentIngestedNewDataOnFulfilledSnapshots(snapshot, rebuiltSnapshot) {
        if (isFulfilledSnapshot(snapshot) && isFulfilledSnapshot(rebuiltSnapshot)) {
          this.instrumentIngestedNewData(snapshot, rebuiltSnapshot);
        }
      }
      retainSnapshotIds(snapshot) {
        const recordId = snapshot.recordId;
        {
          if (typeof recordId !== 'string') {
            throw new Error(`Received invalid snapshot.recordId value: ${snapshot.recordId}`);
          }
        }
        const {
          seenRecords
        } = snapshot;
        const snapshotRetainedIds = seenRecords === undefined ? [recordId] : [recordId, ...Array.from(seenRecords.keysAsStrings())];
        this.retain(snapshotRetainedIds);
      }
      releaseSnapshotIds(snapshot) {
        const recordId = snapshot.recordId;
        {
          if (typeof recordId !== 'string') {
            throw new Error(`Received invalid snapshot.recordId value: ${snapshot.recordId}`);
          }
        }
        const {
          seenRecords
        } = snapshot;
        const snapshotReleaseIds = seenRecords === undefined ? [recordId] : [recordId, ...Array.from(seenRecords.keysAsStrings())];
        this.release(snapshotReleaseIds);
      }
      increaseRetentionCount(key) {
        const count = this.retainedIds[key];
        this.retainedIds[key] = count === undefined ? 1 : count + 1;
        // do not consider this key for trim while retained
        this.pendingTrimKeys.delete(key);
      }
      decreaseRetentionCount(key) {
        const count = this.retainedIds[key];
        if (count === 1) {
          // consider this key for trimming when ref count goes to zero
          this.pendingTrimKeys.add(key);
          return delete this.retainedIds[key];
        } else if (count === undefined) {
          return false;
        } else {
          this.retainedIds[key] = count - 1;
        }
        return false;
      }
      release(keys) {
        const keysLength = keys.length;
        let shouldScheduleTrim = false;
        for (let i = 0; i < keysLength; i++) {
          const key = keys[i];
          const result = this.decreaseRetentionCount(key);
          if (result === true) {
            shouldScheduleTrim = true;
          }
        }
        // only schedule trim if an entry is removed from retention map
        if (shouldScheduleTrim === true) {
          // schedule trim for next tick
          this.scheduleTrim();
        }
      }
      markVisited(canonicalKey) {
        const {
          visitedIds,
          reverseRedirectKeys
        } = this;
        visitedIds[canonicalKey] = true;
        // mark all redirects leading up to the canonical key as visited so
        // affected snapshots are updated
        let redirectKey = reverseRedirectKeys[canonicalKey];
        while (redirectKey !== undefined) {
          visitedIds[redirectKey] = true;
          redirectKey = reverseRedirectKeys[redirectKey];
        }
      }
      markRefreshed(canonicalKey) {
        const {
          refreshedIds,
          reverseRedirectKeys
        } = this;
        refreshedIds[canonicalKey] = true;
        // mark all redirects leading up to the canonical key as refreshed so
        // affected snapshots are updated
        let redirectKey = reverseRedirectKeys[canonicalKey];
        while (redirectKey !== undefined) {
          refreshedIds[redirectKey] = true;
          redirectKey = reverseRedirectKeys[redirectKey];
        }
      }
      serialize() {
        return {
          luvioStoreData: {
            data: this.records,
            metadata: this.metadata,
            version: Serialized_StringKey_Version
          }
        };
      }
      deserialize(storeData, resetInitialDataTtls) {
        const luvioStoreData = storeData.luvioStoreData;
        if (Serialized_StringKey_Version === luvioStoreData.version) {
          this.records = luvioStoreData.data;
          this.metadata = this.calculateAndSetNewTTLs(luvioStoreData.metadata, resetInitialDataTtls);
        }
      }
      calculateAndSetNewTTLs(storeMetadata, resetInitialDataTtls) {
        if (resetInitialDataTtls === true) {
          const now = Date.now();
          keys(storeMetadata).forEach(key => {
            const storeMetadataEntry = storeMetadata[key];
            const ttl = storeMetadataEntry.expirationTimestamp - storeMetadataEntry.ingestionTimestamp;
            storeMetadataEntry.ingestionTimestamp = now;
            storeMetadataEntry.expirationTimestamp = now + ttl;
          });
        }
        return storeMetadata;
      }
    }
    function hasOverlappingIds(snapshot, visitedIds) {
      const {
        seenRecords
      } = snapshot;
      return visitedIds.some(id => seenRecords.has(id) || id === snapshot.recordId);
    }
    function isNonPendingSnapshotWithNoOverlappingIds(snapshot, visitedIds) {
      return isPendingSnapshot(snapshot) === false && hasOverlappingIds(snapshot, visitedIds) === false;
    }
    function isPendingSnapshotWithNoOverlappingIds(snapshot, visitedIds, refreshedIds) {
      // pending snapshot need to check both visited and refreshed IDs
      // because the top-level record might only be refreshed (if it was
      // already in the store after a TTL expired then storePublish won't
      // be called).  And it's not enough to just check refreshed because
      // some records don't have TTLs so refreshedIds would be empty.
      return isPendingSnapshot(snapshot) === true && hasOverlappingIds(snapshot, refreshedIds) === false && hasOverlappingIds(snapshot, visitedIds) === false;
    }
    function getMatchingIds(partialKey, visitedIds) {
      const keys$1 = keys(partialKey);
      return visitedIds.filter(visitedId => {
        return keys$1.every(key => {
          return partialKey[key] === visitedId[key];
        });
      });
    }
    function getTTLOverride(ttlOverrideKey, ttlOverrides, defaultTTLOverride) {
      const override = ttlOverrides.get(ttlOverrideKey);
      const ttlOverride = override === undefined ? defaultTTLOverride : override;
      return ttlOverride;
    }
    class InMemoryStore {
      constructor(options = {}) {
        // public, in memory properties
        this.recordsMap = new StoreKeyMap();
        this.metadataMap = new StoreKeyMap();
        this.visitedIdsSet = new StoreKeySet();
        this.refreshedIdsSet = new StoreKeySet();
        this.redirectKeysMap = new StoreKeyMap();
        this.retainedIdsMap = new StoreKeyMap();
        this.ttlOverridesMap = new StoreKeyMap();
        // End Structured Key Variables
        this.snapshotSubscriptions = [];
        this.trimTask = null;
        this.pendingTrims = new StoreKeySet();
        this.defaultTTLOverride = undefined;
        this.watchSubscriptions = [];
        this.eventObservers = [];
        // private/protected
        this.insertedIdsSet = new StoreKeySet();
        this.reverseRedirectKeysMap = new StoreKeyMap();
        this.scheduler = options.scheduler || buildDefaultScheduler();
        this.fallbackStringKeyInMemoryStore = new StringKeyInMemoryStore(options);
      }
      // interface methods
      readEntry(key) {
        if (typeof key === 'string') {
          return this.fallbackStringKeyInMemoryStore.readEntry(key);
        }
        return this.recordsMap.get(key);
      }
      getNumEntries() {
        const numKeys = this.recordsMap.size();
        if (numKeys === 0) {
          return this.fallbackStringKeyInMemoryStore.getNumEntries();
        }
        return numKeys;
      }
      readMetadata(key) {
        if (typeof key === 'string') {
          return this.fallbackStringKeyInMemoryStore.readMetadata(key);
        }
        return this.metadataMap.get(key);
      }
      readMetadataWhere(query) {
        const keys = this.metadataMap.keysAsArray();
        if (keys.length === 0) {
          return this.fallbackStringKeyInMemoryStore.readMetadataWhere(query);
        }
        const results = [];
        const hasNamespaceQuery = hasOwnProperty.call(query, 'namespace');
        const hasRepresentationNameQuery = hasOwnProperty.call(query, 'representationName');
        const hasTtlOverrideQuery = hasOwnProperty.call(query, 'ttlOverride');
        for (let i = 0, length = keys.length; i < length; i++) {
          const key = keys[i];
          const storeMetadata = this.metadataMap.get(key);
          if (storeMetadata) {
            if (hasNamespaceQuery && storeMetadata.namespace !== query.namespace) {
              continue;
            }
            if (hasRepresentationNameQuery && storeMetadata.representationName !== query.representationName) {
              continue;
            }
            if (hasTtlOverrideQuery) {
              const ttlOverride = this.ttlOverridesMap.get(this.buildStructuredKey(storeMetadata.namespace, storeMetadata.representationName, {}));
              if (ttlOverride !== query.ttlOverride) {
                continue;
              }
            }
            results.push({
              metadata: storeMetadata,
              key
            });
          }
        }
        return results;
      }
      put(recordId, record) {
        if (typeof recordId === 'string') {
          this.fallbackStringKeyInMemoryStore.put(recordId, record);
          return;
        }
        const {
          recordsMap,
          insertedIdsSet,
          pendingTrims,
          retainedIdsMap
        } = this;
        // make sure we publish to the canonical record id in case it's been redirected
        const canonicalKey = this.getCanonicalRecordId(recordId);
        if (recordsMap.get(canonicalKey) === false) {
          insertedIdsSet.add(canonicalKey);
        }
        recordsMap.set(canonicalKey, record);
        // if this id is not retained, add it to the pendingTrim collection.
        // this does not mean it will be trimmed right away, it still needs to be expired
        // and if this key is subsequently subscribed to it will be retained and no longer considered for
        // trim
        if (retainedIdsMap.get(canonicalKey) === undefined) {
          pendingTrims.add(canonicalKey);
        }
        {
          freeze(record);
        }
      }
      publish(recordId, record) {
        if (typeof recordId === 'string') {
          this.fallbackStringKeyInMemoryStore.publish(recordId, record);
          return;
        }
        const canonicalKey = this.getCanonicalRecordId(recordId);
        this.put(canonicalKey, record);
        this.markVisited(canonicalKey);
        this.emitStorePublishEvent(recordId);
      }
      /**
       * Given a record id, this method returns the key where the corresponding data is actually stored.
       * It could be that this record id has been redirected, so this method will follow the redirects, if applicable,
       * and return the canonical key for the record
       * @param recordId The original location of the record
       * @returns The canonical key where the record is stored
       */
      getCanonicalRecordId(recordId) {
        if (typeof recordId === 'string') {
          return this.fallbackStringKeyInMemoryStore.getCanonicalRecordId(recordId);
        }
        const {
          redirectKeysMap
        } = this;
        let canonicalKey = recordId;
        while (redirectKeysMap.get(canonicalKey)) {
          canonicalKey = redirectKeysMap.get(canonicalKey);
        }
        return canonicalKey;
      }
      getRedirectLineage(key) {
        if (typeof key === 'string') {
          return this.fallbackStringKeyInMemoryStore.getRedirectLineage(key);
        }
        const {
          redirectKeysMap
        } = this;
        const lineage = [];
        let canonicalKey = redirectKeysMap.get(key);
        while (canonicalKey !== undefined) {
          push.call(lineage, canonicalKey);
          canonicalKey = redirectKeysMap.get(canonicalKey);
        }
        return lineage;
      }
      redirect(key, canonicalKey) {
        if (typeof key === 'string' && typeof canonicalKey === 'string') {
          this.fallbackStringKeyInMemoryStore.redirect(key, canonicalKey);
          return;
        }
        if (typeof key === 'string' || typeof canonicalKey === 'string') {
          throw new Error('cannot have key and canonicalKey of different types');
        }
        const {
          redirectKeysMap,
          reverseRedirectKeysMap
        } = this;
        if (key === canonicalKey) {
          throw new Error('cannot redirect a key to itself');
        }
        if (reverseRedirectKeysMap.has(canonicalKey)) {
          throw new Error('cannot have multiple redirects keys point to the same canonical key');
        }
        if (redirectKeysMap.has(canonicalKey)) {
          throw new Error('the canonical key must be terminal and cannot already be part of a redirect chain');
        }
        redirectKeysMap.set(key, canonicalKey);
        reverseRedirectKeysMap.set(canonicalKey, key);
        // evict key at original location as it now lives at the canonical key
        this.recordsMap.delete(key);
        this.visitedIdsSet.add(key);
      }
      broadcast(rebuildSnapshot, snapshotAvailable) {
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions,
          watchSubscriptions,
          visitedIdsSet,
          refreshedIdsSet,
          insertedIdsSet
        } = this;
        const allVisitedIds = visitedIdsSet.keysAsArray();
        const allRefreshedIds = refreshedIdsSet.keysAsArray();
        // Early exit if nothing has changed
        if (allVisitedIds.length === 0 && allRefreshedIds.length === 0) {
          if (this.isUsingStringKeys()) {
            return this.fallbackStringKeyInMemoryStore.broadcast(rebuildSnapshot, snapshotAvailable);
          }
          return Promise.resolve();
        }
        // Process snapshot subscriptions
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot
          } = subscription;
          // Don't re-emit the snapshot if there is no overlap between the visited keys and the
          // snapshot seen keys.
          if (isErrorSnapshot(snapshot) || isNonPendingSnapshotWithNoOverlappingIds(snapshot, allVisitedIds) || isPendingSnapshotWithNoOverlappingIds(snapshot, allVisitedIds, allRefreshedIds)) {
            continue;
          }
          rebuildSnapshot(snapshot, asyncAvailableSnapshot => {
            this.emitOrRefreshRebuiltSnapshot(asyncAvailableSnapshot, subscription, snapshotAvailable);
          });
        }
        // Process watch subscriptions
        for (let i = 0, len = watchSubscriptions.length; i < len; i++) {
          const {
            partialKey,
            callback
          } = watchSubscriptions[i];
          const matchingIds = getMatchingIds(partialKey, allVisitedIds);
          if (matchingIds.length > 0) {
            const watchCallbackEntries = [];
            for (let i = 0, len = matchingIds.length; i < len; i++) {
              const id = matchingIds[i];
              const inserted = insertedIdsSet.has(id);
              push.call(watchCallbackEntries, {
                id,
                inserted
              });
            }
            callback(watchCallbackEntries);
          }
        }
        this.visitedIdsSet = new StoreKeySet();
        this.refreshedIdsSet = new StoreKeySet();
        this.insertedIdsSet = new StoreKeySet();
        return Promise.resolve();
      }
      /**
       * Broadcasts an ErrorSnapshot to any Pending snapshots for the given
       * recordId.
       */
      broadcastNonCachedSnapshot(key, errorSnapshot) {
        if (typeof key === 'string') {
          this.fallbackStringKeyInMemoryStore.broadcastNonCachedSnapshot(key, errorSnapshot);
          return;
        }
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions
        } = this;
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot,
            callback
          } = subscription;
          // if the subscriber is pending and its recordId matches then emit
          // the error to it
          if (isPendingSnapshot(snapshot) && snapshot.recordId === key) {
            subscription.snapshot = errorSnapshot;
            callback(errorSnapshot);
          }
        }
      }
      lookup(selector, createSnapshot, refresh, ttlStrategy) {
        return createSnapshot(selector, refresh, ttlStrategy);
      }
      subscribe(snapshot, callback) {
        if (this.delegateToFallbackStringKeyStore(snapshot)) {
          return this.fallbackStringKeyInMemoryStore.subscribe(snapshot, callback);
        }
        const subscription = {
          snapshot,
          callback
        };
        this.snapshotSubscriptions = [...this.snapshotSubscriptions, subscription];
        if (!isErrorSnapshot(snapshot)) {
          this.retainSnapshotIds(snapshot);
        }
        return () => {
          const {
            snapshotSubscriptions
          } = this;
          const index = indexOf.call(snapshotSubscriptions, subscription);
          // only attempt to slice if the subscription is in the list (in case someone
          // calls unsubscribe multiple times)
          if (index > -1) {
            this.snapshotSubscriptions = [...slice.call(snapshotSubscriptions, 0, index), ...slice.call(snapshotSubscriptions, index + 1)];
            {
              this.snapshotSubscriptions = freeze(this.snapshotSubscriptions);
            }
            // need to re-gather snapshot associated Ids to capture latest refs
            const {
              snapshot
            } = subscription;
            if (!isErrorSnapshot(snapshot)) {
              this.releaseSnapshotIds(snapshot);
            }
          }
        };
      }
      updateAvailable(keys) {
        if (keys.length > 0 && typeof keys[0] === 'string') {
          return this.fallbackStringKeyInMemoryStore.updateAvailable(keys);
        }
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions
        } = this;
        // read metadata for each key, and mark as expired
        this.expirePossibleStaleRecords(keys);
        // Process snapshot subscriptions
        const pendingPromises = [];
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot
          } = subscription;
          if (isErrorSnapshot(snapshot)) {
            // TODO: If we want to support refreshing Error Snapshots, we will need
            // to update the ErrorSnapshot interface to include the recordId, or
            // resolve the snapshot through its refresh.config property
            continue;
          }
          if (!hasOverlappingIds(snapshot, keys)) {
            continue;
          }
          pendingPromises.push(this.refreshSnapshot(snapshot));
        }
        // resolves after all snapshots refresh resolve
        // for now catch in case of reject and resolve
        return Promise.all(pendingPromises).then(_promises => undefined).catch(_err => Promise.resolve(undefined));
      }
      retain(keys) {
        if (keys.length > 0 && typeof keys[0] === 'string') {
          return this.fallbackStringKeyInMemoryStore.retain(keys);
        }
        for (let i = 0, keysLength = keys.length; i < keysLength; i++) {
          const key = keys[i];
          this.increaseRetentionCount(key);
        }
        return () => {
          this.release(keys);
        };
      }
      watch(partialKey, callback) {
        if (typeof partialKey === 'string') {
          return this.fallbackStringKeyInMemoryStore.watch(partialKey, callback);
        }
        const subscription = {
          partialKey,
          callback
        };
        this.watchSubscriptions = [...this.watchSubscriptions, subscription];
        return () => {
          const {
            watchSubscriptions
          } = this;
          const index = indexOf.call(watchSubscriptions, subscription);
          this.watchSubscriptions = [...slice.call(watchSubscriptions, 0, index), ...slice.call(watchSubscriptions, index + 1)];
          {
            this.watchSubscriptions = freeze(this.watchSubscriptions);
          }
        };
      }
      /**
       * Evicts data at the canonical key location and marks any redirects (if applicable)
       * to the key as visited
       * @param key key to evict
       */
      evict(key) {
        if (typeof key === 'string') {
          this.fallbackStringKeyInMemoryStore.evict(key);
          return;
        }
        // find and evict the canonical key
        const canonicalKey = this.getCanonicalRecordId(key);
        this.recordsMap.delete(canonicalKey);
        this.markVisited(canonicalKey);
      }
      cleanup() {
        if (this.fallbackStringKeyInMemoryStore.pendingTrimKeys.size > 0) {
          this.fallbackStringKeyInMemoryStore.cleanup();
        }
      }
      /**
       * Deallocates data at the canonical key location for in-memory (L1) cache
       * @param key key to deallocate
       */
      dealloc(key) {
        if (typeof key === 'string') {
          this.fallbackStringKeyInMemoryStore.dealloc(key);
          return;
        }
        // find and deallocate the canonical key
        const canonicalKey = this.getCanonicalRecordId(key);
        this.recordsMap.delete(canonicalKey);
      }
      keyExistsInStore(key) {
        if (typeof key === 'string') {
          return this.fallbackStringKeyInMemoryStore.keyExistsInStore(key);
        }
        return this.recordsMap.get(key) !== undefined;
      }
      publishMetadata(key, storeMetadata) {
        if (typeof key === 'string') {
          this.fallbackStringKeyInMemoryStore.publishMetadata(key, storeMetadata);
          return;
        }
        this.putMetadata(key, storeMetadata, true);
        const canonicalKey = this.getCanonicalRecordId(key);
        this.markRefreshed(canonicalKey);
      }
      putMetadata(key, storeMetadata, adjustTTLOverride) {
        if (typeof key === 'string') {
          this.fallbackStringKeyInMemoryStore.putMetadata(key, storeMetadata, adjustTTLOverride);
          return;
        }
        const {
          namespace,
          representationName,
          ingestionTimestamp
        } = storeMetadata;
        const ttlOverrideKey = this.buildStructuredKey(namespace, representationName, {});
        const ttlOverride = getTTLOverride(ttlOverrideKey, this.ttlOverridesMap, this.defaultTTLOverride);
        const canonicalKey = this.getCanonicalRecordId(key);
        if (ttlOverride !== undefined && adjustTTLOverride) {
          // It should check if the namespace + representationName exists in the ttlOverride map.
          // If a ttlOverride does exist, calculate a new ExpirationTimestamp with the override.
          const newExpiration = ingestionTimestamp + ttlOverride;
          // Create a new StoreMetadata object and publish the new object to storeMetadata.
          const metaDataOverride = {
            ...storeMetadata,
            expirationTimestamp: newExpiration
          };
          this.metadataMap.set(canonicalKey, metaDataOverride);
        } else {
          // If it does not exist, publish the user passed StoreMetadata into the storeMetadata map.
          this.metadataMap.set(canonicalKey, storeMetadata);
        }
      }
      expirePossibleStaleRecords(keys) {
        if (keys.length > 0 && typeof keys[0] === 'string') {
          return this.fallbackStringKeyInMemoryStore.expirePossibleStaleRecords(keys);
        }
        const expirationTimestamp = Date.now();
        for (let i = 0, len = keys.length; i < len; i++) {
          const key = keys[i];
          const metadata = this.readMetadata(key);
          if (metadata !== undefined) {
            this.publishMetadata(key, {
              ...metadata,
              expirationTimestamp
            });
          }
        }
      }
      setTTLOverride(namespace, representationName, ttl) {
        // Set the TTLs in both the stores
        this.fallbackStringKeyInMemoryStore.setTTLOverride(namespace, representationName, ttl);
        this.ttlOverridesMap.set(this.buildStructuredKey(namespace, representationName, {}), ttl);
      }
      getTTLOverride(namespace, representationName) {
        return this.ttlOverridesMap.get(this.buildStructuredKey(namespace, representationName, {}));
      }
      getTTLOverrides() {
        return this.ttlOverridesMap;
      }
      setDefaultTTLOverride(ttl) {
        // Set the TTLs in both the stores
        this.fallbackStringKeyInMemoryStore.setDefaultTTLOverride(ttl);
        this.defaultTTLOverride = ttl;
      }
      getDefaultTTLOverride() {
        return this.defaultTTLOverride;
      }
      reset() {
        this.recordsMap = new StoreKeyMap();
        this.snapshotSubscriptions = [];
        this.watchSubscriptions = [];
        this.visitedIdsSet = new StoreKeySet();
        this.refreshedIdsSet = new StoreKeySet();
        this.insertedIdsSet = new StoreKeySet();
        this.redirectKeysMap = new StoreKeyMap();
        this.reverseRedirectKeysMap = new StoreKeyMap();
        this.retainedIdsMap = new StoreKeyMap();
        this.ttlOverridesMap = new StoreKeyMap();
        this.trimTask = null;
        this.metadataMap = new StoreKeyMap();
        this.defaultTTLOverride = undefined;
        // Don't emit this for now as InMemoryStore's reset() also calls emitLuvioStoreEvent
        //emitLuvioStoreEvent({ type: 'store-reset', timestamp: Date.now() }, this.eventObservers);
        // Also reset the fallbackStringKeyInMemoryStore
        this.fallbackStringKeyInMemoryStore.reset();
      }
      addStoreEventObserver(storeEventObserver) {
        const inMemoryStoreUnsubscribe = this.fallbackStringKeyInMemoryStore.addStoreEventObserver(storeEventObserver);
        this.eventObservers.push(storeEventObserver);
        return () => {
          const {
            eventObservers
          } = this;
          const index = this.eventObservers.indexOf(storeEventObserver);
          if (index > -1) {
            this.eventObservers = [...slice.call(eventObservers, 0, index), ...slice.call(eventObservers, index + 1)];
          }
          inMemoryStoreUnsubscribe();
        };
      }
      // public in memory methods
      scheduleTrim() {
        if (this.fallbackStringKeyInMemoryStore.pendingTrimKeys.size > 0) {
          this.fallbackStringKeyInMemoryStore.scheduleTrim();
          return;
        }
        if (this.trimTask === null) {
          this.trimTask = () => {
            const {
              metadataMap,
              retainedIdsMap,
              pendingTrims
            } = this;
            let deallocCount = 0;
            const now = Date.now();
            pendingTrims.forEach(key => {
              const recordExpiration = metadataMap.get(key);
              if (retainedIdsMap.get(key) !== undefined || recordExpiration === undefined || recordExpiration !== undefined && recordExpiration.expirationTimestamp >= now) {
                return;
              }
              this.dealloc(key);
              deallocCount++;
            });
            pendingTrims.clear();
            return Promise.resolve({
              deallocatedCount: deallocCount
            });
          };
          this.scheduler(this.trimTask, () => {
            this.trimTask = null;
          });
        }
      }
      // private/protected methods
      /**
       * Updates a subscription with a new snapshot and performs retention book-keeping
       * on the existing and new snapshot.
       */
      updateSubscriptionSnapshot(subscription, newSnapshot) {
        const {
          snapshot: oldSnapshot
        } = subscription;
        if (oldSnapshot === newSnapshot) {
          return;
        }
        subscription.snapshot = newSnapshot;
        if (!isErrorSnapshot(newSnapshot)) {
          this.retainSnapshotIds(newSnapshot);
        }
        if (!isErrorSnapshot(oldSnapshot)) {
          this.releaseSnapshotIds(oldSnapshot);
        }
      }
      refreshSnapshot(snapshot) {
        const {
          refresh
        } = snapshot;
        if (refresh !== undefined) {
          return refresh.resolve(refresh.config);
        }
        return Promise.resolve(undefined);
      }
      instrumentIngestedNewData(snapshot, rebuiltSnapshot) {
        const recordId = rebuiltSnapshot.recordId;
        const recordMetadata = this.metadataMap.get(recordId);
        // Non-batch scenario
        if (recordMetadata) {
          emitLuvioStoreEvent({
            type: 'cache-miss-out-of-ttl',
            oldSnapshot: snapshot,
            newSnapshot: rebuiltSnapshot,
            recordId,
            recordMetadata,
            timestamp: Date.now()
          }, this.eventObservers);
        } else {
          rebuiltSnapshot.seenRecords.keysAsArray().forEach(seenRecordId => {
            const seenRecordMetadata = this.metadataMap.get(seenRecordId);
            if (seenRecordMetadata) {
              emitLuvioStoreEvent({
                type: 'cache-miss-out-of-ttl',
                oldSnapshot: snapshot,
                newSnapshot: rebuiltSnapshot,
                recordId: seenRecordId,
                recordMetadata: seenRecordMetadata,
                timestamp: Date.now()
              }, this.eventObservers);
            }
          });
        }
      }
      emitOrRefreshRebuiltSnapshot(rebuiltSnapshot, subscription, snapshotAvailable) {
        const {
          snapshot,
          callback
        } = subscription;
        // if the rebuilt snapshot is pending then continue on, broadcast will get
        // called again once the pending snapshot is resolved
        if (isPendingSnapshot(rebuiltSnapshot)) {
          if (isPendingSnapshot(snapshot)) {
            this.updateSubscriptionSnapshot(subscription, rebuiltSnapshot);
          }
          return;
        }
        this.updateSubscriptionSnapshot(subscription, rebuiltSnapshot);
        if (snapshotAvailable(rebuiltSnapshot)) {
          // TODO [W-10186366]: revisit if we want to handle errors thrown in user-land callback
          if (rebuiltSnapshot !== snapshot) {
            callback(rebuiltSnapshot);
          }
          this.instrumentIngestedNewDataOnFulfilledSnapshots(snapshot, rebuiltSnapshot);
        } else if (isUnfulfilledSnapshot(rebuiltSnapshot)) {
          const {
            refresh
          } = rebuiltSnapshot;
          if (refresh !== undefined) {
            refresh.resolve(refresh.config);
          }
        }
      }
      instrumentIngestedNewDataOnFulfilledSnapshots(snapshot, rebuiltSnapshot) {
        if (isFulfilledSnapshot(snapshot) && isFulfilledSnapshot(rebuiltSnapshot)) {
          this.instrumentIngestedNewData(snapshot, rebuiltSnapshot);
        }
      }
      retainSnapshotIds(snapshot) {
        const {
          recordId,
          seenRecords
        } = snapshot;
        const snapshotRetainedIds = seenRecords === undefined ? [recordId] : [recordId, ...seenRecords.keysAsArray()];
        this.retain(snapshotRetainedIds);
      }
      releaseSnapshotIds(snapshot) {
        const {
          recordId,
          seenRecords
        } = snapshot;
        const snapshotReleaseIds = seenRecords === undefined ? [recordId] : [recordId, ...seenRecords.keysAsArray()];
        this.release(snapshotReleaseIds);
      }
      increaseRetentionCount(key) {
        const count = this.retainedIdsMap.get(key);
        this.retainedIdsMap.set(key, count === undefined ? 1 : count + 1);
        // do not consider this key for trim while retained
        this.pendingTrims.delete(key);
      }
      decreaseRetentionCount(key) {
        const count = this.retainedIdsMap.get(key);
        if (count === 1) {
          // consider this key for trimming when ref count goes to zero
          this.pendingTrims.add(key);
          this.retainedIdsMap.delete(key);
          return true;
        } else if (count === undefined) {
          return false;
        } else {
          this.retainedIdsMap.set(key, count - 1);
        }
        return false;
      }
      release(keys) {
        const keysLength = keys.length;
        let shouldScheduleTrim = false;
        for (let i = 0; i < keysLength; i++) {
          const key = keys[i];
          const result = this.decreaseRetentionCount(key);
          if (result === true) {
            shouldScheduleTrim = true;
          }
        }
        // only schedule trim if an entry is removed from retention map
        if (shouldScheduleTrim === true) {
          // schedule trim for next tick
          this.scheduleTrim();
        }
      }
      markVisited(canonicalKey) {
        if (typeof canonicalKey === 'string') {
          this.fallbackStringKeyInMemoryStore.markVisited(canonicalKey);
          return;
        }
        const {
          visitedIdsSet,
          reverseRedirectKeysMap
        } = this;
        let redirectKey = canonicalKey;
        // mark all redirects leading up to the canonical key as visited so
        // affected snapshots are updated
        do {
          visitedIdsSet.add(redirectKey);
          redirectKey = reverseRedirectKeysMap.get(redirectKey);
        } while (redirectKey !== undefined);
      }
      markRefreshed(canonicalKey) {
        const {
          refreshedIdsSet,
          reverseRedirectKeysMap
        } = this;
        let redirectKey = canonicalKey;
        // mark all redirects leading up to the canonical key as refreshed so
        // affected snapshots are updated
        do {
          refreshedIdsSet.add(redirectKey);
          redirectKey = reverseRedirectKeysMap.get(redirectKey);
        } while (redirectKey !== undefined);
      }
      isUsingStringKeys() {
        return keys(this.fallbackStringKeyInMemoryStore.visitedIds).length !== 0 || keys(this.fallbackStringKeyInMemoryStore.refreshedIds).length !== 0;
      }
      delegateToFallbackStringKeyStore(snapshot) {
        return !isErrorSnapshot(snapshot) && typeof snapshot.recordId === 'string';
      }
      emitStorePublishEvent(keyMetadata) {
        emitLuvioStoreEvent({
          type: 'store-publish',
          timestamp: Date.now(),
          store: this,
          key: keyMetadata,
          keySchema: this.buildKeySchema(keyMetadata)
        }, this.eventObservers);
      }
      buildStructuredKey(namespace, representationName, idValues) {
        {
          const undefinedIdValues = entries(idValues).filter(entry => entry[1] === undefined);
          if (undefinedIdValues.length > 0) {
            throw new Error(`Undefined value for config keys: ${undefinedIdValues.map(entry => entry[0]).join(', ')}. Undefined values are not supported- use null instead.`);
          }
        }
        const key = {
          ...idValues,
          namespace,
          representationName
        };
        return key;
      }
      buildIngestionStagingStore() {
        const store = new InMemoryStore();
        store.ttlOverridesMap = this.ttlOverridesMap;
        store.defaultTTLOverride = this.defaultTTLOverride;
        store.redirectKeysMap = this.redirectKeysMap;
        store.reverseRedirectKeysMap = this.reverseRedirectKeysMap;
        store.fallbackStringKeyInMemoryStore = this.fallbackStringKeyInMemoryStore.buildIngestionStagingStore();
        return store;
      }
      /**
       * Builds keySchema from provided NormalizedKeyMetadata.
       *
       * Rules of key schema:
       *   1. all keys start with "namespace":"representationName:"
       *   2. sort keys from extracted key metadata, as ordering is not guaranteed
       */
      buildKeySchema(keyMetadata) {
        // pull NamespacedType type out of NormalizedKeyMetadata
        const {
          namespace: _ns,
          representationName: _rn,
          ...keyParamValues
        } = keyMetadata;
        const keySchema = keys(keyParamValues).sort();
        return ['namespace', 'representationName', ...keySchema];
      }
      serialize() {
        return this.fallbackStringKeyInMemoryStore.serialize();
      }
    }
    function adapterToNetworkPriority(priority) {
      switch (priority) {
        case 'background':
          return 'background';
        case 'high':
          return 'high';
        case 'normal':
        default:
          return 'normal';
      }
    }
    exports.HttpStatusCode = void 0;
    (function (HttpStatusCode) {
      HttpStatusCode[HttpStatusCode["Ok"] = 200] = "Ok";
      HttpStatusCode[HttpStatusCode["Created"] = 201] = "Created";
      HttpStatusCode[HttpStatusCode["NoContent"] = 204] = "NoContent";
      HttpStatusCode[HttpStatusCode["NotModified"] = 304] = "NotModified";
      HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
      HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
      HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
      HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
      HttpStatusCode[HttpStatusCode["ServerError"] = 500] = "ServerError";
      HttpStatusCode[HttpStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(exports.HttpStatusCode || (exports.HttpStatusCode = {}));
    /**
     * A type guard function for determining if an unknown object is a {@link FormData}
     */
    function isFormData(obj) {
      return typeof obj === 'object' && obj !== null && 'namedEntries' in obj && isArray(obj.namedEntries);
    }
    /**
     * A type guard function for determining if an unknown object is a {@link FileReference}
     */
    function isFileReference(entryValue) {
      return typeof entryValue === 'object' && entryValue !== null && 'isFileReference' in entryValue && entryValue.isFileReference === true;
    }
    function coerceAdapterRequestContext(adapterRequestContext) {
      const {
        priority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = adapterRequestContext;
      return {
        networkPriority: adapterToNetworkPriority(priority),
        requestCorrelator,
        eventObservers,
        sourceContext
      };
    }
    function appendTTLStrategy(storeLookup, ttlStrategy) {
      const returnStoreLookup = (sel, refresh) => storeLookup(sel, refresh, ttlStrategy);
      // append ttlStrategy to storeLookup function (in cases where custom adapter
      // wants to perform it's own lookup)
      returnStoreLookup.ttlStrategy = ttlStrategy;
      return returnStoreLookup;
    }
    function buildNetworkSnapshot(args) {
      const {
        buildNetworkSnapshot,
        buildSnapshotContext,
        coercedAdapterRequestContext
      } = args;
      return buildNetworkSnapshot(buildSnapshotContext, coercedAdapterRequestContext).then(snapshot => snapshot.state === 'Pending' ? args.resolvePendingSnapshot(snapshot) : snapshot);
    }
    function buildTTLStrategy(staleDurationMilliseconds = 0) {
      return (timestamp, metadata, valueIsError) => {
        if (metadata !== undefined) {
          const {
            expirationTimestamp
          } = metadata;
          if (timestamp > expirationTimestamp) {
            if (timestamp <= expirationTimestamp + staleDurationMilliseconds && valueIsError !== true) {
              return exports.StoreResolveResultState.Stale;
            }
            return exports.StoreResolveResultState.NotPresent;
          }
        }
        if (valueIsError === true) {
          return exports.StoreResolveResultState.Error;
        }
        return exports.StoreResolveResultState.Found;
      };
    }
    // TODO - update userland-facing APIs to return `AvailableSnapshot` instead of `Snapshot`
    // and then the signatures here can be updated as well
    function buildAvailableSnapshotFromCachedSnapshotResponse(cachedSnapshot, availableSnapshotFunc) {
      if (isPromise(cachedSnapshot)) {
        return cachedSnapshot.then(availableSnapshotFunc);
      }
      return availableSnapshotFunc(cachedSnapshot);
    }
    function buildCacheAndNetworkImplementation(staleDurationSeconds = 0) {
      return function (args) {
        const {
          buildCachedSnapshot,
          buildNetworkSnapshot: buildNetworkSnapshot$1,
          buildSnapshotContext,
          storeLookup,
          coercedAdapterRequestContext,
          luvio
        } = args;
        const staleDurationMilliseconds = staleDurationSeconds * 1000;
        const cachedSnapshot = buildCachedSnapshot(buildSnapshotContext, appendTTLStrategy(storeLookup, buildTTLStrategy(staleDurationMilliseconds)), luvio);
        return buildAvailableSnapshotFromCachedSnapshotResponse(cachedSnapshot, snapshot => {
          if (snapshot !== undefined) {
            // data found in L1 cache
            if (isFulfilledSnapshot(snapshot) || isErrorSnapshot(snapshot) || isStaleSnapshot(snapshot)) {
              // kick off network request, do not await it
              buildNetworkSnapshot$1(buildSnapshotContext, coercedAdapterRequestContext);
              // return the cached snapshot to caller
              return snapshot;
            }
            if (isPendingSnapshot(snapshot)) {
              return args.resolvePendingSnapshot(snapshot);
            }
            // any other state falls through to network snapshot
          }
          return buildNetworkSnapshot(args);
        });
      };
    }
    const cacheThenNetworkImplementation = function (args) {
      const {
        buildCachedSnapshot,
        buildSnapshotContext,
        storeLookup,
        luvio
      } = args;
      const cachedSnapshot = buildCachedSnapshot(buildSnapshotContext, appendTTLStrategy(storeLookup, buildTTLStrategy()), luvio);
      return buildAvailableSnapshotFromCachedSnapshotResponse(cachedSnapshot, snapshot => {
        if (snapshot !== undefined) {
          if (isFulfilledSnapshot(snapshot) || isErrorSnapshot(snapshot)) {
            return snapshot;
          }
          if (isPendingSnapshot(snapshot)) {
            return args.resolvePendingSnapshot(snapshot);
          }
        }
        return buildNetworkSnapshot(args);
      });
    };
    const noCacheImplementation = function (args) {
      return buildNetworkSnapshot(args);
    };
    const onlyIfCachedImplementation = function (args) {
      const {
        buildCachedSnapshot,
        buildSnapshotContext,
        storeLookup,
        luvio
      } = args;
      const cachedSnapshot = buildCachedSnapshot(buildSnapshotContext, appendTTLStrategy(storeLookup, buildTTLStrategy()), luvio);
      return buildAvailableSnapshotFromCachedSnapshotResponse(cachedSnapshot, snapshot => {
        if (snapshot !== undefined && (isFulfilledSnapshot(snapshot) || isErrorSnapshot(snapshot))) {
          return snapshot;
        }
        const refresh = snapshot !== undefined ? snapshot.refresh : undefined;
        return createErrorSnapshot({
          body: undefined,
          headers: {},
          ok: false,
          status: exports.HttpStatusCode.GatewayTimeout,
          statusText: 'Data requested with only-if-cached policy and not found in the cache.',
          errorType: 'fetchResponse'
        }, refresh);
      });
    };
    function buildStaleWhileRevalidateImplementation(staleDurationSeconds) {
      return function (args) {
        const {
          buildCachedSnapshot,
          buildNetworkSnapshot: buildNetworkSnapshot$1,
          buildSnapshotContext,
          storeLookup,
          coercedAdapterRequestContext,
          luvio
        } = args;
        const staleDurationMilliseconds = staleDurationSeconds * 1000;
        const cachedSnapshot = buildCachedSnapshot(buildSnapshotContext, appendTTLStrategy(storeLookup, buildTTLStrategy(staleDurationMilliseconds)), luvio);
        return buildAvailableSnapshotFromCachedSnapshotResponse(cachedSnapshot, snapshot => {
          if (snapshot !== undefined) {
            if (isFulfilledSnapshot(snapshot) || isErrorSnapshot(snapshot)) {
              return snapshot;
            }
            if (isPendingSnapshot(snapshot)) {
              return args.resolvePendingSnapshot(snapshot);
            }
            if (snapshot.state === SnapshotState.Stale) {
              buildNetworkSnapshot$1(buildSnapshotContext, coercedAdapterRequestContext);
              return snapshot;
            }
          }
          return buildNetworkSnapshot(args);
        });
      };
    }
    function buildValidAtImplementation(basePolicyImplementation, timestamp) {
      return function validAtImplementation(args) {
        // This somewhat convoluted code is used to force the basePolicyImplementation's
        // TTLStrategy to use the the valid-at cache policy's timestamp. The flow goes:
        //
        // Environment.applyCachePolicy => validAtImplementation (this function) =>
        //    basePolicyImplementation => adapter's buildCachedSnapshot =>
        //    basePolicyImplementation's storeLookup => validAtStoreLookup (below) =>
        //    Environment.applyCachePolicy's storeLookup => InMemoryStore/Reader code =>
        //    valid-at TTLStrategy (below) =>
        //    basePolicyImplementation's TTLStrategy (with valid-at timestamp)
        const validAtStoreLookup = (sel, refresh, ttlStrategy) => args.storeLookup(sel, refresh, (_readerTimestamp, metadata, valueIsError) => ttlStrategy(timestamp, metadata, valueIsError));
        // let basePolicy make all the decisions, but have it use our storeLookup
        // so we can override the timestamp passed to the basePolicy's TTLStrategy
        return basePolicyImplementation({
          ...args,
          storeLookup: validAtStoreLookup
        });
      };
    }
    function isNodeLink(node) {
      return typeof node === 'object' && node !== null && hasOwnProperty.call(node, '__ref');
    }
    function isGraphNode(node) {
      return node !== null && node.type === GraphNodeType.Node;
    }
    var GraphNodeType;
    (function (GraphNodeType) {
      GraphNodeType["Link"] = "Link";
      GraphNodeType["Node"] = "Node";
      GraphNodeType["Error"] = "Error";
      GraphNodeType["Locked"] = "Locked";
    })(GraphNodeType || (GraphNodeType = {}));
    class GraphNodeError {
      constructor(store, data) {
        this.type = GraphNodeType.Error;
        this.store = store;
        this.data = data;
      }
      retrieve() {
        return this.data;
      }
    }
    function followLink(store, key) {
      return store.readEntry(key);
    }
    class GraphLink {
      constructor(store, data) {
        this.type = GraphNodeType.Link;
        this.store = store;
        this.data = data;
      }
      isPending() {
        return this.data.pending === true;
      }
      isMissing() {
        return this.data.isMissing === true;
      }
      follow() {
        const {
          __ref
        } = this.data;
        if (__ref === undefined) {
          return null;
        }
        const linked = followLink(this.store, __ref);
        if (linked === null || linked === undefined) {
          return null;
        }
        if (isStoreRecordError(linked)) {
          return new GraphNodeError(this.store, linked);
        }
        return new GraphNode(this.store, linked, __ref);
      }
      linkData() {
        return this.data.data;
      }
      writeLinkData(data) {
        this.data.data = data;
      }
    }
    class GraphNode {
      constructor(store, data, storeKey) {
        this.type = GraphNodeType.Node;
        this.store = store;
        this.data = data;
        this.storeKey = storeKey;
      }
      object(propertyName) {
        const value = this.data[propertyName];
        if (isNodeLink(value)) {
          throw new Error(`Cannot walk to path ${String(propertyName)}. "${String(propertyName)}" is a link: "${value}"`);
        }
        if (typeof value !== 'object' || value === null) {
          throw new Error(`Cannot walk to path ${String(propertyName)}. "${String(propertyName)}" is a scalar: "${value}"`);
        }
        // We're walking to an object property on the current store record, pass the storeKey down.
        return new GraphNode(this.store, value, this.storeKey);
      }
      link(propertyName) {
        const value = this.data[propertyName];
        if (!isNodeLink(value)) {
          throw new Error(`Cannot walk to link ${String(propertyName)}. "${String(propertyName)}" is not a link: "${value}"`);
        }
        return new GraphLink(this.store, value);
      }
      scalar(propertyName) {
        const value = this.data[propertyName];
        if (typeof value === 'object' && value !== null) {
          throw new Error(`Cannot return value at path ${String(propertyName)}. ${String(propertyName)} is not a scalar.`);
        }
        return value;
      }
      keys() {
        return keys(this.data);
      }
      isScalar(propertyName) {
        // TODO W-6900046 - merge.ts casts these to any and manually sets `data`
        // so this guard is required
        if (this.data === undefined) {
          return true;
        }
        const value = this.data[propertyName];
        return typeof value !== 'object' || value === null;
      }
      isMissing(propertyName) {
        const value = this.data[propertyName];
        if (value && typeof value.__state === 'object' && value.__state !== null) {
          return !!value.__state.isMissing;
        }
        return false;
      }
      isPending(propertyName) {
        const value = this.data[propertyName];
        if (value && typeof value.__state === 'object' && value.__state !== null) {
          return !!value.__state.pending;
        }
        return false;
      }
      write(propertyName, value) {
        this.data[propertyName] = value;
        const canonicalKey = this.store.getCanonicalRecordId(this.storeKey);
        this.store.markVisited(canonicalKey);
      }
      isUndefined(propertyName) {
        return this.data[propertyName] === undefined;
      }
      retrieve() {
        return this.data;
      }
    }
    function isUnionObjectSelection(sel) {
      return sel.union === true && sel.kind === 'Object';
    }
    function isReaderFragment(fragment) {
      return fragment.reader === true;
    }
    function isFragmentUnionSelection(sel) {
      return sel.union === true;
    }
    function formatStorageKey(name, argValues) {
      if (!argValues) {
        return name;
      }
      var values = [];
      for (var _argName in argValues) {
        if (hasOwnProperty.call(argValues, _argName)) {
          var value = argValues[_argName];
          if (value !== null || value !== undefined) {
            values.push(_argName + ':' + stringify(value));
          }
        }
      }
      return values.length === 0 ? name : name + '('.concat(values.join(','), ')');
    }
    function getArgumentValues(args, variables) {
      const values = {};
      args.forEach(arg => {
        if (arg.kind === 'Variable') {
          // Variables are provided at runtime and are not guaranteed to be stable.
          values[arg.name] = variables[arg.variableName];
        } else {
          values[arg.name] = arg.value;
        }
      });
      return values;
    }
    function getStorageKey(field, variables) {
      const {
        args,
        name
      } = field;
      if (args && args.length !== 0) {
        return formatStorageKey(name, getArgumentValues(args, variables));
      }
      return name;
    }

    /**
     * Checks if the given variable is defined
     */
    function isDefined(value) {
      return value !== undefined && value !== null;
    }

    /**
     * Checks if the given variable is an object
     */
    function isObject(value) {
      return typeof value === 'object' && value !== null;
    }
    var StoreLinkStateValues;
    (function (StoreLinkStateValues) {
      StoreLinkStateValues[StoreLinkStateValues["NotPresent"] = 0] = "NotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefNotPresent"] = 1] = "RefNotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefPresent"] = 2] = "RefPresent";
      StoreLinkStateValues[StoreLinkStateValues["Null"] = 3] = "Null";
      StoreLinkStateValues[StoreLinkStateValues["Missing"] = 4] = "Missing";
      StoreLinkStateValues[StoreLinkStateValues["Pending"] = 5] = "Pending";
    })(StoreLinkStateValues || (StoreLinkStateValues = {}));
    function getLinkState(link) {
      // This condition is hit when the link itself isn't present
      if (link === undefined) {
        return {
          state: StoreLinkStateValues.NotPresent
        };
      }
      if (link === null) {
        return {
          state: StoreLinkStateValues.Null
        };
      }
      const {
        __ref: key,
        pending,
        isMissing
      } = link;
      if (pending === true) {
        return {
          state: StoreLinkStateValues.Pending
        };
      }
      if (isMissing === true) {
        return {
          state: StoreLinkStateValues.Missing
        };
      }
      if (key === undefined) {
        return {
          state: StoreLinkStateValues.RefNotPresent
        };
      }
      return {
        state: StoreLinkStateValues.RefPresent,
        key
      };
    }
    const skipTTLStrategy = (_timestamp, _metadata, valueIsError) => {
      if (valueIsError === true) {
        return exports.StoreResolveResultState.Error;
      }
      return exports.StoreResolveResultState.Found;
    };
    function storeLookup(key, timestamp, store, ttlStrategy) {
      const redirectKeys = store.getRedirectLineage(key);
      const canonicalKey = store.getCanonicalRecordId(key);
      const value = store.readEntry(canonicalKey);
      if (value === undefined) {
        return {
          state: exports.StoreResolveResultState.NotPresent,
          redirects: redirectKeys,
          resolvedKey: canonicalKey
        };
      }
      let version = undefined;
      const metadata = store.readMetadata(canonicalKey);
      if (metadata !== undefined) {
        version = metadata.version;
      }
      const valueIsError = value !== null && isStoreRecordError(value);
      const state = ttlStrategy(timestamp, metadata, valueIsError);
      if (state === exports.StoreResolveResultState.NotPresent || state === exports.StoreResolveResultState.Stale) {
        if (metadata && metadata.ingestionTimestamp) {
          emitLuvioStoreEvent({
            type: 'data-out-of-ttl-duration-update',
            lastExpiredDuration: timestamp - metadata.ingestionTimestamp,
            recordId: canonicalKey,
            storeResolveResultState: state === exports.StoreResolveResultState.NotPresent ? 'not-present' : 'stale'
          }, store.eventObservers);
        }
      }
      switch (state) {
        case exports.StoreResolveResultState.NotPresent:
          return {
            state,
            redirects: redirectKeys,
            resolvedKey: canonicalKey
          };
        case exports.StoreResolveResultState.Error:
          return {
            state,
            value: value.error,
            version,
            redirects: redirectKeys,
            resolvedKey: canonicalKey
          };
        case exports.StoreResolveResultState.Stale:
          return {
            state,
            value,
            version: version,
            redirects: redirectKeys,
            resolvedKey: canonicalKey
          };
        default:
          return {
            state,
            value: value,
            redirects: redirectKeys,
            resolvedKey: canonicalKey,
            version
          };
      }
    }
    const READER_PATH_ROOT = 'ROOT';
    const EMPTY_STRING = '';
    var FragmentReadResultState;
    (function (FragmentReadResultState) {
      FragmentReadResultState[FragmentReadResultState["Missing"] = 0] = "Missing";
      FragmentReadResultState[FragmentReadResultState["Success"] = 1] = "Success";
      FragmentReadResultState[FragmentReadResultState["Error"] = 2] = "Error";
    })(FragmentReadResultState || (FragmentReadResultState = {}));
    const FRAGMENT_READ_RESULT_MISSING = {
      state: FragmentReadResultState.Missing
    };
    function validateUnionSelection(record, selection, path) {
      const {
        discriminator
      } = selection;
      const discriminatorValue = record[discriminator];
      if (discriminatorValue === undefined) {
        throw new Error(`Invalid discriminator. Expected discriminator at path "${path.fullPath}.${discriminator}" but received "${stringify(record)}"`);
      }
      const unionSelection = selection.unionSelections[discriminatorValue];
      if (unionSelection === undefined) {
        const keys = Object.keys(selection.unionSelections).map(key => `"${key}"`).join(', ');
        throw new Error(`Invalid union selection. Expected to be one of ${keys} but received "${discriminatorValue}"`);
      }
    }
    function resolveLink(reader, storeLink, version) {
      const {
        StoreLinkStateValues
      } = reader;
      const linkState = reader.getLinkState(storeLink);
      switch (linkState.state) {
        case StoreLinkStateValues.RefNotPresent:
        case StoreLinkStateValues.NotPresent:
        case StoreLinkStateValues.Missing:
          reader.markMissingLink(storeLink.__ref);
          reader.markMissing();
          return;
        case StoreLinkStateValues.Pending:
          reader.markPending();
          return;
        case StoreLinkStateValues.Null:
          {
            throw new Error(`TODO: Invalid Link State. Link on "${reader.currentPath.fullPath}"`);
          }
      }
      const {
        key: __ref
      } = linkState;
      return reader.read({
        recordId: __ref,
        node: {
          kind: 'Fragment',
          private: [],
          opaque: true,
          version
        },
        variables: {}
      });
    }
    const readerOpaqueReferenceMap = new WeakMap();
    class Reader {
      constructor(store, variables, refresh, baseSnapshot, ttlStrategy) {
        this.store = store;
        this.hasPendingData = false;
        this.getLinkState = getLinkState;
        this.StoreLinkStateValues = StoreLinkStateValues;
        this.StoreResolveResultState = exports.StoreResolveResultState;
        this.variables = variables;
        this.seenIds = new StoreKeySet();
        this.missingPaths = new StoreKeySet();
        this.missingLinks = new StoreKeySet();
        this.isMissingData = false;
        this.hasStaleData = false;
        this.refresh = refresh;
        // When we aren't passed a base snapshot, we don't have to worry about
        // marking the snapshot as changed because there is nothing to compare against.
        // Therefore, our initial state is that the snapshot has changed.
        let snapshotChanged = true;
        // When we aren't passed a base snapshot, we do not have any previous data
        // So we can just assign this to undefined
        let baseSnapshotValue = undefined;
        // When we are passed a base snapshot, we want to keep track of the previous data
        // We also will need to compare all of our data against the snapshot's previous data
        // Our initial state is that the snapshot has not changed. The reason for this is because
        // Once we detect a change, we can just flip this boolean on the first change and then
        // not have to worry about it for additional changes.
        if (baseSnapshot !== undefined && (baseSnapshot.state === SnapshotState.Fulfilled || baseSnapshot.state === SnapshotState.Stale)) {
          baseSnapshotValue = baseSnapshot.data;
          snapshotChanged = false;
        }
        this.snapshotChanged = snapshotChanged;
        this.currentPath = {
          fullPath: EMPTY_STRING,
          key: READER_PATH_ROOT,
          parent: null,
          baseSnapshotValue
        };
        this.baseSnapshot = baseSnapshot;
        this.timestamp = Date.now();
        this.ttlStrategy = ttlStrategy === undefined ? skipTTLStrategy : ttlStrategy;
      }
      resolveMetadata(source, version) {
        const link = source.__metadata;
        const linkState = getLinkState(link);
        if (linkState.state !== StoreLinkStateValues.RefPresent) {
          this.markMissing();
          return;
        }
        const lookup = this.resolveKey(linkState.key);
        if (lookup.version !== version) {
          this.markMissing();
          return;
        }
        return lookup.value;
      }
      readFragmentUnion(result, selection) {
        const {
          value: record
        } = result;
        {
          validateUnionSelection(record, selection, this.currentPath);
        }
        const {
          discriminator
        } = selection;
        const discriminatorValue = record[discriminator];
        return this.readFragment(result, selection.unionSelections[discriminatorValue]);
      }
      read(selector) {
        const {
          node: selectorNode
        } = selector;
        const {
          recordId: key
        } = selector;
        const result = this.storeLookup(key);
        const fragmentResult = this.readFragment(result, selectorNode);
        switch (fragmentResult.state) {
          case FragmentReadResultState.Missing:
            if (this.isMissingData === false) {
              this.isMissingData = true;
              this.snapshotChanged = true;
            }
            return this.createSnapshot(undefined, selector);
          case FragmentReadResultState.Error:
            return this.createErrorSnapshot(fragmentResult.value);
          default:
            return this.createSnapshot(fragmentResult.value, selector);
        }
      }
      getSnapshotState() {
        if (this.isMissingData === true) {
          return SnapshotState.Unfulfilled;
        }
        if (this.hasPendingData === true) {
          return SnapshotState.Pending;
        }
        if (this.hasStaleData === true) {
          return SnapshotState.Stale;
        }
        return SnapshotState.Fulfilled;
      }
      createErrorSnapshot(data) {
        return {
          data: undefined,
          error: data,
          state: SnapshotState.Error,
          refresh: this.refresh
        };
      }
      createSnapshot(data, selector) {
        // If snapshotChanged === false then we have established that baseSnapshot is present
        // Typescript is unable to conclude this fact hence adding a non-null assertion operator !
        // recordId of selector will be different than of baseSnapshot when reading a child of composite resource
        if (this.snapshotChanged === false && selector.recordId === this.baseSnapshot.recordId) {
          return this.baseSnapshot;
        }
        deepFreeze(data);
        return {
          recordId: selector.recordId,
          select: selector,
          variables: this.variables,
          seenRecords: this.seenIds,
          data,
          state: this.getSnapshotState(),
          missingPaths: this.missingPaths,
          missingLinks: this.missingLinks,
          refresh: this.refresh
        }; // Typescript complains about unfulfilled vs fulfilled snapshot if we don't cast
      }
      // Only works for non-complex values.. No Date or Functions.
      opaqueCopy(value) {
        return parse(stringify(value));
      }
      deepCopy(record, data, key, visitedKeys) {
        const value = record[key];
        this.enterPath(key);
        if (isArray(value)) {
          // Array
          const items = [];
          this.selectAll(value, items, visitedKeys);
          data[key] = items;
        } else if (typeof value === 'object' && value !== null) {
          // Object
          if (value.__ref !== undefined) {
            // Link
            const nextRecordId = value.__ref;
            if (isArray(nextRecordId)) {
              const items = [];
              this.selectAll(nextRecordId, items, visitedKeys);
              data[key] = items;
            } else {
              if (hasOwnProperty.call(visitedKeys, nextRecordId) === true) {
                throw new Error(`Invalid eager selection on records with circular references.`);
              }
              const lookupResult = this.resolveKey(nextRecordId);
              switch (lookupResult.state) {
                case exports.StoreResolveResultState.NotPresent:
                  data[key] = undefined;
                  break;
                case exports.StoreResolveResultState.Found:
                  {
                    const nested = {};
                    this.selectAll(lookupResult.value, nested, {
                      ...visitedKeys,
                      [nextRecordId]: true
                    });
                    data[key] = nested;
                    break;
                  }
              }
            }
          } else {
            // Inlined object
            const items = {};
            this.selectAll(value, items, visitedKeys);
            data[key] = items;
          }
        } else {
          // Scalar
          this.checkIfChanged(value);
          data[key] = value;
        }
        this.exitPath();
      }
      selectAllArray(record, data, visitedKeys) {
        const {
          length
        } = record;
        for (let key = 0; key < length; key += 1) {
          this.deepCopy(record, data, key, visitedKeys);
        }
      }
      selectAllObject(record, data, visitedKeys) {
        const recordKeys = keys(record);
        const {
          length
        } = recordKeys;
        for (let i = 0; i < length; i += 1) {
          const key = recordKeys[i];
          this.deepCopy(record, data, key, visitedKeys);
        }
      }
      selectAll(record, data, visitedKeys = {}) {
        const recordIsArray = isArray(record);
        if (recordIsArray === true) {
          this.selectAllArray(record, data, visitedKeys);
        } else {
          this.selectAllObject(record, data, visitedKeys);
        }
      }
      markPending() {
        this.hasPendingData = true;
      }
      markStale() {
        this.hasStaleData = true;
      }
      markMissing() {
        this.isMissingData = true;
        const fullPath = this.getFullPathString(this.currentPath.fullPath);
        this.missingPaths.add(fullPath);
        this.checkIfChanged(undefined);
      }
      markMissingLink(linkKey) {
        this.missingLinks.add(linkKey);
        this.markMissing();
      }
      unMarkMissing() {
        const fullPath = this.getFullPathString(this.currentPath.fullPath);
        this.missingPaths.delete(fullPath);
        if (this.missingPaths.size() === 0) {
          this.isMissingData = false;
        }
      }
      assignNonScalar(sink, key, value) {
        sink[key] = value;
      }
      enterPath(key) {
        const parent = this.currentPath;
        const {
          key: parentKey,
          fullPath: parentFullPath,
          baseSnapshotValue: parentBaseSnapshotValue
        } = parent;
        let baseSnapshotValue = undefined;
        if (parentBaseSnapshotValue !== undefined && parentBaseSnapshotValue !== null) {
          baseSnapshotValue = parentBaseSnapshotValue[key];
        }
        this.currentPath = {
          parent,
          key,
          fullPath: parentKey === READER_PATH_ROOT ? key : parentFullPath + '.' + key,
          baseSnapshotValue
        };
      }
      exitPath() {
        this.currentPath = this.currentPath.parent;
      }
      readSingleLink(propertyName, selection, source, sink, assignmentProperty) {
        const {
          required,
          nullable,
          fragment
        } = selection;
        const link = source[propertyName];
        const property = assignmentProperty === undefined ? propertyName : assignmentProperty;
        const linkState = getLinkState(link);
        switch (linkState.state) {
          case StoreLinkStateValues.RefNotPresent:
          case StoreLinkStateValues.NotPresent:
          case StoreLinkStateValues.Missing:
            // We need to read synthetic fragments here because data from the link is missing,
            // So we won't have a chance to call readFragment
            if (isReaderFragment(fragment) && fragment.synthetic === true) {
              return this.assignNonScalar(sink, property, fragment.read(this));
            }
            if (linkState.state === StoreLinkStateValues.Missing && required === false) {
              return;
            }
            this.markMissing();
            return;
          case StoreLinkStateValues.Null:
            if (nullable === true) {
              this.readScalar(propertyName, source, sink);
              return;
            }
            throw new Error(`Invalid Link State. Link on "${this.currentPath.fullPath}" is null but selection is not nullable: \n${stringify(selection, null, 2)}`);
          case StoreLinkStateValues.Pending:
            this.markPending();
            return;
          default:
            // if we have a link reference we override the required property passed to true
            // because if there was a missing reference the `isMissing` property would be true and the links state would
            // have returned `Missing`.
            this.readStoreLinkWithRef(linkState, fragment, sink, property, true);
        }
      }
      markRedirectsSeen(state) {
        const {
          redirects
        } = state;
        const {
          length: len
        } = redirects;
        if (len === 0) {
          return;
        }
        for (let i = 0; i < len; i += 1) {
          this.markSeenId(redirects[i]);
        }
      }
      resolveKey(key, options = {}) {
        const lookup = this.storeLookup(key);
        const {
          required
        } = options;
        switch (lookup.state) {
          case exports.StoreResolveResultState.Stale:
            this.markStale();
            break;
          case exports.StoreResolveResultState.NotPresent:
            if (required !== false) {
              this.markMissingLink(key);
            }
            break;
        }
        this.markRedirectsSeen(lookup);
        this.markSeenId(lookup.resolvedKey);
        return lookup;
      }
      readStoreLinkWithRef(linkState, fragment, sink, assignmentProperty, required) {
        const fragmentResult = this.readFragment(this.resolveKey(linkState.key, {
          required
        }), fragment);
        switch (fragmentResult.state) {
          case FragmentReadResultState.Error:
            this.markMissing();
            return;
          case FragmentReadResultState.Success:
            this.assignNonScalar(sink, assignmentProperty, fragmentResult.value);
        }
      }
      readObject(key, selection, source, sink) {
        const sourceValue = source[key];
        if (selection.nullable === true && sourceValue === null) {
          this.readScalar(key, source, sink);
          return;
        }
        if (selection.opaque === true) {
          this.readOpaque(sink, key, sourceValue, selection.required);
          return;
        }
        if (sourceValue === undefined) {
          if (selection.required === false) {
            this.checkIfChanged(sourceValue);
            return;
          }
          return this.markMissing();
        }
        if (typeof sourceValue.__state === 'object') {
          if (selection.supportsMissingMarker === true && sourceValue.__state.isMissing === true) {
            this.checkIfChanged(sourceValue);
            return;
          }
          if (sourceValue.__state.pending === true) {
            this.markPending();
            return;
          }
        }
        const sinkValue = isArray(sourceValue) ? [] : {};
        if (selection.selections === undefined) {
          this.selectAll(sourceValue, sinkValue);
        } else {
          this.traverseSelections(selection, sourceValue, sinkValue);
        }
        this.assignNonScalar(sink, key, sinkValue);
      }
      /**
       * Flip snapshotChanged flag to 'true' if current size of the value 'array' is different from the length of base snapshot.
       *
       * @param value - Sink array to be checked against baseSnapshotValue
       */
      checkIfArrayLengthChanged(value) {
        // If we've already detected a change, just return
        if (this.snapshotChanged === true) {
          return;
        }
        const {
          baseSnapshotValue
        } = this.currentPath;
        if (isDefined(baseSnapshotValue)) {
          this.snapshotChanged = baseSnapshotValue.length !== value.length;
        }
      }
      /**
       * Flip snapshotChanged flag to 'true' if number of keys in the 'Object' is different from the length of keys in base snapshot.
       *
       * @param keys - Array of Object keys to be checked against baseSnapshotValue
       */
      checkIfObjectKeysLengthChanged(keys$1) {
        // If we've already detected a change, just return
        if (this.snapshotChanged === true) {
          return;
        }
        const {
          baseSnapshotValue
        } = this.currentPath;
        if (isDefined(baseSnapshotValue)) {
          this.snapshotChanged = keys$1.length !== keys(baseSnapshotValue).length;
        }
      }
      checkIfChanged(value, options) {
        // If we've already detected a change, just return
        if (this.snapshotChanged === true) {
          return;
        }
        if ((options === null || options === void 0 ? void 0 : options.useDeepEquals) === true) {
          this.snapshotChanged = stringify(this.currentPath.baseSnapshotValue) !== stringify(value);
        } else {
          this.snapshotChanged = this.currentPath.baseSnapshotValue !== value;
        }
      }
      readPluralLink(propertyName, selection, record, data) {
        if (selection.fragment === undefined) {
          return;
        }
        const array = record[propertyName];
        if (array === undefined) {
          if (selection.required === false) {
            return;
          }
          return this.markMissing();
        }
        const sink = data[propertyName] = [];
        for (let i = 0, len = array.length; i < len; i += 1) {
          this.enterPath(i);
          this.readSingleLink(i, selection, array, sink);
          this.exitPath();
        }
        this.checkIfArrayLengthChanged(sink);
      }
      readObjectMap(propertyName, selection, record, data) {
        const obj = record[propertyName];
        if (obj === undefined) {
          if (selection.required === false) {
            return;
          }
          return this.markMissing();
        }
        const sink = data[propertyName] = {};
        const keys$1 = keys(obj);
        this.checkIfObjectKeysLengthChanged(keys$1);
        for (let i = 0, len = keys$1.length; i < len; i += 1) {
          const key = keys$1[i];
          this.enterPath(key);
          this.readObject(key, selection, obj, sink);
          this.exitPath();
        }
      }
      readLinkMap(propertyName, selection, record, data) {
        const map = record[propertyName];
        const keys$1 = keys(map);
        const sink = {};
        this.checkIfObjectKeysLengthChanged(keys$1);
        for (let i = 0, len = keys$1.length; i < len; i += 1) {
          const key = keys$1[i];
          this.enterPath(key);
          this.readSingleLink(key, selection, map, sink);
          this.exitPath();
        }
        this.assignNonScalar(data, propertyName, sink);
      }
      readSuccessResolveState(result, fragment) {
        if (isReaderFragment(fragment) && fragment.synthetic === true) {
          // this state should never occur
          return {
            state: FragmentReadResultState.Missing
          };
        }
        if (isFragmentUnionSelection(fragment)) {
          return this.readFragmentUnion(result, fragment);
        }
        const {
          version
        } = result;
        // apply version checking if version metadata exists
        if (version !== undefined && fragment.version !== undefined && version !== fragment.version) {
          return {
            state: FragmentReadResultState.Missing
          };
        }
        if (isReaderFragment(fragment)) {
          const value = fragment.read(result.value, this);
          return {
            state: FragmentReadResultState.Success,
            value
          };
        }
        if (fragment.opaque) {
          this.checkIfChanged(result.value, {
            useDeepEquals: true
          });
          if (isObject(result.value) && !readerOpaqueReferenceMap.has(result.value)) {
            readerOpaqueReferenceMap.set(result.value, this.opaqueCopy(result.value));
          }
          const opaqueValue = isObject(result.value) ? readerOpaqueReferenceMap.get(result.value) : result.value;
          return {
            state: FragmentReadResultState.Success,
            value: opaqueValue
          };
        }
        const sink = {};
        this.traverseSelections(fragment, result.value, sink);
        return {
          state: FragmentReadResultState.Success,
          value: sink
        };
      }
      readFragment(result, fragment) {
        if (isReaderFragment(fragment) && fragment.synthetic === true) {
          const value = fragment.read(this);
          // Handle the scenario where a synthetic read fails
          // One case being with a top level 404 response
          // from a composite adapter
          if (value.state === 'Error') {
            return {
              state: FragmentReadResultState.Error,
              value: value.value
            };
          }
          return {
            state: FragmentReadResultState.Success,
            value
          };
        }
        switch (result.state) {
          case exports.StoreResolveResultState.NotPresent:
            return FRAGMENT_READ_RESULT_MISSING;
          case exports.StoreResolveResultState.Error:
            return {
              state: FragmentReadResultState.Error,
              value: result.value
            };
          case exports.StoreResolveResultState.Stale:
            this.markStale();
            return this.readSuccessResolveState(result, fragment);
          case exports.StoreResolveResultState.Found:
            return this.readSuccessResolveState(result, fragment);
        }
      }
      readPluralObject(propertyName, selection, record, data) {
        if (selection.selections === undefined) {
          return;
        }
        const array = record[propertyName];
        if (array === undefined) {
          if (selection.required === false) {
            return;
          }
          return this.markMissing();
        }
        const sink = data[propertyName] = [];
        for (let i = 0, len = array.length; i < len; i += 1) {
          this.enterPath(i);
          const nextRecord = array[i];
          if (nextRecord === undefined) {
            this.markMissing();
            this.exitPath();
            return;
          }
          const obj = {};
          this.traverseSelections(selection, nextRecord, obj);
          push.call(sink, obj);
          this.exitPath();
        }
        this.checkIfArrayLengthChanged(sink);
      }
      readOpaque(sink, propertyName, value, required) {
        this.checkIfChanged(value);
        if (value === undefined && required === false) {
          return;
        }
        sink[propertyName] = value; // Should we be using this.opaqueCopy here? Not used by gql but seems bad to directly expose store entries.
      }
      readScalarMap(propertyName, record, data, required) {
        const obj = record[propertyName];
        if (obj === undefined) {
          if (required !== false) {
            this.markMissing();
            return;
          }
          this.checkIfChanged(undefined);
          return;
        }
        const sink = data[propertyName] = {};
        const keys$1 = keys(obj);
        this.checkIfObjectKeysLengthChanged(keys$1);
        for (let i = 0, len = keys$1.length; i < len; i += 1) {
          const key = keys$1[i];
          this.enterPath(key);
          this.readScalar(key, obj, sink);
          this.exitPath();
        }
      }
      readScalarPlural(propertyName, record, data, required) {
        const array = record[propertyName];
        if (array === undefined) {
          if (required === false) {
            return;
          }
          return this.markMissing();
        }
        const sink = data[propertyName] = [];
        // If the current snapshot is already know to be different from
        // previous snapshot, we can fast track and just copy the array
        // over.
        if (this.snapshotChanged === true) {
          // fast path: just copy from array to sink
          push.apply(sink, array);
          return;
        }
        this.checkIfArrayLengthChanged(array);
        // tsc seems to think 'this.snapshotChanged' is constant false here,
        // and it flags comparisons of false === true as error 'ts(2367)'
        // Oddly, this comparison exactly the same as earlier, yet the earlier
        // has no tsc errors.
        // @ts-ignore
        if (this.snapshotChanged === true) {
          // fast path: just copy from array to sink
          push.apply(sink, array);
          return;
        }
        for (let i = 0, len = array.length; i < len; i += 1) {
          this.enterPath(i);
          const value = array[i];
          push.call(sink, value);
          // the following method will change 'this.snapshotChanged'.
          // Later, check to see if 'this.snapshotChanged' is true,
          // if so, we can short-circuit the rest of this loop, and just
          // copy over the remainder of the array.
          this.checkIfChanged(value);
          this.exitPath();
          // see explanation for previous ts-ignore
          // @ts-ignore
          if (this.snapshotChanged === true) {
            // fast path the remainder: just copy from array to sink
            push.apply(sink, slice.call(array, i + 1));
            break;
          }
        }
      }
      readScalar(propertyName, record, data, required) {
        if (!hasOwnProperty.call(record, propertyName)) {
          if (required !== false) {
            this.markMissing();
            return;
          }
          this.checkIfChanged(undefined);
          return;
        }
        this.assignScalar(propertyName, data, record[propertyName]);
      }
      assignScalar(key, sink, value) {
        sink[key] = value;
        this.checkIfChanged(value);
      }
      storeLookup(key) {
        return storeLookup(key, this.timestamp, this.store, this.ttlStrategy);
      }
      selectUnion(selection, storeEntry, discriminatedObject, sink) {
        const {
          discriminator
        } = selection;
        const discriminatorValue = discriminatedObject[discriminator];
        {
          validateUnionSelection(discriminatedObject, selection, this.currentPath);
        }
        const unionSelection = selection.unionSelections[discriminatorValue];
        const childSelection = {
          selections: unionSelection.selections,
          private: unionSelection.private,
          name: selection.name,
          kind: selection.kind
        };
        this.traverseSelection(childSelection, storeEntry, sink);
      }
      selectObjectUnion(selection, source, sink) {
        const {
          name: propertyName
        } = selection;
        const object = source[propertyName];
        if (object === undefined) {
          this.markMissing();
          return;
        }
        if (selection.nullable === true && object === null) {
          this.readScalar(propertyName, source, sink);
          return;
        }
        this.selectUnion(selection, source, object, sink);
      }
      traverseSelection(selection, record, data) {
        const {
          variables
        } = this;
        const key = getStorageKey(selection, variables);
        if (isUnionObjectSelection(selection)) {
          this.selectObjectUnion(selection, record, data);
          return;
        }
        if (selection.kind === 'Link') {
          if (selection.plural === true) {
            this.readPluralLink(key, selection, record, data);
          } else if (selection.map === true) {
            this.readLinkMap(key, selection, record, data);
          } else {
            this.readSingleLink(key, selection, record, data);
          }
        } else if (selection.kind === 'Scalar') {
          if (selection.map === true) {
            this.readScalarMap(key, record, data, selection.required !== false);
          } else if (selection.plural === true) {
            this.readScalarPlural(key, record, data, selection.required !== false);
          } else {
            this.readScalar(key, record, data, selection.required);
          }
        } else if (selection.kind === 'Object') {
          if (selection.map === true) {
            this.readObjectMap(key, selection, record, data);
          } else if (selection.plural === true) {
            this.readPluralObject(key, selection, record, data);
          } else {
            this.readObject(key, selection, record, data);
          }
        }
      }
      traverseSelections(node, record, data) {
        const {
          selections
        } = node;
        if (selections === undefined) {
          this.selectAll(record, data);
          return;
        }
        const {
          length: len
        } = selections;
        for (let i = 0; i < len; i += 1) {
          const selection = selections[i];
          this.enterPath(selection.name);
          this.traverseSelection(selection, record, data);
          this.exitPath();
        }
      }
      isRebuilding() {
        return this.baseSnapshot !== undefined;
      }
      getIsDataMissing() {
        return this.isMissingData;
      }
      getTimeStamp() {
        return this.timestamp;
      }
      markSeenId(key) {
        this.seenIds.add(key);
      }
      getFullPathString(fullPath) {
        return typeof fullPath === 'number' ? fullPath.toString() : fullPath;
      }
    }

    /**
     * Maps a CachePolicy to a CachePolicyImplementation.  We don't necessarily trust
     * "cachePolicy" because that could come from userland code.  But we do trust
     * "defaultCachePolicy" because that comes from our own library code and should
     * be a valid type, so this function will fall back to "defaultCachePolicy" if
     * "cachePolicy" is invalid.
     *
     * @param cachePolicy cache policy
     * @param defaultCachePolicy default cache policy
     * @returns cache policy implementation corresponding to cachePolicy
     */
    function resolveCachePolicy(cachePolicy, defaultCachePolicy) {
      if (cachePolicy === undefined) {
        return resolveCachePolicy(defaultCachePolicy, defaultCachePolicy);
      }
      const {
        type
      } = cachePolicy;
      switch (type) {
        case 'cache-and-network':
          return buildCacheAndNetworkImplementation(cachePolicy.staleDurationSeconds);
        case 'cache-then-network':
          return cacheThenNetworkImplementation;
        case 'no-cache':
          return noCacheImplementation;
        case 'only-if-cached':
          return onlyIfCachedImplementation;
        case 'stale-while-revalidate':
          return buildStaleWhileRevalidateImplementation(cachePolicy.staleDurationSeconds);
        case 'valid-at':
          {
            const basePolicy = resolveCachePolicy(cachePolicy.basePolicy, defaultCachePolicy);
            return buildValidAtImplementation(basePolicy, cachePolicy.timestamp);
          }
        default:
          {
            // use TS "never" here to ensure our switch cases include all enumerations
            const exhaustiveCheck = type;
            {
              throw new Error(`unrecognized cache policy: ${exhaustiveCheck}`);
            }
          }
      }
    }
    function isFetchResponse(error) {
      return error !== null && typeof error === 'object' && 'status' in error;
    }
    /**
     * This function takes the unknown rejected response from a network adapter
     * and normalizes it to an Error object with the proper errorType
     */
    function normalizeNetworkAdapterError(error) {
      // if it's an Error (it should be) then add the errorType
      // NOTE: this preserves stack trace
      if (typeof error === 'object' && error instanceof Error) {
        error.errorType = 'networkAdapterError';
        return error;
      }
      // anything else should get turned into an Error with the errorType set
      const normalizedError = new Error(`NetworkAdapter rejected with non-Error object: ${typeof error === 'undefined' ? 'undefined' : stringify(error)}`);
      normalizedError.errorType = 'networkAdapterError';
      return normalizedError;
    }
    class Environment {
      constructor(store, networkAdapter) {
        this.networkCount = 0;
        this.storeQueryEvaluator = undefined;
        this.defaultCachePolicy = {
          type: 'cache-then-network'
        };
        this.store = store;
        this.networkAdapter = networkAdapter;
        this.adapterContextMap = create(null);
        this.typeQueryEvaluatorMap = create(null);
        // bind these methods so when they get passed into the
        // Store, the this reference is preserved
        this.createSnapshot = this.createSnapshot.bind(this);
        this.rebuildSnapshot = this.rebuildSnapshot.bind(this);
      }
      setDefaultCachePolicy(cachePolicy) {
        this.defaultCachePolicy = cachePolicy;
      }
      /**
       * Returns a resolved promise of a FetchResponse for ok http status codes.
       * Returns a rejected promise of an ErrorResponse of type "fetchResponse" for non-ok http status codes.
       * Returns a rejected promise of an ErrorResponse of type "networkError" if server can't be reached
       *
       * @throws {ErrorResponse}
       */
      dispatchResourceRequest(request, context, eventObservers) {
        const start = Date.now();
        const uuid = `${start}${this.networkCount++}`;
        emitAdapterEvent({
          type: 'network-request-start',
          timestamp: start,
          request,
          uuid
        }, eventObservers);
        return new Promise((resolve, reject) => {
          this.networkAdapter(request, context).then(response => {
            const end = Date.now();
            emitAdapterEvent({
              type: 'network-request-end',
              timestamp: end,
              duration: end - start,
              response,
              uuid
            }, eventObservers);
            if (!response.ok) {
              return reject({
                ...response,
                errorType: 'fetchResponse'
              });
            }
            return resolve(response);
          }, error => {
            const end = Date.now();
            emitAdapterEvent({
              type: 'network-request-error',
              uuid,
              timestamp: end,
              duration: end - start,
              error: error
            }, eventObservers);
            // return reject(normalizeNetworkAdapterError(error));
            // TODO [W-11204139]: uncomment above line and remove below line
            // once all network adapter impls has been updated to follow
            // the new network adapter behavior
            return reject(
            // legacy network adapter check
            isFetchResponse(error) ? {
              ...error,
              errorType: 'fetchResponse'
            } : normalizeNetworkAdapterError(error));
          });
        });
      }
      isErrorCacheable(errorSnapshot) {
        const {
          error
        } = errorSnapshot;
        if (error.errorType === 'fetchResponse') {
          return error.status === exports.HttpStatusCode.NotFound;
        }
        return false;
      }
      /**
       * Returns a Promise that resolves once the given PendingSnapshot is available.
       */
      resolvePendingSnapshot(snapshot) {
        return new Promise(resolve => {
          let unsubscribe;
          unsubscribe = this.storeSubscribe(snapshot, resolvedSnapshot => {
            if (unsubscribe !== undefined) {
              unsubscribe();
            }
            resolve(resolvedSnapshot);
          });
        });
      }
      storeIngest(key, ingest, response, luvio, storeOverride) {
        if (ingest !== null) {
          ingest(response, {
            fullPath: key,
            parent: null,
            propertyName: null
          }, luvio, storeOverride === undefined ? this.store : storeOverride, Date.now());
        }
      }
      storeIngestError(key, errorSnapshot, storeMetadataParams, storeOverride) {
        const {
          error
        } = errorSnapshot;
        if (this.isErrorCacheable(errorSnapshot)) {
          const store = storeOverride === undefined ? this.store : storeOverride;
          const entry = {
            __type: StoreRecordType.Error,
            status: StoreErrorStatus.RESOURCE_NOT_FOUND,
            error
          };
          freeze(entry);
          store.publish(key, entry);
          if (storeMetadataParams !== undefined) {
            const {
              ttl,
              namespace,
              representationName,
              version
            } = storeMetadataParams;
            const now = Date.now();
            const storeMetadata = {
              ingestionTimestamp: now,
              expirationTimestamp: now + ttl,
              representationName,
              namespace,
              version
            };
            store.publishMetadata(key, storeMetadata);
          }
          return;
        }
        // this error is not cached, notify any pending subscribers here
        // since broadcast only deals with cached recordIds
        this.store.broadcastNonCachedSnapshot(key, errorSnapshot);
      }
      // Adds the given data to the store at the given key and marks the key as visited.  Will cause subscribers to rebuild.
      storePublish(key, data) {
        this.store.publish(key, data);
      }
      // Adds the given data to the store at the given key (does NOT mark the key as visited).  Will NOT cause subscribers to rebuild.  NOTE: This should really only be used by internal Luvio APIs.
      storePut(key, data) {
        this.store.put(key, data);
      }
      storeRedirect(existingKey, redirectKey) {
        this.store.redirect(existingKey, redirectKey);
      }
      storeGetCanonicalKey(key) {
        return this.store.getCanonicalRecordId(key);
      }
      storeBroadcast(rebuildSnapshot, snapshotAvailable) {
        return this.store.broadcast(rebuildSnapshot, snapshotAvailable);
      }
      storeSubscribe(snapshot, callback) {
        return this.store.subscribe(snapshot, callback);
      }
      storeWatch(prefix, callback) {
        return this.store.watch(prefix, callback);
      }
      storeLookup(sel, createSnapshot, refresh, ttlStrategy) {
        return this.store.lookup(sel, createSnapshot, refresh, ttlStrategy);
      }
      storeCleanup() {
        this.store.cleanup();
      }
      storeEvict(key) {
        this.store.evict(key);
      }
      storeDealloc(key) {
        this.store.dealloc(key);
      }
      storeReset() {
        this.store.reset();
      }
      storeRetain(keys) {
        return this.store.retain(keys);
      }
      storeKeyExists(key) {
        return this.store.keyExistsInStore(key);
      }
      snapshotAvailable(snapshot) {
        return isFulfilledSnapshot(snapshot) || isErrorSnapshot(snapshot) || isStaleSnapshot(snapshot);
      }
      createSnapshot(selector, refresh, ttlStrategy) {
        const reader = new Reader(this.store, selector.variables, refresh, undefined, ttlStrategy);
        return reader.read(selector);
      }
      rebuildSnapshot(snapshot, onRebuild) {
        const reader = new Reader(this.store, snapshot.variables, snapshot.refresh, snapshot);
        onRebuild(reader.read(snapshot.select));
      }
      getNode(key, storeOverride) {
        const store = storeOverride === undefined ? this.store : storeOverride;
        const value = store.readEntry(key);
        // doesn't exist
        if (value === undefined) {
          return null;
        }
        return this.wrapNormalizedGraphNode(value, key, store);
      }
      wrapNormalizedGraphNode(normalized, key, storeOverride) {
        if (normalized === null) {
          return null;
        }
        const store = storeOverride === undefined ? this.store : storeOverride;
        if (isStoreRecordError(normalized)) {
          return new GraphNodeError(store, normalized);
        }
        return new GraphNode(store, normalized, key);
      }
      withContext(adapter, options) {
        const {
          contextId,
          onContextLoaded
        } = options;
        // simple in-memory object stores metadata
        // retrieve from adapterContextMap if contextId is supplied
        // we will only track context of adapters that explicitly provide a contextId
        if (this.adapterContextMap[contextId] === undefined) {
          this.adapterContextMap[contextId] = create(null);
        }
        const contextStore = this.adapterContextMap[contextId];
        const context = {
          set(key, value) {
            contextStore[key] = value;
          },
          get(key) {
            return contextStore[key];
          }
        };
        // if no onContextLoaded hook then return a function that
        // simply returns the adapter
        if (onContextLoaded === undefined) {
          return (config, requestContext) => {
            return adapter(config, context, requestContext);
          };
        }
        // if we got here then we need to return a function that awaits the
        // onContextLoaded hook only on the first invocation.
        let firstRun = true;
        const hookAsPromise = onContextLoaded(context);
        return (config, requestContext) => {
          if (firstRun) {
            return hookAsPromise.then(() => {
              firstRun = false;
              return adapter(config, context, requestContext); // TODO - remove as any cast after https://github.com/salesforce-experience-platform-emu/luvio/pull/230
            });
          }
          return adapter(config, context, requestContext);
        };
      }
      publishStoreMetadata(key, storeMetadata) {
        this.store.publishMetadata(key, storeMetadata);
      }
      putStoreMetadata(key, storeMetadata, adjustTTLOverride) {
        this.store.putMetadata(key, storeMetadata, adjustTTLOverride);
      }
      storeSetTTLOverride(namespace, representationName, ttl) {
        this.store.setTTLOverride(namespace, representationName, ttl);
        this.recomputeTTLOverrideExpirations(namespace, representationName);
        return Promise.resolve();
      }
      storeGetTTLOverride(namespace, representationName) {
        return Promise.resolve(this.store.getTTLOverride(namespace, representationName));
      }
      storeGetTTLOverrides() {
        return this.store.getTTLOverrides();
      }
      recomputeTTLOverrideExpirations(ttlNamespace, ttlRepresentationName) {
        const metadataResults = this.store.readMetadataWhere({
          namespace: ttlNamespace,
          representationName: ttlRepresentationName
        });
        for (let i = 0, length = metadataResults.length; i < length; i++) {
          const result = metadataResults[i];
          this.publishStoreMetadata(result.key, result.metadata);
        }
      }
      storeSetDefaultTTLOverride(ttl) {
        this.store.setDefaultTTLOverride(ttl);
        this.recomputeDefaultTTLOverrideExpirations();
        return Promise.resolve();
      }
      storeGetDefaultTTLOverride() {
        return this.store.getDefaultTTLOverride();
      }
      recomputeDefaultTTLOverrideExpirations() {
        const metadataResults = this.store.readMetadataWhere({
          ttlOverride: undefined
        });
        for (let i = 0, length = metadataResults.length; i < length; i++) {
          const result = metadataResults[i];
          this.publishStoreMetadata(result.key, result.metadata);
        }
      }
      storeBuildIngestionStagingStore() {
        return this.store.buildIngestionStagingStore();
      }
      applyCachePolicy(luvio, adapterRequestContext, buildSnapshotContext, buildCachedSnapshot, buildNetworkSnapshot) {
        const {
          defaultCachePolicy
        } = this;
        const {
          cachePolicy,
          eventObservers
        } = adapterRequestContext;
        let cachePolicyImpl = resolveCachePolicy(cachePolicy, defaultCachePolicy);
        const resolvePendingSnapshot = snapshot => this.resolvePendingSnapshot(snapshot);
        const storeLookup = (sel, refresh, ttlStrategy) => this.storeLookup(sel, this.createSnapshot, refresh, ttlStrategy);
        let wrappedBuildCacheSnapshot = buildCachedSnapshot;
        let wrappedBuildNetworkSnapshot = buildNetworkSnapshot;
        // if eventObservers are provided for the adapter, wrap calls in versions that emit events
        if (eventObservers !== undefined) {
          const cachePolicyType = cachePolicy === undefined ? defaultCachePolicy.type : cachePolicy.type;
          cachePolicyImpl = cachePolicyImplWithEvents(cachePolicyImpl, cachePolicyType, eventObservers);
          wrappedBuildCacheSnapshot = buildCachedSnapshotWithEvents(buildCachedSnapshot, eventObservers);
          wrappedBuildNetworkSnapshot = buildNetworkSnapshotWithEvents(buildNetworkSnapshot, eventObservers);
        }
        return cachePolicyImpl({
          buildCachedSnapshot: wrappedBuildCacheSnapshot,
          buildNetworkSnapshot: wrappedBuildNetworkSnapshot,
          buildSnapshotContext,
          resolvePendingSnapshot,
          storeLookup,
          coercedAdapterRequestContext: coerceAdapterRequestContext(adapterRequestContext),
          luvio
        });
      }
      handleSuccessResponse(ingestAndBroadcastFunc, _getResponseCacheKeysFunc) {
        return ingestAndBroadcastFunc();
      }
      handleErrorResponse(ingestAndBroadcastFunc) {
        return ingestAndBroadcastFunc();
      }
      /**
       * Gets store entries for notifyChange purposes.  Returns a Promise to
       * support environments that need to do async cache lookups.
       *
       * If not in the store then the cache key is not added to the returned set.
       */
      getNotifyChangeStoreEntries(keys) {
        const entries = [];
        for (let i = 0, len = keys.length; i < len; i++) {
          const key = keys[i];
          const node = this.getNode(key);
          if (isGraphNode(node)) {
            entries.push({
              key,
              record: node.retrieve()
            });
          }
        }
        return Promise.resolve(entries);
      }
      notifyStoreUpdateAvailable(keys) {
        return this.store.updateAvailable(keys);
      }
      registerStoreQueryEvaluator(queryEvaluator) {
        this.storeQueryEvaluator = queryEvaluator;
      }
      getStoreQueryEvaluator() {
        return this.storeQueryEvaluator;
      }
      registerTypeQueryEvaluator(namespace, representationName, queryEvaluator) {
        if (!this.typeQueryEvaluatorMap[namespace]) {
          this.typeQueryEvaluatorMap[namespace] = Object.create(null);
        }
        this.typeQueryEvaluatorMap[namespace][representationName] = queryEvaluator;
      }
      getTypeQueryEvaluator(namespace, representationName) {
        const evaluatorsByNamespace = this.typeQueryEvaluatorMap[namespace];
        if (evaluatorsByNamespace && evaluatorsByNamespace[representationName]) {
          return evaluatorsByNamespace[representationName];
        }
        return undefined;
      }
      buildStructuredKey(namespace, representationName, idValues) {
        return this.store.buildStructuredKey(namespace, representationName, idValues);
      }
      /**
       * Take a list of keys and marks them as stale to be refreshed.
       * Then will be refreshed with the provided refresh function.
       * If no refresh and makeConfig functions are provided it will refresh
       * time that record is trying to be fetched
       *
       * Example: one record from graphql needs to be refreshed and not
       * the entire graphql query
       *
       * @param keys
       * @param makeConfig
       * @param refresh
       * @returns
       */
      expirePossibleStaleRecords(keys, config, refresh) {
        this.store.expirePossibleStaleRecords(keys);
        if (refresh !== undefined && config !== undefined) {
          return this.refreshPossibleStaleRecords(config, refresh);
        }
        return Promise.resolve();
      }
      refreshPossibleStaleRecords(config, refresh) {
        return Promise.resolve(refresh(config, {
          cachePolicy: {
            type: 'no-cache'
          }
        })).then(() => {});
      }
    }
    class Luvio {
      constructor(environment, options = {}) {
        this.environment = environment;
        this.options = options;
      }
      storePublish(key, data) {
        this.environment.storePublish(key, data);
      }
      storeRedirect(existingKey, canonicalKey) {
        this.environment.storeRedirect(existingKey, canonicalKey);
      }
      storeRetain(keys) {
        return this.environment.storeRetain(keys);
      }
      storeGetCanonicalKey(key) {
        return this.environment.storeGetCanonicalKey(key);
      }
      /**
       * Broadcast any cache entry changes to subscribers.
       *
       * NOTE: this MUST be called *AFTER* storeLookup in the ingestion flow as
       * some environments (namely, makeDurable) modify the store in this method.
       */
      storeBroadcast() {
        return this.environment.storeBroadcast(this.environment.rebuildSnapshot, this.environment.snapshotAvailable);
      }
      storeIngest(key, ingest, response) {
        this.environment.storeIngest(key, ingest, response, this);
      }
      storeIngestError(key, errorSnapshot, storeMetadataParams) {
        return this.environment.storeIngestError(key, errorSnapshot, storeMetadataParams);
      }
      /**
       * Subscribe to the Luvio store to observe any changes to the data in the given
       * snapshot.
       *
       * NOTE: Errors are terminal - the callback will never be called after an ErrorSnapshot
       * is emitted (or if the given Snapshot is an ErrorSnapshot).
       *
       * @template D
       * @template V
       * @param {Snapshot<D, V>} snapshot The snapshot that contains data to observe.
       * @param {SnapshotSubscriptionCallback<D, V>} callback The callback to be called
       * whenever the given snapshot's data changes.  NOTE: the snapshot passed to the
       * callback will have consistent, normalized data - however it is not guaranteed
       * to be within the TTL of that data type.
       * @returns {Unsubscribe} A function that will unsubscribe when invoked.
       * @memberof Luvio
       */
      storeSubscribe(snapshot, callback) {
        return this.environment.storeSubscribe(snapshot, callback);
      }
      storeWatch(prefix, callback) {
        return this.environment.storeWatch(prefix, callback);
      }
      storeLookup(sel, refresh) {
        return this.environment.storeLookup(sel, this.environment.createSnapshot, refresh);
      }
      storeEvict(key) {
        this.environment.storeEvict(key);
      }
      storeCleanup() {
        this.environment.storeCleanup();
      }
      storeExpirePossibleStaleRecords(keys, config, refresh) {
        return this.environment.expirePossibleStaleRecords(keys, config, refresh);
      }
      createSnapshot(selector, refresh) {
        return this.environment.createSnapshot(selector, refresh);
      }
      errorSnapshot(error, refresh) {
        return createErrorSnapshot(error, refresh);
      }
      dispatchResourceRequest(resourceRequest, context) {
        let mergedResourceRequest = resourceRequest;
        let resourceRequestContext = {};
        let eventObservers = [];
        if (context !== undefined) {
          if (context.resourceRequestContext !== undefined) {
            resourceRequestContext = context.resourceRequestContext;
          }
          if (context.eventObservers !== undefined) {
            eventObservers = context.eventObservers;
          }
          const {
            overrides
          } = context;
          // Apply resource request override if passed as argument.
          if (overrides !== undefined) {
            const {
              headers,
              priority
            } = overrides;
            if (headers !== undefined) {
              mergedResourceRequest = {
                ...resourceRequest,
                headers: {
                  ...resourceRequest.headers,
                  ...headers
                }
              };
            }
            if (priority !== undefined) {
              mergedResourceRequest.priority = priority;
            }
          }
        }
        // ResourceRequest params are derived from Adapter config properties, which
        // can be optional.  This could leave some queryParams or urlParams with undefined
        // values.  We don't want to put the responsibility of filtering out those
        // undefined values on the injected networkAdapter.  So we do it here, on
        // the API that those adapters call to dispatch their ResourceRequests.
        const {
          queryParams,
          urlParams
        } = mergedResourceRequest;
        for (const paramKey of keys(queryParams)) {
          const value = queryParams[paramKey];
          if (value === undefined) {
            delete queryParams[paramKey];
          }
        }
        for (const paramKey of keys(urlParams)) {
          const value = urlParams[paramKey];
          if (value === undefined) {
            delete urlParams[paramKey];
          }
        }
        return this.environment.dispatchResourceRequest(mergedResourceRequest, resourceRequestContext, eventObservers);
      }
      refreshSnapshot(snapshot) {
        const {
          refresh
        } = snapshot;
        if (refresh !== undefined) {
          const {
            config,
            resolve
          } = refresh;
          return resolve(config);
        }
        throw new Error('Snapshot is not refreshable');
      }
      /**
       * This method is meant for custom scenarios and should not be used for
       * general store lookups.  Use applyCachePolicy instead.
       *
       * NOTE: this method works against synchronous stores only.
       */
      getNode(key) {
        return this.environment.getNode(key);
      }
      wrapNormalizedGraphNode(normalized, key) {
        return this.environment.wrapNormalizedGraphNode(normalized, key);
      }
      instrument(paramsBuilder) {
        const {
          instrument
        } = this.options;
        if (instrument) {
          instrument(paramsBuilder());
        }
      }
      /**
       * Returns true if the given snapshot can be returned to userland without
       * requiring any additional resolution.
       */
      snapshotAvailable(snapshot) {
        return this.environment.snapshotAvailable(snapshot);
      }
      withContext(adapter, options) {
        return this.environment.withContext(adapter, options);
      }
      /**
       * Returns a Promise that resolves once the given PendingSnapshot is available.  This
       * is syntactic sugar for calling storeSubscribe and unsubscribing after the
       * first emit.  Useful for one-shot data reads.  Use storeSubscribe instead of
       * this to get continual updates when data changes.
       *
       * @template D
       * @template V
       * @param {PendingSnapshot<D, V>} snapshot
       * @returns {Promise<Snapshot<D, V>>}
       */
      resolvePendingSnapshot(snapshot) {
        return this.environment.resolvePendingSnapshot(snapshot);
      }
      publishStoreMetadata(key, storeMetadataParams) {
        const {
          ttl,
          namespace,
          representationName,
          version
        } = storeMetadataParams;
        let {
          ingestionTimestamp
        } = storeMetadataParams;
        if (ingestionTimestamp === undefined) {
          ingestionTimestamp = Date.now();
        }
        const storeMetadata = {
          ingestionTimestamp: ingestionTimestamp,
          expirationTimestamp: ingestionTimestamp + ttl,
          representationName,
          namespace,
          version
        };
        return this.environment.publishStoreMetadata(key, storeMetadata);
      }
      /**
       * Sets the TTL value for a specific namespace-representation Type.  The given
       * TTL takes precedence over TTL values defined in RAML and also over the
       * default TTL value (if set using storeSetDefaultTTLOverride).
       *
       * @param {number} ttl Time-to-live in milliseconds
       * @returns {Promise<void>}
       */
      storeSetTTLOverride(namespace, representationName, ttl) {
        return this.environment.storeSetTTLOverride(namespace, representationName, ttl);
      }
      storeGetTTLOverride(namespace, representationName) {
        return this.environment.storeGetTTLOverride(namespace, representationName);
      }
      /**
       * Sets the default TTL value.  The given TTL takes precedence over TTL values
       * defined in RAML, but defers to namespace-representation-specific override
       * values.
       *
       * @param {number} ttl Time-to-live in milliseconds
       * @returns {Promise<void>}
       */
      storeSetDefaultTTLOverride(ttl) {
        return this.environment.storeSetDefaultTTLOverride(ttl);
      }
      applyCachePolicy(adapterRequestContext, buildSnapshotContext, buildCachedSnapshot, buildNetworkSnapshot) {
        return this.environment.applyCachePolicy(this, adapterRequestContext, buildSnapshotContext, buildCachedSnapshot, buildNetworkSnapshot);
      }
      /**
       * A method to be called any time an adapter gets a successful response
       * from the network adapter
       *
       * @param ingestAndBroadcastFunc A function that ingests a response and broadcasts
       * @param getResponseCacheKeysFunc A function that returns the set of cache keys present in a response body
       * @returns A snapshot or the Promise of a snapshot that comes from resource ingestion.  Can return undefined
       * or Promise<undefined> for adapters that do not return a response (ie: DELETE adapters).
       */
      handleSuccessResponse(ingestAndBroadcastFunc, getResponseCacheKeysFunc) {
        const memoizedGetResponseCacheKeysFunc = () => {
          let cachedResult = undefined;
          return function () {
            if (cachedResult === undefined) {
              cachedResult = getResponseCacheKeysFunc();
            }
            return cachedResult;
          };
        };
        return this.environment.handleSuccessResponse(ingestAndBroadcastFunc, memoizedGetResponseCacheKeysFunc());
      }
      /**
       * A method to be called any time an adapter gets an error response
       * from the network adapter
       *
       * @param ingestAndBroadcastFunc A function that ingests a response and broadcasts
       * @returns An ErrorSnapshot or the Promise of an ErrorSnapshot that comes from resource ingestion
       */
      handleErrorResponse(ingestAndBroadcastFunc) {
        return this.environment.handleErrorResponse(ingestAndBroadcastFunc);
      }
      /**
       * This method is meant to be used by adapter's notifyChange function.  It
       * accepts a set of cache keys and returns normalized store entries for each
       * cache key that is present in the store. Results are returned in a Promise
       * to support Environments that use asynchronous stores.
       *
       * If a cache key is not present in the store then that key will not be included
       * in the returned set.
       *
       * NOTE: this method is meant to be used by notifyChange and SHOULD NOT be used
       * as a general purpose way to get data out of the cache.  Use luvio.applyCachePolicy
       * for general-purpose cache lookups.
       *
       * @param keys A list of cache keys to check
       * @returns A Promise of a set of store entries that are present in the cache
       */
      getNotifyChangeStoreEntries(keys) {
        return this.environment.getNotifyChangeStoreEntries(keys);
      }
      notifyStoreUpdateAvailable(keys) {
        return this.environment.notifyStoreUpdateAvailable(keys);
      }
      registerStoreQueryEvaluator(queryEvaluator) {
        return this.environment.registerStoreQueryEvaluator(queryEvaluator);
      }
      getStoreQueryEvaluator() {
        return this.environment.getStoreQueryEvaluator();
      }
      registerTypeQueryEvaluator(namespace, representationName, queryEvaluator) {
        return this.environment.registerTypeQueryEvaluator(namespace, representationName, queryEvaluator);
      }
      getTypeQueryEvaluator(namespace, representationName) {
        return this.environment.getTypeQueryEvaluator(namespace, representationName);
      }
      buildStructuredKey(namespace, representationName, idValues) {
        return this.environment.buildStructuredKey(namespace, representationName, idValues);
      }
    }
    const Wildcard = Symbol('Wildcard');
    class InMemoryStoreQueryEvaluator {
      constructor(store) {
        this.store = store;
        this.storeToIndexMap = new WeakMap();
        this.storeToIndexMap.set(store, {
          nodeType: 'indexBySchema',
          value: {}
        });
      }
      queryByKey(keyQuery, keySchema) {
        const keyIndex = this.getKeyIndex(this.store, keySchema);
        if (keyIndex === undefined) {
          return Promise.resolve([]);
        }
        // Breadth-first search with known/constant depth on all branches
        let visited = [keyIndex];
        for (let i = 0; i < keySchema.length; i++) {
          const newVisited = [];
          const keyValue = keyQuery[keySchema[i]];
          // If the query value is wildcard, all values are acceptable
          const wildcard = keyValue === Wildcard;
          for (let j = 0, visitedLength = visited.length; j < visitedLength; j++) {
            const node = visited[j];
            if (node.nodeType === 'key') {
              // Shouldn't happen
              throw new Error('');
            }
            let children = [];
            if (wildcard) {
              // Push all children into queue
              children = values(node.value);
            } else {
              // Only push matching child if it exists
              if (hasOwnProperty.call(node.value, String(keyValue))) {
                children = [node.value[String(keyValue)]];
              }
            }
            newVisited.push(...children);
          }
          visited = newVisited;
        }
        // Once the whole tree has been traversed, visited should only contain leaf nodes, which always have a KeyMetadata value
        const foundKeyNodes = visited.map(element => {
          if (element.nodeType !== 'key') {
            throw new Error(`Found non-key in result: ${stringify(element, undefined, 2)}`);
          }
          return element;
        }) ;
        return Promise.resolve(foundKeyNodes.map(keyNode => keyNode.value));
      }
      queryWhere(keyQuery, keySchema, valueQuery, valueResolver) {
        const defaultResolver = (store, data) => {
          return this.resolveData(store, data);
        };
        const resolver = valueResolver !== null && valueResolver !== void 0 ? valueResolver : defaultResolver;
        return this.queryByKey(keyQuery, keySchema).then(keys => {
          return keys.filter(key => {
            const value = this.store.readEntry(JSON.stringify(key));
            return evaluateValueQuery(this.store, valueQuery, resolver(this.store, value), resolver);
          });
        });
      }
      resolveData(store, value) {
        if (typeof value === 'object' && value !== null && '__link' in value && typeof value['__link'] === 'string') {
          return store.readEntry(value.__link);
        }
        return value;
      }
      registerKey(store, key, keySchema) {
        const keyIndex = this.getOrRegisterKeyIndex(store, keySchema);
        if (keyIndex === undefined) {
          return;
        }
        const keySchemaLength = keySchema.length;
        let currentIndex = keyIndex;
        // Walk the index tree to find the node right above the leaf
        for (let i = 0; i < keySchemaLength - 1; i++) {
          const keyProperty = keySchema[i];
          const keyValue = key[keyProperty];
          currentIndex = this.getOrRegisterSubKeyIndex(currentIndex, keyValue);
        }
        // Set the leaf node for the key
        currentIndex.value[String(key[keySchema[keySchemaLength - 1]])] = {
          nodeType: 'key',
          value: key
        };
      }
      getIndexBySchema(store) {
        return this.storeToIndexMap.get(store);
      }
      getOrRegisterKeyIndex(store, keySchema) {
        const keyIndexBySchema = this.getIndexBySchema(store);
        if (keyIndexBySchema === undefined) {
          return undefined;
        }
        const keySchemaIdentifier = this.getKeySchemaIdentifier(keySchema);
        let maybeKeyIndex = keyIndexBySchema.value[keySchemaIdentifier];
        if (maybeKeyIndex === undefined) {
          maybeKeyIndex = {
            nodeType: 'index',
            value: {}
          };
          keyIndexBySchema.value[keySchemaIdentifier] = maybeKeyIndex;
        }
        return maybeKeyIndex;
      }
      getKeyIndex(store, keySchema) {
        let maybeKeyIndexBySchema = this.storeToIndexMap.get(store);
        if (maybeKeyIndexBySchema === undefined) {
          return undefined;
        }
        const keySchemaIdentifier = this.getKeySchemaIdentifier(keySchema);
        return maybeKeyIndexBySchema.value[keySchemaIdentifier];
      }
      getOrRegisterSubKeyIndex(index, keyValue) {
        let nextSubIndex = index.value[String(keyValue)];
        if (nextSubIndex === undefined) {
          nextSubIndex = {
            nodeType: 'index',
            value: {}
          };
          index.value[String(keyValue)] = nextSubIndex;
        } else if (nextSubIndex.nodeType !== 'index') {
          // This condition shouldn't be possible
          throw new Error('Failed to find subindex value');
        }
        return nextSubIndex;
      }
      getKeySchemaIdentifier(keySchema) {
        return keySchema.join(':');
      }
    }
    function evaluateValueQuery(store, query, value, resolver) {
      return Object.entries(query).map(([valueQueryKey, propertyQuery]) => {
        if (valueQueryKey.startsWith('$')) {
          return evaluateValueQueryOperator(store, valueQueryKey, query, value, resolver);
        } else {
          if (typeof value === 'object') {
            if (isArray(value)) {
              {
                throw new Error('Array querying is not supported yet');
              }
            }
            return evaluateValueQuery(store, propertyQuery, resolver(store, value[valueQueryKey]), resolver);
          }
        }
      }).every(result => result === true);
    }
    const queryOperatorToEvaluatorMap = {
      $eq: evaluateEqualsOperator,
      $ne: evaluateNotEqualOperator,
      $gt: evaluateGreaterThanOperator,
      $gte: evaluateGreaterThanOrEqualOperator,
      $lt: evaluateLessThanOperator,
      $lte: evaluateLessThanOrEqualOperator,
      $and: evaluateAndOperator,
      $not: evaluateNotOperator,
      $nor: evaluateNorOperator,
      $or: evaluateOrOperator,
      $in: evaluateInOperator,
      $nin: evaluateNotInOperator,
      $exists: evaluateExistsOperator,
      $regex: evaluateRegexOperator
    };
    function evaluateValueQueryOperator(store, operator, operatorQuery, value, resolver) {
      const evaluator = queryOperatorToEvaluatorMap[operator];
      if (evaluator === undefined) {
        {
          throw new Error(`Unsupported operator: ${operator}`);
        }
      }
      return evaluator(store, operatorQuery, value, resolver);
    }
    function evaluateEqualsOperator(_store, query, value, _resolver) {
      // TODO: This won't handle deep comparisons
      if (typeof value === 'object' && value !== null) {
        {
          throw new Error('Equals comparison against objects is not supported');
        }
      }
      return query.$eq === value;
    }
    function evaluateNotEqualOperator(store, query, value, resolver) {
      return !evaluateEqualsOperator(store, {
        $eq: query.$ne
      }, value);
    }
    function evaluateGreaterThanOperator(_store, query, value, _resolver) {
      const result = value > query.$gt;
      return result;
    }
    function evaluateGreaterThanOrEqualOperator(_store, query, value, _resolver) {
      const result = value >= query.$gte;
      return result;
    }
    function evaluateLessThanOperator(_store, query, value, _resolver) {
      const result = value < query.$lt;
      return result;
    }
    function evaluateLessThanOrEqualOperator(_store, query, value, _resolver) {
      const result = value <= query.$lte;
      return result;
    }
    function evaluateAndOperator(store, query, value, resolver) {
      for (let i = 0; i < query.$and.length; i++) {
        const subQuery = query.$and[i];
        const result = evaluateValueQuery(store, subQuery, value, resolver);
        if (result === false) {
          return false;
        }
      }
      return true;
    }
    function evaluateOrOperator(store, query, value, resolver) {
      for (let i = 0; i < query.$or.length; i++) {
        const subQuery = query.$or[i];
        const result = evaluateValueQuery(store, subQuery, value, resolver);
        if (result === true) {
          return true;
        }
      }
      return false;
    }
    function evaluateNorOperator(store, query, value, resolver) {
      const result = !evaluateOrOperator(store, {
        $or: query.$nor
      }, value, resolver);
      return result;
    }
    function evaluateNotOperator(store, query, value, resolver) {
      const result = !evaluateValueQuery(store, query.$not, value, resolver);
      return result;
    }
    function evaluateInOperator(store, query, value, resolver) {
      for (let i = 0; i < query.$in.length; i++) {
        const comparisonValue = query.$in[i];
        if (evaluateEqualsOperator(store, {
          $eq: comparisonValue
        }, value)) {
          return true;
        }
      }
      return false;
    }
    function evaluateNotInOperator(store, query, value, resolver) {
      const result = !evaluateInOperator(store, {
        $in: query.$nin
      }, value);
      return result;
    }
    function evaluateExistsOperator(_store, query, value, _resolver) {
      const valueExists = value !== undefined && value !== null;
      const result = query.$exists ? valueExists : !valueExists;
      return result;
    }
    function evaluateRegexOperator(_store, query, value, _resolver) {
      const result = query.$regex.test(value);
      return result;
    }
    var ResourceParamType;
    (function (ResourceParamType) {
      ResourceParamType[ResourceParamType["UrlParameter"] = 0] = "UrlParameter";
      ResourceParamType[ResourceParamType["QueryParameter"] = 1] = "QueryParameter";
      ResourceParamType[ResourceParamType["Body"] = 2] = "Body";
      ResourceParamType[ResourceParamType["Header"] = 3] = "Header";
    })(ResourceParamType || (ResourceParamType = {}));
    var TypeCheckShapes;
    (function (TypeCheckShapes) {
      TypeCheckShapes[TypeCheckShapes["String"] = 0] = "String";
      TypeCheckShapes[TypeCheckShapes["Boolean"] = 1] = "Boolean";
      TypeCheckShapes[TypeCheckShapes["Number"] = 2] = "Number";
      TypeCheckShapes[TypeCheckShapes["Integer"] = 3] = "Integer";
      TypeCheckShapes[TypeCheckShapes["Unsupported"] = 4] = "Unsupported";
    })(TypeCheckShapes || (TypeCheckShapes = {}));

    // Note: these should be in sync with the compiler ones:
    // https://github.com/salesforce-experience-platform-emu/luvio/blob/main/packages/%40luvio/compiler/src/intermediate/resource.ts#L76-L79
    const CONFIG_PROPERTY_URL_PARAMS = 'urlParams';
    const CONFIG_PROPERTY_QUERY_PARAMS = 'queryParams';
    const CONFIG_PROPERTY_BODY = 'body';
    const CONFIG_PROPERTY_HEADERS = 'headers';
    function isCorrectScalarType(value, type) {
      switch (type) {
        case TypeCheckShapes.String:
          return typeof value === 'string';
        case TypeCheckShapes.Boolean:
          return typeof value === 'boolean';
        case TypeCheckShapes.Number:
          return typeof value === 'number';
        case TypeCheckShapes.Integer:
          return typeof value === 'number' && Math.floor(value) === value;
        default:
          return false;
      }
    }
    function typeCheckArrayOfScalars(untrustedConfig, config, name, typeCheckShape) {
      const untrustedConfig_field = untrustedConfig[name];
      if (isArray(untrustedConfig_field)) {
        const untrustedConfig_field_array = [];
        for (let i = 0, arrayLength = untrustedConfig_field.length; i < arrayLength; i++) {
          const untrustedConfig_field_item = untrustedConfig_field[i];
          if (isCorrectScalarType(untrustedConfig_field_item, typeCheckShape)) {
            untrustedConfig_field_array.push(untrustedConfig_field_item);
          }
        }
        config[name] = untrustedConfig_field_array;
      }
    }
    function typeCheckConfig(untrustedConfig, config, configMetadata) {
      configMetadata.forEach(({
        name,
        typeCheckShape,
        isArrayShape
      }) => {
        switch (typeCheckShape) {
          case TypeCheckShapes.Unsupported:
            return;
          case TypeCheckShapes.String:
          case TypeCheckShapes.Boolean:
          case TypeCheckShapes.Number:
          case TypeCheckShapes.Integer:
            {
              if (isArrayShape) {
                typeCheckArrayOfScalars(untrustedConfig, config, name, typeCheckShape);
              } else {
                const untrustedConfig_field = untrustedConfig[name];
                if (isCorrectScalarType(untrustedConfig_field, typeCheckShape)) {
                  config[name] = untrustedConfig_field;
                }
              }
              return;
            }
          default:
            {
              return;
            }
        }
      });
    }
    function coerceConfig(uncoercedConfig, configMetadata) {
      const config = {};
      configMetadata.forEach(({
        name,
        coerceFn
      }) => {
        const value = coerceFn === undefined ? uncoercedConfig[name] : coerceFn(uncoercedConfig[name]);
        if (value !== undefined) {
          config[name] = value;
        }
      });
      return config;
    }
    function buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshotIdentifier, alternativeMethod, includeCacheSnapshot) {
      const {
        luvio,
        config
      } = context;
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext,
          luvioRequestMethod: alternativeMethod
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return includeCacheSnapshot ? buildNetworkSnapshotIdentifier(luvio, config, dispatchOptions, context.cacheSnapshot) : buildNetworkSnapshotIdentifier(luvio, config, dispatchOptions);
    }
    function ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize, namespace, version, representationName, equals) {
      const existingRecord = store.readEntry(key);
      let incomingRecord = normalize(input, existingRecord, {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
        ttl: ttlToUse
      }, luvio, store, timestamp);
      if (existingRecord === undefined || equals(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
      }
      if (ttlToUse !== undefined) {
        const storeMetadataParams = {
          ttl: ttlToUse,
          namespace,
          version,
          representationName,
          ingestionTimestamp: timestamp
        };
        luvio.publishStoreMetadata(key, storeMetadataParams);
      }
    }
    function createResourceParams(configMetadata) {
      return config => createResourceParamsImpl(config, configMetadata);
    }
    function createResourceParamsImpl(config, configMetadata) {
      const parametersReducer = (acc, {
        name
      }) => {
        acc[name] = config[name];
        return acc;
      };
      const urlParams = configMetadata.filter(p => p.resourceType === ResourceParamType.UrlParameter).reduce(parametersReducer, {});
      const queryParams = configMetadata.filter(p => p.resourceType === ResourceParamType.QueryParameter).reduce(parametersReducer, {});
      const headerParams = configMetadata.filter(p => p.resourceType === ResourceParamType.Header).reduce(parametersReducer, {});
      const bodyParams = configMetadata.filter(p => p.resourceType === ResourceParamType.Body);
      const actualBodyParams = bodyParams.reduce((acc, {
        name,
        required
      }) => {
        const configValue = config[name];
        if (required) {
          acc[name] = configValue;
        } else if (configValue !== undefined) {
          acc[name] = configValue;
        }
        return acc;
      }, {});
      const resourceParams = {};
      if (keys(urlParams).length > 0) {
        resourceParams[CONFIG_PROPERTY_URL_PARAMS] = urlParams;
      }
      if (keys(queryParams).length > 0) {
        resourceParams[CONFIG_PROPERTY_QUERY_PARAMS] = queryParams;
      }
      if (bodyParams.length > 0) {
        resourceParams[CONFIG_PROPERTY_BODY] = actualBodyParams;
      }
      if (keys(headerParams).length > 0) {
        resourceParams[CONFIG_PROPERTY_HEADERS] = headerParams;
      }
      return resourceParams;
    }
    // version: 1.309.0-dev21-4baf03ecaf
    const __lwc_hmr_context = { moduleHash : '111984866657c41c81ca4000779f8a87' };
    if (lwc.hot) {
        lwc.hot.register('force/luvioEngine/luvioEngine.js', '111984866657c41c81ca4000779f8a87', {"name":"luvioEngine","namespace":"force","enableLightningWebSecurityTransforms":false,"experimentalDynamicComponent":{"loader":"@salesforce/loader","strictSpecifier":false},"experimentalDynamicDirective":false,"enableDynamicComponents":true,"enableStaticContentOptimization":true,"outputConfig":{"sourcemap":false}});
    }

    exports.Environment = Environment;
    exports.GraphNode = GraphNode;
    exports.InMemoryStore = InMemoryStore;
    exports.InMemoryStoreQueryEvaluator = InMemoryStoreQueryEvaluator;
    exports.Luvio = Luvio;
    exports.Reader = Reader;
    exports.StoreKeyMap = StoreKeyMap;
    exports.StoreKeySet = StoreKeySet;
    exports.StringKeyInMemoryStore = StringKeyInMemoryStore;
    exports.Wildcard = Wildcard;
    exports.__lwc_hmr_context = __lwc_hmr_context;
    exports.adapterToNetworkPriority = adapterToNetworkPriority;
    exports.buildNetworkSnapshotCachePolicy = buildNetworkSnapshotCachePolicy;
    exports.coerceAdapterRequestContext = coerceAdapterRequestContext;
    exports.coerceConfig = coerceConfig;
    exports.createCustomAdapterEventEmitter = createCustomAdapterEventEmitter;
    exports.createResourceParams = createResourceParams;
    exports.deepFreeze = deepFreeze;
    exports.emitAdapterEvent = emitAdapterEvent;
    exports.ingestShape = ingestShape;
    exports.isFileReference = isFileReference;
    exports.isFormData = isFormData;
    exports.resolveLink = resolveLink;
    exports.serializeStructuredKey = serializeStructuredKey;
    exports.setBypassDeepFreeze = setBypassDeepFreeze;
    exports.typeCheckConfig = typeCheckConfig;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('force/ldsAdaptersUiapi', ['exports', 'lwc', 'force/ldsBindings', 'force/ldsEngineWebruntime', 'force/luvioEngine'], (function (exports, lwc, ldsBindings, ldsEngine, luvioEngine) {

    /**
     * Copyright (c) 2022, Salesforce, Inc.,
     * All rights reserved.
     * For full license text, see the LICENSE.txt file
     */

    var SnapshotState;
    (function (SnapshotState) {
      SnapshotState["Fulfilled"] = "Fulfilled";
      SnapshotState["Unfulfilled"] = "Unfulfilled";
      SnapshotState["Error"] = "Error";
      SnapshotState["Pending"] = "Pending";
      SnapshotState["Stale"] = "Stale";
    })(SnapshotState || (SnapshotState = {}));
    Promise.resolve();
    var StoreErrorStatus;
    (function (StoreErrorStatus) {
      StoreErrorStatus[StoreErrorStatus["RESOURCE_NOT_FOUND"] = 404] = "RESOURCE_NOT_FOUND";
    })(StoreErrorStatus || (StoreErrorStatus = {}));
    var StoreRecordType;
    (function (StoreRecordType) {
      StoreRecordType["Error"] = "error";
    })(StoreRecordType || (StoreRecordType = {}));
    var StoreLinkStateValues$1;
    (function (StoreLinkStateValues) {
      StoreLinkStateValues[StoreLinkStateValues["NotPresent"] = 0] = "NotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefNotPresent"] = 1] = "RefNotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefPresent"] = 2] = "RefPresent";
      StoreLinkStateValues[StoreLinkStateValues["Null"] = 3] = "Null";
      StoreLinkStateValues[StoreLinkStateValues["Missing"] = 4] = "Missing";
      StoreLinkStateValues[StoreLinkStateValues["Pending"] = 5] = "Pending";
    })(StoreLinkStateValues$1 || (StoreLinkStateValues$1 = {}));
    var StoreResolveResultState;
    (function (StoreResolveResultState) {
      StoreResolveResultState[StoreResolveResultState["Found"] = 0] = "Found";
      StoreResolveResultState[StoreResolveResultState["Error"] = 1] = "Error";
      StoreResolveResultState[StoreResolveResultState["Null"] = 2] = "Null";
      StoreResolveResultState[StoreResolveResultState["NotPresent"] = 3] = "NotPresent";
      StoreResolveResultState[StoreResolveResultState["Stale"] = 4] = "Stale";
    })(StoreResolveResultState || (StoreResolveResultState = {}));
    var HttpStatusCode;
    (function (HttpStatusCode) {
      HttpStatusCode[HttpStatusCode["Ok"] = 200] = "Ok";
      HttpStatusCode[HttpStatusCode["Created"] = 201] = "Created";
      HttpStatusCode[HttpStatusCode["NoContent"] = 204] = "NoContent";
      HttpStatusCode[HttpStatusCode["NotModified"] = 304] = "NotModified";
      HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
      HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
      HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
      HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
      HttpStatusCode[HttpStatusCode["ServerError"] = 500] = "ServerError";
      HttpStatusCode[HttpStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpStatusCode || (HttpStatusCode = {}));
    var GraphNodeType;
    (function (GraphNodeType) {
      GraphNodeType["Link"] = "Link";
      GraphNodeType["Node"] = "Node";
      GraphNodeType["Error"] = "Error";
      GraphNodeType["Locked"] = "Locked";
    })(GraphNodeType || (GraphNodeType = {}));
    var StoreLinkStateValues;
    (function (StoreLinkStateValues) {
      StoreLinkStateValues[StoreLinkStateValues["NotPresent"] = 0] = "NotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefNotPresent"] = 1] = "RefNotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefPresent"] = 2] = "RefPresent";
      StoreLinkStateValues[StoreLinkStateValues["Null"] = 3] = "Null";
      StoreLinkStateValues[StoreLinkStateValues["Missing"] = 4] = "Missing";
      StoreLinkStateValues[StoreLinkStateValues["Pending"] = 5] = "Pending";
    })(StoreLinkStateValues || (StoreLinkStateValues = {}));
    var FragmentReadResultState;
    (function (FragmentReadResultState) {
      FragmentReadResultState[FragmentReadResultState["Missing"] = 0] = "Missing";
      FragmentReadResultState[FragmentReadResultState["Success"] = 1] = "Success";
      FragmentReadResultState[FragmentReadResultState["Error"] = 2] = "Error";
    })(FragmentReadResultState || (FragmentReadResultState = {}));
    ({
      state: FragmentReadResultState.Missing
    });
    var ResourceParamType;
    (function (ResourceParamType) {
      ResourceParamType[ResourceParamType["UrlParameter"] = 0] = "UrlParameter";
      ResourceParamType[ResourceParamType["QueryParameter"] = 1] = "QueryParameter";
      ResourceParamType[ResourceParamType["Body"] = 2] = "Body";
      ResourceParamType[ResourceParamType["Header"] = 3] = "Header";
    })(ResourceParamType || (ResourceParamType = {}));
    var TypeCheckShapes;
    (function (TypeCheckShapes) {
      TypeCheckShapes[TypeCheckShapes["String"] = 0] = "String";
      TypeCheckShapes[TypeCheckShapes["Boolean"] = 1] = "Boolean";
      TypeCheckShapes[TypeCheckShapes["Number"] = 2] = "Number";
      TypeCheckShapes[TypeCheckShapes["Integer"] = 3] = "Integer";
      TypeCheckShapes[TypeCheckShapes["Unsupported"] = 4] = "Unsupported";
    })(TypeCheckShapes || (TypeCheckShapes = {}));
    // engine version: 0.156.4-dev2-78889b7e

    const {
      keys: ObjectKeys$2,
      create: ObjectCreate$2
    } = Object;
    const {
      assign: assign$1,
      create: create$1,
      freeze: freeze$1,
      isFrozen: isFrozen$1,
      keys: keys$1
    } = Object;
    function isString$1(value) {
      return typeof value === 'string';
    }
    function isFieldId$1(unknown) {
      if (typeof unknown !== 'object' || unknown === null) {
        return false;
      }
      const value = unknown;
      return isString$1(value.objectApiName) && isString$1(value.fieldApiName);
    }
    /**
     * Split the object API name and field API name from a qualified field name.
     * Eg: Opportunity.Title returns ['Opportunity', 'Title']
     * Eg: Opportunity.Account.Name returns ['Opportunity', 'Account.Name']
     * @param fieldApiName The qualified field name.
     * @return The object and field API names.
     */
    function splitQualifiedFieldApiName$1(fieldApiName) {
      const idx = fieldApiName.indexOf('.');
      if (idx < 1) {
        // object api name must non-empty
        throw new TypeError('Value does not include an object API name.');
      }
      return [fieldApiName.substring(0, idx), fieldApiName.substring(idx + 1)];
    }

    /**
     * Returns the field API name, qualified with an object name if possible.
     * @param value The value from which to get the qualified field API name.
     * @param onlyQualifiedFieldNames - Whether or not this function should skip fieldApiName that do not include the delimiter '.'
     * @return The qualified field API name.
     */
    function getFieldApiName$1(value, onlyQualifiedFieldNames = false) {
      // Note: tightening validation logic changes behavior from userland getting
      // a server-provided error to the adapter noop'ing. In 224 we decided to not
      // change the behavior. In 250 we decided to add the 'onlyQualifiedFieldName' flag to tighten the logic
      // optionally to avoid issues with persisted invalid field names.
      if (isString$1(value)) {
        const trimmed = value.trim();
        if (trimmed.length > 0 && (onlyQualifiedFieldNames ? trimmed.indexOf('.') > -1 : true)) {
          return trimmed;
        }
      } else if (isFieldId$1(value)) {
        return value.objectApiName + '.' + value.fieldApiName;
      }
      return undefined;
    }
    ObjectCreate$2(null);
    ObjectCreate$2(null);
    freeze$1({
      name: '',
      children: {}
    });
    /**
     * Returns a new object that has a list of fields that has been filtered by
     * edited fields. Only contains fields that have been edited from their original
     * values (excluding Id which is always copied over).
     * @param input The RecordInputRepresentation object to filter.
     * @param original The Record object that contains the original field values.
     * @returns RecordInputRepresentation, see the description
     */
    function createRecordInputFilteredByEditedFields(input, original) {
      const filteredRecordInput = getRecordInput();
      // Always copy over any existing id.
      if (original.id) {
        filteredRecordInput.fields.Id = original.id;
      }
      const recordInputFields = input.fields;
      const originalRecordFields = original.fields;
      const recordInputFieldPropertyNames = keys$1(recordInputFields);
      for (let i = 0, len = recordInputFieldPropertyNames.length; i < len; i++) {
        const fieldName = recordInputFieldPropertyNames[i];
        let originalRecordFieldsEntry;
        if (originalRecordFields) {
          originalRecordFieldsEntry = originalRecordFields[fieldName];
        }
        if (!originalRecordFieldsEntry || originalRecordFields && recordInputFields[fieldName] !== originalRecordFieldsEntry.value) {
          filteredRecordInput.fields[fieldName] = recordInputFields[fieldName];
        }
      }
      return filteredRecordInput;
    }
    /**
     * Returns an object with its data populated from the given record. All fields
     * with values that aren't nested records will be assigned. This object can be
     * used to create a record.
     * @param record The record that contains the source data.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
     *        If provided, only fields that are createable=true (excluding Id) will
     *        be assigned to the object return value.
     * @returns RecordInputRepresentation See description.
     */
    function generateRecordInputForCreate(record, objectInfo) {
      const recordInput = _generateRecordInput(record, field => field.createable === true, objectInfo);
      recordInput.apiName = record.apiName;
      // fields.Id is not required for CREATE which might have been copied over,
      // so delete fields.Id
      delete recordInput.fields.Id;
      return recordInput;
    }
    /**
     * Returns an object with its data populated from the given record. All fields
     * with values that aren't nested records will be assigned. This object can be
     * used to update a record.
     * @param record The record that contains the source data.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
     *        If provided, only fields that are updateable=true (excluding Id) will
     *        be assigned to the object return value.
     * @returns RecordInputRepresentation See description.
     */
    function generateRecordInputForUpdate(record, objectInfo) {
      const recordInput = _generateRecordInput(record, field => field.updateable === true, objectInfo);
      if (!record.id) {
        {
          throw new Error('record must have id for update');
        }
      }
      // Always copy over any existing id.
      recordInput.fields.Id = record.id;
      return recordInput;
    }
    function isRecordInputFieldValue(unknown) {
      const type = typeof unknown;
      return unknown === null || type === 'string' || type === 'number' || type === 'boolean';
    }
    /**
     * Returns an object with its data populated from the given record. All fields
     * with values that aren't nested records will be assigned.
     * @param record The record that contains the source data.
     * @param copyFieldPredicate predicate to determine if a field should be copied.
     *        Required if "objectInfo" parameter is passed.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
     *        If provided, only fields that match the copyFieldPredicate (excluding
     *        Id) will be assigned to the object return value.
     * @returns RecordInputRepresentation
     */
    function _generateRecordInput(record, copyFieldPredicate, objectInfo) {
      const recordInput = getRecordInput();
      const recordFields = record.fields;
      let objectInfoFields;
      if (objectInfo) {
        objectInfoFields = objectInfo.fields;
      }
      const recordFieldPropertyNames = keys$1(recordFields);
      for (let i = 0, len = recordFieldPropertyNames.length; i < len; i++) {
        const fieldName = recordFieldPropertyNames[i];
        const recordFieldsFieldNameEntry = recordFields[fieldName].value;
        if (isRecordInputFieldValue(recordFieldsFieldNameEntry)) {
          if (objectInfoFields && copyFieldPredicate) {
            const objectInfoFieldsFieldNameValue = objectInfoFields[fieldName];
            if (objectInfoFieldsFieldNameValue && copyFieldPredicate(objectInfoFieldsFieldNameValue)) {
              recordInput.fields[fieldName] = recordFieldsFieldNameEntry;
            }
          } else {
            recordInput.fields[fieldName] = recordFieldsFieldNameEntry;
          }
        }
      }
      return recordInput;
    }
    /**
     * Gets a new Record Input.
     */
    function getRecordInput() {
      return {
        apiName: undefined,
        fields: {}
      };
    }
    /**
     * Gets a field's value from a record.
     * @param record The record.
     * @param field The qualified API name of the field to return.
     * @returns The field's value (which may be a record in the case of spanning
     *          fields), or undefined if the field isn't found.
     */
    function getFieldValue(record, field) {
      const fieldValueRepresentation = getField(record, field);
      if (fieldValueRepresentation === undefined) {
        return undefined;
      }
      if (isFieldValueRepresentation(fieldValueRepresentation)) {
        return fieldValueRepresentation.value;
      }
      return fieldValueRepresentation;
    }
    /**
     * Gets a field's display value from a record.
     * @param record The record.
     * @param field The qualified API name of the field to return.
     * @returns The field's display value, or undefined if the field isn't found.
     */
    function getFieldDisplayValue(record, field) {
      const fieldValueRepresentation = getField(record, field);
      if (fieldValueRepresentation === undefined) {
        return undefined;
      }
      if (isFieldValueRepresentation(fieldValueRepresentation)) {
        return fieldValueRepresentation.displayValue;
      }
      return fieldValueRepresentation;
    }
    function isFieldValueRepresentation(unknown) {
      if (typeof unknown !== 'object' || unknown === null) {
        return false;
      }
      return 'value' in unknown && 'displayValue' in unknown;
    }
    function getField(record, field) {
      const fieldApiName = getFieldApiName$1(field);
      if (fieldApiName === undefined) {
        return undefined;
      }
      const unqualifiedField = splitQualifiedFieldApiName$1(fieldApiName)[1];
      const fields = unqualifiedField.split('.');
      let r = record;
      while (r && r.fields) {
        const f = fields.shift();
        const fvr = r.fields[f];
        if (fvr === undefined) {
          return undefined;
        } else if (fields.length > 0) {
          r = fvr.value;
        } else {
          return fvr;
        }
      }
      return r;
    }
    if (lwc.hot) {
        lwc.hot.register('force/ldsAdaptersUiapi/uiapi-static-functions.js', '86842db7ac7b1becdefb71129d3e0680', {"name":"ldsAdaptersUiapi","namespace":"force","enableLightningWebSecurityTransforms":false,"experimentalDynamicComponent":{"loader":"@salesforce/loader","strictSpecifier":false},"experimentalDynamicDirective":false,"enableDynamicComponents":true,"enableStaticContentOptimization":true,"outputConfig":{"sourcemap":false}});
    }

    /**
     * Limit the frequency and the duration that a function is invoked.
     *
     * @param invokeLimit The frequency a function could be invoked.
     * @param timeLimit The duration a function could be invoked with the rate limit, in milliseconds.
     * @param fn The function to be invoked.
     * @param options Extra options for instrumentation, logging, or bookkeeping purposes.
     * @returns The wrapped rate limited function.
     */
    function throttle(invokeLimit, timeLimit, fn, options) {
      if (invokeLimit <= 0 || timeLimit <= 0) {
        {
          throw new Error('only supports throttling with positive invokeLimit and timeLimit');
        }
      }
      let invokeCount = 0;
      let time = Date.now();
      const allowFunction = options && options.allowFunction ? options.allowFunction : () => {};
      const dropFunction = options && options.dropFunction ? options.dropFunction : () => {};
      return (...args) => {
        const calledTime = Date.now();
        if (calledTime - time <= timeLimit) {
          if (invokeCount < invokeLimit) {
            invokeCount += 1;
            allowFunction();
            return fn(...args);
          } else {
            dropFunction();
          }
        } else {
          time = calledTime;
          invokeCount = 1;
          allowFunction();
          return fn(...args);
        }
      };
    }

    /**
     * Defines configuration for the module with a default value which can be overridden by the runtime environment.
     */
    /**
     * Environment Aware GraphQLBatch adapter
     */
    let environmentAwareGraphQLBatchAdapter = undefined;
    /**
     * Draft-aware GraphQL adapter
     */
    let draftAwareGraphQLAdapter = undefined;
    /**
     * Draft-aware createRecord adapter
     */
    let draftAwareCreateRecordAdapter = undefined;
    /**
     * Draft-aware updateRecord adapter
     */
    let draftAwareUpdateRecordAdapter = undefined;
    /**
     * Draft-aware deleteRecord adapter
     */
    let draftAwareDeleteRecordAdapter = undefined;
    /**
     * Draft-aware createContentDocumentAndVersion adapter
     */
    let draftAwareCreateContentDocumentAndVersionAdapter = undefined;
    /**
     * Draft-aware createContentVersion adapter
     */
    let draftAwareCreateContentVersionAdapter = undefined;
    /**
     * Depth to which tracked fields will be added to a request that results from a cache miss.
     * A value of 0 inhibits the addition of tracked fields, 1 will add tracked fields that can
     * be reached by following 1 relationship from the root record, etc.
     * @defaultValue '5', replicates the current behavior
     */
    let trackedFieldDepthOnCacheMiss = 5;
    /**
     * Depth to which tracked fields will be added to a request that results from a merge conflict
     * A value of 0 inhibits the addition of tracked fields, 1 will add tracked fields that can
     * be reached by following 1 relationship from the root record, etc.
     * @defaultValue '5', replicates the current behavior
     */
    let trackedFieldDepthOnCacheMergeConflict = 5;
    /**
     * Depth to which tracked fields will be added to a request that results from a notify change invocation by the consumer
     * A value of 0 inhibits the addition of tracked fields, 1 will add tracked fields that can
     * be reached by following 1 relationship from the root record, etc.
     * @defaultValue '5', replicates the current behavior
     */
    let trackedFieldDepthOnNotifyChange = 5;
    /**
     * Determines if we will only fetch the 'Id' field for the leaf relationship record
     * @defaultValue 'false', replicates the current behavior and fetches all fields in the store for the leaf relationship record
     */
    let trackedFieldLeafNodeIdAndNameOnly = false;
    /**
     * One store enabled Get Object Info adapter
     */
    let oneStoreGetObjectInfoAdapter = undefined;
    /**
     * One store enabled Get Object Infos adapter
     */
    let oneStoreGetObjectInfosAdapter = undefined;
    /**
     * Determines when to include PDL strategies for Related Lists
     */
    let relatedListsPredictionsEnabled = false;
    /**
     * Defines the configuration API and is exposed internally as well as externally.
     * Configuration for one store enabled REST adapters only.
     */
    const configurationForOneStoreEnabledAdapters = {
      setGetObjectInfoAdapter: function (adapter) {
        oneStoreGetObjectInfoAdapter = adapter;
      },
      getGetObjectInfoAdapter: function () {
        return oneStoreGetObjectInfoAdapter;
      },
      setGetObjectInfosAdapter: function (adapter) {
        oneStoreGetObjectInfosAdapter = adapter;
      },
      getGetObjectInfosAdapter: function () {
        return oneStoreGetObjectInfosAdapter;
      }
    };
    /**
     * Helper function to return the one store adapter if it's defined, otherwise return the luvio adapter.
     * @param luvioAdapter - The luvio bound adapter.
     * @param oneStoreAdapter - The one store bound adapter.
     * @returns Luvio or one store wire adapter constructor.
     */
    function getLuvioOrOneStoreAdapter(luvioAdapter, oneStoreAdapter) {
      return oneStoreAdapter !== null && oneStoreAdapter !== void 0 ? oneStoreAdapter : luvioAdapter;
    }
    /**
     * Defines the configuration API and is exposed internally as well as externally.
     * Configuration for REST adapters only.
     */
    const configurationForRestAdapters = {
      setTrackedFieldDepthOnCacheMiss: function (trackedFieldDepthOnCacheMissParam) {
        trackedFieldDepthOnCacheMiss = trackedFieldDepthOnCacheMissParam;
      },
      getTrackedFieldDepthOnCacheMiss: function () {
        return trackedFieldDepthOnCacheMiss;
      },
      setTrackedFieldDepthOnCacheMergeConflict: function (trackedFieldDepthOnCacheMergeConflictParam) {
        trackedFieldDepthOnCacheMergeConflict = trackedFieldDepthOnCacheMergeConflictParam;
      },
      getTrackedFieldDepthOnCacheMergeConflict: function () {
        return trackedFieldDepthOnCacheMergeConflict;
      },
      setTrackedFieldDepthOnNotifyChange: function (trackedFieldDepthOnNotifyChangeParam) {
        trackedFieldDepthOnNotifyChange = trackedFieldDepthOnNotifyChangeParam;
      },
      getTrackedFieldDepthOnNotifyChange: function () {
        return trackedFieldDepthOnNotifyChange;
      },
      setTrackedFieldLeafNodeIdAndNameOnly: function (trackedFieldLeafNodeIdAndNameOnlyParam) {
        trackedFieldLeafNodeIdAndNameOnly = trackedFieldLeafNodeIdAndNameOnlyParam;
      },
      getTrackedFieldLeafNodeIdAndNameOnly: function () {
        return trackedFieldLeafNodeIdAndNameOnly;
      },
      // createRecord
      setDraftAwareCreateRecordAdapter: function (adapter) {
        draftAwareCreateRecordAdapter = adapter;
      },
      getDraftAwareCreateRecordAdapter: function () {
        return draftAwareCreateRecordAdapter;
      },
      // updateRecord
      setDraftAwareUpdateRecordAdapter: function (adapter) {
        draftAwareUpdateRecordAdapter = adapter;
      },
      getDraftAwareUpdateRecordAdapter: function () {
        return draftAwareUpdateRecordAdapter;
      },
      // deleteRecord
      setDraftAwareDeleteRecordAdapter: function (adapter) {
        draftAwareDeleteRecordAdapter = adapter;
      },
      getDraftAwareDeleteRecordAdapter: function () {
        return draftAwareDeleteRecordAdapter;
      },
      // createContentDocumentAndVersion
      setDraftAwareCreateContentDocumentAndVersionAdapter: function (adapter) {
        draftAwareCreateContentDocumentAndVersionAdapter = adapter;
      },
      getDraftAwareCreateContentDocumentAndVersionAdapter: function () {
        return draftAwareCreateContentDocumentAndVersionAdapter;
      },
      setRelatedListsPredictionsEnabled: function (f) {
        relatedListsPredictionsEnabled = f;
      },
      areRelatedListsPredictionsEnabled: function () {
        return relatedListsPredictionsEnabled === true;
      },
      // createContentVersion
      setDraftAwareCreateContentVersionAdapter: function (adapter) {
        draftAwareCreateContentVersionAdapter = adapter;
      },
      getDraftAwareCreateContentVersionAdapter: function () {
        return draftAwareCreateContentVersionAdapter;
      },
      ...configurationForOneStoreEnabledAdapters
    };
    /**
     * Defines the configuration API and is exposed internally as well as externally.
     * Configuration for GraphQL adapters only.
     */
    const configurationForGraphQLAdapters = {
      setDraftAwareGraphQLAdapter: function (adapter) {
        draftAwareGraphQLAdapter = adapter;
      },
      getDraftAwareGraphQLAdapter: function () {
        return draftAwareGraphQLAdapter;
      },
      setEnvironmentAwareGraphQLBatchAdapter: function (adapter) {
        environmentAwareGraphQLBatchAdapter = adapter;
      },
      getEnvironmentAwareGraphQLBatchAdapter: function () {
        return environmentAwareGraphQLBatchAdapter;
      }
    };
    const registrations = new Set();
    /**
     * lds-adapter-uiapi is special.  The non-SFDC bundle combines REST and GQL adapters,
     * yet for SFDC those are separate bundles.  So non-SFDC bundle (./main.ts) registers
     * both REST and GQL configs.  We want each SFDC bundle to register (we don't want one
     * SFDC bundle to assume the other is being loaded and therefore the other one will
     * take care of registration) but we don't want to double register either.
     *
     * So we make this function that memoizes if it's been called before and only
     * actually registers once.
     */
    function ensureRegisteredOnce(registration) {
      const {
        id
      } = registration;
      if (!registrations.has(id)) {
        ldsEngine.register(registration);
        registrations.add(id);
      }
    }

    // For use by callers within this module to instrument interesting things.
    let instrumentation = {
      /**
       * Called when a set of record conflicts has been fully resolved. The
       * parameter indicates the number of server requests that were needed
       * to fully resolve all the record conflicts.
       */
      recordConflictsResolved: _serverRequestCount => {},
      /**
       * Called during merging of incoming and existing FieldValues.
       * Called when the incoming FieldValue display value is null.
       *
       * Note: Temporary instrumentation to capture distribution and frequency, W-8990630
       * Flipped to counter metric due to W-9611107
       */
      nullDisplayValueConflict: _fieldInfo => {},
      /**
       * SFDC Throttling
       * getRecordNotifyChange and notifyRecordUpdateAvailable are both throttled
       */
      getRecordNotifyChangeAllowed: () => {},
      getRecordNotifyChangeDropped: () => {},
      notifyRecordUpdateAvailableAllowed: () => {},
      notifyRecordUpdateAvailableDropped: () => {},
      /**
       * RecordRepresentation merge
       * Called when records change apiName
       */
      recordApiNameChanged: (_existingApiName, _incomingApiName) => {},
      recordTypeIdIsNull: _apiName => {},
      /**
       * RecordRepresentation merge
       * Called when either incoming or existing RecordRepresentation has a weakEtag=0
       */
      weakEtagZero: (_incomingWeakEtagZero, _existingWeakEtagZero, _apiName) => {},
      /**
       * getRecord notifyChangeFactory
       * Called when dispatchResourceRequest is resolved/rejected
       */
      getRecordNotifyChangeNetworkResult: (_uniqueWeakEtags, _error) => {}
    };
    /**
     * Allows external modules (typically a runtime environment) to set
     * instrumentation hooks for this module. Note that the hooks are
     * incremental - hooks not suppiled in newInstrumentation will retain
     * their previous values. The default instrumentation hooks are no-ops.
     *
     * @param newInstrumentation instrumentation hooks to be overridden
     */
    function instrument(newInstrumentation) {
      instrumentation = Object.assign(instrumentation, newInstrumentation);
    }
    const engineForPrefetcherMap = new Map();
    function registerPrefetcher(luvio, prefetcher) {
      {
        if (engineForPrefetcherMap.has(luvio)) {
          throw new Error('Environment error: Only one prefetcher per engine is allowed.');
        }
      }
      engineForPrefetcherMap.set(luvio, prefetcher);
    }
    function getPrefetcherFor(luvio) {
      return engineForPrefetcherMap.get(luvio);
    }
    function createLDSAdapterWithPrediction(adapter, luvio, name) {
      return (config, requestContext) => {
        const prefetcher = getPrefetcherFor(luvio);
        const result = adapter(config, requestContext);
        // only save requests with a valid config.
        if (result !== null && prefetcher !== undefined && !(requestContext && requestContext.excludeFromPredictions)) {
          prefetcher.saveRequest({
            adapterName: name,
            config
          });
        }
        return result;
      };
    }
    function createRelatedListAdapterWithPrediction(adapter, luvio, name) {
      if (configurationForRestAdapters.areRelatedListsPredictionsEnabled() /* gate is open */) {
        return createLDSAdapterWithPrediction(adapter, luvio, name);
      } else {
        return (config, requestContext) => {
          return adapter(config, requestContext);
        };
      }
    }
    const {
      hasOwnProperty: ObjectPrototypeHasOwnProperty
    } = Object.prototype;
    const {
      keys: ObjectKeys$1,
      create: ObjectCreate$1
    } = Object;
    const {
      stringify: JSONStringify$1
    } = JSON;
    const {
      isArray: ArrayIsArray$1
    } = Array;
    const {
      push: ArrayPrototypePush
    } = Array.prototype;
    /**
     * Validates an adapter config is well-formed.
     * @param config The config to validate.
     * @param adapter The adapter validation configuration.
     * @param oneOf The keys the config must contain at least one of.
     * @throws A TypeError if config doesn't satisfy the adapter's config validation.
     */
    function validateConfig(config, adapter, oneOf) {
      const {
        displayName
      } = adapter;
      const {
        required,
        optional,
        unsupported
      } = adapter.parameters;
      if (config === undefined || required.every(req => ObjectPrototypeHasOwnProperty.call(config, req)) === false) {
        throw new TypeError(`adapter ${displayName} configuration must specify ${required.sort().join(', ')}`);
      }
      if (oneOf && oneOf.some(req => ObjectPrototypeHasOwnProperty.call(config, req)) === false) {
        throw new TypeError(`adapter ${displayName} configuration must specify one of ${oneOf.sort().join(', ')}`);
      }
      if (unsupported !== undefined && unsupported.some(req => ObjectPrototypeHasOwnProperty.call(config, req))) {
        throw new TypeError(`adapter ${displayName} does not yet support ${unsupported.sort().join(', ')}`);
      }
      const supported = required.concat(optional);
      if (ObjectKeys$1(config).some(key => !supported.includes(key))) {
        throw new TypeError(`adapter ${displayName} configuration supports only ${supported.sort().join(', ')}`);
      }
    }
    function untrustedIsObject(untrusted) {
      return typeof untrusted === 'object' && untrusted !== null && ArrayIsArray$1(untrusted) === false;
    }
    function areRequiredParametersPresent(config, configPropertyNames) {
      return configPropertyNames.parameters.required.every(req => req in config);
    }
    const SNAPSHOT_STATE_UNFULFILLED = 'Unfulfilled';
    const snapshotRefreshOptions = {
      overrides: {
        headers: {
          'Cache-Control': 'no-cache'
        }
      }
    };
    /**
     * A deterministic JSON stringify implementation. Heavily adapted from https://github.com/epoberezkin/fast-json-stable-stringify.
     * This is needed because insertion order for JSON.stringify(object) affects output:
     * JSON.stringify({a: 1, b: 2})
     *      "{"a":1,"b":2}"
     * JSON.stringify({b: 2, a: 1})
     *      "{"b":2,"a":1}"
     * @param data Data to be JSON-stringified.
     * @returns JSON.stringified value with consistent ordering of keys.
     */
    function stableJSONStringify(node) {
      // This is for Date values.
      if (node && node.toJSON && typeof node.toJSON === 'function') {
        // eslint-disable-next-line no-param-reassign
        node = node.toJSON();
      }
      if (node === undefined) {
        return;
      }
      if (typeof node === 'number') {
        return isFinite(node) ? '' + node : 'null';
      }
      if (typeof node !== 'object') {
        return JSONStringify$1(node);
      }
      let i;
      let out;
      if (ArrayIsArray$1(node)) {
        out = '[';
        for (i = 0; i < node.length; i++) {
          if (i) {
            out += ',';
          }
          out += stableJSONStringify(node[i]) || 'null';
        }
        return out + ']';
      }
      if (node === null) {
        return 'null';
      }
      const keys = ObjectKeys$1(node).sort();
      out = '';
      for (i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = stableJSONStringify(node[key]);
        if (!value) {
          continue;
        }
        if (out) {
          out += ',';
        }
        out += JSONStringify$1(key) + ':' + value;
      }
      return '{' + out + '}';
    }
    function getFetchResponseStatusText(status) {
      switch (status) {
        case 200:
          return 'OK';
        case 201:
          return 'Created';
        case 304:
          return 'Not Modified';
        case 404:
          return 'Not Found';
        case 400:
          return 'Bad Request';
        case 500:
          return 'Server Error';
        default:
          return `Unexpected HTTP Status Code: ${status}`;
      }
    }
    function isUnfulfilledSnapshot$1(snapshot) {
      return snapshot.state === SNAPSHOT_STATE_UNFULFILLED;
    }
    function generateParamConfigMetadata(name, required, resourceType, typeCheckShape, isArrayShape = false, coerceFn) {
      return {
        name,
        required,
        resourceType,
        typeCheckShape,
        isArrayShape,
        coerceFn
      };
    }
    function buildAdapterValidationConfig(displayName, paramsMeta) {
      const required = paramsMeta.filter(p => p.required).map(p => p.name);
      const optional = paramsMeta.filter(p => !p.required).map(p => p.name);
      return {
        displayName,
        parameters: {
          required,
          optional
        }
      };
    }
    const keyPrefix = 'UiApi';
    const {
      assign,
      create,
      freeze,
      isFrozen,
      keys
    } = Object;
    const {
      hasOwnProperty
    } = Object.prototype;
    const {
      split,
      endsWith
    } = String.prototype;
    const {
      isArray
    } = Array;
    const {
      concat,
      filter,
      includes,
      push,
      reduce
    } = Array.prototype;
    const {
      parse,
      stringify
    } = JSON;
    function isString(value) {
      return typeof value === 'string';
    }
    /**
     * @param value The array to inspect.
     * @returns True if the array is non-empty and contains only non-empty strings.
     */
    function isArrayOfNonEmptyStrings(value) {
      if (value.length === 0) {
        return false;
      }
      return value.every(v => isString(v) && v.trim().length > 0);
    }
    /**
     * @param value The array to dedupe
     * @returns An array without duplicates.
     */
    function dedupe(value) {
      const result = {};
      for (let i = 0, len = value.length; i < len; i += 1) {
        result[value[i]] = true;
      }
      return keys(result);
    }
    /**
     * @param source The array of string to filter
     * @param compare The array to filter against
     * @returns An array with values from source that do not exist in compare
     * If the "compare" array is empty, "source" array itself is returned, not a shallow copy
     */
    function difference(source, compare) {
      const {
        length: sourceLength
      } = source;
      const {
        length: compareLength
      } = compare;
      if (sourceLength === 0 || source === compare) {
        return [];
      }
      if (compareLength === 0) {
        return source;
      }
      // Put all the values from "compare" into a map
      // This should be faster than doing an indexOf for every string in source
      const map = {};
      for (let i = 0; i < compareLength; i += 1) {
        map[compare[i]] = true;
      }
      const strings = [];
      for (let i = 0; i < sourceLength; i += 1) {
        const string = source[i];
        if (map[string] === undefined) {
          strings.push(string);
        }
      }
      return strings;
    }
    function isObjectId(unknown) {
      if (typeof unknown !== 'object' || unknown === null) {
        return false;
      }
      return isString(unknown.objectApiName);
    }

    /**
     * Returns the object API name.
     * @param value The value from which to get the object API name.
     * @returns The object API name.
     */
    function getObjectApiName$1(value) {
      // Note: tightening validation logic changes behavior from userland getting
      // a server-provided error to the adapter noop'ing. In 224 we decided to not
      // change the behavior.
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (trimmed.length > 0) {
          return trimmed;
        }
      } else if (isObjectId(value)) {
        return value.objectApiName.trim();
      }
      return undefined;
    }
    function isFieldId(unknown) {
      if (typeof unknown !== 'object' || unknown === null) {
        return false;
      }
      const value = unknown;
      return isString(value.objectApiName) && isString(value.fieldApiName);
    }
    function stringToFieldId(fieldApiName) {
      const split = fieldApiName.split('.');
      {
        if (split.length === 1) {
          // object api name must non-empty
          throw new TypeError('Value does not include an object API name.');
        }
      }
      return {
        objectApiName: split[0],
        fieldApiName: split[1]
      };
    }
    function getFieldId(value) {
      if (isFieldId(value)) {
        return value;
      }
      return stringToFieldId(value);
    }
    /**
     * Split the object API name and field API name from a qualified field name.
     * Eg: Opportunity.Title returns ['Opportunity', 'Title']
     * Eg: Opportunity.Account.Name returns ['Opportunity', 'Account.Name']
     * @param fieldApiName The qualified field name.
     * @return The object and field API names.
     */
    function splitQualifiedFieldApiName(fieldApiName) {
      const idx = fieldApiName.indexOf('.');
      if (idx < 1) {
        // object api name must non-empty
        throw new TypeError('Value does not include an object API name.');
      }
      return [fieldApiName.substring(0, idx), fieldApiName.substring(idx + 1)];
    }

    /**
     * Returns the field API name, qualified with an object name if possible.
     * @param value The value from which to get the qualified field API name.
     * @param onlyQualifiedFieldNames - Whether or not this function should skip fieldApiName that do not include the delimiter '.'
     * @return The qualified field API name.
     */
    function getFieldApiName(value, onlyQualifiedFieldNames = false) {
      // Note: tightening validation logic changes behavior from userland getting
      // a server-provided error to the adapter noop'ing. In 224 we decided to not
      // change the behavior. In 250 we decided to add the 'onlyQualifiedFieldName' flag to tighten the logic
      // optionally to avoid issues with persisted invalid field names.
      if (isString(value)) {
        const trimmed = value.trim();
        if (trimmed.length > 0 && (onlyQualifiedFieldNames ? trimmed.indexOf('.') > -1 : true)) {
          return trimmed;
        }
      } else if (isFieldId(value)) {
        return value.objectApiName + '.' + value.fieldApiName;
      }
      return undefined;
    }

    /**
     * Returns the field API name.
     * @param value The value from which to get the field API name.
     * @param options Option bag. onlyQualifiedFieldNames is a boolean that allows this function to skip returning invalid FieldApiNames.
     * @returns The field API name.
     */
    function getFieldApiNamesArray(value, options = {
      onlyQualifiedFieldNames: false
    }) {
      const valueArray = isArray(value) ? value : [value];
      const array = [];
      for (let i = 0, len = valueArray.length; i < len; i += 1) {
        const item = valueArray[i];
        const apiName = getFieldApiName(item, options.onlyQualifiedFieldNames);
        if (apiName === undefined) {
          if (options.onlyQualifiedFieldNames) {
            continue; // Just skips invalid field names rather than failing to return an array at all
          }
          return undefined;
        }
        push.call(array, apiName);
      }
      if (array.length === 0) {
        return undefined;
      }
      return dedupe(array).sort();
    }
    const {
      keys: ObjectKeys,
      create: ObjectCreate,
      assign: ObjectAssign
    } = Object;
    const {
      isArray: ArrayIsArray
    } = Array;
    const {
      stringify: JSONStringify
    } = JSON;
    function equalsArray(a, b, equalsItem) {
      const aLength = a.length;
      const bLength = b.length;
      if (aLength !== bLength) {
        return false;
      }
      for (let i = 0; i < aLength; i++) {
        if (equalsItem(a[i], b[i]) === false) {
          return false;
        }
      }
      return true;
    }
    function equalsObject(a, b, equalsProp) {
      const aKeys = ObjectKeys(a).sort();
      const bKeys = ObjectKeys(b).sort();
      const aKeysLength = aKeys.length;
      const bKeysLength = bKeys.length;
      if (aKeysLength !== bKeysLength) {
        return false;
      }
      for (let i = 0; i < aKeys.length; i++) {
        const key = aKeys[i];
        if (key !== bKeys[i]) {
          return false;
        }
        if (equalsProp(a[key], b[key]) === false) {
          return false;
        }
      }
      return true;
    }
    function createLink(ref) {
      return {
        __ref: luvioEngine.serializeStructuredKey(ref)
      };
    }
    function assignMetadataLink(entry, metadataKey) {
      entry['__metadata'] = createLink(metadataKey);
    }
    const VERSION$1t = "623aa9ce3a11031e35faf5671a41746e";
    function validate$2a(obj, path = 'ListFilterByInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_operandLabels = obj.operandLabels;
        const path_operandLabels = path + '.operandLabels';
        if (!ArrayIsArray(obj_operandLabels)) {
          return new TypeError('Expected "array" but received "' + typeof obj_operandLabels + '" (at "' + path_operandLabels + '")');
        }
        for (let i = 0; i < obj_operandLabels.length; i++) {
          const obj_operandLabels_item = obj_operandLabels[i];
          const path_operandLabels_item = path_operandLabels + '[' + i + ']';
          if (typeof obj_operandLabels_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_operandLabels_item + '" (at "' + path_operandLabels_item + '")');
          }
        }
        const obj_operator = obj.operator;
        const path_operator = path + '.operator';
        if (typeof obj_operator !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_operator + '" (at "' + path_operator + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$26 = function ListFilterByInfoRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1t,
        private: [],
        selections: [{
          name: 'fieldApiName',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'operandLabels',
          kind: 'Scalar',
          plural: true
        }, {
          name: 'operator',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$1s = "f98dc7dec10408a9648ef8e5b37002a3";
    function validate$29(obj, path = 'ListInlineEditDetailsRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_message = obj.message;
        const path_message = path + '.message';
        let obj_message_union0 = null;
        const obj_message_union0_error = (() => {
          if (typeof obj_message !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_message + '" (at "' + path_message + '")');
          }
        })();
        if (obj_message_union0_error != null) {
          obj_message_union0 = obj_message_union0_error.message;
        }
        let obj_message_union1 = null;
        const obj_message_union1_error = (() => {
          if (obj_message !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_message + '" (at "' + path_message + '")');
          }
        })();
        if (obj_message_union1_error != null) {
          obj_message_union1 = obj_message_union1_error.message;
        }
        if (obj_message_union0 && obj_message_union1) {
          let message = 'Object doesn\'t match union (at "' + path_message + '")';
          message += '\n' + obj_message_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_message_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_state = obj.state;
        const path_state = path + '.state';
        let obj_state_union0 = null;
        const obj_state_union0_error = (() => {
          if (typeof obj_state !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_state + '" (at "' + path_state + '")');
          }
        })();
        if (obj_state_union0_error != null) {
          obj_state_union0 = obj_state_union0_error.message;
        }
        let obj_state_union1 = null;
        const obj_state_union1_error = (() => {
          if (obj_state !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_state + '" (at "' + path_state + '")');
          }
        })();
        if (obj_state_union1_error != null) {
          obj_state_union1 = obj_state_union1_error.message;
        }
        if (obj_state_union0 && obj_state_union1) {
          let message = 'Object doesn\'t match union (at "' + path_state + '")';
          message += '\n' + obj_state_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_state_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$25 = function ListInlineEditDetailsRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1s,
        private: [],
        selections: [{
          name: 'message',
          kind: 'Scalar'
        }, {
          name: 'state',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$1r = "76042ff4af603b2ac0ec69fa0bd12046";
    function validate$28(obj, path = 'ListReferenceRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
          if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union0_error != null) {
          obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
          if (obj_id !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union1_error != null) {
          obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
          let message = 'Object doesn\'t match union (at "' + path_id + '")';
          message += '\n' + obj_id_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_id_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_listViewApiName = obj.listViewApiName;
        const path_listViewApiName = path + '.listViewApiName';
        let obj_listViewApiName_union0 = null;
        const obj_listViewApiName_union0_error = (() => {
          if (typeof obj_listViewApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
          }
        })();
        if (obj_listViewApiName_union0_error != null) {
          obj_listViewApiName_union0 = obj_listViewApiName_union0_error.message;
        }
        let obj_listViewApiName_union1 = null;
        const obj_listViewApiName_union1_error = (() => {
          if (obj_listViewApiName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
          }
        })();
        if (obj_listViewApiName_union1_error != null) {
          obj_listViewApiName_union1 = obj_listViewApiName_union1_error.message;
        }
        if (obj_listViewApiName_union0 && obj_listViewApiName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_listViewApiName + '")';
          message += '\n' + obj_listViewApiName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_listViewApiName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$24 = function ListReferenceRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1r,
        private: [],
        selections: [{
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'listViewApiName',
          kind: 'Scalar'
        }, {
          name: 'objectApiName',
          kind: 'Scalar'
        }, {
          name: 'type',
          kind: 'Scalar'
        }]
      };
    };
    function equals$1a(existing, incoming) {
      const existing_objectApiName = existing.objectApiName;
      const incoming_objectApiName = incoming.objectApiName;
      if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
      }
      const existing_type = existing.type;
      const incoming_type = incoming.type;
      if (!(existing_type === incoming_type)) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_listViewApiName = existing.listViewApiName;
      const incoming_listViewApiName = incoming.listViewApiName;
      if (!(existing_listViewApiName === incoming_listViewApiName)) {
        return false;
      }
      return true;
    }
    const VERSION$1q = "f1519bef57e70ab7c5ef160dc5ff0c47";
    function validate$27(obj, path = 'ListInfoShareRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_shareApiName = obj.shareApiName;
        const path_shareApiName = path + '.shareApiName';
        if (typeof obj_shareApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_shareApiName + '" (at "' + path_shareApiName + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$23 = function ListInfoShareRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1q,
        private: [],
        selections: [{
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'shareApiName',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$1p = "561657f32721ec1dac1601575b029640";
    function validate$26(obj, path = 'ListInfoShareCategoryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_shareType = obj.shareType;
        const path_shareType = path + '.shareType';
        if (typeof obj_shareType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_shareType + '" (at "' + path_shareType + '")');
        }
        const obj_shares = obj.shares;
        const path_shares = path + '.shares';
        if (!ArrayIsArray(obj_shares)) {
          return new TypeError('Expected "array" but received "' + typeof obj_shares + '" (at "' + path_shares + '")');
        }
        for (let i = 0; i < obj_shares.length; i++) {
          const obj_shares_item = obj_shares[i];
          const path_shares_item = path_shares + '[' + i + ']';
          const referencepath_shares_itemValidationError = validate$27(obj_shares_item, path_shares_item);
          if (referencepath_shares_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListInfoShareRepresentation (at "' + path_shares_item + '")\n';
            message += referencepath_shares_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$22 = function ListInfoShareCategoryRepresentationSelect() {
      const {
        selections: ListInfoShareRepresentation__selections,
        opaque: ListInfoShareRepresentation__opaque
      } = select$23();
      return {
        kind: 'Fragment',
        version: VERSION$1p,
        private: [],
        selections: [{
          name: 'shareType',
          kind: 'Scalar'
        }, {
          name: 'shares',
          kind: 'Object',
          plural: true,
          selections: ListInfoShareRepresentation__selections
        }]
      };
    };
    const VERSION$1o = "32def9b631252c12b91a8209c1f49f5a";
    function validate$25(obj, path = 'ListOrderByInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_isAscending = obj.isAscending;
        const path_isAscending = path + '.isAscending';
        if (typeof obj_isAscending !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isAscending + '" (at "' + path_isAscending + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        let obj_label_union0 = null;
        const obj_label_union0_error = (() => {
          if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
          }
        })();
        if (obj_label_union0_error != null) {
          obj_label_union0 = obj_label_union0_error.message;
        }
        let obj_label_union1 = null;
        const obj_label_union1_error = (() => {
          if (obj_label !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_label + '" (at "' + path_label + '")');
          }
        })();
        if (obj_label_union1_error != null) {
          obj_label_union1 = obj_label_union1_error.message;
        }
        if (obj_label_union0 && obj_label_union1) {
          let message = 'Object doesn\'t match union (at "' + path_label + '")';
          message += '\n' + obj_label_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_label_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$21 = function ListOrderByInfoRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1o,
        private: [],
        selections: [{
          name: 'fieldApiName',
          kind: 'Scalar'
        }, {
          name: 'isAscending',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }]
      };
    };
    function equals$19(existing, incoming) {
      const existing_isAscending = existing.isAscending;
      const incoming_isAscending = incoming.isAscending;
      if (!(existing_isAscending === incoming_isAscending)) {
        return false;
      }
      const existing_fieldApiName = existing.fieldApiName;
      const incoming_fieldApiName = incoming.fieldApiName;
      if (!(existing_fieldApiName === incoming_fieldApiName)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      return true;
    }
    const VERSION$1n = "2634258f216db34315c06d759a35676d";
    function validate$24(obj, path = 'ListScopeEntityRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$20 = function ListScopeEntityRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1n,
        private: [],
        selections: [{
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$1m = "3b85c5a08d50ce328481b9f8ab56127b";
    function validate$23(obj, path = 'ListScopeRelatedEntityRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1$ = function ListScopeRelatedEntityRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1m,
        private: [],
        selections: [{
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'type',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$1l = "2fe9814e7124b47f59da585483c1b3f9";
    function validate$22(obj, path = 'ListScopeRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_entity = obj.entity;
        const path_entity = path + '.entity';
        let obj_entity_union0 = null;
        const obj_entity_union0_error = (() => {
          const referencepath_entityValidationError = validate$24(obj_entity, path_entity);
          if (referencepath_entityValidationError !== null) {
            let message = 'Object doesn\'t match ListScopeEntityRepresentation (at "' + path_entity + '")\n';
            message += referencepath_entityValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_entity_union0_error != null) {
          obj_entity_union0 = obj_entity_union0_error.message;
        }
        let obj_entity_union1 = null;
        const obj_entity_union1_error = (() => {
          if (obj_entity !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_entity + '" (at "' + path_entity + '")');
          }
        })();
        if (obj_entity_union1_error != null) {
          obj_entity_union1 = obj_entity_union1_error.message;
        }
        if (obj_entity_union0 && obj_entity_union1) {
          let message = 'Object doesn\'t match union (at "' + path_entity + '")';
          message += '\n' + obj_entity_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_entity_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        let obj_label_union0 = null;
        const obj_label_union0_error = (() => {
          if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
          }
        })();
        if (obj_label_union0_error != null) {
          obj_label_union0 = obj_label_union0_error.message;
        }
        let obj_label_union1 = null;
        const obj_label_union1_error = (() => {
          if (obj_label !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_label + '" (at "' + path_label + '")');
          }
        })();
        if (obj_label_union1_error != null) {
          obj_label_union1 = obj_label_union1_error.message;
        }
        if (obj_label_union0 && obj_label_union1) {
          let message = 'Object doesn\'t match union (at "' + path_label + '")';
          message += '\n' + obj_label_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_label_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_relatedEntity = obj.relatedEntity;
        const path_relatedEntity = path + '.relatedEntity';
        let obj_relatedEntity_union0 = null;
        const obj_relatedEntity_union0_error = (() => {
          const referencepath_relatedEntityValidationError = validate$23(obj_relatedEntity, path_relatedEntity);
          if (referencepath_relatedEntityValidationError !== null) {
            let message = 'Object doesn\'t match ListScopeRelatedEntityRepresentation (at "' + path_relatedEntity + '")\n';
            message += referencepath_relatedEntityValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_relatedEntity_union0_error != null) {
          obj_relatedEntity_union0 = obj_relatedEntity_union0_error.message;
        }
        let obj_relatedEntity_union1 = null;
        const obj_relatedEntity_union1_error = (() => {
          if (obj_relatedEntity !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_relatedEntity + '" (at "' + path_relatedEntity + '")');
          }
        })();
        if (obj_relatedEntity_union1_error != null) {
          obj_relatedEntity_union1 = obj_relatedEntity_union1_error.message;
        }
        if (obj_relatedEntity_union0 && obj_relatedEntity_union1) {
          let message = 'Object doesn\'t match union (at "' + path_relatedEntity + '")';
          message += '\n' + obj_relatedEntity_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_relatedEntity_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1_ = function ListScopeRepresentationSelect() {
      const {
        selections: ListScopeEntityRepresentation__selections,
        opaque: ListScopeEntityRepresentation__opaque
      } = select$20();
      const {
        selections: ListScopeRelatedEntityRepresentation__selections,
        opaque: ListScopeRelatedEntityRepresentation__opaque
      } = select$1$();
      return {
        kind: 'Fragment',
        version: VERSION$1l,
        private: [],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'entity',
          kind: 'Object',
          nullable: true,
          selections: ListScopeEntityRepresentation__selections
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'relatedEntity',
          kind: 'Object',
          nullable: true,
          selections: ListScopeRelatedEntityRepresentation__selections
        }]
      };
    };
    const VERSION$1k = "6506134f4d72fdfa349fe60ef1af2413";
    function validate$21(obj, path = 'ListUserPreferenceRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_columnWidths = obj.columnWidths;
        const path_columnWidths = path + '.columnWidths';
        if (typeof obj_columnWidths !== 'object' || ArrayIsArray(obj_columnWidths) || obj_columnWidths === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_columnWidths + '" (at "' + path_columnWidths + '")');
        }
        const obj_columnWidths_keys = ObjectKeys(obj_columnWidths);
        for (let i = 0; i < obj_columnWidths_keys.length; i++) {
          const key = obj_columnWidths_keys[i];
          const obj_columnWidths_prop = obj_columnWidths[key];
          const path_columnWidths_prop = path_columnWidths + '["' + key + '"]';
          if (typeof obj_columnWidths_prop !== 'number' || typeof obj_columnWidths_prop === 'number' && Math.floor(obj_columnWidths_prop) !== obj_columnWidths_prop) {
            return new TypeError('Expected "integer" but received "' + typeof obj_columnWidths_prop + '" (at "' + path_columnWidths_prop + '")');
          }
        }
        const obj_columnWrap = obj.columnWrap;
        const path_columnWrap = path + '.columnWrap';
        if (typeof obj_columnWrap !== 'object' || ArrayIsArray(obj_columnWrap) || obj_columnWrap === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_columnWrap + '" (at "' + path_columnWrap + '")');
        }
        const obj_columnWrap_keys = ObjectKeys(obj_columnWrap);
        for (let i = 0; i < obj_columnWrap_keys.length; i++) {
          const key = obj_columnWrap_keys[i];
          const obj_columnWrap_prop = obj_columnWrap[key];
          const path_columnWrap_prop = path_columnWrap + '["' + key + '"]';
          if (typeof obj_columnWrap_prop !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_columnWrap_prop + '" (at "' + path_columnWrap_prop + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1Z = function ListUserPreferenceRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1k,
        private: [],
        selections: [{
          name: 'columnWidths',
          kind: 'Scalar',
          map: true
        }, {
          name: 'columnWrap',
          kind: 'Scalar',
          map: true
        }]
      };
    };
    function validate$20(obj, path = 'ListColumnInlineEditAttributesRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_editable = obj.editable;
        const path_editable = path + '.editable';
        if (typeof obj_editable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_editable + '" (at "' + path_editable + '")');
        }
        const obj_required = obj.required;
        const path_required = path + '.required';
        if (typeof obj_required !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_required + '" (at "' + path_required + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$1$(obj, path = 'ListColumnInlineEditAttributesRepresentationWrapper') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_keys = ObjectKeys(obj);
        for (let i = 0; i < obj_keys.length; i++) {
          const key = obj_keys[i];
          const obj_prop = obj[key];
          const path_prop = path + '["' + key + '"]';
          const referencepath_propValidationError = validate$20(obj_prop, path_prop);
          if (referencepath_propValidationError !== null) {
            let message = 'Object doesn\'t match ListColumnInlineEditAttributesRepresentation (at "' + path_prop + '")\n';
            message += referencepath_propValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const VERSION$1j = "64e2cac6d374ad92f491a9f8a952c6c3";
    function validate$1_(obj, path = 'ListColumnRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_inlineEditAttributes = obj.inlineEditAttributes;
        const path_inlineEditAttributes = path + '.inlineEditAttributes';
        let obj_inlineEditAttributes_union0 = null;
        const obj_inlineEditAttributes_union0_error = (() => {
          const referencepath_inlineEditAttributesValidationError = validate$1$(obj_inlineEditAttributes, path_inlineEditAttributes);
          if (referencepath_inlineEditAttributesValidationError !== null) {
            let message = 'Object doesn\'t match ListColumnInlineEditAttributesRepresentationWrapper (at "' + path_inlineEditAttributes + '")\n';
            message += referencepath_inlineEditAttributesValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_inlineEditAttributes_union0_error != null) {
          obj_inlineEditAttributes_union0 = obj_inlineEditAttributes_union0_error.message;
        }
        let obj_inlineEditAttributes_union1 = null;
        const obj_inlineEditAttributes_union1_error = (() => {
          if (obj_inlineEditAttributes !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_inlineEditAttributes + '" (at "' + path_inlineEditAttributes + '")');
          }
        })();
        if (obj_inlineEditAttributes_union1_error != null) {
          obj_inlineEditAttributes_union1 = obj_inlineEditAttributes_union1_error.message;
        }
        if (obj_inlineEditAttributes_union0 && obj_inlineEditAttributes_union1) {
          let message = 'Object doesn\'t match union (at "' + path_inlineEditAttributes + '")';
          message += '\n' + obj_inlineEditAttributes_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_inlineEditAttributes_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_lookupId = obj.lookupId;
        const path_lookupId = path + '.lookupId';
        let obj_lookupId_union0 = null;
        const obj_lookupId_union0_error = (() => {
          if (typeof obj_lookupId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lookupId + '" (at "' + path_lookupId + '")');
          }
        })();
        if (obj_lookupId_union0_error != null) {
          obj_lookupId_union0 = obj_lookupId_union0_error.message;
        }
        let obj_lookupId_union1 = null;
        const obj_lookupId_union1_error = (() => {
          if (obj_lookupId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lookupId + '" (at "' + path_lookupId + '")');
          }
        })();
        if (obj_lookupId_union1_error != null) {
          obj_lookupId_union1 = obj_lookupId_union1_error.message;
        }
        if (obj_lookupId_union0 && obj_lookupId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lookupId + '")';
          message += '\n' + obj_lookupId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lookupId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_searchable = obj.searchable;
        const path_searchable = path + '.searchable';
        if (typeof obj_searchable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_searchable + '" (at "' + path_searchable + '")');
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$Z = 'ListColumnRepresentation';
    function normalize$S(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1Y = function ListColumnRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1j,
        private: [],
        opaque: true
      };
    };
    function equals$18(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$S = function ListColumnRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1_(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$S, "UiApi", VERSION$1j, RepresentationType$Z, equals$18);
      return createLink(key);
    };
    function getTypeCacheKeys$_(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$Z,
        mergeable: false
      });
    }
    const keyBuilderFromType$F = function ListInfoRepresentationKeyBuilderFromType(luvio, object) {
      const keyParams = {
        listViewApiName: object.listReference.listViewApiName ? object.listReference.listViewApiName.toLowerCase() : object.listReference.listViewApiName,
        objectApiName: object.listReference.objectApiName.toLowerCase(),
        type: object.listReference.type
      };
      return keyBuilder$2a(luvio, keyParams);
    };
    const TTL$B = 900000;
    const VERSION$1i = "5adf17d38be03c0f71b1c52485b377a6";
    function validate$1Z(obj, path = 'ListInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_cloneable = obj.cloneable;
        const path_cloneable = path + '.cloneable';
        if (typeof obj_cloneable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_cloneable + '" (at "' + path_cloneable + '")');
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_deletable = obj.deletable;
        const path_deletable = path + '.deletable';
        if (typeof obj_deletable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_deletable + '" (at "' + path_deletable + '")');
        }
        const obj_displayColumns = obj.displayColumns;
        const path_displayColumns = path + '.displayColumns';
        if (!ArrayIsArray(obj_displayColumns)) {
          return new TypeError('Expected "array" but received "' + typeof obj_displayColumns + '" (at "' + path_displayColumns + '")');
        }
        for (let i = 0; i < obj_displayColumns.length; i++) {
          const obj_displayColumns_item = obj_displayColumns[i];
          const path_displayColumns_item = path_displayColumns + '[' + i + ']';
          if (typeof obj_displayColumns_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_displayColumns_item + '" (at "' + path_displayColumns_item + '")');
          }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_filterLogicString = obj.filterLogicString;
        const path_filterLogicString = path + '.filterLogicString';
        let obj_filterLogicString_union0 = null;
        const obj_filterLogicString_union0_error = (() => {
          if (typeof obj_filterLogicString !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_filterLogicString + '" (at "' + path_filterLogicString + '")');
          }
        })();
        if (obj_filterLogicString_union0_error != null) {
          obj_filterLogicString_union0 = obj_filterLogicString_union0_error.message;
        }
        let obj_filterLogicString_union1 = null;
        const obj_filterLogicString_union1_error = (() => {
          if (obj_filterLogicString !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_filterLogicString + '" (at "' + path_filterLogicString + '")');
          }
        })();
        if (obj_filterLogicString_union1_error != null) {
          obj_filterLogicString_union1 = obj_filterLogicString_union1_error.message;
        }
        if (obj_filterLogicString_union0 && obj_filterLogicString_union1) {
          let message = 'Object doesn\'t match union (at "' + path_filterLogicString + '")';
          message += '\n' + obj_filterLogicString_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_filterLogicString_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_filteredByInfo = obj.filteredByInfo;
        const path_filteredByInfo = path + '.filteredByInfo';
        if (!ArrayIsArray(obj_filteredByInfo)) {
          return new TypeError('Expected "array" but received "' + typeof obj_filteredByInfo + '" (at "' + path_filteredByInfo + '")');
        }
        for (let i = 0; i < obj_filteredByInfo.length; i++) {
          const obj_filteredByInfo_item = obj_filteredByInfo[i];
          const path_filteredByInfo_item = path_filteredByInfo + '[' + i + ']';
          const referencepath_filteredByInfo_itemValidationError = validate$2a(obj_filteredByInfo_item, path_filteredByInfo_item);
          if (referencepath_filteredByInfo_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListFilterByInfoRepresentation (at "' + path_filteredByInfo_item + '")\n';
            message += referencepath_filteredByInfo_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        if (obj.hasMassActions !== undefined) {
          const obj_hasMassActions = obj.hasMassActions;
          const path_hasMassActions = path + '.hasMassActions';
          if (typeof obj_hasMassActions !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_hasMassActions + '" (at "' + path_hasMassActions + '")');
          }
        }
        const obj_inlineEditDetails = obj.inlineEditDetails;
        const path_inlineEditDetails = path + '.inlineEditDetails';
        const referencepath_inlineEditDetailsValidationError = validate$29(obj_inlineEditDetails, path_inlineEditDetails);
        if (referencepath_inlineEditDetailsValidationError !== null) {
          let message = 'Object doesn\'t match ListInlineEditDetailsRepresentation (at "' + path_inlineEditDetails + '")\n';
          message += referencepath_inlineEditDetailsValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        let obj_label_union0 = null;
        const obj_label_union0_error = (() => {
          if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
          }
        })();
        if (obj_label_union0_error != null) {
          obj_label_union0 = obj_label_union0_error.message;
        }
        let obj_label_union1 = null;
        const obj_label_union1_error = (() => {
          if (obj_label !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_label + '" (at "' + path_label + '")');
          }
        })();
        if (obj_label_union1_error != null) {
          obj_label_union1 = obj_label_union1_error.message;
        }
        if (obj_label_union0 && obj_label_union1) {
          let message = 'Object doesn\'t match union (at "' + path_label + '")';
          message += '\n' + obj_label_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_label_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referencepath_listReferenceValidationError = validate$28(obj_listReference, path_listReference);
        if (referencepath_listReferenceValidationError !== null) {
          let message = 'Object doesn\'t match ListReferenceRepresentation (at "' + path_listReference + '")\n';
          message += referencepath_listReferenceValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_listShares = obj.listShares;
        const path_listShares = path + '.listShares';
        if (!ArrayIsArray(obj_listShares)) {
          return new TypeError('Expected "array" but received "' + typeof obj_listShares + '" (at "' + path_listShares + '")');
        }
        for (let i = 0; i < obj_listShares.length; i++) {
          const obj_listShares_item = obj_listShares[i];
          const path_listShares_item = path_listShares + '[' + i + ']';
          const referencepath_listShares_itemValidationError = validate$26(obj_listShares_item, path_listShares_item);
          if (referencepath_listShares_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListInfoShareCategoryRepresentation (at "' + path_listShares_item + '")\n';
            message += referencepath_listShares_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_objectApiNames = obj.objectApiNames;
        const path_objectApiNames = path + '.objectApiNames';
        if (!ArrayIsArray(obj_objectApiNames)) {
          return new TypeError('Expected "array" but received "' + typeof obj_objectApiNames + '" (at "' + path_objectApiNames + '")');
        }
        for (let i = 0; i < obj_objectApiNames.length; i++) {
          const obj_objectApiNames_item = obj_objectApiNames[i];
          const path_objectApiNames_item = path_objectApiNames + '[' + i + ']';
          if (typeof obj_objectApiNames_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiNames_item + '" (at "' + path_objectApiNames_item + '")');
          }
        }
        const obj_orderedByInfo = obj.orderedByInfo;
        const path_orderedByInfo = path + '.orderedByInfo';
        if (!ArrayIsArray(obj_orderedByInfo)) {
          return new TypeError('Expected "array" but received "' + typeof obj_orderedByInfo + '" (at "' + path_orderedByInfo + '")');
        }
        for (let i = 0; i < obj_orderedByInfo.length; i++) {
          const obj_orderedByInfo_item = obj_orderedByInfo[i];
          const path_orderedByInfo_item = path_orderedByInfo + '[' + i + ']';
          const referencepath_orderedByInfo_itemValidationError = validate$25(obj_orderedByInfo_item, path_orderedByInfo_item);
          if (referencepath_orderedByInfo_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListOrderByInfoRepresentation (at "' + path_orderedByInfo_item + '")\n';
            message += referencepath_orderedByInfo_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_scope = obj.scope;
        const path_scope = path + '.scope';
        let obj_scope_union0 = null;
        const obj_scope_union0_error = (() => {
          const referencepath_scopeValidationError = validate$22(obj_scope, path_scope);
          if (referencepath_scopeValidationError !== null) {
            let message = 'Object doesn\'t match ListScopeRepresentation (at "' + path_scope + '")\n';
            message += referencepath_scopeValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_scope_union0_error != null) {
          obj_scope_union0 = obj_scope_union0_error.message;
        }
        let obj_scope_union1 = null;
        const obj_scope_union1_error = (() => {
          if (obj_scope !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_scope + '" (at "' + path_scope + '")');
          }
        })();
        if (obj_scope_union1_error != null) {
          obj_scope_union1 = obj_scope_union1_error.message;
        }
        if (obj_scope_union0 && obj_scope_union1) {
          let message = 'Object doesn\'t match union (at "' + path_scope + '")';
          message += '\n' + obj_scope_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_scope_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_searchable = obj.searchable;
        const path_searchable = path + '.searchable';
        if (typeof obj_searchable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_searchable + '" (at "' + path_searchable + '")');
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
        const obj_userPreferences = obj.userPreferences;
        const path_userPreferences = path + '.userPreferences';
        const referencepath_userPreferencesValidationError = validate$21(obj_userPreferences, path_userPreferences);
        if (referencepath_userPreferencesValidationError !== null) {
          let message = 'Object doesn\'t match ListUserPreferenceRepresentation (at "' + path_userPreferences + '")\n';
          message += referencepath_userPreferencesValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_visibility = obj.visibility;
        const path_visibility = path + '.visibility';
        if (typeof obj_visibility !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_visibility + '" (at "' + path_visibility + '")');
        }
        const obj_visibilityEditable = obj.visibilityEditable;
        const path_visibilityEditable = path + '.visibilityEditable';
        if (typeof obj_visibilityEditable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_visibilityEditable + '" (at "' + path_visibilityEditable + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$Y = 'ListInfoRepresentation';
    function keyBuilder$2a(luvio, config) {
      return keyPrefix + '::' + RepresentationType$Y + ':' + (config.listViewApiName === null ? '' : config.listViewApiName) + ':' + config.objectApiName + ':' + config.type;
    }
    function normalize$R(input, existing, path, luvio, store, timestamp) {
      const input_displayColumns = input.displayColumns;
      const input_displayColumns_id = path.fullPath + '__displayColumns';
      for (let i = 0; i < input_displayColumns.length; i++) {
        const input_displayColumns_item = input_displayColumns[i];
        let input_displayColumns_item_id = input_displayColumns_id + '__' + i;
        input_displayColumns[i] = ingest$S(input_displayColumns_item, {
          fullPath: input_displayColumns_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1X = function ListInfoRepresentationSelect() {
      const {
        selections: ListFilterByInfoRepresentation__selections,
        opaque: ListFilterByInfoRepresentation__opaque
      } = select$26();
      const {
        selections: ListInlineEditDetailsRepresentation__selections,
        opaque: ListInlineEditDetailsRepresentation__opaque
      } = select$25();
      const {
        selections: ListReferenceRepresentation__selections,
        opaque: ListReferenceRepresentation__opaque
      } = select$24();
      const {
        selections: ListInfoShareCategoryRepresentation__selections,
        opaque: ListInfoShareCategoryRepresentation__opaque
      } = select$22();
      const {
        selections: ListOrderByInfoRepresentation__selections,
        opaque: ListOrderByInfoRepresentation__opaque
      } = select$21();
      const {
        selections: ListScopeRepresentation__selections,
        opaque: ListScopeRepresentation__opaque
      } = select$1_();
      const {
        selections: ListUserPreferenceRepresentation__selections,
        opaque: ListUserPreferenceRepresentation__opaque
      } = select$1Z();
      return {
        kind: 'Fragment',
        version: VERSION$1i,
        private: ['eTag'],
        selections: [{
          name: 'cloneable',
          kind: 'Scalar'
        }, {
          name: 'createable',
          kind: 'Scalar'
        }, {
          name: 'deletable',
          kind: 'Scalar'
        }, {
          name: 'displayColumns',
          kind: 'Link',
          plural: true,
          fragment: select$1Y()
        }, {
          name: 'filterLogicString',
          kind: 'Scalar'
        }, {
          name: 'filteredByInfo',
          kind: 'Object',
          plural: true,
          selections: ListFilterByInfoRepresentation__selections
        }, {
          name: 'hasMassActions',
          kind: 'Scalar',
          required: false
        }, {
          name: 'inlineEditDetails',
          kind: 'Object',
          selections: ListInlineEditDetailsRepresentation__selections
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'listReference',
          kind: 'Object',
          selections: ListReferenceRepresentation__selections
        }, {
          name: 'listShares',
          kind: 'Object',
          plural: true,
          selections: ListInfoShareCategoryRepresentation__selections
        }, {
          name: 'objectApiNames',
          kind: 'Scalar',
          plural: true
        }, {
          name: 'orderedByInfo',
          kind: 'Object',
          plural: true,
          selections: ListOrderByInfoRepresentation__selections
        }, {
          name: 'scope',
          kind: 'Object',
          nullable: true,
          selections: ListScopeRepresentation__selections
        }, {
          name: 'searchable',
          kind: 'Scalar'
        }, {
          name: 'updateable',
          kind: 'Scalar'
        }, {
          name: 'userPreferences',
          kind: 'Object',
          selections: ListUserPreferenceRepresentation__selections
        }, {
          name: 'visibility',
          kind: 'Scalar'
        }, {
          name: 'visibilityEditable',
          kind: 'Scalar'
        }]
      };
    };
    function equals$17(existing, incoming) {
      if (existing.eTag !== incoming.eTag) {
        return false;
      }
      return true;
    }
    const ingest$R = function ListInfoRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1Z(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$F(luvio, input);
      const ttlToUse = TTL$B;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$R, "UiApi", VERSION$1i, RepresentationType$Y, equals$17);
      return createLink(key);
    };
    function getTypeCacheKeys$Z(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$F(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$Y,
        mergeable: false
      });
      const input_displayColumns_length = input.displayColumns.length;
      for (let i = 0; i < input_displayColumns_length; i++) {
        getTypeCacheKeys$_(rootKeySet, luvio, input.displayColumns[i], () => '');
      }
    }
    const notifyUpdateAvailableFactory$6 = luvio => {
      return function notifyListInfoUpdateAvailable(configs) {
        {
          const requiredKeyParams = ['listViewApiName', 'objectApiName', 'type'];
          configs.forEach(config => {
            if (false === requiredKeyParams.every(req => req in config)) {
              throw new Error(`one of the configs did not contain all required parameters: ${JSONStringify(ObjectKeys(config))}`);
            }
          });
        }
        const keys = configs.map(c => keyBuilder$2a(luvio, c));
        return luvio.notifyStoreUpdateAvailable(keys);
      };
    };
    const RECORD_ID_DECODER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456';
    /**
     * Converts to 18-char record ids. Details at http://sfdc.co/bnBMvm.
     * @param value A 15- or 18-char record id.
     * @returns An 18-char record id, and throws error if an invalid record id was provided.
     */
    function getRecordId18(value) {
      if (isString(value)) {
        if (value.length === 18) {
          return value;
        } else if (value.length === 15) {
          // Add the 3 character suffix
          let recordId = value;
          for (let offset = 0; offset < 15; offset += 5) {
            let decodeValue = 0;
            for (let bit = 0; bit < 5; bit++) {
              const c = value[offset + bit];
              if (c >= 'A' && c <= 'Z') {
                decodeValue += 1 << bit;
              }
            }
            recordId += RECORD_ID_DECODER[decodeValue];
          }
          return recordId;
        }
      } else if (value === undefined || value === null) {
        // Not throwing here - input params might not have settled
        return undefined;
      }
      {
        throw new Error(`Configuration Error: Invalid RecordId passed: ${JSON.stringify(value)}. RecordIds must be 15 or 18 character strings.`);
      }
    }
    function toSortedStringArray(value) {
      const valueArray = isArray(value) ? value : [value];
      if (valueArray.length !== 0 && isArrayOfNonEmptyStrings(valueArray)) {
        return dedupe(valueArray).sort();
      }
      return undefined;
    }
    const VERSION$1h = "d1e589a127fb1060c89070cdb6f500b2";
    function validate$1Y(obj, path = 'RecordTypeInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_available = obj.available;
        const path_available = path + '.available';
        if (typeof obj_available !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_available + '" (at "' + path_available + '")');
        }
        const obj_defaultRecordTypeMapping = obj.defaultRecordTypeMapping;
        const path_defaultRecordTypeMapping = path + '.defaultRecordTypeMapping';
        if (typeof obj_defaultRecordTypeMapping !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_defaultRecordTypeMapping + '" (at "' + path_defaultRecordTypeMapping + '")');
        }
        const obj_master = obj.master;
        const path_master = path + '.master';
        if (typeof obj_master !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_master + '" (at "' + path_master + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        if (typeof obj_recordTypeId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1W = function RecordTypeInfoRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1h,
        private: [],
        selections: [{
          name: 'available',
          kind: 'Scalar'
        }, {
          name: 'defaultRecordTypeMapping',
          kind: 'Scalar'
        }, {
          name: 'master',
          kind: 'Scalar'
        }, {
          name: 'name',
          kind: 'Scalar'
        }, {
          name: 'recordTypeId',
          kind: 'Scalar'
        }]
      };
    };
    function equals$16(existing, incoming) {
      const existing_available = existing.available;
      const incoming_available = incoming.available;
      if (!(existing_available === incoming_available)) {
        return false;
      }
      const existing_defaultRecordTypeMapping = existing.defaultRecordTypeMapping;
      const incoming_defaultRecordTypeMapping = incoming.defaultRecordTypeMapping;
      if (!(existing_defaultRecordTypeMapping === incoming_defaultRecordTypeMapping)) {
        return false;
      }
      const existing_master = existing.master;
      const incoming_master = incoming.master;
      if (!(existing_master === incoming_master)) {
        return false;
      }
      const existing_name = existing.name;
      const incoming_name = incoming.name;
      if (!(existing_name === incoming_name)) {
        return false;
      }
      const existing_recordTypeId = existing.recordTypeId;
      const incoming_recordTypeId = incoming.recordTypeId;
      if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
      }
      return true;
    }
    const VERSION$1g = "195d918987a35f45e1aa4dce9a11d8c5";
    function validate$1X(obj, path = 'FieldValueRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_displayValue = obj.displayValue;
        const path_displayValue = path + '.displayValue';
        let obj_displayValue_union0 = null;
        const obj_displayValue_union0_error = (() => {
          if (typeof obj_displayValue !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_displayValue + '" (at "' + path_displayValue + '")');
          }
        })();
        if (obj_displayValue_union0_error != null) {
          obj_displayValue_union0 = obj_displayValue_union0_error.message;
        }
        let obj_displayValue_union1 = null;
        const obj_displayValue_union1_error = (() => {
          if (obj_displayValue !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_displayValue + '" (at "' + path_displayValue + '")');
          }
        })();
        if (obj_displayValue_union1_error != null) {
          obj_displayValue_union1 = obj_displayValue_union1_error.message;
        }
        if (obj_displayValue_union0 && obj_displayValue_union1) {
          let message = 'Object doesn\'t match union (at "' + path_displayValue + '")';
          message += '\n' + obj_displayValue_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_displayValue_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_value = obj.value;
        const path_value = path + '.value';
        let obj_value_union0 = null;
        const obj_value_union0_error = (() => {
          if (typeof obj_value !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_value + '" (at "' + path_value + '")');
          }
        })();
        if (obj_value_union0_error != null) {
          obj_value_union0 = obj_value_union0_error.message;
        }
        let obj_value_union1 = null;
        const obj_value_union1_error = (() => {
          if (typeof obj_value !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_value + '" (at "' + path_value + '")');
          }
        })();
        if (obj_value_union1_error != null) {
          obj_value_union1 = obj_value_union1_error.message;
        }
        let obj_value_union2 = null;
        const obj_value_union2_error = (() => {
          if (typeof obj_value !== 'number') {
            return new TypeError('Expected "number" but received "' + typeof obj_value + '" (at "' + path_value + '")');
          }
        })();
        if (obj_value_union2_error != null) {
          obj_value_union2 = obj_value_union2_error.message;
        }
        let obj_value_union3 = null;
        const obj_value_union3_error = (() => {
          if (typeof obj_value !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_value + '" (at "' + path_value + '")');
          }
        })();
        if (obj_value_union3_error != null) {
          obj_value_union3 = obj_value_union3_error.message;
        }
        let obj_value_union4 = null;
        const obj_value_union4_error = (() => {
          if (obj_value !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_value + '" (at "' + path_value + '")');
          }
        })();
        if (obj_value_union4_error != null) {
          obj_value_union4 = obj_value_union4_error.message;
        }
        if (obj_value_union0 && obj_value_union1 && obj_value_union2 && obj_value_union3 && obj_value_union4) {
          let message = 'Object doesn\'t match union (at "' + path_value + '")';
          message += '\n' + obj_value_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_value_union1.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_value_union2.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_value_union3.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_value_union4.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$X = 'FieldValueRepresentation';
    function normalize$Q(input, existing, path, luvio, store, timestamp) {
      const input_value = input.value;
      const input_value_id = path.fullPath + '__value';
      if (input_value !== null && typeof input_value === 'object') {
        input.value = ingest$O(input_value, {
          fullPath: input_value_id,
          propertyName: 'value',
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1V = function FieldValueRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1g,
        private: [],
        selections: [{
          name: 'displayValue',
          kind: 'Scalar'
        }, {
          name: 'value',
          kind: 'Link',
          nullable: true,
          fragment: select$1T()
        }]
      };
    };
    function equals$15(existing, incoming) {
      const existing_displayValue = existing.displayValue;
      const incoming_displayValue = incoming.displayValue;
      if (!(existing_displayValue === incoming_displayValue)) {
        return false;
      }
      const existing_value = existing.value;
      const incoming_value = incoming.value;
      if (!(existing_value === incoming_value || existing_value != null && incoming_value != null && existing_value.__ref != null && incoming_value.__ref != null && existing_value.__ref === incoming_value.__ref)) {
        return false;
      }
      return true;
    }
    const ingest$Q = function FieldValueRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1X(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$Q, "UiApi", VERSION$1g, RepresentationType$X, equals$15);
      return createLink(key);
    };
    function getTypeCacheKeys$Y(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$X,
        mergeable: false
      });
      if (input.value !== null && typeof input.value === 'object') {
        getTypeCacheKeys$X(rootKeySet, luvio, input.value);
      }
    }

    // we override the generated so we can set "mergeable: true" on the root key
    const getTypeCacheKeys$X = (rootKeySet, luvio, input, _fullPathFactory) => {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$D(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$V,
        mergeable: true
      });
      const input_childRelationships = input.childRelationships;
      const input_childRelationships_keys = keys(input_childRelationships);
      const input_childRelationships_length = input_childRelationships_keys.length;
      for (let i = 0; i < input_childRelationships_length; i++) {
        const key = input_childRelationships_keys[i];
        getTypeCacheKeys$W(rootKeySet, luvio, input_childRelationships[key], () => rootKey + '__childRelationships' + '__' + key);
      }
      const input_fields = input.fields;
      const input_fields_keys = keys(input_fields);
      const input_fields_length = input_fields_keys.length;
      for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        getTypeCacheKeys$Y(rootKeySet, luvio, input_fields[key], () => rootKey + '__fields__' + key);
      }
      return rootKeySet;
    };
    const TTL$A = 120000;
    const VERSION$1f = "79cb5ac9f44542f683d00245fdfe500d";
    function validate$1W(obj, path = 'RecordCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count) {
          return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        let obj_currentPageToken_union0 = null;
        const obj_currentPageToken_union0_error = (() => {
          if (typeof obj_currentPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
          }
        })();
        if (obj_currentPageToken_union0_error != null) {
          obj_currentPageToken_union0 = obj_currentPageToken_union0_error.message;
        }
        let obj_currentPageToken_union1 = null;
        const obj_currentPageToken_union1_error = (() => {
          if (obj_currentPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
          }
        })();
        if (obj_currentPageToken_union1_error != null) {
          obj_currentPageToken_union1 = obj_currentPageToken_union1_error.message;
        }
        if (obj_currentPageToken_union0 && obj_currentPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_currentPageToken + '")';
          message += '\n' + obj_currentPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_currentPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
          if (typeof obj_nextPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union0_error != null) {
          obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
          if (obj_nextPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union1_error != null) {
          obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
          message += '\n' + obj_nextPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
          if (typeof obj_nextPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union0_error != null) {
          obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
          if (obj_nextPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union1_error != null) {
          obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
          message += '\n' + obj_nextPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
          if (typeof obj_previousPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union0_error != null) {
          obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
          if (obj_previousPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union1_error != null) {
          obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
          message += '\n' + obj_previousPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
          if (typeof obj_previousPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union0_error != null) {
          obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
          if (obj_previousPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union1_error != null) {
          obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
          message += '\n' + obj_previousPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (!ArrayIsArray(obj_records)) {
          return new TypeError('Expected "array" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        for (let i = 0; i < obj_records.length; i++) {
          const obj_records_item = obj_records[i];
          const path_records_item = path_records + '[' + i + ']';
          if (typeof obj_records_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_records_item + '" (at "' + path_records_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$W = 'RecordCollectionRepresentation';
    function normalize$P(input, existing, path, luvio, store, timestamp) {
      const input_records = input.records;
      const input_records_id = path.fullPath + '__records';
      for (let i = 0; i < input_records.length; i++) {
        const input_records_item = input_records[i];
        let input_records_item_id = input_records_id + '__' + i;
        input_records[i] = ingest$O(input_records_item, {
          fullPath: input_records_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1U = function RecordCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1f,
        private: [],
        selections: [{
          name: 'count',
          kind: 'Scalar'
        }, {
          name: 'currentPageToken',
          kind: 'Scalar'
        }, {
          name: 'currentPageUrl',
          kind: 'Scalar'
        }, {
          name: 'nextPageToken',
          kind: 'Scalar'
        }, {
          name: 'nextPageUrl',
          kind: 'Scalar'
        }, {
          name: 'previousPageToken',
          kind: 'Scalar'
        }, {
          name: 'previousPageUrl',
          kind: 'Scalar'
        }, {
          name: 'records',
          kind: 'Link',
          plural: true,
          fragment: select$1T()
        }]
      };
    };
    function equals$14(existing, incoming) {
      const existing_count = existing.count;
      const incoming_count = incoming.count;
      if (!(existing_count === incoming_count)) {
        return false;
      }
      const existing_currentPageUrl = existing.currentPageUrl;
      const incoming_currentPageUrl = incoming.currentPageUrl;
      if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
      }
      const existing_currentPageToken = existing.currentPageToken;
      const incoming_currentPageToken = incoming.currentPageToken;
      if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
      }
      const existing_nextPageToken = existing.nextPageToken;
      const incoming_nextPageToken = incoming.nextPageToken;
      if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
      }
      const existing_nextPageUrl = existing.nextPageUrl;
      const incoming_nextPageUrl = incoming.nextPageUrl;
      if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
      }
      const existing_previousPageToken = existing.previousPageToken;
      const incoming_previousPageToken = incoming.previousPageToken;
      if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
      }
      const existing_previousPageUrl = existing.previousPageUrl;
      const incoming_previousPageUrl = incoming.previousPageUrl;
      if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
      }
      const existing_records = existing.records;
      const incoming_records = incoming.records;
      const equals_records_items = equalsArray(existing_records, incoming_records, (existing_records_item, incoming_records_item) => {
        if (!(existing_records_item.__ref === incoming_records_item.__ref)) {
          return false;
        }
      });
      if (equals_records_items === false) {
        return false;
      }
      return true;
    }
    const ingest$P = function RecordCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1W(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$A;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$P, "UiApi", VERSION$1f, RepresentationType$W, equals$14);
      return createLink(key);
    };
    function getTypeCacheKeys$W(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$W,
        mergeable: false
      });
      const input_records_length = input.records.length;
      for (let i = 0; i < input_records_length; i++) {
        getTypeCacheKeys$X(rootKeySet, luvio, input.records[i]);
      }
    }
    const VIEW_ENTITY_API_NAME = 'Name';
    const VIEW_ENTITY_KEY_PREFIX = `${keyPrefix}::RecordViewEntityRepresentation:${VIEW_ENTITY_API_NAME}:`;
    const keyBuilderFromType$E = function RecordRepresentationKeyBuilderFromType(luvio, object) {
      const {
        apiName,
        id
      } = object;
      if (apiName === VIEW_ENTITY_API_NAME) {
        return VIEW_ENTITY_KEY_PREFIX + id;
      }
      return keyBuilderFromType$D(luvio, object);
    };
    const TTL$z = 30000;
    const VERSION$1e = "98c5b18512e48ca8d28727549507e4ba";
    function validate$1V(obj, path = 'RecordRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_childRelationships = obj.childRelationships;
        const path_childRelationships = path + '.childRelationships';
        if (typeof obj_childRelationships !== 'object' || ArrayIsArray(obj_childRelationships) || obj_childRelationships === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_childRelationships + '" (at "' + path_childRelationships + '")');
        }
        const obj_childRelationships_keys = ObjectKeys(obj_childRelationships);
        for (let i = 0; i < obj_childRelationships_keys.length; i++) {
          const key = obj_childRelationships_keys[i];
          const obj_childRelationships_prop = obj_childRelationships[key];
          const path_childRelationships_prop = path_childRelationships + '["' + key + '"]';
          if (typeof obj_childRelationships_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_childRelationships_prop + '" (at "' + path_childRelationships_prop + '")');
          }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray(obj_fields) || obj_fields === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
          const key = obj_fields_keys[i];
          const obj_fields_prop = obj_fields[key];
          const path_fields_prop = path_fields + '["' + key + '"]';
          if (typeof obj_fields_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
          }
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_lastModifiedById = obj.lastModifiedById;
        const path_lastModifiedById = path + '.lastModifiedById';
        let obj_lastModifiedById_union0 = null;
        const obj_lastModifiedById_union0_error = (() => {
          if (typeof obj_lastModifiedById !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
          }
        })();
        if (obj_lastModifiedById_union0_error != null) {
          obj_lastModifiedById_union0 = obj_lastModifiedById_union0_error.message;
        }
        let obj_lastModifiedById_union1 = null;
        const obj_lastModifiedById_union1_error = (() => {
          if (obj_lastModifiedById !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
          }
        })();
        if (obj_lastModifiedById_union1_error != null) {
          obj_lastModifiedById_union1 = obj_lastModifiedById_union1_error.message;
        }
        if (obj_lastModifiedById_union0 && obj_lastModifiedById_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lastModifiedById + '")';
          message += '\n' + obj_lastModifiedById_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lastModifiedById_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        let obj_lastModifiedDate_union0 = null;
        const obj_lastModifiedDate_union0_error = (() => {
          if (typeof obj_lastModifiedDate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
          }
        })();
        if (obj_lastModifiedDate_union0_error != null) {
          obj_lastModifiedDate_union0 = obj_lastModifiedDate_union0_error.message;
        }
        let obj_lastModifiedDate_union1 = null;
        const obj_lastModifiedDate_union1_error = (() => {
          if (obj_lastModifiedDate !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
          }
        })();
        if (obj_lastModifiedDate_union1_error != null) {
          obj_lastModifiedDate_union1 = obj_lastModifiedDate_union1_error.message;
        }
        if (obj_lastModifiedDate_union0 && obj_lastModifiedDate_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lastModifiedDate + '")';
          message += '\n' + obj_lastModifiedDate_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lastModifiedDate_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
          if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union0_error != null) {
          obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
          if (obj_recordTypeId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union1_error != null) {
          obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
          message += '\n' + obj_recordTypeId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_recordTypeId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_recordTypeInfo = obj.recordTypeInfo;
        const path_recordTypeInfo = path + '.recordTypeInfo';
        let obj_recordTypeInfo_union0 = null;
        const obj_recordTypeInfo_union0_error = (() => {
          const referencepath_recordTypeInfoValidationError = validate$1Y(obj_recordTypeInfo, path_recordTypeInfo);
          if (referencepath_recordTypeInfoValidationError !== null) {
            let message = 'Object doesn\'t match RecordTypeInfoRepresentation (at "' + path_recordTypeInfo + '")\n';
            message += referencepath_recordTypeInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_recordTypeInfo_union0_error != null) {
          obj_recordTypeInfo_union0 = obj_recordTypeInfo_union0_error.message;
        }
        let obj_recordTypeInfo_union1 = null;
        const obj_recordTypeInfo_union1_error = (() => {
          if (obj_recordTypeInfo !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_recordTypeInfo + '" (at "' + path_recordTypeInfo + '")');
          }
        })();
        if (obj_recordTypeInfo_union1_error != null) {
          obj_recordTypeInfo_union1 = obj_recordTypeInfo_union1_error.message;
        }
        if (obj_recordTypeInfo_union0 && obj_recordTypeInfo_union1) {
          let message = 'Object doesn\'t match union (at "' + path_recordTypeInfo + '")';
          message += '\n' + obj_recordTypeInfo_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_recordTypeInfo_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_systemModstamp = obj.systemModstamp;
        const path_systemModstamp = path + '.systemModstamp';
        let obj_systemModstamp_union0 = null;
        const obj_systemModstamp_union0_error = (() => {
          if (typeof obj_systemModstamp !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
          }
        })();
        if (obj_systemModstamp_union0_error != null) {
          obj_systemModstamp_union0 = obj_systemModstamp_union0_error.message;
        }
        let obj_systemModstamp_union1 = null;
        const obj_systemModstamp_union1_error = (() => {
          if (obj_systemModstamp !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
          }
        })();
        if (obj_systemModstamp_union1_error != null) {
          obj_systemModstamp_union1 = obj_systemModstamp_union1_error.message;
        }
        if (obj_systemModstamp_union0 && obj_systemModstamp_union1) {
          let message = 'Object doesn\'t match union (at "' + path_systemModstamp + '")';
          message += '\n' + obj_systemModstamp_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_systemModstamp_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_weakEtag = obj.weakEtag;
        const path_weakEtag = path + '.weakEtag';
        if (typeof obj_weakEtag !== 'number' || typeof obj_weakEtag === 'number' && Math.floor(obj_weakEtag) !== obj_weakEtag) {
          return new TypeError('Expected "integer" but received "' + typeof obj_weakEtag + '" (at "' + path_weakEtag + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$V = 'RecordRepresentation';
    function keyBuilder$29(luvio, config) {
      return keyPrefix + '::' + RepresentationType$V + ':' + config.recordId;
    }
    function keyBuilderFromType$D(luvio, object) {
      const keyParams = {
        recordId: object.id
      };
      return keyBuilder$29(luvio, keyParams);
    }
    function dynamicNormalize$5(ingestParams) {
      return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_childRelationships = input.childRelationships;
        const input_childRelationships_id = path.fullPath + '__childRelationships';
        const input_childRelationships_keys = Object.keys(input_childRelationships);
        const input_childRelationships_length = input_childRelationships_keys.length;
        for (let i = 0; i < input_childRelationships_length; i++) {
          const key = input_childRelationships_keys[i];
          const input_childRelationships_prop = input_childRelationships[key];
          const input_childRelationships_prop_id = input_childRelationships_id + '__' + key;
          input_childRelationships[key] = ingestParams.childRelationships(input_childRelationships_prop, {
            fullPath: input_childRelationships_prop_id,
            propertyName: key,
            parent: {
              data: input,
              key: path.fullPath,
              existing: existing
            },
            ttl: path.ttl
          }, luvio, store, timestamp);
        }
        const input_fields = input.fields;
        const input_fields_id = path.fullPath + '__fields';
        const input_fields_keys = Object.keys(input_fields);
        const input_fields_length = input_fields_keys.length;
        for (let i = 0; i < input_fields_length; i++) {
          const key = input_fields_keys[i];
          const input_fields_prop = input_fields[key];
          const input_fields_prop_id = input_fields_id + '__' + key;
          input_fields[key] = ingestParams.fields(input_fields_prop, {
            fullPath: input_fields_prop_id,
            propertyName: key,
            parent: {
              data: input,
              key: path.fullPath,
              existing: existing
            },
            ttl: path.ttl
          }, luvio, store, timestamp);
        }
        return input;
      };
    }
    const select$1T = function RecordRepresentationSelect() {
      const {
        selections: RecordTypeInfoRepresentation__selections,
        opaque: RecordTypeInfoRepresentation__opaque
      } = select$1W();
      return {
        kind: 'Fragment',
        version: VERSION$1e,
        private: ['eTag', 'weakEtag'],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'childRelationships',
          kind: 'Link',
          map: true,
          fragment: select$1U()
        }, {
          name: 'fields',
          kind: 'Link',
          map: true,
          fragment: select$1V()
        }, {
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'lastModifiedById',
          kind: 'Scalar'
        }, {
          name: 'lastModifiedDate',
          kind: 'Scalar'
        }, {
          name: 'recordTypeId',
          kind: 'Scalar'
        }, {
          name: 'recordTypeInfo',
          kind: 'Object',
          nullable: true,
          selections: RecordTypeInfoRepresentation__selections
        }, {
          name: 'systemModstamp',
          kind: 'Scalar'
        }]
      };
    };
    const dynamicSelect$8 = function dynamicRecordRepresentationSelect(params) {
      const childRelationshipsPathSelection = params.childRelationships === undefined ? {
        name: 'childRelationships',
        kind: 'Link',
        map: true,
        fragment: select$1U()
      } : params.childRelationships;
      const fieldsPathSelection = params.fields === undefined ? {
        name: 'fields',
        kind: 'Link',
        map: true,
        fragment: select$1V()
      } : params.fields;
      const {
        selections: RecordTypeInfoRepresentation__selections,
        opaque: RecordTypeInfoRepresentation__opaque
      } = select$1W();
      return {
        kind: 'Fragment',
        version: VERSION$1e,
        private: ['eTag', 'weakEtag'],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, childRelationshipsPathSelection, fieldsPathSelection, {
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'lastModifiedById',
          kind: 'Scalar'
        }, {
          name: 'lastModifiedDate',
          kind: 'Scalar'
        }, {
          name: 'recordTypeId',
          kind: 'Scalar'
        }, {
          name: 'recordTypeInfo',
          kind: 'Object',
          nullable: true,
          selections: RecordTypeInfoRepresentation__selections
        }, {
          name: 'systemModstamp',
          kind: 'Scalar'
        }]
      };
    };
    function equals$13(existing, incoming) {
      const existing_weakEtag = existing.weakEtag;
      const incoming_weakEtag = incoming.weakEtag;
      if (!(existing_weakEtag === incoming_weakEtag)) {
        return false;
      }
      const existing_apiName = existing.apiName;
      const incoming_apiName = incoming.apiName;
      if (!(existing_apiName === incoming_apiName)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_childRelationships = existing.childRelationships;
      const incoming_childRelationships = incoming.childRelationships;
      const equals_childRelationships_props = equalsObject(existing_childRelationships, incoming_childRelationships, (existing_childRelationships_prop, incoming_childRelationships_prop) => {
        if (!(existing_childRelationships_prop.__ref === incoming_childRelationships_prop.__ref)) {
          return false;
        }
      });
      if (equals_childRelationships_props === false) {
        return false;
      }
      const existing_fields = existing.fields;
      const incoming_fields = incoming.fields;
      const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
          return false;
        }
      });
      if (equals_fields_props === false) {
        return false;
      }
      const existing_lastModifiedById = existing.lastModifiedById;
      const incoming_lastModifiedById = incoming.lastModifiedById;
      if (!(existing_lastModifiedById === incoming_lastModifiedById)) {
        return false;
      }
      const existing_lastModifiedDate = existing.lastModifiedDate;
      const incoming_lastModifiedDate = incoming.lastModifiedDate;
      if (!(existing_lastModifiedDate === incoming_lastModifiedDate)) {
        return false;
      }
      const existing_recordTypeId = existing.recordTypeId;
      const incoming_recordTypeId = incoming.recordTypeId;
      if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
      }
      const existing_recordTypeInfo = existing.recordTypeInfo;
      const incoming_recordTypeInfo = incoming.recordTypeInfo;
      if (!(existing_recordTypeInfo === incoming_recordTypeInfo || existing_recordTypeInfo != null && incoming_recordTypeInfo != null && equals$16(existing_recordTypeInfo, incoming_recordTypeInfo))) {
        return false;
      }
      const existing_systemModstamp = existing.systemModstamp;
      const incoming_systemModstamp = incoming.systemModstamp;
      if (!(existing_systemModstamp === incoming_systemModstamp)) {
        return false;
      }
      return true;
    }
    function getTypeCacheKeys$V(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$E(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$V,
        mergeable: false
      });
      const input_childRelationships = input.childRelationships;
      const input_childRelationships_keys = ObjectKeys(input_childRelationships);
      const input_childRelationships_length = input_childRelationships_keys.length;
      for (let i = 0; i < input_childRelationships_length; i++) {
        const key = input_childRelationships_keys[i];
        getTypeCacheKeys$W(rootKeySet, luvio, input_childRelationships[key], () => rootKey + "__childRelationships" + "__" + key);
      }
      const input_fields = input.fields;
      const input_fields_keys = ObjectKeys(input_fields);
      const input_fields_length = input_fields_keys.length;
      for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        getTypeCacheKeys$Y(rootKeySet, luvio, input_fields[key], () => rootKey + "__fields" + "__" + key);
      }
    }
    const notifyUpdateAvailableFactory$5 = luvio => {
      return function notifyRecordUpdateAvailable(configs) {
        {
          const requiredKeyParams = ['recordId'];
          configs.forEach(config => {
            if (false === requiredKeyParams.every(req => req in config)) {
              throw new Error(`one of the configs did not contain all required parameters: ${JSONStringify(ObjectKeys(config))}`);
            }
          });
        }
        const keys = configs.map(c => keyBuilder$29(luvio, c));
        return luvio.notifyStoreUpdateAvailable(keys);
      };
    };

    /**
     * The master record type id.
     */
    const MAIN_RECORD_TYPE_ID = '012000000000000AAA';

    /**
     * A set of the string names of known entities.
     *
     * Generated
     *     from: ui-services-private-object-allow-list.yaml
     *     API version: 60
     *     at: Fri, 10 Nov 2023 19:35:20 GMT
     */
    const UIAPI_SUPPORTED_ENTITY_API_NAMES = new Set(['AIPredictionScore', 'AISentimentResult', 'AcademicSession', 'AcademicTerm', 'AcademicTermEnrollment', 'AcademicYear', 'Account', 'AccountAccountRelation', 'AccountBrand', 'AccountContactRelation', 'AccountForecast', 'AccountForecastAdjustment', 'AccountForecastPeriodMetric', 'AccountParticipant', 'AccountPartner', 'AccountProductForecast', 'AccountProductPeriodForecast', 'AccountRelationship', 'AccountTeamMember', 'Accreditation', 'AcctMgrPeriodicTargetDstr', 'AcctMgrTarget', 'AcctMgrTargetDstr', 'ActionCadence', 'ActionCadenceStep', 'ActionCadenceStepTracker', 'ActionCadenceTracker', 'ActionPlan', 'ActionPlanBaseTemplateAsgn', 'ActionPlanItem', 'ActionPlanItemDependency', 'ActionPlanTemplate', 'ActionPlanTemplateAssignment', 'ActionPlanTemplateItem', 'ActionPlanTemplateItemValue', 'ActionPlanTemplateVersion', 'ActionPlanTmplItmAssessmentInd', 'ActionPlnTmplItmDependency', 'ActionVisibility', 'ActionableList', 'ActionableListColumn', 'ActionableListMember', 'ActionableListMemberStatus', 'ActivationTarget', 'ActiveScratchOrg', 'ActivityMetric', 'ActivityMetricRollup', 'ActivityTiming', 'AdBuyServerAccount', 'AdCreativeSizeType', 'AdOpportunity', 'AdOrderItem', 'AdOrderItemCreativeSizeType', 'AdOrderItemPrintIssue', 'AdOrderItemUnitsSplit', 'AdOrderLineAdTarget', 'AdPageLayoutType', 'AdProductDefaultTargetCategory', 'AdProductTargetCategory', 'AdQuote', 'AdQuoteLine', 'AdQuoteLineAdTarget', 'AdQuoteLineCreativeSizeType', 'AdQuoteLinePrintIssue', 'AdQuoteLineUnitsSplit', 'AdServer', 'AdServerAccount', 'AdServerUser', 'AdSpaceCreativeSizeType', 'AdSpaceGroupMember', 'AdSpaceSpecification', 'AdSpecMediaPrintIssue', 'AdTargetCategory', 'AdTargetCategorySegment', 'AdUsage', 'AdUsageSummary', 'AddOnDefinition', 'Address', 'AdvAccountForecastFact', 'AdvAcctForecastSetPartner', 'AdvAcctForecastSetUse', 'AiDataset', 'AiImageDetectedObject', 'AiImageTrainingObject', 'AiVisionModel', 'AiVisionModelMetric', 'AiVisionModelObjectMetric', 'AiVisitRecommendRequest', 'AiVisitRecommendation', 'AiVisitSummary', 'AiVisitTaskRcmd', 'AiVisitTaskRcmdRequest', 'AirTravelEmssnFctr', 'AirTravelEnrgyUse', 'AllergyIntolerance', 'AlternativePaymentMethod', 'AnnualEmssnInventory', 'AnnualEmssnRdctnTarget', 'AntiCorruptionInitSum', 'ApiAnomalyEventStore', 'AppAnalyticsDeliveryConfig', 'AppAnalyticsQueryRequest', 'AppExtension', 'AppMenuItem', 'AppUsageAssignment', 'ApplicationCase', 'ApplicationDecision', 'ApplicationFormTemplate', 'ApplicationRecommendation', 'ApplicationRecommender', 'ApplicationReview', 'ApplicationTimeline', 'AppointmentInvitation', 'AppointmentInvitee', 'AppointmentReason', 'AppointmentTopicTimeSlot', 'ApptBundleAggrDurDnscale', 'ApptBundleAggrPolicy', 'ApptBundleConfig', 'ApptBundlePolicy', 'ApptBundlePolicySvcTerr', 'ApptBundlePropagatePolicy', 'ApptBundleRestrictPolicy', 'ApptBundleSortPolicy', 'ApptReasonEngmtChannelType', 'AsmtQstnRespRecommendation', 'Assessment', 'AssessmentEnvelope', 'AssessmentEnvelopeItem', 'AssessmentIndDefinedValue', 'AssessmentIndValue', 'AssessmentIndicatorDefinition', 'AssessmentQuestion', 'AssessmentQuestionAssignment', 'AssessmentQuestionResponse', 'AssessmentQuestionSet', 'AssessmentQuestionVersion', 'AssessmentSignature', 'AssessmentTask', 'AssessmentTaskContentDocument', 'AssessmentTaskDefinition', 'AssessmentTaskIndDefinition', 'AssessmentTaskOrder', 'Asset', 'AssetAccountParticipant', 'AssetAction', 'AssetActionSource', 'AssetAttribute', 'AssetContactParticipant', 'AssetDowntimePeriod', 'AssetMilestone', 'AssetRelationship', 'AssetStatePeriod', 'AssetWarranty', 'AssignedResource', 'AssistantText', 'AssociatedLocation', 'Assortment', 'AssortmentProduct', 'AsyncOperationLog', 'AttachedContentNote', 'AttributeCategory', 'AttributeDefinition', 'AttributePicklist', 'AttributePicklistValue', 'AuthApplicationAsset', 'AuthApplicationPlace', 'AuthFormRequestRecord', 'AuthLocationAccessSchedule', 'AuthorNote', 'AuthorizationForm', 'AuthorizationFormConsent', 'AuthorizationFormDataUse', 'AuthorizationFormText', 'AuthorizedInsuranceLine', 'AutomatedAction', 'AutomatedActionCondition', 'AutomatedActionParameter', 'Award', 'BCEntityPermission', 'BCEntityPermissionSet', 'BCFieldPermission', 'BCParticipant', 'BCParticipantAccess', 'BCPermissionSet', 'BCRecordAccess', 'BCRecordAccessApproval', 'BCRelatedParticipant', 'BackgroundOperation', 'Banker', 'BatchJob', 'BatchJobPartFailedRecord', 'Benefit', 'BenefitAssignment', 'BenefitAssignmentAdjustment', 'BenefitDisbursement', 'BenefitDisbursementAdj', 'BenefitParameterValue', 'BenefitSchedule', 'BenefitSession', 'BenefitType', 'BillingBatchFilterCriteria', 'BillingBatchScheduler', 'BillingPeriodItem', 'BillingPolicy', 'BillingSchedule', 'BillingScheduleCreationStatus', 'BillingScheduleGroup', 'BillingTreatment', 'BillingTreatmentItem', 'BldgEnrgyIntensity', 'BldgEnrgyIntensityVal', 'BldgSizeCategory', 'BlockchainAppMember', 'BlockchainApplication', 'BlockchainEntity', 'BlockchainField', 'BlockchainMember', 'BoardCertification', 'BranchUnit', 'BranchUnitBusinessMember', 'BranchUnitCustomer', 'BranchUnitRelatedRecord', 'BroadcastCommAudience', 'BroadcastCommunication', 'BroadcastTopic', 'Budget', 'BudgetAllocation', 'BudgetCategory', 'BudgetCategoryValue', 'BudgetPeriod', 'BundledCareFeeAgreement', 'BusRegAuthTypeDependency', 'BusRegAuthorizationType', 'BusinessAlert', 'BusinessAlertStatus', 'BusinessBrand', 'BusinessHours', 'BusinessLicense', 'BusinessLicenseApplication', 'BusinessMilestone', 'BusinessProfile', 'BusinessType', 'BuyerAccount', 'BuyerGroup', 'BuyerGroupPricebook', 'CalcProcStepRelationship', 'CalculationMatrix', 'CalculationMatrixColumn', 'CalculationMatrixRow', 'CalculationMatrixVersion', 'CalculationProcedure', 'CalculationProcedureStep', 'CalculationProcedureVariable', 'CalculationProcedureVersion', 'Campaign', 'CampaignInsight', 'CampaignMember', 'CampaignMemberStatus', 'CapitationCareFeeAgreement', 'CardPaymentMethod', 'CareBarrier', 'CareBarrierDeterminant', 'CareBarrierType', 'CareBenefitVerifyRequest', 'CareDeterminant', 'CareDeterminantType', 'CareDiagnosis', 'CareEpisode', 'CareEpisodeDetail', 'CareFeeScheduleItem', 'CareInterventionType', 'CareLimitType', 'CareMetricTarget', 'CareObservation', 'CareObservationComponent', 'CarePerformer', 'CarePgmEnrolleeWkOrdStep', 'CarePgmEnrolleeWorkOrder', 'CarePgmProvHealthcareProvider', 'CarePlan', 'CarePlanActivity', 'CarePlanActivityDetail', 'CarePlanDetail', 'CarePlanTemplate', 'CarePlanTemplateBenefit', 'CarePlanTemplateGoal', 'CarePlanTemplateProblem', 'CarePractnFacilityAppt', 'CarePreauth', 'CarePreauthItem', 'CareProgram', 'CareProgramCampaign', 'CareProgramEligibilityRule', 'CareProgramEnrollee', 'CareProgramEnrolleeProduct', 'CareProgramEnrollmentCard', 'CareProgramGoal', 'CareProgramProduct', 'CareProgramProvider', 'CareProgramTeamMember', 'CareProviderAdverseAction', 'CareProviderFacilitySpecialty', 'CareProviderSearchableField', 'CareRegisteredDevice', 'CareRequest', 'CareRequestDrug', 'CareRequestExtension', 'CareRequestItem', 'CareRequestReviewer', 'CareSpecialty', 'CareSpecialtyTaxonomy', 'CareTaxonomy', 'CartDeliveryGroup', 'CartItem', 'CartTax', 'Case', 'CaseArticle', 'CaseComment', 'CaseContactRole', 'CaseMilestone', 'CaseParticipant', 'CaseProgram', 'CaseRelatedIssue', 'CategorizedCareFeeAgreement', 'ChangeRequest', 'ChangeRequestRelatedIssue', 'ChangeRequestRelatedItem', 'ChannelObjectLinkingRule', 'ChannelProgram', 'ChannelProgramLevel', 'ChannelProgramMember', 'Claim', 'ClaimCase', 'ClaimCovPaymentAdjustment', 'ClaimCovReserveAdjustment', 'ClaimCoverage', 'ClaimCoveragePaymentDetail', 'ClaimCoverageReserveDetail', 'ClaimItem', 'ClaimParticipant', 'ClaimPaymentSummary', 'ClaimPayoutPlan', 'ClaimRecovery', 'ClaimTeamMember', 'ClauseCatgConfiguration', 'ClinicalAlert', 'ClinicalDetectedIssue', 'ClinicalDetectedIssueDetail', 'ClinicalEncounter', 'ClinicalEncounterDiagnosis', 'ClinicalEncounterFacility', 'ClinicalEncounterIdentifier', 'ClinicalEncounterProvider', 'ClinicalEncounterReason', 'ClinicalEncounterSvcRequest', 'ClinicalServiceRequest', 'ClinicalServiceRequestDetail', 'CloudServiceProvider', 'CodeSet', 'CodeSetBundle', 'CodeSetRelationship', 'CollaborationRoom', 'CommSubscription', 'CommSubscriptionChannelType', 'CommSubscriptionConsent', 'CommSubscriptionTiming', 'CommerceEntitlementPolicy', 'CommissionSchedule', 'CommissionScheduleAssignment', 'CommsRegionDiscount', 'CommsVolumeDiscount', 'ComplaintCase', 'ComplaintParticipant', 'ConsentMetric', 'ConsentUsageMetric', 'ConstituentRole', 'ConsumptionRate', 'ConsumptionSchedule', 'Contact', 'ContactContactRelation', 'ContactEncounter', 'ContactEncounterParticipant', 'ContactPointAddress', 'ContactPointConsent', 'ContactPointEmail', 'ContactPointPhone', 'ContactPointTypeConsent', 'ContactProfile', 'ContactRequest', 'ContentDocument', 'ContentDocumentLink', 'ContentDocumentListViewMapping', 'ContentFolderItem', 'ContentFolderLink', 'ContentNote', 'ContentVersion', 'ContentWorkspace', 'Contract', 'ContractContactRole', 'ContractDocVerContentDoc', 'ContractDocVersionSection', 'ContractDocumentVersion', 'ContractGroupPlan', 'ContractGroupPlanGroupClass', 'ContractLineItem', 'ContractLineOutcome', 'ContractLineOutcomeData', 'ContractPaymentAgreement', 'ContractType', 'ContractTypeConfig', 'ConversationBroadcast', 'ConversationBroadcastEntry', 'Coupon', 'CourseOffering', 'CourseOfferingParticipant', 'CourseOfferingPtcpResult', 'CourseOfferingSchedule', 'CourseOfferingScheduleTmpl', 'CoverageBenefit', 'CoverageBenefitItem', 'CoverageBenefitItemLimit', 'CoverageLimit', 'CoverageType', 'CrbnCreditAlloc', 'CrbnCreditAllocItem', 'CrbnCreditDistribution', 'CrbnCreditProject', 'CrbnEmssnScopeAlloc', 'CrbnEmssnScopeAllocVal', 'CredentialStuffingEventStore', 'CreditMemo', 'CreditMemoAddressGroup', 'CreditMemoInvApplication', 'CreditMemoLine', 'Crisis', 'CryptoProdCatgWalletGroup', 'CryptoProdtCatgWalletRole', 'CryptoProduct', 'CryptoTransEnvelopeChgLog', 'CryptoTransaction', 'CryptoTransactionEnvelope', 'CryptoWallet', 'CryptoWalletGroup', 'CryptoWalletGroupItem', 'CspTrustedSite', 'CustomObjectParticipant', 'Customer', 'CustomerProperty', 'DandBCompany', 'DataAction', 'DataActionTarget', 'DataConnectorS3', 'DataLakeObjectInstance', 'DataStream', 'DataUseLegalBasis', 'DataUsePurpose', 'DelegatedAccount', 'DeleteEvent', 'DeliveryTask', 'DiagnosticSummary', 'DiagnosticSummaryDetail', 'DigitalSignature', 'DigitalWallet', 'Disclosure', 'DisclosureDefinition', 'DisclosureDefinitionVersion', 'DisclosureType', 'DisclsReportingPeriod', 'DistributorAuthorization', 'DivrsEquityInclSum', 'DocTemplateSectionCondition', 'DocumentChecklistItem', 'DocumentClause', 'DocumentClauseSet', 'DocumentEnvelope', 'DocumentGenerationProcess', 'DocumentGenerationSetting', 'DocumentRecipient', 'DocumentTemplate', 'DocumentTemplateContentDoc', 'DocumentTemplateSection', 'DocumentTemplateToken', 'DrugDisplayTerm', 'DsarPolicyLog', 'DuplicateRecordItem', 'DuplicateRecordSet', 'ECart', 'EconomicPerformanceSum', 'EditionDefinition', 'EducationalInfoRequest', 'ElectricityEmssnFctrSet', 'ElectronicMediaGroup', 'EmailContent', 'EmailMessageRelation', 'EmissionsActivity', 'EmissionsForecastFact', 'EmpBenefitSummary', 'EmpUserProvisionProcessErr', 'EmpUserProvisioningProcess', 'Employee', 'EmployeeAsset', 'EmployeeContact', 'EmployeeCrisisAssessment', 'EmployeeDemographicSum', 'EmployeeDevelopmentSum', 'EmployeeJob', 'EmployeeJobPosition', 'EmployeeOrganization', 'EmssnRdctnCommitment', 'EmssnReductionTarget', 'EnablementProgram', 'EnblProgramSection', 'EnblProgramTaskDefinition', 'EnblProgramTaskProgress', 'EngagementAttendee', 'EngagementChannelType', 'EngagementChannelWorkType', 'EngagementInteraction', 'EngagementProgram', 'EngagementProgramVersion', 'EngagementTopic', 'EnhancedEmailTemplate', 'EnhancedLetterhead', 'EnrollmentEligibilityCriteria', 'Entitlement', 'EntitlementContact', 'EntityArchivingException', 'EntityArchivingJob', 'EntityArchivingSetup', 'EntityMilestone', 'EnvironmentHubMember', 'EnvironmentalRisk', 'Examination', 'Expense', 'ExpenseReport', 'ExpenseReportEntry', 'ExplainabilityMsgTemplate', 'ExpressionSet', 'ExpressionSetVersion', 'ExtDataShare', 'ExtDataShareTarget', 'ExternalAccountHierarchy', 'FTestVirtualBpoLookup', 'FeeScheduleDefinition', 'FeedItem', 'FieldServiceMobileExtension', 'FieldServiceMobileSettings', 'FieldServiceOrgSettings', 'FinanceBalanceSnapshot', 'FinanceBook', 'FinancePeriod', 'FinanceTransaction', 'FinanceTransactionErrorLog', 'FinancialDeal', 'FinancialDealAsset', 'FinancialDealBid', 'FinancialDealInteraction', 'FinancialDealParticipant', 'FinancialDealParty', 'FinancialDealProduct', 'FinclDealInteractionSummary', 'FlowInterview', 'FlowOrchestrationInstance', 'FlowOrchestrationStageInstance', 'FlowOrchestrationStepInstance', 'FlowOrchestrationWorkItem', 'ForecastingOwnerAdjustment', 'FrgtHaulingEmssnFctr', 'FrgtHaulingEnrgyUse', 'FtestBigObjectLookup', 'FtestConcrete', 'FtestConcrete6', 'FtestConcrete7', 'FtestConcrete8', 'FtestVirtualMain', 'FtestZosUiPrototypeChild1', 'FtestZosUiPrototypeChild2', 'FtestZosUiPrototypeParent', 'FulfillmentOrder', 'FulfillmentOrderLineItem', 'FundingAward', 'FundingAwardAmendment', 'FundingAwardRequirement', 'FundingDisbursement', 'FundingOpportunity', 'GeneratedDocument', 'GeneratedDocumentSection', 'GeneratedWaste', 'GenericVisitTask', 'GenericVisitTaskContext', 'GeoCountry', 'GeoState', 'GnrcVstKeyPerformanceInd', 'GnrcVstTaskContextRelation', 'GoalAssignment', 'GoalAssignmentDetail', 'GoalDefinition', 'GoalLink', 'GovtFinancialAsstSum', 'GroundTravelEmssnFctr', 'GroundTravelEnrgyUse', 'Group', 'GroupCensus', 'GroupCensusMember', 'GroupCensusMemberPlan', 'GroupClass', 'GroupClassContribution', 'GuestBuyerProfile', 'HealthCareDiagnosis', 'HealthCareProcedure', 'HealthCondition', 'HealthConditionDetail', 'HealthScore', 'HealthScoreActionLog', 'HealthcareFacility', 'HealthcareFacilityNetwork', 'HealthcarePayerNetwork', 'HealthcarePractitionerFacility', 'HealthcareProvider', 'HealthcareProviderNpi', 'HealthcareProviderSpecialty', 'HealthcareProviderTaxonomy', 'Holiday', 'HotelStayEmssnFctr', 'HotelStayEnrgyUse', 'IPAddressRange', 'Identifier', 'IdentityDocument', 'IdentityResolution', 'Image', 'InStoreLocation', 'Incident', 'IncidentRelatedItem', 'IncludedLicenseDefinition', 'Individual', 'IndividualApplication', 'IndividualApplicationItem', 'IndividualCrisisAssessment', 'InflationRate', 'InfoAuthRequestForm', 'InfoAuthorizationRequest', 'InsPolicyTransactionDetail', 'InsightsExternalData', 'InsightsExternalDataPart', 'InspectionAssessmentInd', 'InspectionType', 'InsuranceClaimAsset', 'InsuranceContract', 'InsurancePolicy', 'InsurancePolicyAsset', 'InsurancePolicyCoverage', 'InsurancePolicyMemberAsset', 'InsurancePolicyOwner', 'InsurancePolicyParticipant', 'InsurancePolicySurcharge', 'InsurancePolicyTransaction', 'InsuranceProfile', 'Interaction', 'InteractionAttendee', 'InteractionParticipant', 'InteractionRelatedAccount', 'InteractionSumDiscussedAccount', 'InteractionSummary', 'InteractionSummaryParticipant', 'InterestTag', 'InternalOrganizationUnit', 'InventoryItemReservation', 'InventoryReservation', 'Invoice', 'InvoiceAddressGroup', 'InvoiceBatchRun', 'InvoiceBatchRunCriteria', 'InvoiceBatchRunRecovery', 'InvoiceLine', 'JobFamily', 'JobPosition', 'JobProfile', 'JournalSubType', 'JournalType', 'KnowledgeArticleVersion', 'Lead', 'LeadLineItem', 'LeadPreferredSeller', 'LearnerProgram', 'LearnerProgramRequirement', 'LearnerProgramRqmtProgress', 'Learning', 'LearningAchievement', 'LearningCourse', 'LearningFoundationItem', 'LearningItem', 'LearningItemAssignment', 'LearningItemProgress', 'LearningOutcomeItem', 'LearningProgram', 'LearningProgramPlan', 'LearningProgramPlanRqmt', 'LegalEntity', 'LicensingError', 'LicensingRequest', 'LicensingRequestOrderItem', 'LicensingSnapshotRequest', 'LinkedArticle', 'ListEmail', 'LiveAgentSession', 'LiveChatButton', 'LiveChatDeployment', 'LiveChatSensitiveDataRule', 'LiveChatTranscript', 'LiveChatVisitor', 'LoanApplicant', 'LoanApplicantAddress', 'LoanApplicantAsset', 'LoanApplicantDeclaration', 'LoanApplicantEmployment', 'LoanApplicantIncome', 'LoanApplicantLiability', 'LoanApplicationAsset', 'LoanApplicationFinancial', 'LoanApplicationLiability', 'LoanApplicationProperty', 'LoanApplicationTitleHolder', 'LocWaitlistMsgTemplate', 'Location', 'LocationGroup', 'LocationGroupAssignment', 'LocationTrustMeasure', 'LocationWaitlist', 'LocationWaitlistedParty', 'LoyaltyLedger', 'LoyaltyMemberCurrency', 'LoyaltyMemberTier', 'LoyaltyMembershipLifecycle', 'LoyaltyPartnerProduct', 'LoyaltyPgmEngmtAttrProm', 'LoyaltyPgmEngmtAttribute', 'LoyaltyPgmGroupMbrRlnsp', 'LoyaltyPgmMbrAttributeVal', 'LoyaltyPgmPartnerCurrency', 'LoyaltyPgmPartnerPromotion', 'LoyaltyPgmPtnrLdgrSummary', 'LoyaltyPgmPtnrPrepaidPack', 'LoyaltyProgram', 'LoyaltyProgramBadge', 'LoyaltyProgramCurrency', 'LoyaltyProgramMbrPromotion', 'LoyaltyProgramMember', 'LoyaltyProgramMemberBadge', 'LoyaltyProgramMemberCase', 'LoyaltyProgramMemberMerge', 'LoyaltyProgramPartner', 'LoyaltyProgramProcess', 'LoyaltyProgramWidget', 'LoyaltyTier', 'LoyaltyTierBenefit', 'LoyaltyTierGroup', 'Macro', 'MaintenanceAsset', 'MaintenancePlan', 'MaintenanceWorkRule', 'ManagedContent', 'ManagedContentVariant', 'ManufacturingProgram', 'MarketSegment', 'MarketSegmentActivation', 'MarketingAction', 'MarketingForm', 'MarketingLink', 'MarketingLinkContent', 'MarketingResource', 'MedReconRecommendation', 'MedReconStmtRecommendation', 'MedTherapyStmtReviewIssue', 'MediaChannel', 'MediaContentTitle', 'MediaPrintIssue', 'MediaTitleAvailability', 'MediaTitleReleaseDate', 'MediaTitleRevenue', 'Medication', 'MedicationDispense', 'MedicationReconciliation', 'MedicationRequest', 'MedicationStatement', 'MedicationStatementDetail', 'MedicationTherapyReview', 'MedicationTherapyStmtReview', 'MedicinalIngredient', 'MemberBenefit', 'MemberPlan', 'MerchantAccount', 'MessagingChannel', 'MessagingDeliveryError', 'MessagingEndUser', 'MessagingSession', 'Metric', 'MfgProgramCpntFrcstFact', 'MfgProgramForecastFact', 'MfgProgramVariantFrcstFact', 'MktAiPredictiveInsight', 'MktCalculatedInsight', 'MktDataTransform', 'MktMLModel', 'MobileSettingsAssignment', 'MsgChannelLanguageKeyword', 'MultipartyInfoAuthRequest', 'NamespaceRegistry', 'NetworkReferencedObject', 'Note', 'ObjectRelatedUrl', 'ObjectStateActionDefinition', 'ObjectStateDefinition', 'ObjectStateTransition', 'ObjectStateTransitionAction', 'ObjectStateValue', 'ObjectTerritory2Association', 'OcrDocumentScanResult', 'OmniAssessmentTask', 'OmniDataPack', 'OmniDataTransform', 'OmniDataTransformItem', 'OmniESignatureTemplate', 'OmniProcess', 'OmniProcessAsmtQuestionVer', 'OmniProcessCompilation', 'OmniProcessElement', 'OmniProcessTransientData', 'OmniScriptSavedSession', 'OmniUiCard', 'OperatingHours', 'OperatingHoursHoliday', 'Opportunity', 'OpportunityContactRole', 'OpportunityHistory', 'OpportunityLineItem', 'OpportunityLineItemSchedule', 'OpportunityLineItemSplit', 'OpportunityParticipant', 'OpportunityPartner', 'OpportunityPreferredSeller', 'OpportunitySplit', 'OpportunityTeamMember', 'Order', 'OrderAction', 'OrderAdjustmentGroup', 'OrderAdjustmentGroupSummary', 'OrderChangeLog', 'OrderDeliveryGroup', 'OrderDeliveryGroupSummary', 'OrderDeliveryMethod', 'OrderItem', 'OrderItemAdjustmentLineItem', 'OrderItemAdjustmentLineSummary', 'OrderItemConsumptionRate', 'OrderItemConsumptionSchedule', 'OrderItemRelationship', 'OrderItemSummary', 'OrderItemSummaryChange', 'OrderItemTaxLineItem', 'OrderItemTaxLineItemSummary', 'OrderPaymentSummary', 'OrderSummary', 'OrderSummaryRoutingSchedule', 'OrgIncidentSummary', 'OrgMetric', 'OrgMetricScanResult', 'OrgMetricScanSummary', 'Organization', 'OtherComponentTask', 'OtherEmssnFctrSet', 'OtherEmssnFctrSetItem', 'Partner', 'PartnerFundAllocation', 'PartnerFundClaim', 'PartnerFundRequest', 'PartnerMarketingBudget', 'PartyCertifiedCapacity', 'PartyConsent', 'PartyIdentityVerification', 'PartyIdentityVerificationStep', 'PartyIncome', 'PartyProfile', 'PartyProfileAddress', 'PartyProfileRisk', 'PartyRelationshipGroup', 'PartyRoleRelation', 'PartyScreeningStep', 'PartyScreeningSummary', 'PatientHealthReaction', 'PatientImmunization', 'PatientImmunizationProtocol', 'PatientMedicalProcedure', 'PatientMedicalProcedureDetail', 'PatientMedicationDosage', 'PaymentAuthAdjustment', 'PaymentBatchRun', 'PaymentBatchRunCriteria', 'PaymentGateway', 'PaymentGatewayLog', 'PaymentGatewayProvider', 'PaymentIntent', 'PaymentLineInvoice', 'PaymentRequest', 'PaymentRequestLine', 'PaymentSchedule', 'PaymentScheduleItem', 'PaymentSchedulePolicy', 'PaymentScheduleTreatment', 'PaymentScheduleTreatmentDtl', 'PaymentTerm', 'PaymentTermItem', 'PcmtEmssnFctrSet', 'PcmtEmssnFctrSetItem', 'PercentileBsdCareFeeAgreement', 'Period', 'PersonAccount', 'PersonDisability', 'PersonEducation', 'PersonEmployment', 'PersonExamination', 'PersonLanguage', 'PersonLifeEvent', 'PersonList', 'PersonName', 'PgmRebateTypBnftMapping', 'PickTicket', 'PickTicketAssignment', 'PickTicketProduct', 'PlanBenefit', 'PlanBenefitItem', 'PlatformLicenseDefinition', 'Polygon', 'PreliminaryApplicationRef', 'PreventiveCareAgreement', 'PriceAdjustmentGroupShape', 'PriceAdjustmentItemShape', 'PriceAdjustmentSchedule', 'PriceAdjustmentTier', 'PriceList', 'PriceRule', 'PriceRuleAction', 'PriceRuleActionItem', 'PriceRuleCondition', 'PriceRuleConditionFilter', 'PriceRuleExecutionStage', 'Pricebook2', 'PricebookEntry', 'PricingHeader', 'PricingLineItem', 'PricingProduct', 'PrivacyHold', 'PrivacyHoldReason', 'PrivacyJobSession', 'PrivacyPolicy', 'PrivacyRequest', 'Problem', 'ProblemDefinition', 'ProblemGoalDefinition', 'ProblemIncident', 'ProblemRelatedItem', 'ProcessDefinition', 'ProcessException', 'ProcessInstance', 'Producer', 'ProducerCommission', 'ProducerPolicyAssignment', 'Product2', 'Product2DataTranslation', 'ProductAttribute', 'ProductAttributeDefinition', 'ProductAttributeSet', 'ProductAttributeSetItem', 'ProductAttributeSetProduct', 'ProductAvailabilityProjection', 'ProductCatalog', 'ProductCategory', 'ProductCategoryAttribute', 'ProductCategoryDataTranslation', 'ProductCategoryMedia', 'ProductCategoryProduct', 'ProductCategoryServiceProcess', 'ProductComponentGroup', 'ProductConfigurationalRule', 'ProductConsumed', 'ProductConsumedState', 'ProductConsumptionSchedule', 'ProductCoverage', 'ProductCoverageLimit', 'ProductEmissionsFactor', 'ProductFaultCode', 'ProductFulfillmentLocation', 'ProductItem', 'ProductItemTransaction', 'ProductLaborCode', 'ProductLicenseMap', 'ProductMedia', 'ProductOverridePathItem', 'ProductQuantityRule', 'ProductRelComponentOverride', 'ProductRelatedComponent', 'ProductRelatedMaterial', 'ProductRelatedServiceProcess', 'ProductRelationshipType', 'ProductRequest', 'ProductRequestLineItem', 'ProductRequired', 'ProductSellingModel', 'ProductSellingModelOption', 'ProductServiceCampaign', 'ProductServiceCampaignItem', 'ProductSpecificationType', 'ProductTransfer', 'ProductTransferState', 'ProductWarrantyTerm', 'ProfileSkill', 'ProfileSkillEndorsement', 'ProfileSkillUser', 'Program', 'ProgramEnrollment', 'ProgramProduct', 'ProgramRebateTypPayoutSrc', 'ProgramRebateType', 'ProgramRebateTypeBenefit', 'ProgramRebateTypeFilter', 'ProgramRebateTypePayout', 'ProgramRebateTypeProduct', 'ProgramRebateTypeReference', 'ProgramTermApplnTimeline', 'Promotion', 'PromotionChannel', 'PromotionDataTranslation', 'PromotionLoyaltyPtnrProdt', 'PromotionMarketSegment', 'PromotionProduct', 'PromotionProductCategory', 'PromotionQualifier', 'PromotionSegment', 'PromotionSegmentBuyerGroup', 'PromotionSegmentSalesStore', 'PromotionTarget', 'PromotionTier', 'ProrationPolicy', 'ProviderNetworkContract', 'ProviderNetworkTier', 'ProviderSearchSyncLog', 'ProvisioningRun', 'ProvisioningRunEvent', 'ProvisioningTargetGroup', 'ProvisioningTargetItem', 'ProvisioningTargetRole', 'PublicApplicationParticipant', 'PublicComplaint', 'PublicProgram', 'PurchaseQuantityRule', 'PurchaserPlan', 'PurchaserPlanAssn', 'PymtSchdDistributionMethod', 'QuickText', 'Quote', 'QuoteDocument', 'QuoteItemTaxItem', 'QuoteLineItem', 'QuoteLineItemAttribute', 'QuoteLinePriceAdjustment', 'QuoteLineRelationship', 'RebateClaim', 'RebateMemberAggregateItem', 'RebateMemberProductAggregate', 'RebatePayment', 'RebatePayoutAdjustment', 'RebateProgram', 'RebateProgramMember', 'RebateProgramMemberPayout', 'RebateProgramPayoutPeriod', 'ReceivedDocument', 'ReceivedDocumentType', 'Recommendation', 'RecordAction', 'RecordAlert', 'RecordType', 'RecordsetFilterCriteria', 'RecordsetFilterCriteriaRule', 'RecordsetFltrCritMonitor', 'RecurrenceSchedule', 'ReferencedDashboard', 'Referral', 'RefrigerantEmssnFctr', 'RefundLinePayment', 'RegAuthorizationTypeProduct', 'RegionStatusDiscount', 'RegulatoryAuthority', 'RegulatoryAuthorizationType', 'RegulatoryCode', 'RegulatoryCodeAssessmentInd', 'RegulatoryCodeUse', 'RegulatoryCodeViolation', 'RegulatoryTrxnFee', 'RegulatoryTrxnFeeItem', 'ReinsAgreementLineItem', 'ReinsPolicyBordereauFact', 'ReinsProtocolProdtComponent', 'ReinsuranceAgreement', 'ReinsuranceProtocol', 'ReinsuranceProtocolAgreement', 'RentalCarEmssnFctr', 'RentalCarEnrgyUse', 'ReplyText', 'Report', 'ReportAnomalyEventStore', 'ReportedConsumption', 'ResidentialLoanApplication', 'ResourceAbsence', 'ResourcePreference', 'RetailLocationGroup', 'RetailStore', 'RetailStoreGroupAssignment', 'RetailStoreKpi', 'RetailVisitKpi', 'ReturnOrder', 'ReturnOrderItemAdjustment', 'ReturnOrderItemTax', 'ReturnOrderLineItem', 'RevRecogTreatmentItemGroup', 'RevenueAsyncOperation', 'RevenueDistributionMethod', 'RevenueElement', 'RevenueElementDistribution', 'RevenueRecogTreatmentItem', 'RevenueRecognitionPolicy', 'RevenueRecognitionTreatment', 'RevenueTransactionErrorLog', 'RightsQuote', 'RightsQuoteLineItem', 'RightsQuoteLineMediaTitle', 'SalesAgreement', 'SalesAgreementProduct', 'SalesAgreementProductSchedule', 'SalesChannel', 'SalesContractLine', 'SalesTransactionItemShape', 'SalesTransactionShape', 'SalesTrxnItemRelationShape', 'SalesforceContract', 'SalesforceInvoice', 'SalesforceQuote', 'SchedulingConstraint', 'Scope3CrbnFtprnt', 'Scope3EmssnSrc', 'Scope3PcmtItem', 'Scope3PcmtSummary', 'Scorecard', 'ScorecardAssociation', 'ScorecardMetric', 'ScratchOrgInfo', 'SearchPromotionRule', 'SecuritiesHolding', 'Seller', 'SerializedProduct', 'SerializedProductTransaction', 'ServiceAppointment', 'ServiceAppointmentCapacityUsage', 'ServiceAppointmentGroup', 'ServiceContract', 'ServiceCrew', 'ServiceCrewMember', 'ServiceReport', 'ServiceReportLayout', 'ServiceResource', 'ServiceResourceCapacity', 'ServiceResourceDataTranslation', 'ServiceResourcePreference', 'ServiceResourceSkill', 'ServiceTerritory', 'ServiceTerritoryDataTranslation', 'ServiceTerritoryLocation', 'ServiceTerritoryMember', 'ServiceTerritoryRelationship', 'ServiceTerritoryWorkType', 'SessionHijackingEventStore', 'SettingUsageDefinition', 'SettingUsageMap', 'SetupAssistantStep', 'SharedSavingPaymentAgreement', 'SharingRecordCollection', 'SharingRecordCollectionItem', 'Shift', 'ShiftEngagementChannel', 'ShiftPattern', 'ShiftPatternEntry', 'ShiftSegment', 'ShiftSegmentType', 'ShiftTemplate', 'ShiftWorkTopic', 'Shipment', 'ShipmentItem', 'SignatureTask', 'SignatureTaskLineItem', 'Skill', 'SkillLevelDefinition', 'SkillRequirement', 'Snippet', 'SnippetAssignment', 'SocialContributionSum', 'SocialPersona', 'SocialPost', 'StandardCareFeeAgreement', 'StandardPermissionSet', 'StaticResource', 'StnryAssetAnnualFact', 'StnryAssetCrbnFtprnt', 'StnryAssetCrbnFtprntItm', 'StnryAssetEnrgyUse', 'StnryAssetEnvrSrc', 'StnryAssetWaterActvty', 'StnryAssetWaterFtprnt', 'StnryAssetWtrFtprntItm', 'StoreActionPlanTemplate', 'StoreAssortment', 'StoreProduct', 'StreamingChannel', 'SuccessTeam', 'Supplier', 'SupplierProduct', 'Survey', 'SurveyEmailBranding', 'SurveyInvitation', 'SurveyQuestion', 'SurveyQuestionChoice', 'SurveyQuestionResponse', 'SurveyResponse', 'SurveySubject', 'SustainabilityCntrLine', 'SustainabilityCredit', 'SustainabilityPurchase', 'SustainabilityScorecard', 'SvcCatalogCategory', 'SvcCatalogCategoryItem', 'SvcCatalogItemDef', 'SvcCatalogReqExtdAttrVal', 'SvcCatalogReqRelatedItem', 'SvcCatalogRequest', 'Swarm', 'SwarmMember', 'TagCategory', 'TagCategoryAssignment', 'TaxDisclosureSummary', 'TaxEngine', 'TaxEngineInteractionLog', 'TaxEngineProvider', 'TaxGeoConfig', 'TaxPolicy', 'TaxRate', 'TaxTreatment', 'Tenant', 'TenantParameterMap', 'ThreatDetectionFeedback', 'TimeSheet', 'TimeSheetEntry', 'TimeSlot', 'Topic', 'TopicAssignment', 'TrackedCommunication', 'TrackedCommunicationDetail', 'TrainingCourseParticipant', 'TransactionJournal', 'Translation', 'TravelMode', 'TrialEnvironmentSignup', 'TrnCourse', 'UnitOfMeasure', 'UnitOfMeasureConversion', 'UsageEntitlement', 'UsageEntitlementPeriod', 'UsageEntitlementUsage', 'UsageFactor', 'UsageImpactFactor', 'UsageImpactGroup', 'UsageImpactGroupFactor', 'UsageImpactGroupPgmMeasure', 'UsageImpactGroupVersion', 'User', 'UserEsignVendorIdentifier', 'UserFinancialAuthority', 'UserLicenseDefinition', 'UserLocationAssignment', 'UserRole', 'Vehicle', 'VehicleAssetCrbnFtprnt', 'VehicleAssetEmssnSrc', 'VehicleAssetEnrgyUse', 'VehicleDefinition', 'VehicleUserAssignment', 'VideoCall', 'ViolationEnforcementAction', 'ViolationType', 'ViolationTypeAssessmentInd', 'ViolationTypeUse', 'Visit', 'VisitedParty', 'Visitor', 'VoiceCall', 'VolumeDiscount', 'VolunteerProject', 'Voucher', 'VoucherDefinition', 'WarrantyTerm', 'WarrantyTermCoverage', 'WasteFootprint', 'WasteFootprintItem', 'WaveAutoInstallRequest', 'WebCart', 'WebStore', 'WebStoreBuyerGroup', 'WebStoreCatalog', 'WebStoreInventorySource', 'WebStorePricebook', 'WebStoreSearchProdSettings', 'WorkCapacityLimit', 'WorkCapacityUsage', 'WorkCoaching', 'WorkContract', 'WorkOrder', 'WorkOrderLineItem', 'WorkPlan', 'WorkPlanSelectionRule', 'WorkPlanTemplate', 'WorkPlanTemplateEntry', 'WorkProcedure', 'WorkProcedureStep', 'WorkRewardFund', 'WorkRewardFundType', 'WorkStep', 'WorkStepTemplate', 'WorkType', 'WorkTypeCareSpecialty', 'WorkTypeCodeSetBundle', 'WorkTypeExtension', 'WorkTypeGroup', 'WorkTypeGroupDataTranslation', 'WorkTypeGroupMember', 'WorkTypeGroupRole', 'WorkerCompCoverageClass', 'WstDispoEmssnFctrSet', 'WstDispoEmssnFctrSetItm']);
    /**
     * A set of the string names of known entities.
     *
     * Generated
     *     from: ui-services-private-object-deny-list.yaml
     *     API version: 60
     *     at: Fri, 10 Nov 2023 19:35:20 GMT
     */
    const UIAPI_DENIED_ENTITY_API_NAMES = new Set(['AIProductOptimizedField', 'ASEOrgSyncHealthStats', 'ASEOrgSyncHealthTxns', 'ActionableOrchResponseEvent', 'ActionableOrchSourceEvent', 'ActnblListKeyPrfmIndAsgnt', 'ApplicationSectionDefinition', 'ApplnStageSectionDefinition', 'AssetThresholdUpdateEvent', 'BulkApi2JobResultsEvent', 'BulkApi2JobStatusEvent', 'BulkMessage', 'CommerceJobStatus', 'CommerceSearchResultsRule', 'CompiledProduct', 'ConsentUnsubscribeEvent', 'ContentTaxonomyModel', 'ContextPersistenceEvent', 'ContractCreationEvent', 'ConvIntelligenceVoiceCall', 'ConvMessageSendRequest', 'ConversationInsightEvent', 'ConversationTranscriptSendRequest', 'DataActionJobStatusEvent', 'DataCloudCurrencyConfig', 'DataCloudFiscalCalendar', 'DataMultiOrgServiceEvent', 'DataObjectDependency', 'DecisionTableRecordset', 'DiscoveryFrwrkSampleTemplate', 'DiscoveryFrwrkTemplateMember', 'DocumentExtReviewerConsent', 'EmailBounceEvent', 'ExtKnowledgeIngestionStatus', 'ExtKnowledgeIngestionTask', 'ExtKnowledgeOrgStatus', 'ExtKnowledgeXDSConnector', 'ExternalDocRefMapping', 'ExternalEncryptionRootKey', 'FirstBillPaymentSetupEvent', 'FlowDefDataActionMapping', 'GenericHammerResult', 'GeolocationBasedAction', 'InsuranceRatingInput', 'InsuranceRatingOutput', 'InsuranceRatingRequestEvent', 'InsuranceRatingRequestItem', 'InterviewItemWaitCondition', 'MLFeature', 'ManagedContentJobBody', 'ManagedContentOffCoreLocation', 'ManagedContentSpaceFolderShare', 'MerchantAccountEvent', 'MessagingChannelUpdateEvent', 'MetricsDeletionJobStatus', 'MktMLModelPartitionRun', 'MktMLModelSetupRun', 'MktMLSetupRunChgEvent', 'MngContentFormActionEvent', 'ObjectUserTerritory2View', 'OrgSharingEvent', 'PaymentIntentEvent', 'PaymentLinkEvent', 'PlatformEventUsage', 'PriceSheetData', 'PricingDecisionHashMap', 'PricingLookupSyncStatus', 'PushUpgradeCustomization', 'QuoteSaveEvent', 'RelationshipGraphView', 'Rule', 'RuleAction', 'RuleActionParameter', 'RuleCondition', 'RuleDeploymentRequestEvent', 'RuleExpression', 'RuleExpressionTerm', 'RuleFilterCriteria', 'RuleLibrary', 'RuleReferenceVariable', 'RuleValue', 'RuleVersion', 'Ruleset', 'RulesetDependency', 'RulesetVersion', 'SalesTrxnItemPrcSht', 'SalesTrxnItemPrcShtShape', 'SavedPaymentMethodEvent', 'ScheduledReminder', 'SearchBBRule', 'SearchBBRuleCondition', 'ServiceAppointmentEvent', 'SiqOrgMigrationStatus', 'StatsInvalidationEvent', 'TenantBillingUsageEvent', 'WebPushMessageSubscription', 'WebStoreCMS', 'WebStoreUserCreatedEvent']);
    const MAX_RECORD_DEPTH = 5;
    const FIELD_SEPARATOR = '.';
    const SCALAR_VALUE_SELECTION = {
      kind: 'Scalar',
      name: 'value'
    };
    const DISPLAY_VALUE_SELECTION = {
      kind: 'Scalar',
      name: 'displayValue'
    };
    const FIELDS_SELECTION = {
      kind: 'Object',
      name: 'fields'
    };
    function convertRecordFieldsArrayToTrie(fields, optionalFields = []) {
      const root = {
        name: '<root>',
        optional: false,
        scalar: false,
        children: {}
      };
      insertFieldsIntoTrie(root, fields, false);
      insertFieldsIntoTrie(root, optionalFields, true);
      return root;
    }
    function createPathSelection(propertyName, fieldDefinition) {
      const fieldsSelection = [];
      const {
        children
      } = fieldDefinition;
      const childrenKeys = keys(children);
      for (let i = 0, len = childrenKeys.length; i < len; i += 1) {
        const childKey = childrenKeys[i];
        const childFieldDefinition = children[childKey];
        let fieldValueSelection;
        if (childFieldDefinition.scalar === true) {
          fieldValueSelection = SCALAR_VALUE_SELECTION;
        } else {
          fieldValueSelection = {
            kind: 'Link',
            name: 'value',
            nullable: true,
            fragment: {
              kind: 'Fragment',
              private: ['eTag', 'weakEtag'],
              selections: createRecordSelection(childFieldDefinition),
              version: VERSION$1e
            }
          };
        }
        const fieldSelection = {
          kind: 'Link',
          name: childFieldDefinition.name,
          required: childFieldDefinition.optional === true ? false : undefined,
          fragment: {
            kind: 'Fragment',
            version: VERSION$1g,
            private: [],
            selections: [DISPLAY_VALUE_SELECTION, fieldValueSelection]
          }
        };
        push.call(fieldsSelection, fieldSelection);
      }
      return {
        kind: 'Object',
        name: propertyName,
        selections: fieldsSelection
      };
    }
    /**
     * Convert a RecordRepresentationLike into its equivalent selection.
     */
    function createPathSelectionFromValue(fields) {
      const fieldsSelection = [];
      const fieldNames = keys(fields);
      for (let i = 0, len = fieldNames.length; i < len; i++) {
        const fieldName = fieldNames[i];
        const {
          value: fieldValue
        } = fields[fieldName];
        let fieldValueSelection = SCALAR_VALUE_SELECTION;
        if (isSpanningRecord(fieldValue)) {
          fieldValueSelection = {
            kind: 'Link',
            name: 'value',
            nullable: true,
            fragment: {
              kind: 'Fragment',
              private: [],
              selections: buildSelectionFromRecord(fieldValue),
              version: VERSION$1e
            }
          };
        }
        const fieldSelection = {
          kind: 'Link',
          name: fieldName,
          required: undefined,
          fragment: {
            kind: 'Fragment',
            version: VERSION$1g,
            private: [],
            selections: [DISPLAY_VALUE_SELECTION, fieldValueSelection]
          }
        };
        push.call(fieldsSelection, fieldSelection);
      }
      return {
        kind: 'Object',
        name: FIELDS_SELECTION.name,
        selections: fieldsSelection
      };
    }
    function extractRecordFieldsRecursively(record) {
      const fields = [];
      const fieldNames = keys(record.fields);
      for (let i = 0, len = fieldNames.length; i < len; i++) {
        const fieldName = fieldNames[i];
        const {
          value: fieldValue
        } = record.fields[fieldName];
        if (isSpanningRecord(fieldValue)) {
          const spanningRecordFields = extractRecordFieldsRecursively(fieldValue);
          for (let j = 0, len = spanningRecordFields.length; j < len; j++) {
            spanningRecordFields[j] = `${fieldName}.${spanningRecordFields[j]}`;
          }
          push.apply(fields, spanningRecordFields);
        } else {
          push.call(fields, fieldName);
        }
      }
      return fields;
    }
    /**
     * Returns a list of fields for a RecordRepresentationLike.
     *
     * TODO [W-6900271]: Remove this function once getRelatedList don't depend on it anymore. Always prefer
     * generating a selection out of a record, than convert a record to a field list and back to a
     * selection.
     */
    function extractFields(value) {
      const {
        apiName
      } = value;
      const fields = extractRecordFieldsRecursively(value);
      for (let i = 0, len = fields.length; i < len; i++) {
        fields[i] = `${apiName}.${fields[i]}`;
      }
      return fields;
    }
    function insertFieldsIntoTrie(root, fields, optional) {
      for (let i = 0, len = fields.length; i < len; i++) {
        const field = fields[i].split(FIELD_SEPARATOR);
        let current = root;
        for (let j = 1, len = field.length; j < len && j <= MAX_RECORD_DEPTH + 1; j++) {
          const fieldName = field[j];
          let next = current.children[fieldName];
          if (next === undefined) {
            // A field is scalar only if it is the last field name in the field.
            const scalar = j === len - 1;
            // LDS restricts the numbers of fields that can be traversed to MAX_RECORD_DEPTH,
            // however we still denormalize fields at MAX_RECORD_DEPTH + 1, only if they are
            // scalar fields.
            if (j <= MAX_RECORD_DEPTH || scalar === true) {
              // We now know that there are children fields, so we can mark the parent
              // as not a scalar
              current.scalar = false;
              next = {
                name: fieldName,
                scalar,
                optional,
                children: {}
              };
              current.children[fieldName] = next;
            }
          }
          current = next;
        }
      }
    }
    const CHILD_RELATIONSHIP_SELECTION = {
      // We don't support RecordRep.childRelationships because it has a nasty
      // degenerate case of multiple pages of child records
      kind: 'Object',
      name: 'childRelationships'
    };
    // This selection is a client-side only selection and will only
    // be applied to a RecordRepresentation in environments configured with
    // drafts when the record has draft changes applied to it
    // TODO [W-8237087]: explore if this selection can only be added in environments where drafts are enabled
    const DRAFTS_SELECTION = {
      kind: 'Object',
      opaque: true,
      name: 'drafts',
      required: false
    };
    function isSpanningRecord(fieldValue) {
      return fieldValue !== null && typeof fieldValue === 'object';
    }
    function createRecordSelection(fieldDefinition) {
      const sel = dynamicSelect$8({
        childRelationships: CHILD_RELATIONSHIP_SELECTION,
        fields: createPathSelection('fields', fieldDefinition)
      });
      return [...sel.selections, DRAFTS_SELECTION];
    }
    /**
     * Convert a list of fields and optional fields into RecordRepresentation its equivalent
     * selection.
     */
    function buildSelectionFromFields(fields, optionalFields = []) {
      return createRecordSelection(convertRecordFieldsArrayToTrie(fields, optionalFields));
    }
    /**
     * Convert a RecordRepresentationLike into its equivalent selection.
     */
    function buildSelectionFromRecord(record) {
      const sel = dynamicSelect$8({
        childRelationships: CHILD_RELATIONSHIP_SELECTION,
        fields: createPathSelectionFromValue(record.fields)
      });
      return [...sel.selections, DRAFTS_SELECTION];
    }
    const CUSTOM_API_NAME_SUFFIX = '__c';
    const DMO_API_NAME_SUFFIX = '__dlm';
    const CUSTOM_EXTERNAL_OBJECT_FIELD_SUFFIX = '__x';
    const RECORD_REPRESENTATION_ERROR_VERSION = 'RECORD_REPRESENTATION_ERROR_VERSION_1';
    const RECORD_REPRESENTATION_ERROR_STORE_METADATA_PARAMS = {
      representationName: '',
      namespace: keyPrefix,
      ttl: TTL$z,
      version: RECORD_REPRESENTATION_ERROR_VERSION
    };
    function isGraphNode(node) {
      return !!node && node.type === 'Node';
    }
    function addScalarFieldId(current) {
      addScalarField(current, 'Id');
    }
    function addScalarFieldName(current) {
      addScalarField(current, 'Name');
    }
    function addScalarField(current, leafNodeFieldKey) {
      if (current.children[leafNodeFieldKey] === undefined) {
        current.children[leafNodeFieldKey] = {
          name: leafNodeFieldKey,
          children: {}
        };
      }
    }
    function extractTrackedFieldsToTrie(recordId, node, root, config, visitedRecordIds = {}, depth = 0) {
      // Filter Error and null nodes
      if (!isGraphNode(node)) {
        return;
      }
      // Stop the traversal if the key has already been visited, since the fields for this record
      // have already been gathered at this point.
      if (hasOwnProperty.call(visitedRecordIds, recordId)) {
        return;
      }
      // The visitedRecordIds object passed to the spanning record is a copy of the original
      // visitedRecordIds + the current record id, since we want to detect circular references within
      // a given path.
      let spanningVisitedRecordIds = {
        ...visitedRecordIds,
        [recordId]: true
      };
      const fields = node.object('fields');
      const keys$1 = fields.keys();
      let current = root;
      for (let i = 0, len = keys$1.length; i < len; i += 1) {
        const key = keys$1[i];
        const fieldValueRep = fields.link(key);
        let next = current.children[key];
        if (next === undefined) {
          next = {
            name: key,
            children: {}
          };
          if (fieldValueRep.isMissing()) {
            current.children[key] = next;
            continue;
          }
          const field = fieldValueRep.follow();
          // Filter Error and null nodes
          if (!isGraphNode(field)) {
            continue;
          }
          const {
            maxDepth,
            onlyFetchLeafNodeIdAndName
          } = config;
          if (field.isScalar('value') === false) {
            if (depth + 1 > maxDepth) {
              if (onlyFetchLeafNodeIdAndName === true) {
                addScalarFieldId(current);
                addScalarFieldName(current);
              }
              continue;
            }
            const spanningLink = field.link('value');
            const spanning = spanningLink.follow();
            // W-8058425, do not include external lookups added by getTrackedFields
            if (isExternalLookupFieldKey(spanning)) {
              // NOTE: the logic to get here is mimicked in RecordRepresentation/merge::mergePendingFields as of
              // W-11899329 due to issues with external lookups being marked pending but never fetched
              continue;
            }
            extractTrackedFieldsToTrie(spanningLink.data.__ref, spanning, next, config, spanningVisitedRecordIds, depth + 1);
            // For a spanning record that is detected to be a circular reference, we add the field along with Id and Name.
            // It's possible for spanning record lookup fields to sometimes be circular, and sometimes not - depending on the value of the lookup field.
            // For more information on scenarios that caused this fix: search "LDS Recursive Spanning Fields Problem" in Quip
            if (keys(next.children).length === 0) {
              addScalarFieldId(next);
              addScalarFieldName(next);
            }
            current.children[key] = next;
          } else {
            // Skip the field, if its value is null at the max level depth.
            // Ideally, it should only skip relationship field. However,
            // on the client, there is not a reliable way to determine the
            // the field type.
            if (depth === maxDepth) {
              if (onlyFetchLeafNodeIdAndName === true) {
                addScalarFieldId(current);
                addScalarFieldName(current);
                continue;
              }
              if (field.scalar('value') === null) {
                continue;
              }
            }
            const state = fieldValueRep.linkData();
            if (state !== undefined) {
              const {
                fields
              } = state;
              // W-8058425, do not include external lookups added by getTrackedFields
              if (includes.call(fields, 'ExternalId')) {
                // NOTE: the logic to get here is mimicked in RecordRepresentation/merge::mergePendingFields as of
                // W-11899329 due to issues with external lookups being marked pending but never fetched
                continue;
              }
              for (let s = 0, len = fields.length; s < len; s += 1) {
                const childFieldName = fields[s];
                next.children[childFieldName] = {
                  name: childFieldName,
                  children: {}
                };
              }
            }
          }
          current.children[key] = next;
        }
      }
    }
    function isExternalLookupFieldKey(spanningNode) {
      // The only way to know if a record is an external lookup is to look into its fields
      // list and find an "ExternalId" field.
      // Filter Error and null nodes
      if (!isGraphNode(spanningNode) || !spanningNode.isScalar('apiName')) {
        return false;
      }
      return endsWith.call(spanningNode.scalar('apiName'), CUSTOM_EXTERNAL_OBJECT_FIELD_SUFFIX);
    }
    function convertTrieToFields(root) {
      if (keys(root.children).length === 0) {
        return [];
      }
      return convertTrieToFieldsRecursively(root);
    }
    function convertTrieToFieldsRecursively(root) {
      const childKeys = keys(root.children);
      if (childKeys.length === 0) {
        if (root.name === '') {
          return [];
        }
        return [root.name];
      }
      return reduce.call(childKeys, (acc, cur) => concat.call(acc, convertTrieToFieldsRecursively(root.children[cur]).map(i => `${root.name}.${i}`)), []);
    }
    const BLANK_RECORD_FIELDS_TRIE = freeze({
      name: '',
      children: {}
    });
    const convertFieldsToTrie = (fields = [], isOptional = false) => {
      if (fields.length === 0) {
        return BLANK_RECORD_FIELDS_TRIE;
      }
      const name = getObjectNameFromField(fields[0]);
      const fieldsTrie = {
        name,
        children: {},
        optional: isOptional
      };
      insertFieldsIntoTrie(fieldsTrie, fields, isOptional);
      return fieldsTrie;
    };
    const getObjectNameFromField = field => {
      const fieldApiName = getFieldApiName(field);
      if (fieldApiName === undefined) {
        return '';
      }
      return splitQualifiedFieldApiName(fieldApiName)[0];
    };
    // merge all nodes in Trie B into Trie A
    function mergeFieldsTries(rootA, rootB) {
      const rootAchildren = rootA.children;
      const rootBchildren = rootB.children;
      const childBKeys = keys(rootBchildren);
      for (let i = 0, len = childBKeys.length; i < len; i++) {
        const childBKey = childBKeys[i];
        if (rootAchildren[childBKey] === undefined) {
          rootAchildren[childBKey] = rootBchildren[childBKey];
        } else {
          mergeFieldsTries(rootAchildren[childBKey], rootBchildren[childBKey]);
        }
      }
    }
    function getTrackedFields(key, graphNode, config, fieldsFromConfig) {
      const fieldsList = fieldsFromConfig === undefined ? [] : [...fieldsFromConfig];
      if (!isGraphNode(graphNode)) {
        return fieldsList;
      }
      const name = graphNode.scalar('apiName');
      const root = {
        name,
        children: {}
      };
      extractTrackedFieldsToTrie(key, graphNode, root, config);
      const rootFromConfig = {
        name,
        children: {}
      };
      insertFieldsIntoTrie(rootFromConfig, fieldsList);
      mergeFieldsTries(root, rootFromConfig);
      return convertTrieToFields(root).sort();
    }
    function getRecordTypeId$2(record) {
      return record.recordTypeId === null ? MAIN_RECORD_TYPE_ID : record.recordTypeId;
    }
    // This function traverses through a record and marks missing
    // optional fields as "missing"
    function markMissingOptionalFields(record, optionalFields) {
      if (!isGraphNode(record)) {
        return;
      }
      const apiName = record.scalar('apiName');
      for (let a = 0, aLen = optionalFields.length; a < aLen; a++) {
        const parts = optionalFields[a].split('.');
        if (parts[0] === apiName) {
          _markMissingPath(record, parts.slice(1));
        }
      }
    }
    function markNulledOutPath(record, path) {
      if (!isGraphNode(record)) {
        return;
      }
      const fieldValueRepresentation = record.object('fields');
      const fieldName = path.shift();
      if (fieldValueRepresentation.isUndefined(fieldName)) {
        return;
      }
      const link = fieldValueRepresentation.link(fieldName);
      const resolved = link.follow();
      if (isGraphNode(resolved) && resolved.isScalar('value') && path.length > 0 &&
      // TODO [W-14082782]: temporary fix
      !isFrozen(link.data)) {
        const linkState = link.linkData();
        const fields = linkState === undefined ? [] : linkState.fields;
        link.writeLinkData({
          fields: dedupe([...fields, path.join('.')])
        });
      }
    }
    function markNulledOutRequiredFields(record, fields) {
      if (!isGraphNode(record)) {
        return;
      }
      const apiName = record.scalar('apiName');
      for (let a = 0, aLen = fields.length; a < aLen; a++) {
        const parts = fields[a].split('.');
        if (parts[0] === apiName) {
          markNulledOutPath(record, parts.slice(1));
        }
      }
    }
    function _markMissingPath(record, path) {
      // Filter out Error and null nodes
      if (!isGraphNode(record)) {
        return;
      }
      const fieldValueRepresentation = record.object('fields');
      const fieldName = path.shift();
      if (fieldValueRepresentation.isUndefined(fieldName) === true) {
        writeMissingFieldToStore(fieldValueRepresentation, fieldName);
        return;
      }
      const link = fieldValueRepresentation.link(fieldName);
      if (link.isPending()) {
        writeMissingFieldToStore(fieldValueRepresentation, fieldName);
      } else if (path.length > 0 && link.isMissing() === false) {
        const fieldValue = link.follow();
        // Filter out Error and null nodes
        if (!isGraphNode(fieldValue)) {
          return;
        }
        // if value is not a scalar, follow the link and mark it as missing
        if (fieldValue.isScalar('value') === false) {
          _markMissingPath(fieldValue.link('value').follow(), path);
        }
      }
    }
    /**
     * Graph Node Directly modifies store entries, which is generally a non-starter.
     * Until we can refactor this mess, you need to use this function to safely mark the RecordRepresentation
     * as a seenId in the store when you perform this mutation.
     */
    function writeMissingFieldToStore(field, fieldName) {
      // TODO [W-6900046]: remove cast, make RecordRepresentationNormalized['fields'] accept
      // an undefined/non-present __ref if isMissing is present
      field.write(fieldName, {
        __ref: undefined,
        isMissing: true
      });
    }
    /**
     * Tells you if an objectApiName is supported by UI API or not.
     * Note: Luvio does not currently support all the entities, the list is limited to UI API supported entities
     * @param objectApiName the object API name from a record.
     * @return True if the provided objectApiName is supported in UI API.
     */
    function isSupportedEntity(objectApiName) {
      return (UIAPI_SUPPORTED_ENTITY_API_NAMES.has(objectApiName) || endsWith.call(objectApiName, CUSTOM_API_NAME_SUFFIX) || endsWith.call(objectApiName, DMO_API_NAME_SUFFIX)) && !UIAPI_DENIED_ENTITY_API_NAMES.has(objectApiName);
    }
    /** Return true if a >= b */
    function isSuperset(a, b) {
      if (b.length > a.length) {
        return false;
      }
      const aMap = {};
      // Put all keys from subset into a map
      // so we don't have to use subset.includes which will be slow
      for (let i = 0, len = a.length; i < len; i += 1) {
        aMap[a[i]] = true;
      }
      for (let i = 0, len = b.length; i < len; i += 1) {
        if (aMap[b[i]] === undefined) {
          return false;
        }
      }
      return true;
    }
    /** return true if a and b start with the same root name and a contains all nodes in b */
    function isSuperRecordFieldTrie(a, b) {
      if (a.name !== b.name) {
        return false;
      }
      const childrenA = a.children;
      const childrenB = b.children;
      const childKeysA = keys(childrenA);
      const childKeysB = keys(childrenB);
      const childKeysBLength = childKeysB.length;
      if (childKeysBLength > childKeysA.length) {
        return false;
      }
      let ret = true;
      for (let i = 0; i < childKeysBLength; i++) {
        const childBKey = childKeysB[i];
        const childA = childrenA[childBKey];
        if (childA === undefined) {
          return false;
        }
        ret = ret && isSuperRecordFieldTrie(childA, childrenB[childBKey]);
      }
      return ret;
    }
    function ingestRecordResponse(luvio, response, recordId, recordIngest, conflictMap) {
      const {
        body
      } = response;
      const sel = buildSelectionFromRecord(body);
      const key = keyBuilder$29(luvio, {
        recordId
      });
      luvio.storeIngest(key, recordIngest, body);
      resolveConflict(luvio, conflictMap);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: {
          kind: 'Fragment',
          private: [],
          selections: sel,
          version: VERSION$1e
        },
        variables: {}
      });
      return snapshot;
    }

    // This function sets fields that we are refreshing to pending
    // These values will go into the store
    function mergePendingFields(newRecord, oldRecord, existingNode) {
      const mergedFields = {
        ...newRecord.fields
      };
      const merged = {
        ...newRecord,
        fields: mergedFields
      };
      const existingFields = keys(oldRecord.fields);
      for (let i = 0, len = existingFields.length; i < len; i += 1) {
        const spanningFieldName = existingFields[i];
        if (newRecord.fields[spanningFieldName] === undefined) {
          /*
           * Per W-8058425 external lookups fields are excluded from the tracked fields. However, as covered in
           * W-11899329, situations can arise in which a merge conflict occurs when the existing record has a
           * reference to an external lookup field.  The exclusion ultimately results in a snapshot stuck in the
           * pending state. This is an approach to prevent that situation.
           *
           * The same logic checks for W-8058425 to "continue" as it relates to not tracking external lookups is
           * mimicked here as it relates to not marking them as pending.
           */
          // make sure external lookups are NOT marked as pending when `existingNode` is provided
          if (isGraphNode(existingNode)) {
            // get the node for the spanning field
            const fieldValueRep = existingNode.object('fields').link(spanningFieldName);
            const field = fieldValueRep.follow();
            if (isGraphNode(field)) {
              if (field.isScalar('value') === false) {
                const record = field.link('value').follow();
                if (isExternalLookupFieldKey(record)) {
                  continue;
                }
              }
            } else {
              const state = fieldValueRep.linkData();
              if (state !== undefined) {
                const {
                  fields
                } = state;
                if (includes.call(fields, 'ExternalId')) {
                  continue;
                }
              }
            }
          }
          // TODO [W-6900046]: fix above casting issue so we're not stuffing arbitrary things
          // into RecordRepresentationNormalized['fields']
          mergedFields[spanningFieldName] = {
            __ref: undefined,
            pending: true
          };
        }
      }
      return merged;
    }
    // This method gets called
    // when incoming record has a higher version
    // than the record that is currently in the store
    function mergeAndRefreshHigherVersionRecord(incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot, recordConflictMap, existingNode) {
      // If the higher version (incoming) does not contain a superset of fields as existing
      // then we need to refresh to get updated versions of fields in existing
      if (isSuperRecordFieldTrie(incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot) === false) {
        // If this is an unsupported entity, do NOT attempt to go to the network
        // Simply merge what we have and move on
        if (isSupportedEntity(incoming.apiName) === false) {
          return mergeRecordFields(incoming, existing);
        }
        // update the conflict map to resolve the record conflict in resolveConflict
        recordConflictMap.conflicts[incoming.id] = {
          recordId: incoming.id,
          trackedFields: existingTrackedFieldsTrieRoot
        };
        // We want to mark fields in the store as pending
        // Because we don't want to emit any data to components
        return mergePendingFields(incoming, existing, existingNode);
      }
      return incoming;
    }
    // This method gets called
    // when incoming record has a lower version
    // than the record that is currently in the store
    function mergeAndRefreshLowerVersionRecord(luvio, incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot, recordConflictMap, existingNode) {
      // If the higher version (existing) does not have a superset of fields as incoming
      // then we need to refresh to get updated versions of fields on incoming
      if (isSuperRecordFieldTrie(existingTrackedFieldsTrieRoot, incomingTrackedFieldsTrieRoot) === false) {
        // If this is an unsupported entity, do NOT attempt to go to the network
        // Simply merge what we have and move on
        if (isSupportedEntity(incoming.apiName) === false) {
          return mergeRecordFields(existing, incoming);
        }
        const merged = mergePendingFields(existing, incoming, existingNode);
        // update the conflict map to resolve the record conflict in resolveConflict
        if (recordConflictMap) {
          recordConflictMap.conflicts[incoming.id] = {
            recordId: incoming.id,
            trackedFields: incomingTrackedFieldsTrieRoot
          };
        } else {
          buildNetworkSnapshot$16(luvio, {
            recordId: incoming.id,
            optionalFields: convertTrieToFields(incomingTrackedFieldsTrieRoot)
          });
        }
        return merged;
      }
      return existing;
    }
    function mergeRecordConflict(luvio, incoming, existing, recordConflictMap) {
      const recordKey = keyBuilder$29(luvio, {
        recordId: incoming.id
      });
      const incomingNode = luvio.wrapNormalizedGraphNode(incoming, recordKey);
      const existingNode = luvio.wrapNormalizedGraphNode(existing, recordKey);
      const incomingTrackedFieldsTrieRoot = {
        name: incoming.apiName,
        children: {}
      };
      const existingTrackedFieldsTrieRoot = {
        name: existing.apiName,
        children: {}
      };
      const trackedFieldsConfig = {
        maxDepth: configurationForRestAdapters.getTrackedFieldDepthOnCacheMergeConflict(),
        onlyFetchLeafNodeIdAndName: configurationForRestAdapters.getTrackedFieldLeafNodeIdAndNameOnly()
      };
      extractTrackedFieldsToTrie(recordKey, incomingNode, incomingTrackedFieldsTrieRoot, trackedFieldsConfig);
      extractTrackedFieldsToTrie(recordKey, existingNode, existingTrackedFieldsTrieRoot, trackedFieldsConfig);
      if (incoming.weakEtag > existing.weakEtag) {
        return mergeAndRefreshHigherVersionRecord(incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot, recordConflictMap, existingNode);
      }
      return mergeAndRefreshLowerVersionRecord(luvio, incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot, recordConflictMap);
    }
    function getNotNull(recordAValue, recordBValue) {
      return recordAValue === null ? recordBValue : recordAValue;
    }
    function mergeRecordFields(recordA, recordB) {
      const lastModifiedDate = getNotNull(recordA.lastModifiedDate, recordB.lastModifiedDate);
      const lastModifiedById = getNotNull(recordA.lastModifiedById, recordB.lastModifiedById);
      const systemModstamp = getNotNull(recordA.systemModstamp, recordB.systemModstamp);
      return {
        ...recordA,
        fields: {
          ...recordB.fields,
          ...recordA.fields
        },
        lastModifiedDate,
        lastModifiedById,
        systemModstamp
      };
    }
    function isErrorEntry(entry) {
      return entry.__type === 'error';
    }
    function merge$3(existing, incoming, luvio, _path, recordConflictMap) {
      if (existing === undefined || isErrorEntry(existing)) {
        return incoming;
      }
      // recordTypeId may get changed based on record state.
      // Evicts all dependencies from store.
      if (incoming.recordTypeId !== existing.recordTypeId) {
        if (incoming.recordTypeId === null || incoming.recordTypeId === undefined || existing.recordTypeId === null || existing.recordTypeId === undefined) {
          instrumentation.recordTypeIdIsNull(incoming.apiName);
        }
        const recordDepKey = dependencyKeyBuilder({
          recordId: existing.id
        });
        const node = luvio.getNode(recordDepKey);
        if (isGraphNode(node)) {
          const dependencies = node.retrieve();
          if (dependencies !== null) {
            const depKeys = keys(dependencies);
            for (let i = 0, len = depKeys.length; i < len; i++) {
              luvio.storeEvict(depKeys[i]);
            }
          }
        }
      }
      // eslint-disable-next-line @salesforce/lds/no-invalid-todo
      // TODO - handle merging of records that change apiName
      // if (existing.apiName !== incoming.apiName) {
      //     if ("development" === 'production') {
      //         lds.log(`API Name changed from ${existing.apiName} to ${incoming.apiName}`);
      //     } else {
      //         throw new Error('API Name cannot be different for merging records.');
      //     }
      // }
      // Adding instrumentation to see how frequently this occurs
      if (existing.apiName !== incoming.apiName) {
        instrumentation.recordApiNameChanged(incoming.apiName, existing.apiName);
      }
      const incomingWeakEtagZero = incoming.weakEtag === 0;
      const existingWeakEtagZero = existing.weakEtag === 0;
      if (incomingWeakEtagZero || existingWeakEtagZero) {
        instrumentation.weakEtagZero(incomingWeakEtagZero, existingWeakEtagZero, incoming.apiName);
      }
      // TODO [W-6900085]: UIAPI returns weakEtag=0 when the record is >2 levels nested. For now
      // we treat the record as mergeable.
      if (!incomingWeakEtagZero && !existingWeakEtagZero && incoming.weakEtag !== existing.weakEtag) {
        return mergeRecordConflict(luvio, incoming, existing, recordConflictMap);
      }
      return mergeRecordFields(incoming, existing);
    }
    function dependencyKeyBuilder(config) {
      return `UiApi::RecordRepresentationDependency:${config.recordId}`;
    }
    function merge$2(existing, incoming, _luvio, path) {
      if (existing === undefined) {
        return incoming;
      }
      fixDisplayValue(existing, incoming, path);
      const {
        value
      } = incoming;
      if (value === null || value.__ref === undefined) {
        // Parent will never be null this field only exists in the context of a RecordRep.
        const parent = path.parent;
        // It may happen that a parent.exists is null, this is the case when the same field is
        // ingested multiple times in the same ingestion cycle. For example: when the same record
        // is present multiple time in the ingested payload.
        if (parent.existing === undefined) {
          return incoming;
        }
        const existingVersion = parent.existing.weakEtag;
        const incomingVersion = parent.data.weakEtag;
        if (existingVersion > incomingVersion) {
          return existing;
        }
      }
      return incoming;
    }
    function fixDisplayValue(existing, incoming, path) {
      // Temporary fix for the issue that non-null displayValue gets replaced by null in mistake. (W-8904195)
      // If displayValue and value are both null, it means the field is empty.
      //
      // Couple sources may emit incorrect null displayValue to LDS:
      //   1. ADS may receive records with incorrect null displayValue from RecordGvp and emit to LDS.
      //      This case may affect certain types of fields:
      //      a. Spanning record field.
      //      b. Formattable fields, such as date, currency.
      //   2. AggregateUi endpoint. For some fields, displayValue only gets populated when certain combination
      //      of fields are requested. Currently, LDS handles large record requests with aggregateUi endpoint.
      //      On the network layer, record fields get split into separate chunks. Potentially, when certain
      //      combination of fields gets split into separate chunks, it would result in displayValue getting set
      //      to null.
      //   3. Any resource that returns nested Records, like list-records and list-ui, potentially exhibits this behavior
      //
      // There might be more cases masked by this workaround. We need to be careful when removing this code.
      // It would be required to have some telemetries in prod to verify if any code hits this workaround.
      const incomingValue = incoming.value;
      if (existing.displayValue !== null && incoming.displayValue === null && incomingValue !== null) {
        incoming.displayValue = existing.displayValue;
        const isSpanningRecord = typeof incomingValue === 'object';
        instrumentation.nullDisplayValueConflict({
          entityName: path.parent.data.apiName,
          fieldName: path.propertyName,
          fieldType: isSpanningRecord ? 'spanning-record' : 'scalar',
          areValuesEqual: isSpanningRecord ? undefined : incomingValue === existing.value
        });
      }
    }
    function normalize$O(input, existing, path, luvio, store, timestamp, fieldsTrie, optionalFieldsTrie, recordConflictMap) {
      const input_value = input.value;
      const input_value_id = path.fullPath + '__value';
      if (input_value !== null && typeof input_value === 'object') {
        const ingest = createRecordIngest(fieldsTrie, optionalFieldsTrie, recordConflictMap);
        input.value = ingest(input_value, {
          fullPath: input_value_id,
          propertyName: 'value',
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          }
        }, luvio, store, timestamp);
      }
      return input;
    }
    function makeIngest(fieldsTrie, optionalFieldsTrie, recordConflictMap) {
      return (input, path, luvio, store, timestamp) => {
        {
          const validateError = validate$1X(input);
          if (validateError !== null) {
            throw validateError;
          }
        }
        const key = path.fullPath;
        let existingRecord = store.readEntry(key);
        let incomingRecord = normalize$O(input, store.readEntry(key), {
          fullPath: key,
          parent: path.parent,
          propertyName: path.propertyName
        }, luvio, store, timestamp, fieldsTrie, optionalFieldsTrie, recordConflictMap);
        // read again after children ingested in case of a circular ref
        existingRecord = store.readEntry(key);
        incomingRecord = merge$2(existingRecord, incomingRecord, luvio, path);
        if (existingRecord === undefined || equals$15(existingRecord, incomingRecord) === false) {
          luvio.storePublish(key, incomingRecord);
        }
        return createLink(key);
      };
    }

    /**
     * Adds fields listed in the two trie parameters into the store link.
     * Functionally analogous to markNulledOutRequiredFields.
     * @param fieldsTrie
     * @param optionalFieldsTrie
     * @param storeLink
     */
    function addFieldsToStoreLink(fieldsTrie, optionalFieldsTrie, storeLink) {
      let fields = [];
      const fieldSubtries = [];
      if (fieldsTrie) {
        push.call(fieldSubtries, fieldsTrie);
      }
      if (optionalFieldsTrie) {
        push.call(fieldSubtries, optionalFieldsTrie);
      }
      for (let i = 0; i < fieldSubtries.length; i++) {
        const subtrie = fieldSubtries[i];
        const fieldNames = keys(subtrie.children);
        for (let i = 0; i < fieldNames.length; i++) {
          const fieldName = fieldNames[i];
          const childTrie = subtrie.children[fieldName];
          if (childTrie) {
            fields = [...fields, ...convertTrieToFieldsRecursively(childTrie)];
          }
        }
      }
      fields = dedupe(fields);
      if (fields.length > 0) {
        storeLink.data = {
          fields
        };
      }
    }
    function getChildRecordFieldTrie(parent, key) {
      const value = parent.children[key];
      if (value === undefined) {
        return BLANK_RECORD_FIELDS_TRIE;
      }
      return value;
    }
    function createFieldsIngestion(fieldsTrie, optionalFieldsTrie, recordConflictMap) {
      return (data, path, luvio, store, timestamp) => {
        {
          if (typeof path.propertyName !== 'string') {
            throw new Error('FieldValueRepresentation should always have a string propertyName value');
          }
        }
        const key = path.propertyName;
        const fieldsSubtrie = getChildRecordFieldTrie(fieldsTrie, key);
        const optionalFieldsSubtrie = getChildRecordFieldTrie(optionalFieldsTrie, key);
        const fieldValueLink = makeIngest(fieldsSubtrie, optionalFieldsSubtrie, recordConflictMap)(data, path, luvio, store, timestamp);
        // If a relationship field is null, memorize names of subordinate fields.
        // Spannning fields are specified in the dot notation.
        if (data.value === null) {
          addFieldsToStoreLink(fieldsSubtrie, optionalFieldsSubtrie, fieldValueLink);
        }
        return fieldValueLink;
      };
    }
    function createChildRecordNormalize(fieldsTrie, optionalFieldsTrie, recordConflictMap) {
      return dynamicNormalize$5({
        childRelationships: ingest$P,
        fields: createFieldsIngestion(fieldsTrie, optionalFieldsTrie, recordConflictMap)
      });
    }
    const createRecordIngest = (fieldsTrie, optionalFieldsTrie, recordConflictMap) => {
      const childNormalize = createChildRecordNormalize(fieldsTrie, optionalFieldsTrie, recordConflictMap);
      return (input, path, luvio, store, timestamp) => {
        {
          const validateError = validate$1V(input);
          if (validateError !== null) {
            throw validateError;
          }
        }
        input.eTag = ''; //[W-13724550] Record Reps ALWAYS have '' etag, to be consistent with GraphQL, as it is not queryable via GraphQL.
        const key = keyBuilderFromType$E(luvio, input);
        let existingRecord = store.readEntry(key);
        const recordPath = {
          fullPath: key,
          parent: path.parent,
          propertyName: path.propertyName
        };
        let incomingRecord = childNormalize(input, existingRecord, recordPath, luvio, store, timestamp);
        // read from the store again since it might have been ingested as a nested child ref
        existingRecord = store.readEntry(key);
        incomingRecord = merge$3(existingRecord, incomingRecord, luvio, path, recordConflictMap);
        if (existingRecord === undefined || equals$13(existingRecord, incomingRecord) === false ||
        // always publish if existing record has drafts
        existingRecord.drafts !== undefined) {
          luvio.storePublish(key, incomingRecord);
        }
        luvio.publishStoreMetadata(key, {
          ttl: TTL$z,
          representationName: RepresentationType$V,
          namespace: keyPrefix,
          version: VERSION$1e,
          ingestionTimestamp: timestamp
        });
        return createLink(key);
      };
    };
    function createFieldsIngestSuccess$3(params) {
      const {
        fields,
        optionalFields,
        trackedFields,
        serverRequestCount = 1
      } = params;
      const recordConflictMap = {
        conflicts: {},
        serverRequestCount
      };
      const ingest = createRecordIngest(fields, optionalFields, recordConflictMap);
      return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        resolveConflict(luvio, recordConflictMap);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
      };
    }
    function fulfill(existing, incoming) {
      // early out if incoming isn't a request only for fields and optionalFields
      const {
        queryParams,
        headers,
        basePath,
        baseUri,
        urlParams
      } = incoming;
      const {
        basePath: existingBasePath,
        baseUri: existingBaseUri,
        headers: existingHeaders,
        urlParams: existingUrlParams
      } = existing;
      const path = `${baseUri}${basePath}`;
      const existingPath = `${existingBaseUri}${existingBasePath}`;
      if (queryParams.layoutTypes !== undefined) {
        return false;
      }
      if (existingPath !== path) {
        // W-11964675 - Correlate an incoming single record request to an existing batch record
        // request requesting the same single record
        const incomingUrlRecords = getRecordIdsFromUrlParams(urlParams);
        const existingUrlRecords = getRecordIdsFromUrlParams(existingUrlParams);
        const batchRequestWithSingleRequest = isSingleBatchRecordRequest(existingUrlParams) && isSingleRecordRequest(urlParams) && incomingUrlRecords[0] === existingUrlRecords[0];
        if (!batchRequestWithSingleRequest || isRestrictedPathCondition(existingPath, path)) {
          return false;
        }
      }
      const headersKeys = keys(headers);
      const headersKeyLength = headersKeys.length;
      if (headersKeyLength !== keys(existingHeaders).length) {
        return false;
      }
      for (let i = 0, len = headersKeyLength; i < len; i++) {
        let key = headersKeys[i];
        if (headers[key] !== existingHeaders[key]) {
          return false;
        }
      }
      // TODO [W-6900100]: handle when incoming.fields are only in existing.optionalFields, and
      // existing's response doesn't include those fields. We need to detect this then
      // re-issue the request to get the relevant error response.
      const existingFieldsUnion = unionFields(existing.queryParams.fields, existing.queryParams.optionalFields);
      const incomingFieldsUnion = unionFields(queryParams.fields, queryParams.optionalFields);
      return isSuperset(existingFieldsUnion, incomingFieldsUnion);
    }
    function unionFields(fields, optionalFields) {
      const fieldsArray = isArray(fields) ? fields : [];
      const optionalFieldsArray = isArray(optionalFields) ? optionalFields : [];
      return [...fieldsArray, ...optionalFieldsArray];
    }
    function getRecordIdsFromUrlParams(urlParams) {
      if (hasOwnProperty.call(urlParams, 'recordId')) {
        return [urlParams.recordId];
      } else if (hasOwnProperty.call(urlParams, 'recordIds')) {
        return urlParams.recordIds;
      }
      return [];
    }
    function isSingleBatchRecordRequest(urlParams) {
      return hasOwnProperty.call(urlParams, 'recordIds') && urlParams.recordIds.length === 1;
    }
    function isSingleRecordRequest(urlParams) {
      return hasOwnProperty.call(urlParams, 'recordId');
    }
    function isRestrictedPathCondition(existingPath, path) {
      // should not dedupe getRecordUi and getRecord as both of their representation is different
      // records call cannot digest response of getRecordUi
      return existingPath.includes('/record-ui') && path.includes('/records') || existingPath.includes('/records') && path.includes('/record-ui');
    }
    const createResourceRequest$1c = function getUiApiRecordsByRecordIdCreateResourceRequest(config) {
      return {
        ...createResourceRequest$1b(config),
        fulfill: fulfill
      };
    };
    function keyBuilder$28(luvio, params) {
      return keyBuilder$29(luvio, {
        recordId: params.urlParams.recordId
      });
    }
    function getResponseCacheKeys$12(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$X(storeKeyMap, luvio, response);
    }
    function createResourceRequest$1b(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/records/' + config.urlParams.recordId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$13 = 'getRecord';
    const oneOfConfigPropertiesIdentifier$1 = ['layoutTypes', 'fields', 'optionalFields'];
    const getRecord_ConfigPropertyMetadata = [generateParamConfigMetadata('recordId', true, 0 /* UrlParameter */, 0 /* String */, false, getRecordId18), generateParamConfigMetadata('childRelationships', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('fields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('forms', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('layoutTypes', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray), generateParamConfigMetadata('modes', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray), generateParamConfigMetadata('optionalFields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('updateMru', false, 1 /* QueryParameter */, 1 /* Boolean */)];
    const createResourceParams$12 = /*#__PURE__*/luvioEngine.createResourceParams(getRecord_ConfigPropertyMetadata);
    function typeCheckConfig$18(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRecord_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$1a(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames, oneOfConfigPropertiesIdentifier$1);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRecord_ConfigPropertyMetadata);
      const config = typeCheckConfig$18(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      if (config.layoutTypes === undefined && config.fields === undefined && config.optionalFields === undefined) {
        return null;
      }
      return config;
    }

    // used by getUiApiRecordsBatchByRecordIds#selectChildResourceParams
    function buildRecordSelector(luvio, recordId, fields, optionalFields) {
      return {
        recordId: keyBuilder$29(luvio, {
          recordId
        }),
        node: {
          kind: 'Fragment',
          private: ['eTag', 'weakEtag'],
          selections: buildSelectionFromFields(fields, optionalFields),
          version: VERSION$1e
        },
        variables: {}
      };
    }
    function buildSnapshotRefresh$5(luvio, config) {
      return {
        config,
        resolve: () => buildNetworkSnapshot$16(luvio, config)
      };
    }
    function prepareRequest$7(luvio, config) {
      const {
        recordId,
        fields
      } = config;
      // Should this go into the coersion logic?
      const key = keyBuilder$28(luvio, createResourceParams$12(config));
      const allTrackedFields = getTrackedFields(key, luvio.getNode(key), {
        maxDepth: configurationForRestAdapters.getTrackedFieldDepthOnCacheMiss(),
        onlyFetchLeafNodeIdAndName: configurationForRestAdapters.getTrackedFieldLeafNodeIdAndNameOnly()
      }, config.optionalFields);
      const optionalFields = fields === undefined ? allTrackedFields : difference(allTrackedFields, fields);
      const resourceParams = createResourceParams$12({
        recordId,
        fields,
        optionalFields: optionalFields.length > 0 ? optionalFields : undefined
      });
      const request = createResourceRequest$1c(resourceParams);
      return {
        request,
        key,
        allTrackedFields,
        resourceParams
      };
    }
    function ingestSuccess$S(luvio, config, key, allTrackedFields, response, serverRequestCount) {
      const {
        body
      } = response;
      const fields = config.fields === undefined ? [] : config.fields;
      const optionalFields = config.optionalFields === undefined ? [] : config.optionalFields;
      const fieldTrie = convertFieldsToTrie(fields, false);
      luvio.storeIngest(key, createFieldsIngestSuccess$3({
        fields: fieldTrie,
        optionalFields: convertFieldsToTrie(optionalFields, true),
        trackedFields: convertFieldsToTrie(allTrackedFields, true),
        serverRequestCount
      }), body);
      return luvio.storeLookup(buildRecordSelector(luvio, config.recordId, fields, optionalFields), buildSnapshotRefresh$5(luvio, config));
    }
    function onResourceSuccess(luvio, config, key, allTrackedFields, response, serverRequestCount) {
      const snapshot = ingestSuccess$S(luvio, config, key, allTrackedFields, response, serverRequestCount);
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function ingestError$M(luvio, config, key, err) {
      const errorSnapshot = luvio.errorSnapshot(err, buildSnapshotRefresh$5(luvio, config));
      luvio.storeIngestError(key, errorSnapshot, RECORD_REPRESENTATION_ERROR_STORE_METADATA_PARAMS);
      return errorSnapshot;
    }
    function onResourceError(luvio, config, key, err) {
      const errorSnapshot = ingestError$M(luvio, config, key, err);
      return luvio.storeBroadcast().then(() => errorSnapshot);
    }
    function buildNetworkSnapshot$16(luvio, config, serverRequestCount = 0, options) {
      const {
        request,
        key,
        allTrackedFields,
        resourceParams
      } = prepareRequest$7(luvio, config);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        // W-11964675 - Condition to dedupe a very specific set of requests for
        // Komaci - a batch record request with a single record followed by a single
        // record request. The fulfill logic sends the same network response, so
        // there is some TypeScript massaging to extract the RecordRepresentation
        //
        // W-14381091 - Ensure hoisting the response body happens prior to
        // calling `luvio.handleSuccessResponse`, since both arguments capture
        // the response.
        if (isSingleBatchRecordResponse(response.body)) {
          response.body = response.body.results[0].result;
        }
        return luvio.handleSuccessResponse(() => {
          return onResourceSuccess(luvio, config, key, allTrackedFields, response, serverRequestCount + 1);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$12(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, err => {
        return luvio.handleErrorResponse(() => {
          return onResourceError(luvio, config, key, err);
        });
      });
    }
    // used by getRecordLayoutType#refresh
    function buildCachedSnapshot$9(luvio, config, refresh) {
      const fields = config.fields === undefined ? [] : config.fields;
      const optionalFields = config.optionalFields === undefined ? [] : config.optionalFields;
      const sel = buildRecordSelector(luvio, config.recordId, fields, optionalFields);
      return luvio.storeLookup(sel, refresh ? refresh : buildSnapshotRefresh$5(luvio, config));
    }
    function buildCachedSnapshotCachePolicy$Q(context, storeLookup) {
      const {
        config,
        luvio
      } = context;
      const fields = config.fields === undefined ? [] : config.fields;
      const optionalFields = config.optionalFields === undefined ? [] : config.optionalFields;
      const sel = buildRecordSelector(luvio, config.recordId, fields, optionalFields);
      return storeLookup(sel, buildSnapshotRefresh$5(luvio, config));
    }
    function buildNetworkSnapshotCachePolicy$R(context, coercedAdapterRequestContext) {
      const {
        config,
        luvio
      } = context;
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return buildNetworkSnapshot$16(luvio, config, 0, dispatchOptions);
    }
    function getRecordByFields(luvio, config, requestContext) {
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      }, buildCachedSnapshotCachePolicy$Q, buildNetworkSnapshotCachePolicy$R);
    }
    function isSingleBatchRecordResponse(response) {
      return isArray(response.results) && response.results.length === 1;
    }
    const VERSION$1d = "98cce53b8d13b1883d001bbdaab24383";
    const nonCachedErrors$7 = ObjectCreate$1(null);
    function ingestSuccessChildResourceParams$8(luvio, childResourceParamsArray, childEnvelopes, serverRequestCount = 0) {
      const childSnapshotDataResponses = [];
      let seenRecords = new luvioEngine.StoreKeySet();
      let snapshotState = 'Fulfilled';
      const now = Date.now();
      for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$28(luvio, childResourceParams);
        const result = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = result;
        if (childStatusCode === 200) {
          const childResponse = {
            status: childStatusCode,
            body: childBody,
            ok: true,
            statusText: 'OK',
            headers: {}
          };
          const childTrackedFields = getTrackedFields(childKey, luvio.getNode(childKey), {
            maxDepth: configurationForRestAdapters.getTrackedFieldDepthOnCacheMiss(),
            onlyFetchLeafNodeIdAndName: configurationForRestAdapters.getTrackedFieldLeafNodeIdAndNameOnly()
          }, childResourceParams.queryParams.optionalFields);
          const childSnapshot = ingestSuccess$S(luvio, {
            recordId: childResourceParams.urlParams.recordId,
            fields: childResourceParams.queryParams.fields,
            optionalFields: childResourceParams.queryParams.optionalFields
          }, childKey, childTrackedFields, childResponse, serverRequestCount + 1);
          if (childSnapshot.state === 'Stale') {
            snapshotState = 'Stale';
          }
          seenRecords.merge(childSnapshot.seenRecords);
          seenRecords.add(childSnapshot.recordId);
          const childValue = {
            statusCode: childStatusCode,
            result: childSnapshot.data
          };
          childSnapshotDataResponses.push(childValue);
        } else {
          const childStatusCodeText = getFetchResponseStatusText(childStatusCode);
          const childResponse = {
            status: childStatusCode,
            body: childBody,
            ok: false,
            statusText: childStatusCodeText,
            headers: {},
            errorType: 'fetchResponse'
          };
          ingestError$M(luvio, {
            recordId: childResourceParams.urlParams.recordId,
            fields: childResourceParams.queryParams.fields,
            optionalFields: childResourceParams.queryParams.optionalFields
          }, childKey, childResponse);
          seenRecords.add(childKey);
          const childValue = {
            statusCode: childStatusCode,
            result: childBody
          };
          childSnapshotDataResponses.push(childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
          nonCachedErrors$7[childKey] = {
            expiration: now + TTL$z,
            response: childBody,
            status: childStatusCode
          };
        } else {
          delete nonCachedErrors$7[childKey];
        }
      }
      const childSnapshotData = {
        results: childSnapshotDataResponses
      };
      luvioEngine.deepFreeze(childSnapshotData);
      return {
        childSnapshotData,
        seenRecords,
        snapshotState
      };
    }
    function selectChildResourceParams$7(luvio, childResources, resourceParams) {
      const envelopeBodyPath = 'result';
      const envelopeStatusCodePath = 'statusCode';
      const envelopePath = 'results';
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: reader => {
          // Top-level 404 lookup
          const compositeSnapshot = luvio.storeLookup({
            recordId: keyBuilder$27(luvio, resourceParams),
            node: {
              kind: 'Fragment',
              private: [],
              version: VERSION$1d
            },
            variables: {}
          });
          if (compositeSnapshot.state === 'Error' && compositeSnapshot.error.errorType === 'fetchResponse' && compositeSnapshot.error.status === 404) {
            return {
              state: compositeSnapshot.state,
              value: compositeSnapshot.error
            };
          }
          const sink = {};
          reader.enterPath(envelopePath);
          const timestamp = reader.getTimeStamp();
          const results = [];
          for (let i = 0, len = childResources.length; i < len; i += 1) {
            reader.enterPath(i);
            reader.enterPath(envelopeBodyPath);
            const childResource = childResources[i];
            const childKey = keyBuilder$28(luvio, childResource);
            const isMissingDataBeforeChildRead = reader.getIsDataMissing();
            const childSnapshot = reader.read(buildRecordSelector(luvio, childResource.urlParams.recordId, childResource.queryParams.fields || [], childResource.queryParams.optionalFields || []));
            reader.exitPath();
            const childSink = {};
            reader.markSeenId(childKey);
            switch (childSnapshot.state) {
              case 'Stale':
                reader.markStale();
              // Stale needs envelope bodies filled in so don't break
              // eslint-disable-next-line no-fallthrough
              case 'Fulfilled':
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                reader.exitPath();
                break;
              case 'Error':
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink,
                // child snapshots will always have FetchResponses
                childSnapshot.error.status);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath,
                // child snapshots will always have FetchResponses
                childSnapshot.error.body);
                reader.exitPath();
                break;
              case 'Unfulfilled':
                // if child snapshot doesn't have any data then
                // that means the child record key is missing
                if (childSnapshot.data === undefined) {
                  if (reader.isRebuilding() === false) {
                    // not a rebuild, mark as missing and move on
                    reader.markMissingLink(childKey);
                    break;
                  }
                  // On rebuilds we have to check if there is a non-cached
                  // error that we know about.  If we don't do this then
                  // rebuilds will go into endless refresh loop if a child
                  // has non-cached errors (since the top-level composite
                  // snapshot will look like an Unfulfilled snapshot
                  // instead of an error snapshot).
                  const nonCachedError = nonCachedErrors$7[childKey];
                  if (nonCachedError === undefined || nonCachedError.expiration < timestamp) {
                    reader.markMissingLink(childKey);
                  } else {
                    // if this child error was the only reason the reader
                    // is marked as missing then we want to undo that
                    if (isMissingDataBeforeChildRead === false) {
                      reader.unMarkMissing();
                    }
                    // put status code and body into reader path
                    const {
                      response: nonCachedBody,
                      status: nonCachedStatus
                    } = nonCachedError;
                    reader.enterPath(envelopeStatusCodePath);
                    reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                    reader.exitPath();
                    reader.enterPath(envelopeBodyPath);
                    reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                    reader.exitPath();
                  }
                }
                break;
              case 'Pending':
                reader.markPending();
                break;
            }
            ArrayPrototypePush.call(results, childSink);
            reader.exitPath();
          }
          reader.assignNonScalar(sink, envelopePath, results);
          luvioEngine.deepFreeze(sink);
          reader.exitPath();
          return sink;
        }
      };
    }
    ObjectCreate$1(null);
    function createChildResourceParams$b(resourceParams) {
      let childConfigs = [];
      for (let index = 0, len = resourceParams.urlParams.recordIds.length; index < len; index += 1) {
        const item = resourceParams.urlParams.recordIds[index];
        childConfigs.push({
          urlParams: {
            recordId: item
          },
          queryParams: {
            fields: resourceParams.queryParams.fields,
            optionalFields: resourceParams.queryParams.optionalFields
          }
        });
      }
      return childConfigs;
    }
    function keyBuilder$27(luvio, params) {
      return keyPrefix + '::BatchRepresentation:(' + 'childRelationships:' + params.queryParams.childRelationships + ',' + 'fields:' + params.queryParams.fields + ',' + 'layoutTypes:' + params.queryParams.layoutTypes + ',' + 'modes:' + params.queryParams.modes + ',' + 'optionalFields:' + params.queryParams.optionalFields + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'updateMru:' + params.queryParams.updateMru + ',' + 'recordIds:' + params.urlParams.recordIds + ')';
    }
    function getResponseCacheKeys$11(keys, luvio, resourceParams, response) {
      const childEnvelopes = response.results;
      const childResourceParamsArray = createChildResourceParams$b(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      // get children keys
      for (let index = 0, len = childResourceParamsArray.length; index < len; index++) {
        const childResourceParams = childResourceParamsArray[index];
        const childResult = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = childResult;
        if (childStatusCode === 200) {
          getResponseCacheKeys$12(keys, luvio, childResourceParams, childBody);
        } else if (childStatusCode === 404) {
          const childKey = keyBuilder$28(luvio, childResourceParams);
          keys.set(childKey, {
            namespace: keyPrefix,
            representationName: RepresentationType$V,
            mergeable: false
          });
        }
      }
    }
    function ingestError$L(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$27(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$1a(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/records/batch/' + config.urlParams.recordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function createResourceParams$11(config) {
      const {
        records: configRecords
      } = config;
      const recordIds = [];
      const resourceConfigFields = [];
      const resourceConfigOptionalFields = [];
      for (let index = 0, len = configRecords.length; index < len; index += 1) {
        const {
          recordIds: recordIdsFromConfig,
          fields = [],
          optionalFields = []
        } = configRecords[index];
        ArrayPrototypePush.call(recordIds, ...recordIdsFromConfig);
        if (fields.length > 0) {
          ArrayPrototypePush.call(resourceConfigFields, ...fields);
        }
        if (optionalFields.length > 0) {
          ArrayPrototypePush.call(resourceConfigOptionalFields, ...optionalFields);
        }
      }
      return {
        urlParams: {
          recordIds
        },
        queryParams: {
          fields: resourceConfigFields.length > 0 ? resourceConfigFields : undefined,
          optionalFields: resourceConfigOptionalFields.length > 0 ? resourceConfigOptionalFields : undefined
        }
      };
    }
    function createChildResourceParams$a(config) {
      const childResources = [];
      const {
        records
      } = config;
      for (let outerIdx = 0, numOfRecordBatches = records.length; outerIdx < numOfRecordBatches; outerIdx += 1) {
        const currentRecordBatch = records[outerIdx];
        const {
          recordIds,
          fields,
          optionalFields
        } = currentRecordBatch;
        for (let innerIdx = 0, numOfRecordIds = recordIds.length; innerIdx < numOfRecordIds; innerIdx += 1) {
          const currentRecordId = recordIds[innerIdx];
          const queryParams = {};
          if (ArrayIsArray$1(fields)) {
            queryParams.fields = fields;
          }
          if (ArrayIsArray$1(optionalFields)) {
            queryParams.optionalFields = optionalFields;
          }
          childResources.push({
            urlParams: {
              recordId: currentRecordId
            },
            queryParams
          });
        }
      }
      return childResources;
    }
    function adapterFragment$J(luvio, config) {
      const childResources = createChildResourceParams$a(config);
      const resourceParams = createResourceParams$11(config);
      return selectChildResourceParams$7(luvio, childResources, resourceParams);
    }
    function onFetchResponseSuccess$N(luvio, config, resourceParams, response, serverRequestCount = 0) {
      const childEnvelopes = response.body.results;
      const childResourceParamsArray = createChildResourceParams$a(config);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      const snapshotStateFulfilled = 'Fulfilled';
      const key = keyBuilder$27(luvio, resourceParams);
      const {
        childSnapshotData,
        seenRecords
      } = ingestSuccessChildResourceParams$8(luvio, childResourceParamsArray, childEnvelopes, serverRequestCount);
      const snapshot = {
        recordId: key,
        data: childSnapshotData,
        state: snapshotStateFulfilled,
        seenRecords: seenRecords,
        select: {
          recordId: key,
          node: adapterFragment$J(luvio, config),
          variables: {}
        },
        refresh: {
          config,
          resolve: () => buildNetworkSnapshot$15(luvio, config, serverRequestCount, snapshotRefreshOptions)
        },
        variables: {}
      };
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$O(luvio, config, resourceParams, response) {
      const snapshot = ingestError$L(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$15(luvio, config, 0, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$15(luvio, config, serverRequestCount = 0, options) {
      const resourceParams = createResourceParams$11(config);
      const request = createResourceRequest$1a(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$N(luvio, config, resourceParams, response, serverRequestCount + 1), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$11(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$O(luvio, config, resourceParams, response));
      });
    }

    // iterate through the map to build configs for network calls
    function resolveConflict(luvio, map) {
      const ids = keys(map.conflicts);
      if (ids.length === 0) {
        instrumentation.recordConflictsResolved(map.serverRequestCount);
        return;
      }
      if (ids.length === 1) {
        const recordId = ids[0];
        const config = {
          recordId,
          optionalFields: convertTrieToFields(map.conflicts[recordId].trackedFields)
        };
        buildNetworkSnapshot$16(luvio, config, map.serverRequestCount);
      } else {
        const records = reduce.call(ids, (acc, id) => {
          const {
            trackedFields
          } = map.conflicts[id];
          push.call(acc, {
            recordIds: [id],
            optionalFields: convertTrieToFields(trackedFields)
          });
          return acc;
        }, []);
        const config = {
          records
        };
        buildNetworkSnapshot$15(luvio, config, map.serverRequestCount);
      }
    }
    const createIngestRecordWithFields = (fields, optionalFields) => {
      return (input, path, luvio, store, timestamp) => {
        input.eTag = ''; //[W-13724550] Record Reps ALWAYS have '' etag, to be consistent with GraphQL, as it is not queryable via GraphQL.
        const conflictMap = {
          conflicts: {},
          serverRequestCount: 0
        };
        const result = createRecordIngest(fields, optionalFields, conflictMap)(input, path, luvio, store, timestamp);
        resolveConflict(luvio, conflictMap);
        return result;
      };
    };
    const ingest$O = (input, path, luvio, store, timestamp) => {
      const conflictMap = {
        conflicts: {},
        serverRequestCount: 0
      };
      input.eTag = ''; //[W-13724550] Record Reps ALWAYS have '' etag, to be consistent with GraphQL, as it is not queryable via GraphQL.
      const result = createRecordIngest(BLANK_RECORD_FIELDS_TRIE, BLANK_RECORD_FIELDS_TRIE, conflictMap)(input, path, luvio, store, timestamp);
      resolveConflict(luvio, conflictMap);
      return result;
    };
    const PAGINATION_VERSION$1 = "0.111.0";
    const paginationStoreMetadata$1 = {
      ttl: Number.MAX_SAFE_INTEGER,
      namespace: '',
      representationName: '',
      version: PAGINATION_VERSION$1
    };
    function getPageTokenAndOffset$1(paginationMetadata, token) {
      if (token === undefined) {
        const startToken = tokenFromOffset(paginationMetadata, 0);
        if (startToken === undefined) {
          return;
        }
        return [startToken, 0];
      }
      const startOffset = offsetFromToken(paginationMetadata, token);
      if (startOffset < 0) {
        return;
      }
      return [token, startOffset];
    }
    function mergeMetadata$1(existingMetadata, incomingMetadata) {
      if (existingMetadata === undefined) {
        return incomingMetadata;
      }
      return {
        ...existingMetadata,
        ...incomingMetadata
      };
    }
    function getNextPageToken(paginationMetadata, pageEndOffset) {
      const listEndOffset = paginationMetadata.__END__;
      if (listEndOffset === undefined || pageEndOffset < listEndOffset) {
        return tokenFromOffset(paginationMetadata, pageEndOffset);
      }
      return null;
    }
    function offsetFromToken(paginationMetadata, token) {
      if (token === undefined || token === null) {
        return 0;
      }
      const offset = paginationMetadata[token];
      return offset === undefined ? -1 : offset;
    }
    function pageEndOffset$1(paginationMetadata, startOffset, pageSize) {
      const listEndOffset = paginationMetadata.__END__;
      const nextPageOffset = startOffset + pageSize;
      if (listEndOffset === undefined) {
        return nextPageOffset;
      }
      return Math.min(nextPageOffset, listEndOffset);
    }
    function getPreviousPageToken(paginationMetadata, startOffset, pageSize) {
      const previousPageOffset = startOffset - pageSize;
      if (previousPageOffset < 0) {
        return null;
      }
      const listEndOffset = paginationMetadata.__END__;
      if (listEndOffset !== undefined && previousPageOffset >= listEndOffset) {
        return;
      }
      return tokenFromOffset(paginationMetadata, previousPageOffset);
    }
    function tokenFromOffset(paginationMetadata, offset) {
      const tokens = Object.keys(paginationMetadata);
      for (let i = 0, len = tokens.length; i < len; i++) {
        const token = tokens[i];
        if (paginationMetadata[token] === offset && token !== '__END__') {
          return token;
        }
      }
    }
    function tokenForAtMost(paginationMetadata, maxOffset) {
      const tokens = Object.keys(paginationMetadata);
      let tokenResult = undefined;
      let offsetResult = -1;
      for (let i = 0, len = tokens.length; i < len; i++) {
        const token = tokens[i];
        const offset = paginationMetadata[token];
        if (token === '__END__' || offset === undefined) {
          continue;
        }
        if (offset === maxOffset) {
          return [token, offset];
        }
        if (offset < maxOffset && offset > offsetResult) {
          tokenResult = token;
          offsetResult = offset;
        }
      }
      return [tokenResult, offsetResult];
    }
    const keyBuilderFromType$C = function ListRecordCollectionRepresentationKeyBuilderFromType(luvio, object) {
      const keyParams = {
        objectApiName: object.listReference.objectApiName.toLowerCase(),
        searchTerm: object.searchTerm,
        sortBy: object.sortBy,
        where: object.where,
        listViewApiName: object.listReference.listViewApiName ? object.listReference.listViewApiName.toLowerCase() : object.listReference.listViewApiName
      };
      return keyBuilder$26(luvio, keyParams);
    };
    const TTL$y = 30000;
    const VERSION$1c = "e5c90c4081cd557f8ffec53028ede1e8";
    function validate$1U(obj, path = 'ListRecordCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count) {
          return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        if (typeof obj_currentPageToken !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (!ArrayIsArray(obj_fields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        for (let i = 0; i < obj_fields.length; i++) {
          const obj_fields_item = obj_fields[i];
          const path_fields_item = path_fields + '[' + i + ']';
          if (typeof obj_fields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fields_item + '" (at "' + path_fields_item + '")');
          }
        }
        const obj_listInfoETag = obj.listInfoETag;
        const path_listInfoETag = path + '.listInfoETag';
        let obj_listInfoETag_union0 = null;
        const obj_listInfoETag_union0_error = (() => {
          if (typeof obj_listInfoETag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_listInfoETag + '" (at "' + path_listInfoETag + '")');
          }
        })();
        if (obj_listInfoETag_union0_error != null) {
          obj_listInfoETag_union0 = obj_listInfoETag_union0_error.message;
        }
        let obj_listInfoETag_union1 = null;
        const obj_listInfoETag_union1_error = (() => {
          if (obj_listInfoETag !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_listInfoETag + '" (at "' + path_listInfoETag + '")');
          }
        })();
        if (obj_listInfoETag_union1_error != null) {
          obj_listInfoETag_union1 = obj_listInfoETag_union1_error.message;
        }
        if (obj_listInfoETag_union0 && obj_listInfoETag_union1) {
          let message = 'Object doesn\'t match union (at "' + path_listInfoETag + '")';
          message += '\n' + obj_listInfoETag_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_listInfoETag_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referencepath_listReferenceValidationError = validate$28(obj_listReference, path_listReference);
        if (referencepath_listReferenceValidationError !== null) {
          let message = 'Object doesn\'t match ListReferenceRepresentation (at "' + path_listReference + '")\n';
          message += referencepath_listReferenceValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
          if (typeof obj_nextPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union0_error != null) {
          obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
          if (obj_nextPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union1_error != null) {
          obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
          message += '\n' + obj_nextPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
          if (typeof obj_nextPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union0_error != null) {
          obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
          if (obj_nextPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union1_error != null) {
          obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
          message += '\n' + obj_nextPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_optionalFields = obj.optionalFields;
        const path_optionalFields = path + '.optionalFields';
        if (!ArrayIsArray(obj_optionalFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_optionalFields + '" (at "' + path_optionalFields + '")');
        }
        for (let i = 0; i < obj_optionalFields.length; i++) {
          const obj_optionalFields_item = obj_optionalFields[i];
          const path_optionalFields_item = path_optionalFields + '[' + i + ']';
          if (typeof obj_optionalFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_optionalFields_item + '" (at "' + path_optionalFields_item + '")');
          }
        }
        const obj_pageSize = obj.pageSize;
        const path_pageSize = path + '.pageSize';
        if (typeof obj_pageSize !== 'number' || typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize) {
          return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
          if (typeof obj_previousPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union0_error != null) {
          obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
          if (obj_previousPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union1_error != null) {
          obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
          message += '\n' + obj_previousPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
          if (typeof obj_previousPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union0_error != null) {
          obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
          if (obj_previousPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union1_error != null) {
          obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
          message += '\n' + obj_previousPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (!ArrayIsArray(obj_records)) {
          return new TypeError('Expected "array" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        for (let i = 0; i < obj_records.length; i++) {
          const obj_records_item = obj_records[i];
          const path_records_item = path_records + '[' + i + ']';
          if (typeof obj_records_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_records_item + '" (at "' + path_records_item + '")');
          }
        }
        const obj_searchTerm = obj.searchTerm;
        const path_searchTerm = path + '.searchTerm';
        let obj_searchTerm_union0 = null;
        const obj_searchTerm_union0_error = (() => {
          if (typeof obj_searchTerm !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_searchTerm + '" (at "' + path_searchTerm + '")');
          }
        })();
        if (obj_searchTerm_union0_error != null) {
          obj_searchTerm_union0 = obj_searchTerm_union0_error.message;
        }
        let obj_searchTerm_union1 = null;
        const obj_searchTerm_union1_error = (() => {
          if (obj_searchTerm !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_searchTerm + '" (at "' + path_searchTerm + '")');
          }
        })();
        if (obj_searchTerm_union1_error != null) {
          obj_searchTerm_union1 = obj_searchTerm_union1_error.message;
        }
        if (obj_searchTerm_union0 && obj_searchTerm_union1) {
          let message = 'Object doesn\'t match union (at "' + path_searchTerm + '")';
          message += '\n' + obj_searchTerm_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_searchTerm_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_sortBy = obj.sortBy;
        const path_sortBy = path + '.sortBy';
        let obj_sortBy_union0 = null;
        const obj_sortBy_union0_error = (() => {
          if (!ArrayIsArray(obj_sortBy)) {
            return new TypeError('Expected "array" but received "' + typeof obj_sortBy + '" (at "' + path_sortBy + '")');
          }
          for (let i = 0; i < obj_sortBy.length; i++) {
            const obj_sortBy_item = obj_sortBy[i];
            const path_sortBy_item = path_sortBy + '[' + i + ']';
            if (typeof obj_sortBy_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_sortBy_item + '" (at "' + path_sortBy_item + '")');
            }
          }
        })();
        if (obj_sortBy_union0_error != null) {
          obj_sortBy_union0 = obj_sortBy_union0_error.message;
        }
        let obj_sortBy_union1 = null;
        const obj_sortBy_union1_error = (() => {
          if (obj_sortBy !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_sortBy + '" (at "' + path_sortBy + '")');
          }
        })();
        if (obj_sortBy_union1_error != null) {
          obj_sortBy_union1 = obj_sortBy_union1_error.message;
        }
        if (obj_sortBy_union0 && obj_sortBy_union1) {
          let message = 'Object doesn\'t match union (at "' + path_sortBy + '")';
          message += '\n' + obj_sortBy_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_sortBy_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_where = obj.where;
        const path_where = path + '.where';
        let obj_where_union0 = null;
        const obj_where_union0_error = (() => {
          if (typeof obj_where !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_where + '" (at "' + path_where + '")');
          }
        })();
        if (obj_where_union0_error != null) {
          obj_where_union0 = obj_where_union0_error.message;
        }
        let obj_where_union1 = null;
        const obj_where_union1_error = (() => {
          if (obj_where !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_where + '" (at "' + path_where + '")');
          }
        })();
        if (obj_where_union1_error != null) {
          obj_where_union1 = obj_where_union1_error.message;
        }
        if (obj_where_union0 && obj_where_union1) {
          let message = 'Object doesn\'t match union (at "' + path_where + '")';
          message += '\n' + obj_where_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_where_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$U = 'ListRecordCollectionRepresentation';
    function keyBuilder$26(luvio, config) {
      return keyPrefix + '::' + RepresentationType$U + ':' + config.objectApiName + ':' + (config.searchTerm === null ? '' : config.searchTerm) + ':' + (config.sortBy === null ? '' : '[' + config.sortBy.join(',') + ']') + ':' + (config.where === null ? '' : config.where) + ':' + (config.listViewApiName === null ? '' : config.listViewApiName);
    }
    function paginationKeyBuilder(luvio, config) {
      return keyBuilder$26(luvio, config) + '__pagination';
    }
    function normalize$N(input, existing, path, luvio, store, timestamp) {
      const input_records = input.records;
      const input_records_id = path.fullPath + '__records';
      for (let i = 0; i < input_records.length; i++) {
        const input_records_item = input_records[i];
        let input_records_item_id = input_records_id + '__' + i;
        input_records[i] = ingest$O(input_records_item, {
          fullPath: input_records_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1S = function ListRecordCollectionRepresentationSelect(paginationParams) {
      const {
        selections: ListReferenceRepresentation__selections,
        opaque: ListReferenceRepresentation__opaque
      } = select$24();
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: false,
        version: VERSION$1c,
        read: (source, reader) => {
          const sink = {};
          if (paginationParams === undefined) {
            return sink;
          }
          const metadata = reader.resolveMetadata(source, PAGINATION_VERSION$1);
          const currentPageMetadata = getPageMetadata$3(metadata, paginationParams);
          const {
            startOffset,
            endOffset,
            metadataProperties
          } = currentPageMetadata;
          if (metadata !== undefined && startOffset !== undefined && endOffset !== undefined) {
            const itemsProperty = 'records';
            reader.enterPath(itemsProperty);
            const itemsSource = source[itemsProperty];
            const itemsSink = [];
            const allSink = [];
            for (let i = startOffset; i < endOffset; i++) {
              reader.enterPath(i);
              reader.readSingleLink(i, {
                name: 'records',
                kind: 'Link',
                fragment: select$1T()
              }, itemsSource, allSink, i - startOffset);
              if (reader.getIsDataMissing() === false) {
                itemsSink[i - startOffset] = allSink[i - startOffset];
              }
              reader.exitPath();
            }
            reader.exitPath();
            reader.assignNonScalar(sink, itemsProperty, itemsSink);
          }
          reader.enterPath('currentPageToken');
          reader.readScalar('currentPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('nextPageToken');
          reader.readScalar('nextPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('previousPageToken');
          reader.readScalar('previousPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('pageSize');
          reader.readScalar('pageSize', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('count');
          reader.readScalar('count', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('fields');
          reader.readScalarPlural('fields', source, sink, true);
          reader.exitPath();
          reader.enterPath('listInfoETag');
          reader.readScalar('listInfoETag', source, sink);
          reader.exitPath();
          reader.enterPath('listReference');
          reader.readObject('listReference', {
            name: 'listReference',
            kind: 'Object',
            selections: ListReferenceRepresentation__selections
          }, source, sink);
          reader.exitPath();
          reader.enterPath('optionalFields');
          reader.readScalarPlural('optionalFields', source, sink, true);
          reader.exitPath();
          reader.enterPath('searchTerm');
          reader.readScalar('searchTerm', source, sink);
          reader.exitPath();
          reader.enterPath('sortBy');
          if (source['sortBy'] === null) {
            reader.readScalar('sortBy', source, sink);
          } else {
            reader.readScalarPlural('sortBy', source, sink, true);
          }
          reader.exitPath();
          reader.enterPath('where');
          reader.readScalar('where', source, sink);
          reader.exitPath();
          return sink;
        }
      };
    };
    function getPageMetadata$3(paginationMetadata, paginationParams) {
      const metadataProperties = {};
      const sink = {
        metadataProperties
      };
      if (paginationMetadata === undefined) {
        return sink;
      }
      const {
        token,
        pageSize
      } = paginationParams;
      const pageTokenAndOffset = getPageTokenAndOffset$1(paginationMetadata, token);
      if (pageTokenAndOffset === undefined) {
        return sink;
      }
      const [pageToken, startOffset] = pageTokenAndOffset;
      const endOffset = pageEndOffset$1(paginationMetadata, startOffset, pageSize);
      sink.startOffset = startOffset;
      sink.endOffset = endOffset;
      metadataProperties.currentPageToken = pageToken;
      const nextToken = getNextPageToken(paginationMetadata, endOffset);
      if (nextToken !== undefined) {
        metadataProperties.nextPageToken = nextToken;
      }
      const previousToken = getPreviousPageToken(paginationMetadata, startOffset, pageSize);
      if (previousToken !== undefined) {
        metadataProperties.previousPageToken = previousToken;
      }
      metadataProperties.pageSize = pageSize;
      metadataProperties.count = endOffset - startOffset;
      return sink;
    }
    const dynamicSelect$7 = function dynamicListRecordCollectionRepresentationSelect(params, paginationParams) {
      const recordsPathSelection = params.records === undefined ? {
        name: 'records',
        kind: 'Link',
        fragment: select$1T()
      } : params.records;
      const {
        selections: ListReferenceRepresentation__selections,
        opaque: ListReferenceRepresentation__opaque
      } = select$24();
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: false,
        version: VERSION$1c,
        read: (source, reader) => {
          const sink = {};
          if (paginationParams === undefined) {
            return sink;
          }
          const metadata = reader.resolveMetadata(source, PAGINATION_VERSION$1);
          const currentPageMetadata = getPageMetadata$3(metadata, paginationParams);
          const {
            startOffset,
            endOffset,
            metadataProperties
          } = currentPageMetadata;
          if (metadata !== undefined && startOffset !== undefined && endOffset !== undefined) {
            const itemsProperty = 'records';
            reader.enterPath(itemsProperty);
            const itemsSource = source[itemsProperty];
            const itemsSink = [];
            const allSink = [];
            for (let i = startOffset; i < endOffset; i++) {
              reader.enterPath(i);
              reader.readSingleLink(i, recordsPathSelection, itemsSource, allSink, i - startOffset);
              if (reader.getIsDataMissing() === false) {
                itemsSink[i - startOffset] = allSink[i - startOffset];
              }
              reader.exitPath();
            }
            reader.exitPath();
            reader.assignNonScalar(sink, itemsProperty, itemsSink);
          }
          reader.enterPath('currentPageToken');
          reader.readScalar('currentPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('nextPageToken');
          reader.readScalar('nextPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('previousPageToken');
          reader.readScalar('previousPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('pageSize');
          reader.readScalar('pageSize', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('count');
          reader.readScalar('count', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('fields');
          reader.readScalarPlural('fields', source, sink, true);
          reader.exitPath();
          reader.enterPath('listInfoETag');
          reader.readScalar('listInfoETag', source, sink);
          reader.exitPath();
          reader.enterPath('listReference');
          reader.readObject('listReference', {
            name: 'listReference',
            kind: 'Object',
            selections: ListReferenceRepresentation__selections
          }, source, sink);
          reader.exitPath();
          reader.enterPath('optionalFields');
          reader.readScalarPlural('optionalFields', source, sink, true);
          reader.exitPath();
          reader.enterPath('searchTerm');
          reader.readScalar('searchTerm', source, sink);
          reader.exitPath();
          reader.enterPath('sortBy');
          if (source['sortBy'] === null) {
            reader.readScalar('sortBy', source, sink);
          } else {
            reader.readScalarPlural('sortBy', source, sink, true);
          }
          reader.exitPath();
          reader.enterPath('where');
          reader.readScalar('where', source, sink);
          reader.exitPath();
          return sink;
        }
      };
    };
    function equals$12(existing, incoming) {
      const existing_count = existing.count;
      const incoming_count = incoming.count;
      if (!(existing_count === incoming_count)) {
        return false;
      }
      const existing_pageSize = existing.pageSize;
      const incoming_pageSize = incoming.pageSize;
      if (!(existing_pageSize === incoming_pageSize)) {
        return false;
      }
      const existing_currentPageToken = existing.currentPageToken;
      const incoming_currentPageToken = incoming.currentPageToken;
      if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
      }
      const existing_currentPageUrl = existing.currentPageUrl;
      const incoming_currentPageUrl = incoming.currentPageUrl;
      if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
      }
      const existing_fields = existing.fields;
      const incoming_fields = incoming.fields;
      const equals_fields_items = equalsArray(existing_fields, incoming_fields, (existing_fields_item, incoming_fields_item) => {
        if (!(existing_fields_item === incoming_fields_item)) {
          return false;
        }
      });
      if (equals_fields_items === false) {
        return false;
      }
      const existing_listInfoETag = existing.listInfoETag;
      const incoming_listInfoETag = incoming.listInfoETag;
      if (!(existing_listInfoETag === incoming_listInfoETag)) {
        return false;
      }
      const existing_listReference = existing.listReference;
      const incoming_listReference = incoming.listReference;
      if (!equals$1a(existing_listReference, incoming_listReference)) {
        return false;
      }
      const existing_nextPageToken = existing.nextPageToken;
      const incoming_nextPageToken = incoming.nextPageToken;
      if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
      }
      const existing_nextPageUrl = existing.nextPageUrl;
      const incoming_nextPageUrl = incoming.nextPageUrl;
      if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
      }
      const existing_optionalFields = existing.optionalFields;
      const incoming_optionalFields = incoming.optionalFields;
      const equals_optionalFields_items = equalsArray(existing_optionalFields, incoming_optionalFields, (existing_optionalFields_item, incoming_optionalFields_item) => {
        if (!(existing_optionalFields_item === incoming_optionalFields_item)) {
          return false;
        }
      });
      if (equals_optionalFields_items === false) {
        return false;
      }
      const existing_previousPageToken = existing.previousPageToken;
      const incoming_previousPageToken = incoming.previousPageToken;
      if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
      }
      const existing_previousPageUrl = existing.previousPageUrl;
      const incoming_previousPageUrl = incoming.previousPageUrl;
      if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
      }
      const existing_records = existing.records;
      const incoming_records = incoming.records;
      const equals_records_items = equalsArray(existing_records, incoming_records, (existing_records_item, incoming_records_item) => {
        if (!(existing_records_item.__ref === incoming_records_item.__ref)) {
          return false;
        }
      });
      if (equals_records_items === false) {
        return false;
      }
      const existing_searchTerm = existing.searchTerm;
      const incoming_searchTerm = incoming.searchTerm;
      if (!(existing_searchTerm === incoming_searchTerm)) {
        return false;
      }
      const existing_sortBy = existing.sortBy;
      const incoming_sortBy = incoming.sortBy;
      if (!(() => {
        if (existing_sortBy === null || incoming_sortBy === null) {
          return existing_sortBy === incoming_sortBy;
        }
        const equals_sortBy_items = equalsArray(existing_sortBy, incoming_sortBy, (existing_sortBy_item, incoming_sortBy_item) => {
          if (!(existing_sortBy_item === incoming_sortBy_item)) {
            return false;
          }
        });
        if (equals_sortBy_items === false) {
          return false;
        }
      })()) {
        return false;
      }
      const existing_where = existing.where;
      const incoming_where = incoming.where;
      if (!(existing_where === incoming_where)) {
        return false;
      }
      return true;
    }
    const ingest$N = function ListRecordCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1U(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$C(luvio, input);
      const existingRecord = store.readEntry(key);
      const ttlToUse = TTL$y;
      let incomingRecord = normalize$N(input, store.readEntry(key), {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
        ttl: ttlToUse
      }, luvio, store, timestamp);
      const paginationKey = key + '__pagination';
      const existingPaginationMetadata = store.readEntry(paginationKey);
      const {
        count: count,
        currentPageToken: token,
        nextPageToken: nextToken,
        pageSize: pageSize,
        previousPageToken: previousToken,
        records: items
      } = input;
      const startOffset = existingPaginationMetadata === undefined ? 0 : offsetFromToken(existingPaginationMetadata, token);
      {
        if (startOffset < 0 || existingRecord && existingRecord.records && existingRecord.records.length < startOffset) {
          throw new RangeError('currentPageToken value ' + token + ' is not recognized');
        }
      }
      const incomingPaginationMetadata = {
        [token]: startOffset
      };
      const nextOffset = startOffset + items.length;
      if (nextToken === null) {
        incomingPaginationMetadata.__END__ = nextOffset;
      } else {
        incomingPaginationMetadata[nextToken] = nextOffset;
        if (existingPaginationMetadata !== undefined) {
          const listEndOffset = existingPaginationMetadata.__END__;
          if (listEndOffset !== undefined && nextOffset >= listEndOffset) {
            incomingPaginationMetadata.__END__ = undefined;
          }
        }
      }
      if (previousToken !== null) {
        incomingPaginationMetadata[previousToken] = Math.max(startOffset - pageSize, 0);
      }
      const mergedPaginationMetadata = mergeMetadata$1(existingPaginationMetadata, incomingPaginationMetadata);
      if (existingPaginationMetadata === undefined || equalsObject(existingPaginationMetadata, mergedPaginationMetadata, (existingProp, incomingProp) => {
        return existingProp === incomingProp;
      }) === false) {
        luvio.storePublish(paginationKey, mergedPaginationMetadata);
        luvio.publishStoreMetadata(paginationKey, paginationStoreMetadata$1);
      }
      assignMetadataLink(incomingRecord, paginationKey);
      if (existingRecord !== undefined && existingRecord.records !== undefined) {
        incomingRecord.records = [...existingRecord.records.slice(0, startOffset), ...incomingRecord.records, ...existingRecord.records.slice(nextOffset)];
      }
      if (existingRecord === undefined || equals$12(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
      }
      {
        const storeMetadataParams = {
          ttl: ttlToUse,
          namespace: "UiApi",
          version: VERSION$1c,
          representationName: RepresentationType$U,
          ingestionTimestamp: timestamp
        };
        luvio.publishStoreMetadata(key, storeMetadataParams);
      }
      return createLink(key);
    };
    function getTypeCacheKeys$U(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$C(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$U,
        mergeable: true
      });
      rootKeySet.set(rootKey + '__pagination', {
        namespace: keyPrefix,
        representationName: RepresentationType$U,
        mergeable: true
      });
      const input_records_length = input.records.length;
      for (let i = 0; i < input_records_length; i++) {
        getTypeCacheKeys$X(rootKeySet, luvio, input.records[i]);
      }
    }
    const notifyUpdateAvailableFactory$4 = luvio => {
      return function notifyListRecordCollectionUpdateAvailable(configs) {
        {
          const requiredKeyParams = ['objectApiName', 'searchTerm', 'sortBy', 'where', 'listViewApiName'];
          configs.forEach(config => {
            if (false === requiredKeyParams.every(req => req in config)) {
              throw new Error(`one of the configs did not contain all required parameters: ${JSONStringify(ObjectKeys(config))}`);
            }
          });
        }
        const keys = configs.map(c => keyBuilder$26(luvio, c));
        return luvio.notifyStoreUpdateAvailable(keys);
      };
    };
    const VERSION$1b = "cf8d2eb042188974da26ffe6618cfd07";
    function validate$1T(obj, path = 'ListUiRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_info = obj.info;
        const path_info = path + '.info';
        if (typeof obj_info !== 'object') {
          return new TypeError('Expected "object" but received "' + typeof obj_info + '" (at "' + path_info + '")');
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (typeof obj_records !== 'object') {
          return new TypeError('Expected "object" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$T = 'ListUiRepresentation';
    function keyBuilder$25(luvio, config) {
      return keyPrefix + '::' + RepresentationType$T + ':' + (config.listViewApiName === null ? '' : config.listViewApiName) + ':' + config.objectApiName + ':' + config.type + ':' + (config.sortBy === null ? '' : '[' + config.sortBy.join(',') + ']');
    }
    function keyBuilderFromType$B(luvio, object) {
      const keyParams = {
        listViewApiName: object.info.listReference.listViewApiName,
        objectApiName: object.info.listReference.objectApiName,
        type: object.info.listReference.type,
        sortBy: object.records.sortBy
      };
      return keyBuilder$25(luvio, keyParams);
    }
    function normalize$M(input, existing, path, luvio, store, timestamp) {
      const input_info = input.info;
      const input_info_id = path.fullPath + '__info';
      input.info = ingest$R(input_info, {
        fullPath: input_info_id,
        propertyName: 'info',
        parent: {
          data: input,
          key: path.fullPath,
          existing: existing
        },
        ttl: path.ttl
      }, luvio, store, timestamp);
      const input_records = input.records;
      const input_records_id = path.fullPath + '__records';
      input.records = ingest$N(input_records, {
        fullPath: input_records_id,
        propertyName: 'records',
        parent: {
          data: input,
          key: path.fullPath,
          existing: existing
        },
        ttl: path.ttl
      }, luvio, store, timestamp);
      return input;
    }
    const dynamicSelect$6 = function dynamicListUiRepresentationSelect(params, paginationParams) {
      const infoPathSelection = params.info === undefined ? {
        name: 'info',
        kind: 'Link',
        fragment: select$1X()
      } : params.info;
      const recordsPathSelection = params.records === undefined ? {
        name: 'records',
        kind: 'Link',
        fragment: select$1S(paginationParams)
      } : params.records;
      return {
        kind: 'Fragment',
        version: VERSION$1b,
        private: ['eTag'],
        selections: [infoPathSelection, recordsPathSelection]
      };
    };
    function equals$11(existing, incoming) {
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_info = existing.info;
      const incoming_info = incoming.info;
      if (!(existing_info.__ref === incoming_info.__ref)) {
        return false;
      }
      const existing_records = existing.records;
      const incoming_records = incoming.records;
      if (!(existing_records.__ref === incoming_records.__ref)) {
        return false;
      }
      return true;
    }
    const ingest$M = function ListUiRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1T(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$B(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$M, "UiApi", VERSION$1b, RepresentationType$T, equals$11);
      return createLink(key);
    };
    function getTypeCacheKeys$T(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$B(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$T,
        mergeable: false
      });
      getTypeCacheKeys$Z(rootKeySet, luvio, input.info);
      getTypeCacheKeys$U(rootKeySet, luvio, input.records);
    }
    function createPaginationParams$6(params) {
      const {
        queryParams
      } = params;
      return {
        token: queryParams.pageToken,
        pageSize: queryParams.pageSize === undefined ? 50 : queryParams.pageSize
      };
    }
    function createResourceRequest$19(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-ui/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$12 = 'getListUiByApiName';
    const getListUiByApiName_ConfigPropertyMetadata = [generateParamConfigMetadata('listViewApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('fields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('optionalFields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageToken', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('sortBy', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray)];
    const getListUiByApiName_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$12, getListUiByApiName_ConfigPropertyMetadata);
    const createResourceParams$10 = /*#__PURE__*/luvioEngine.createResourceParams(getListUiByApiName_ConfigPropertyMetadata);
    function typeCheckConfig$17(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getListUiByApiName_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$19(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getListUiByApiName_ConfigPropertyMetadata);
      const config = typeCheckConfig$17(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function createPaginationParams$5(params) {
      const {
        queryParams
      } = params;
      return {
        token: queryParams.pageToken,
        pageSize: queryParams.pageSize === undefined ? 50 : queryParams.pageSize
      };
    }
    function createResourceRequest$18(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-ui/' + config.urlParams.listViewId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$11 = 'getListUiByListViewId';
    const getListUiByListViewId_ConfigPropertyMetadata = [generateParamConfigMetadata('listViewId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('fields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('optionalFields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageToken', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('sortBy', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray)];
    const getListUiByListViewId_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$11, getListUiByListViewId_ConfigPropertyMetadata);
    const createResourceParams$$ = /*#__PURE__*/luvioEngine.createResourceParams(getListUiByListViewId_ConfigPropertyMetadata);
    function typeCheckConfig$16(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getListUiByListViewId_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$18(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getListUiByListViewId_ConfigPropertyMetadata);
      const config = typeCheckConfig$16(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function createResourceRequest$17(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-records/' + config.urlParams.listViewId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const VERSION$1a = "0b29241fd9ed04bb61fde26b3f558ac4";
    function validate$1S(obj, path = 'ListInfoSummaryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
          if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union0_error != null) {
          obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
          if (obj_id !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union1_error != null) {
          obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
          let message = 'Object doesn\'t match union (at "' + path_id + '")';
          message += '\n' + obj_id_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_id_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$S = 'ListInfoSummaryRepresentation';
    function keyBuilder$24(luvio, config) {
      return keyPrefix + '::' + RepresentationType$S + ':' + (config.id === null ? '' : config.id);
    }
    function keyBuilderFromType$A(luvio, object) {
      const keyParams = {
        id: object.id
      };
      return keyBuilder$24(luvio, keyParams);
    }
    function normalize$L(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1R = function ListInfoSummaryRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1a,
        private: [],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'url',
          kind: 'Scalar'
        }]
      };
    };
    function equals$10(existing, incoming) {
      const existing_apiName = existing.apiName;
      const incoming_apiName = incoming.apiName;
      if (!(existing_apiName === incoming_apiName)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      const existing_url = existing.url;
      const incoming_url = incoming.url;
      if (!(existing_url === incoming_url)) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      return true;
    }
    const ingest$L = function ListInfoSummaryRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1S(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$A(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$L, "UiApi", VERSION$1a, RepresentationType$S, equals$10);
      return createLink(key);
    };
    function getTypeCacheKeys$S(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$A(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$S,
        mergeable: false
      });
    }
    const VERSION$19 = "d0cadb0927f908b5b64694e1cff0b2d7";
    function validate$1R(obj, path = 'ListInfoSummaryCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count) {
          return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        if (typeof obj_currentPageToken !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_lists = obj.lists;
        const path_lists = path + '.lists';
        if (!ArrayIsArray(obj_lists)) {
          return new TypeError('Expected "array" but received "' + typeof obj_lists + '" (at "' + path_lists + '")');
        }
        for (let i = 0; i < obj_lists.length; i++) {
          const obj_lists_item = obj_lists[i];
          const path_lists_item = path_lists + '[' + i + ']';
          if (typeof obj_lists_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_lists_item + '" (at "' + path_lists_item + '")');
          }
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
          if (typeof obj_nextPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union0_error != null) {
          obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
          if (obj_nextPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union1_error != null) {
          obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
          message += '\n' + obj_nextPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
          if (typeof obj_nextPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union0_error != null) {
          obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
          if (obj_nextPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union1_error != null) {
          obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
          message += '\n' + obj_nextPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_pageSize = obj.pageSize;
        const path_pageSize = path + '.pageSize';
        if (typeof obj_pageSize !== 'number' || typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize) {
          return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
          if (typeof obj_previousPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union0_error != null) {
          obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
          if (obj_previousPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union1_error != null) {
          obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
          message += '\n' + obj_previousPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
          if (typeof obj_previousPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union0_error != null) {
          obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
          if (obj_previousPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union1_error != null) {
          obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
          message += '\n' + obj_previousPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_queryString = obj.queryString;
        const path_queryString = path + '.queryString';
        let obj_queryString_union0 = null;
        const obj_queryString_union0_error = (() => {
          if (typeof obj_queryString !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_queryString + '" (at "' + path_queryString + '")');
          }
        })();
        if (obj_queryString_union0_error != null) {
          obj_queryString_union0 = obj_queryString_union0_error.message;
        }
        let obj_queryString_union1 = null;
        const obj_queryString_union1_error = (() => {
          if (obj_queryString !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_queryString + '" (at "' + path_queryString + '")');
          }
        })();
        if (obj_queryString_union1_error != null) {
          obj_queryString_union1 = obj_queryString_union1_error.message;
        }
        if (obj_queryString_union0 && obj_queryString_union1) {
          let message = 'Object doesn\'t match union (at "' + path_queryString + '")';
          message += '\n' + obj_queryString_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_queryString_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_recentListsOnly = obj.recentListsOnly;
        const path_recentListsOnly = path + '.recentListsOnly';
        if (typeof obj_recentListsOnly !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_recentListsOnly + '" (at "' + path_recentListsOnly + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$R = 'ListInfoSummaryCollectionRepresentation';
    function keyBuilder$23(luvio, config) {
      return keyPrefix + '::' + RepresentationType$R + ':' + config.objectApiName + ':' + (config.queryString === null ? '' : config.queryString) + ':' + config.recentListsOnly;
    }
    function keyBuilderFromType$z(luvio, object) {
      const keyParams = {
        objectApiName: object.objectApiName,
        queryString: object.queryString,
        recentListsOnly: object.recentListsOnly
      };
      return keyBuilder$23(luvio, keyParams);
    }
    function normalize$K(input, existing, path, luvio, store, timestamp) {
      const input_lists = input.lists;
      const input_lists_id = path.fullPath + '__lists';
      for (let i = 0; i < input_lists.length; i++) {
        const input_lists_item = input_lists[i];
        let input_lists_item_id = input_lists_id + '__' + i;
        input_lists[i] = ingest$L(input_lists_item, {
          fullPath: input_lists_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1Q = function ListInfoSummaryCollectionRepresentationSelect(paginationParams) {
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: false,
        version: VERSION$19,
        read: (source, reader) => {
          const sink = {};
          if (paginationParams === undefined) {
            return sink;
          }
          const metadata = reader.resolveMetadata(source, PAGINATION_VERSION$1);
          const currentPageMetadata = getPageMetadata$2(metadata, paginationParams);
          const {
            startOffset,
            endOffset,
            metadataProperties
          } = currentPageMetadata;
          if (metadata !== undefined && startOffset !== undefined && endOffset !== undefined) {
            const itemsProperty = 'lists';
            reader.enterPath(itemsProperty);
            const itemsSource = source[itemsProperty];
            const itemsSink = [];
            const allSink = [];
            for (let i = startOffset; i < endOffset; i++) {
              reader.enterPath(i);
              reader.readSingleLink(i, {
                name: 'lists',
                kind: 'Link',
                fragment: select$1R()
              }, itemsSource, allSink, i - startOffset);
              if (reader.getIsDataMissing() === false) {
                itemsSink[i - startOffset] = allSink[i - startOffset];
              }
              reader.exitPath();
            }
            reader.exitPath();
            reader.assignNonScalar(sink, itemsProperty, itemsSink);
          }
          reader.enterPath('currentPageToken');
          reader.readScalar('currentPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('nextPageToken');
          reader.readScalar('nextPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('previousPageToken');
          reader.readScalar('previousPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('pageSize');
          reader.readScalar('pageSize', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('count');
          reader.readScalar('count', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('objectApiName');
          reader.readScalar('objectApiName', source, sink);
          reader.exitPath();
          reader.enterPath('queryString');
          reader.readScalar('queryString', source, sink);
          reader.exitPath();
          reader.enterPath('recentListsOnly');
          reader.readScalar('recentListsOnly', source, sink);
          reader.exitPath();
          return sink;
        }
      };
    };
    function getPageMetadata$2(paginationMetadata, paginationParams) {
      const metadataProperties = {};
      const sink = {
        metadataProperties
      };
      if (paginationMetadata === undefined) {
        return sink;
      }
      const {
        token,
        pageSize
      } = paginationParams;
      const pageTokenAndOffset = getPageTokenAndOffset$1(paginationMetadata, token);
      if (pageTokenAndOffset === undefined) {
        return sink;
      }
      const [pageToken, startOffset] = pageTokenAndOffset;
      const endOffset = pageEndOffset$1(paginationMetadata, startOffset, pageSize);
      sink.startOffset = startOffset;
      sink.endOffset = endOffset;
      metadataProperties.currentPageToken = pageToken;
      const nextToken = getNextPageToken(paginationMetadata, endOffset);
      if (nextToken !== undefined) {
        metadataProperties.nextPageToken = nextToken;
      }
      const previousToken = getPreviousPageToken(paginationMetadata, startOffset, pageSize);
      if (previousToken !== undefined) {
        metadataProperties.previousPageToken = previousToken;
      }
      metadataProperties.pageSize = pageSize;
      metadataProperties.count = endOffset - startOffset;
      return sink;
    }
    function equals$$(existing, incoming) {
      const existing_recentListsOnly = existing.recentListsOnly;
      const incoming_recentListsOnly = incoming.recentListsOnly;
      if (!(existing_recentListsOnly === incoming_recentListsOnly)) {
        return false;
      }
      const existing_count = existing.count;
      const incoming_count = incoming.count;
      if (!(existing_count === incoming_count)) {
        return false;
      }
      const existing_pageSize = existing.pageSize;
      const incoming_pageSize = incoming.pageSize;
      if (!(existing_pageSize === incoming_pageSize)) {
        return false;
      }
      const existing_currentPageToken = existing.currentPageToken;
      const incoming_currentPageToken = incoming.currentPageToken;
      if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
      }
      const existing_currentPageUrl = existing.currentPageUrl;
      const incoming_currentPageUrl = incoming.currentPageUrl;
      if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_objectApiName = existing.objectApiName;
      const incoming_objectApiName = incoming.objectApiName;
      if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
      }
      const existing_lists = existing.lists;
      const incoming_lists = incoming.lists;
      const equals_lists_items = equalsArray(existing_lists, incoming_lists, (existing_lists_item, incoming_lists_item) => {
        if (!(existing_lists_item.__ref === incoming_lists_item.__ref)) {
          return false;
        }
      });
      if (equals_lists_items === false) {
        return false;
      }
      const existing_nextPageToken = existing.nextPageToken;
      const incoming_nextPageToken = incoming.nextPageToken;
      if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
      }
      const existing_nextPageUrl = existing.nextPageUrl;
      const incoming_nextPageUrl = incoming.nextPageUrl;
      if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
      }
      const existing_previousPageToken = existing.previousPageToken;
      const incoming_previousPageToken = incoming.previousPageToken;
      if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
      }
      const existing_previousPageUrl = existing.previousPageUrl;
      const incoming_previousPageUrl = incoming.previousPageUrl;
      if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
      }
      const existing_queryString = existing.queryString;
      const incoming_queryString = incoming.queryString;
      if (!(existing_queryString === incoming_queryString)) {
        return false;
      }
      return true;
    }
    const ingest$K = function ListInfoSummaryCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1R(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$z(luvio, input);
      const existingRecord = store.readEntry(key);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      let incomingRecord = normalize$K(input, store.readEntry(key), {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
        ttl: ttlToUse
      }, luvio, store, timestamp);
      const paginationKey = key + '__pagination';
      const existingPaginationMetadata = store.readEntry(paginationKey);
      const {
        count: count,
        currentPageToken: token,
        nextPageToken: nextToken,
        pageSize: pageSize,
        previousPageToken: previousToken,
        lists: items
      } = input;
      const startOffset = existingPaginationMetadata === undefined ? 0 : offsetFromToken(existingPaginationMetadata, token);
      {
        if (startOffset < 0 || existingRecord && existingRecord.lists && existingRecord.lists.length < startOffset) {
          throw new RangeError('currentPageToken value ' + token + ' is not recognized');
        }
      }
      const incomingPaginationMetadata = {
        [token]: startOffset
      };
      const nextOffset = startOffset + items.length;
      if (nextToken === null) {
        incomingPaginationMetadata.__END__ = nextOffset;
      } else {
        incomingPaginationMetadata[nextToken] = nextOffset;
        if (existingPaginationMetadata !== undefined) {
          const listEndOffset = existingPaginationMetadata.__END__;
          if (listEndOffset !== undefined && nextOffset >= listEndOffset) {
            incomingPaginationMetadata.__END__ = undefined;
          }
        }
      }
      if (previousToken !== null) {
        incomingPaginationMetadata[previousToken] = Math.max(startOffset - pageSize, 0);
      }
      const mergedPaginationMetadata = mergeMetadata$1(existingPaginationMetadata, incomingPaginationMetadata);
      if (existingPaginationMetadata === undefined || equalsObject(existingPaginationMetadata, mergedPaginationMetadata, (existingProp, incomingProp) => {
        return existingProp === incomingProp;
      }) === false) {
        luvio.storePublish(paginationKey, mergedPaginationMetadata);
        luvio.publishStoreMetadata(paginationKey, paginationStoreMetadata$1);
      }
      assignMetadataLink(incomingRecord, paginationKey);
      if (existingRecord !== undefined && existingRecord.lists !== undefined) {
        incomingRecord.lists = [...existingRecord.lists.slice(0, startOffset), ...incomingRecord.lists, ...existingRecord.lists.slice(nextOffset)];
      }
      if (existingRecord === undefined || equals$$(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
      }
      if (ttlToUse !== undefined) {
        const storeMetadataParams = {
          ttl: ttlToUse,
          namespace: "UiApi",
          version: VERSION$19,
          representationName: RepresentationType$R,
          ingestionTimestamp: timestamp
        };
        luvio.publishStoreMetadata(key, storeMetadataParams);
      }
      return createLink(key);
    };
    function getTypeCacheKeys$R(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$z(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$R,
        mergeable: true
      });
      rootKeySet.set(rootKey + '__pagination', {
        namespace: keyPrefix,
        representationName: RepresentationType$R,
        mergeable: true
      });
      const input_lists_length = input.lists.length;
      for (let i = 0; i < input_lists_length; i++) {
        getTypeCacheKeys$S(rootKeySet, luvio, input.lists[i]);
      }
    }
    const notifyUpdateAvailableFactory$3 = luvio => {
      return function notifyListInfoSummaryUpdateAvailable(configs) {
        {
          const requiredKeyParams = ['objectApiName', 'queryString', 'recentListsOnly'];
          configs.forEach(config => {
            if (false === requiredKeyParams.every(req => req in config)) {
              throw new Error(`one of the configs did not contain all required parameters: ${JSONStringify(ObjectKeys(config))}`);
            }
          });
        }
        const keys = configs.map(c => keyBuilder$23(luvio, c));
        return luvio.notifyStoreUpdateAvailable(keys);
      };
    };
    const LIST_RECORDS_PREFIX = keyPrefix + '::' + RepresentationType$U;
    const LIST_SUMMARY_PREFIX = keyPrefix + '::' + RepresentationType$R;
    /**
     * Watch a Luvio instance for ListRecordCollection and ListInfoSummaryCollection cache entries.
     */
    let listRecordCollectionCache = new Map();
    let listSummaryCollectionCache = new Map();
    function getListRecordCollectionKeys(objectApiName, listViewApiName) {
      const cacheEntriesByObjectApiName = listRecordCollectionCache.get(objectApiName.toLowerCase()) || new Map();
      const keys = cacheEntriesByObjectApiName.get(listViewApiName.toLowerCase()) || [];
      return [...keys];
    }
    function getListSummaryCollectionKeys(objectApiName, recentLists = undefined) {
      const cacheEntriesByObjectApiName = listSummaryCollectionCache.get(objectApiName) || new Map();
      const keys = cacheEntriesByObjectApiName.get(recentLists ? 'true' : 'false') || [];
      const allKeys = recentLists === undefined ? cacheEntriesByObjectApiName.get('true') || [] : [];
      return [...keys, ...allKeys];
    }
    function addListRecordCollectionKey(objectApiName, listViewApiName, key) {
      const cacheEntryByObjectName = listRecordCollectionCache.get(objectApiName) || new Map();
      if (!cacheEntryByObjectName.size) {
        listRecordCollectionCache.set(objectApiName, cacheEntryByObjectName);
      }
      const keys = cacheEntryByObjectName.get(listViewApiName) || new Set();
      if (!keys.size) {
        cacheEntryByObjectName.set(listViewApiName, keys);
      }
      keys.add(key);
    }
    function addListSummaryCollectionKey(objectApiName, recentLists, key) {
      const cacheEntryByObjectName = listSummaryCollectionCache.get(objectApiName) || new Map();
      if (!cacheEntryByObjectName.size) {
        listSummaryCollectionCache.set(objectApiName, cacheEntryByObjectName);
      }
      const keys = cacheEntryByObjectName.get(recentLists) || new Set();
      if (!keys.size) {
        cacheEntryByObjectName.set(recentLists, keys);
      }
      keys.add(key);
    }
    function splitListRecordCollectionKey(key) {
      const keyElements = key.split(':');
      return {
        objectApiName: keyElements[3],
        listViewApiName: keyElements[7]
      };
    }
    function splitListSummaryCollectionKey(key) {
      const keyElements = key.split(':');
      return {
        objectApiName: keyElements[3],
        recentLists: keyElements[5]
      };
    }
    function setupListRecordCollectionStoreWatcher(luvio) {
      luvio.storeWatch(LIST_RECORDS_PREFIX, entries => {
        for (let i = 0, len = entries.length; i < len; i++) {
          const entry = entries[i];
          if (entry.id.endsWith('__pagination')) {
            continue;
          }
          const {
            objectApiName,
            listViewApiName
          } = splitListRecordCollectionKey(entry.id);
          addListRecordCollectionKey(objectApiName, listViewApiName, entry.id);
        }
      });
    }
    function setupListSummaryCollectionStoreWatcher(luvio) {
      luvio.storeWatch(LIST_SUMMARY_PREFIX, entries => {
        for (let i = 0, len = entries.length; i < len; i++) {
          const entry = entries[i];
          if (entry.id.endsWith('__pagination')) {
            continue;
          }
          const {
            objectApiName,
            recentLists
          } = splitListSummaryCollectionKey(entry.id);
          addListSummaryCollectionKey(objectApiName, recentLists, entry.id);
        }
      });
    }
    function buildListRefByIdContextKey(listViewId) {
      return `listReferenceById::${listViewId}`;
    }
    function buildListRefByApiNameContextKey(objectApiName, listViewApiName) {
      return `listReferenceByApiName::${objectApiName.toLowerCase()}:${listViewApiName.toLowerCase()}`;
    }
    /**
     * Adds a list reference so it can be retrieved with #getListReference later.
     *
     * @param listRef list reference
     */
    function addListReference(listRef, context) {
      addListReferenceWithId(listRef, context, listRef.id);
    }
    /**
     * Adds a list reference with some specified key so it can be retrieved with #getListReference later.
     *
     * @param listRef
     * @param context
     * @param id - Specified Id to use in the context key
     */
    function addListReferenceWithId(listRef, context, id) {
      // Add listReference by id if present
      if (id) {
        context.set(buildListRefByIdContextKey(id), listRef);
      }
      // Add listReference by objectApiName & listViewApiName
      context.set(buildListRefByApiNameContextKey(listRef.objectApiName, listRef.listViewApiName || ''), listRef);
    }
    /**
     * Returns a list reference from the store if it's present.
     *
     * @param query list view to look for
     * @param luvio Luvio
     */
    function getListReference(query, context) {
      return query.listViewId ? context.get(buildListRefByIdContextKey(query.listViewId)) : context.get(buildListRefByApiNameContextKey(query.objectApiName || '', query.listViewApiName || ''));
    }
    /**
     * Reader selections to copy a list info
     */
    const LIST_INFO_SELECTIONS = select$1X().selections;
    /**
     * List info private memebers
     */
    select$1X().private;
    const LIST_INFO_SELECTIONS_ETAG = [...LIST_INFO_SELECTIONS, {
      kind: 'Scalar',
      name: 'eTag'
    }];
    /**
     * Retrieves the snapshot of the list info corresponding to the specified list
     * reference from the store.
     *
     * @param listRef list reference
     * @param luvio Luvio
     */
    function getListInfo(luvio, listRef, storeLookup) {
      let mutatedListRef = {
        ...listRef
      };
      mutatedListRef.objectApiName = mutatedListRef.objectApiName.toLowerCase();
      mutatedListRef.listViewApiName = mutatedListRef.listViewApiName ? mutatedListRef.listViewApiName.toLowerCase() : mutatedListRef.listViewApiName;
      const key = keyBuilder$2a(luvio, {
        ...mutatedListRef
      });
      return storeLookup({
        recordId: key,
        node: {
          kind: 'Fragment',
          selections: LIST_INFO_SELECTIONS_ETAG,
          private: [],
          version: VERSION$1i
        },
        variables: {}
      });
    }
    function buildDefaultsKey(listRef) {
      const {
        objectApiName,
        listViewApiName
      } = listRef;
      return `defaults::${objectApiName.toLowerCase()}:${listViewApiName ? listViewApiName.toLowerCase() : listViewApiName}`;
    }
    /**
     * Update the default values based on a server response.
     *
     * @param config getListUi config
     * @param serverResponse ListUiRepresentation from the server
     */
    function addServerDefaults(config, records, listReference, context) {
      // If the request already contains the potential default information,
      // or the response does not come back with a default or comes back wih an empty array []
      if (config.sortBy !== undefined && config.sortBy.length > 0 || records.sortBy === null) {
        return;
      }
      const key = buildDefaultsKey(listReference);
      const currentDefaults = context.get(key) || {};
      context.set(key, {
        ...currentDefaults,
        sortBy: records.sortBy
      });
    }
    /**
     * Returns default values observed on previous requests for a list.
     *
     * @param config getListUi config
     * @returns defaults from previous requests for this list, or {} if no defaults are known
     */
    function getServerDefaults(config, context) {
      const listRef = getListReference(config, context);
      if (listRef === undefined) {
        return {};
      }
      const key = buildDefaultsKey(listRef);
      return context.get(key) || {};
    }
    // Logic to deal with fields on the list view. This would be reasonably straightforward
    // except that the server sometimes adds 5 well-known fields to every record & nested
    // record in its responses.
    // hardcoded fields that the server adds
    const DEFAULT_SERVER_FIELDS = ['CreatedDate', 'Id', 'LastModifiedById', 'LastModifiedDate', 'SystemModstamp'];
    /**
     * Adds default fields for every record referenced in a given field name. E.g. if field
     * is "Opportunity.Account.Name" then add default fields "Opportunity.CreatedDate",
     * "Opportunity.Id", ..., "Opportunity.Account.CreatedDate", "Opportunity.Account.Id", ... .
     *
     * @param field explicitly included field
     * @param defaultFields fields object to be updated with the fields that the server will
     *    implicitly add
     */
    function addDefaultFields(field, defaultFields) {
      const fieldParts = field.split('.');
      for (let i = 1; i < fieldParts.length; ++i) {
        const fieldPrefix = fieldParts.slice(0, i).join('.');
        for (let j = 0; j < DEFAULT_SERVER_FIELDS.length; ++j) {
          defaultFields[`${fieldPrefix}.${DEFAULT_SERVER_FIELDS[j]}`] = true;
        }
      }
    }
    /**
     * Indicates if a RecordRepresentation contains a specified field.
     *
     * @param record record
     * @param field field to check for, split on '.'s, with the leading object api name omitted.
     *    E.g. if searching an Opportunity for "Opportunity.Account.Name" this parameter should
     *    be ['Account','Name'].
     */
    function recordContainsField(record, field) {
      // make sure it looks like a record and the first piece of the field path has a value
      if (!record || !record.fields || !record.fields[field[0]] || record.fields[field[0]].value === undefined) {
        return false;
      }
      // recurse if nested record
      else if (field.length > 1) {
        return recordContainsField(record.fields[field[0]].value, field.slice(1));
      }
      // found it
      return true;
    }
    function listFields(luvio, {
      fields = [],
      optionalFields = [],
      sortBy
    }, listInfo) {
      const {
        displayColumns,
        listReference: {
          objectApiName
        }
      } = listInfo;
      let fields_ = {},
        optionalFields_ = {},
        defaultFields_ = {};
      // all the fields in the list info are required
      for (let i = 0, len = displayColumns.length; i < len; ++i) {
        const qualifiedField = `${objectApiName}.${displayColumns[i].fieldApiName}`;
        fields_[qualifiedField] = true;
        addDefaultFields(qualifiedField, defaultFields_);
      }
      // required fields from the component
      for (let i = 0, len = fields.length; i < len; ++i) {
        const qualifiedField = fields[i].startsWith(`${objectApiName}.`) ? fields[i] : `${objectApiName}.${fields[i]}`;
        if (!fields_[qualifiedField]) {
          fields_[qualifiedField] = true;
          addDefaultFields(qualifiedField, defaultFields_);
        }
      }
      // optional fields from the component
      for (let i = 0, len = optionalFields.length; i < len; ++i) {
        const qualifiedField = optionalFields[i].startsWith(`${objectApiName}.`) ? optionalFields[i] : `${objectApiName}.${optionalFields[i]}`;
        if (!fields_[qualifiedField]) {
          optionalFields_[qualifiedField] = true;
          addDefaultFields(qualifiedField, defaultFields_);
        }
      }
      const key = keyBuilder$26(luvio, {
        listViewId: listInfo.eTag,
        sortBy: sortBy || null,
        searchTerm: null,
        where: null,
        objectApiName: listInfo.listReference.objectApiName,
        listViewApiName: listInfo.listReference.listViewApiName
      }) + '__fieldstatus';
      const node = luvio.getNode(key);
      const defaultServerFieldStatus = isGraphNode(node) ? node.retrieve() : {
        missingFields: {
          ...defaultFields_
        }
      };
      return {
        getRecordSelectionFieldSets() {
          const optionalPlusDefaultFields = {
            ...optionalFields_
          };
          const fields = keys(defaultFields_);
          for (let i = 0; i < fields.length; ++i) {
            const field = fields[i];
            if (!fields_[field] && !defaultServerFieldStatus.missingFields[field]) {
              optionalPlusDefaultFields[field] = true;
            }
          }
          return [keys(fields_).sort(), keys(optionalPlusDefaultFields).sort()];
        },
        processRecords(records) {
          const {
            missingFields
          } = defaultServerFieldStatus;
          const fields = keys(missingFields);
          for (let i = 0; i < fields.length; ++i) {
            const field = fields[i],
              splitField = field.split('.').slice(1);
            for (let i = 0; i < records.length; ++i) {
              if (recordContainsField(records[i], splitField)) {
                delete missingFields[field];
                break;
              }
            }
          }
          luvio.storePublish(key, defaultServerFieldStatus);
          // snapshots do not subscribe to this key, so no need to broadcast
          return this;
        }
      };
    }
    function setupNotifyAllListRecordUpdateAvailable(luvio) {
      return notifyInput => {
        const keys = getListRecordCollectionKeys(notifyInput.objectApiName, notifyInput.listViewApiName);
        // W-16311716 - Bug is happening because we are removing keys from the cache when
        // the actual data has not changed. This causes a mismatch in this notifyAll cache
        // vs the actual LDS cache. Not removing these keys from the notifyAll cache has
        // no forseen drawbacks
        //removeListRecordCollectionKeys(notifyInput.objectApiName, notifyInput.listViewApiName);
        return luvio.notifyStoreUpdateAvailable(keys);
      };
    }
    function setupNotifyAllListInfoSummaryUpdateAvailable(luvio) {
      return notifyInput => {
        const keys = getListSummaryCollectionKeys(notifyInput.objectApiName, notifyInput.recentLists);
        // W-16311716 - Bug is happening because we are removing keys from the cache when
        // the actual data has not changed. This causes a mismatch in this notifyAll cache
        // vs the actual LDS cache. Not removing these keys from the notifyAll cache has
        // no forseen drawbacks
        //removeListSummaryCollectionKeys(notifyInput.objectApiName, notifyInput.recentLists);
        return luvio.notifyStoreUpdateAvailable(keys);
      };
    }
    let context$1;
    function setContext$1(adapterContext) {
      context$1 = adapterContext;
    }
    function keyBuilder$22(luvio, params) {
      // lists data can now be fetched using case insensitive urlParams therefore
      // also changing contextStore to use lowercase caching
      const query = {
        objectApiName: params.urlParams.objectApiName.toLowerCase(),
        listViewApiName: params.urlParams.listViewApiName.toLowerCase()
      };
      // Fetch listReference from internal store to better ensure a cache hit regardless of listViewApiName or listViewId
      const listReference = getListReference(query, context$1);
      if (listReference !== undefined) {
        // Check and use any default values returned from the server (i.e. sortBy)
        const config = {
          ...params.urlParams,
          ...params.body
        };
        const defaults = getServerDefaults(config, context$1);
        // Use default values when sortBy is undefined or an empty Array []
        return keyBuilder$26(luvio, {
          objectApiName: listReference.objectApiName.toLowerCase(),
          listViewApiName: listReference.listViewApiName ? listReference.listViewApiName.toLowerCase() : listReference.listViewApiName,
          // # removing listViewId from key only supporing getting records using api name
          // listViewId: listReference.id,
          searchTerm: params.body.searchTerm || null,
          where: params.body.where || null,
          sortBy: params.body.sortBy !== undefined && params.body.sortBy.length <= 0 ? defaults.sortBy || params.body.sortBy || [] : params.body.sortBy || defaults.sortBy || []
        });
      }
      // If there are no matching entries in the store, then we haven't fetched any data for this list view yet.
      // Assuming that listViewId is empty and continue on
      return keyBuilder$26(luvio, {
        objectApiName: params.urlParams.objectApiName.toLowerCase(),
        listViewApiName: params.urlParams.listViewApiName.toLowerCase(),
        // # removing listViewId from key only supporing getting records using api name
        // listViewId: '',
        searchTerm: params.body.searchTerm || null,
        where: params.body.where || null,
        sortBy: params.body.sortBy || []
      });
    }
    function select$1P(luvio, params) {
      const {
        fields = [],
        optionalFields = []
      } = params.body;
      return dynamicSelect$7({
        records: {
          name: 'records',
          kind: 'Link',
          fragment: {
            kind: 'Fragment',
            private: ['eTag', 'weakEtag'],
            selections: buildSelectionFromFields(fields, optionalFields),
            version: VERSION$1e
          }
        }
      }, createPaginationParams$4(params));
    }
    function ingestSuccess$R(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$22(luvio, resourceParams);
      luvio.storeIngest(key, ingest$N, body);
      const optionalFields = resourceParams.body.optionalFields;
      if (optionalFields && optionalFields.length > 0) {
        const normalized = body;
        markMissingOptionalFieldsOnRecords$1(luvio, normalized, optionalFields);
      }
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1P(luvio, resourceParams),
        variables: {}
      }, snapshotRefresh);
      return snapshot;
    }
    function markMissingOptionalFieldsOnRecords$1(luvio, nomalized, optionalFields) {
      const records = nomalized.records;
      for (let i = 0; i < records.length; i++) {
        const record = records[i];
        const recordKey = record.__ref;
        if (recordKey !== undefined) {
          const node = luvio.getNode(recordKey);
          markMissingOptionalFields(node, optionalFields);
        }
      }
    }
    function createPaginationParams$4(params) {
      const {
        body
      } = params;
      return {
        token: body.pageToken,
        pageSize: body.pageSize === undefined ? 50 : body.pageSize
      };
    }
    function getResponseCacheKeys$10(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$U(storeKeyMap, luvio, response);
    }
    function ingestError$K(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$22(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$y,
        namespace: keyPrefix,
        version: VERSION$1c,
        representationName: RepresentationType$U
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$16(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-records/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }

    /**
     * Examines a set of paginated data & metadata from an UnfulfilledSnapshot and computes a
     * pageToken and pageSize that will minimize the amount of data requested while still
     * satisfying the original request.
     *
     * @param config.name name of the field within data that contains the items
     * @param conifg.data paginated data/metadata from an UnfulfilledSnapshot
     * @param config.pageSize requested pageSize
     * @param config.pagination pagination data/functions from engine
     * @returns pageToken & pageSize to fill in the missing data
     */
    function minimizeRequest(config) {
      // the only way to handle missing current or previous token is to ask for the full set of requested records
      if (!config.data || !config.data[config.name] || config.data.previousPageToken === undefined) {
        return {
          pageSize: config.pageSize,
          pageToken: config.pageToken
        };
      } else {
        // compute the offset of the last record that was found
        const {
          offsetFromToken,
          tokenForAtMost,
          paginationMetadata
        } = config.pagination;
        const pageTokenOffset = offsetFromToken(paginationMetadata, config.data.currentPageToken);
        if (pageTokenOffset < 0) {
          return {
            pageSize: config.pageSize,
            pageToken: config.pageToken
          };
        }
        const lastFoundOffset = pageTokenOffset + config.data[config.name].length;
        // backup to the nearest offset for which we have a token
        const [newToken, newOffset] = tokenForAtMost(paginationMetadata, lastFoundOffset);
        // recompute pageToken and pageSize for query based on new starting token
        return {
          pageSize: pageTokenOffset - newOffset + config.pageSize,
          pageToken: newToken
        };
      }
    }
    function isFulfilledSnapshot(snapshot) {
      return snapshot.state === 'Fulfilled';
    }
    function isUnfulfilledSnapshot(snapshot) {
      return snapshot.state === 'Unfulfilled';
    }
    function isStaleSnapshot(snapshot) {
      return snapshot.state === 'Stale';
    }
    function isErrorSnapshot(snapshot) {
      return snapshot.state === 'Error';
    }
    const VERSION$18 = "3529c5f7d0eb2206c90a52c6d9f721d4";
    function validate$1Q(obj, path = 'ListViewSummaryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
          if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union0_error != null) {
          obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
          if (obj_id !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union1_error != null) {
          obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
          let message = 'Object doesn\'t match union (at "' + path_id + '")';
          message += '\n' + obj_id_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_id_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_listUiUrl = obj.listUiUrl;
        const path_listUiUrl = path + '.listUiUrl';
        if (typeof obj_listUiUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_listUiUrl + '" (at "' + path_listUiUrl + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$Q = 'ListViewSummaryRepresentation';
    function keyBuilder$21(luvio, config) {
      return keyPrefix + '::' + RepresentationType$Q + ':' + (config.id === null ? '' : config.id);
    }
    function keyBuilderFromType$y(luvio, object) {
      const keyParams = {
        id: object.id
      };
      return keyBuilder$21(luvio, keyParams);
    }
    function normalize$J(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1O = function ListViewSummaryRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$18,
        private: [],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'listUiUrl',
          kind: 'Scalar'
        }]
      };
    };
    function equals$_(existing, incoming) {
      const existing_apiName = existing.apiName;
      const incoming_apiName = incoming.apiName;
      if (!(existing_apiName === incoming_apiName)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      const existing_listUiUrl = existing.listUiUrl;
      const incoming_listUiUrl = incoming.listUiUrl;
      if (!(existing_listUiUrl === incoming_listUiUrl)) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      return true;
    }
    const ingest$J = function ListViewSummaryRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1Q(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$y(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$J, "UiApi", VERSION$18, RepresentationType$Q, equals$_);
      return createLink(key);
    };
    function getTypeCacheKeys$Q(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$y(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$Q,
        mergeable: false
      });
    }
    const VERSION$17 = "f4c79fe066da3558499d5ee88c72abcd";
    function validate$1P(obj, path = 'ListViewSummaryCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count) {
          return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        if (typeof obj_currentPageToken !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_lists = obj.lists;
        const path_lists = path + '.lists';
        if (!ArrayIsArray(obj_lists)) {
          return new TypeError('Expected "array" but received "' + typeof obj_lists + '" (at "' + path_lists + '")');
        }
        for (let i = 0; i < obj_lists.length; i++) {
          const obj_lists_item = obj_lists[i];
          const path_lists_item = path_lists + '[' + i + ']';
          if (typeof obj_lists_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_lists_item + '" (at "' + path_lists_item + '")');
          }
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
          if (typeof obj_nextPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union0_error != null) {
          obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
          if (obj_nextPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union1_error != null) {
          obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
          message += '\n' + obj_nextPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
          if (typeof obj_nextPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union0_error != null) {
          obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
          if (obj_nextPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union1_error != null) {
          obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
          message += '\n' + obj_nextPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_pageSize = obj.pageSize;
        const path_pageSize = path + '.pageSize';
        if (typeof obj_pageSize !== 'number' || typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize) {
          return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
          if (typeof obj_previousPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union0_error != null) {
          obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
          if (obj_previousPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union1_error != null) {
          obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
          message += '\n' + obj_previousPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
          if (typeof obj_previousPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union0_error != null) {
          obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
          if (obj_previousPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union1_error != null) {
          obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
          message += '\n' + obj_previousPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_queryString = obj.queryString;
        const path_queryString = path + '.queryString';
        let obj_queryString_union0 = null;
        const obj_queryString_union0_error = (() => {
          if (typeof obj_queryString !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_queryString + '" (at "' + path_queryString + '")');
          }
        })();
        if (obj_queryString_union0_error != null) {
          obj_queryString_union0 = obj_queryString_union0_error.message;
        }
        let obj_queryString_union1 = null;
        const obj_queryString_union1_error = (() => {
          if (obj_queryString !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_queryString + '" (at "' + path_queryString + '")');
          }
        })();
        if (obj_queryString_union1_error != null) {
          obj_queryString_union1 = obj_queryString_union1_error.message;
        }
        if (obj_queryString_union0 && obj_queryString_union1) {
          let message = 'Object doesn\'t match union (at "' + path_queryString + '")';
          message += '\n' + obj_queryString_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_queryString_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_recentListsOnly = obj.recentListsOnly;
        const path_recentListsOnly = path + '.recentListsOnly';
        if (typeof obj_recentListsOnly !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_recentListsOnly + '" (at "' + path_recentListsOnly + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$P = 'ListViewSummaryCollectionRepresentation';
    function keyBuilder$20(luvio, config) {
      return keyPrefix + '::' + RepresentationType$P + ':' + config.objectApiName + ':' + (config.queryString === null ? '' : config.queryString) + ':' + config.recentListsOnly;
    }
    function keyBuilderFromType$x(luvio, object) {
      const keyParams = {
        objectApiName: object.objectApiName,
        queryString: object.queryString,
        recentListsOnly: object.recentListsOnly
      };
      return keyBuilder$20(luvio, keyParams);
    }
    function normalize$I(input, existing, path, luvio, store, timestamp) {
      const input_lists = input.lists;
      const input_lists_id = path.fullPath + '__lists';
      for (let i = 0; i < input_lists.length; i++) {
        const input_lists_item = input_lists[i];
        let input_lists_item_id = input_lists_id + '__' + i;
        input_lists[i] = ingest$J(input_lists_item, {
          fullPath: input_lists_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1N = function ListViewSummaryCollectionRepresentationSelect(paginationParams) {
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: false,
        version: VERSION$17,
        read: (source, reader) => {
          const sink = {};
          if (paginationParams === undefined) {
            return sink;
          }
          const metadata = reader.resolveMetadata(source, PAGINATION_VERSION$1);
          const currentPageMetadata = getPageMetadata$1(metadata, paginationParams);
          const {
            startOffset,
            endOffset,
            metadataProperties
          } = currentPageMetadata;
          if (metadata !== undefined && startOffset !== undefined && endOffset !== undefined) {
            const itemsProperty = 'lists';
            reader.enterPath(itemsProperty);
            const itemsSource = source[itemsProperty];
            const itemsSink = [];
            const allSink = [];
            for (let i = startOffset; i < endOffset; i++) {
              reader.enterPath(i);
              reader.readSingleLink(i, {
                name: 'lists',
                kind: 'Link',
                fragment: select$1O()
              }, itemsSource, allSink, i - startOffset);
              if (reader.getIsDataMissing() === false) {
                itemsSink[i - startOffset] = allSink[i - startOffset];
              }
              reader.exitPath();
            }
            reader.exitPath();
            reader.assignNonScalar(sink, itemsProperty, itemsSink);
          }
          reader.enterPath('currentPageToken');
          reader.readScalar('currentPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('nextPageToken');
          reader.readScalar('nextPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('previousPageToken');
          reader.readScalar('previousPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('pageSize');
          reader.readScalar('pageSize', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('count');
          reader.readScalar('count', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('objectApiName');
          reader.readScalar('objectApiName', source, sink);
          reader.exitPath();
          reader.enterPath('queryString');
          reader.readScalar('queryString', source, sink);
          reader.exitPath();
          reader.enterPath('recentListsOnly');
          reader.readScalar('recentListsOnly', source, sink);
          reader.exitPath();
          return sink;
        }
      };
    };
    function getPageMetadata$1(paginationMetadata, paginationParams) {
      const metadataProperties = {};
      const sink = {
        metadataProperties
      };
      if (paginationMetadata === undefined) {
        return sink;
      }
      const {
        token,
        pageSize
      } = paginationParams;
      const pageTokenAndOffset = getPageTokenAndOffset$1(paginationMetadata, token);
      if (pageTokenAndOffset === undefined) {
        return sink;
      }
      const [pageToken, startOffset] = pageTokenAndOffset;
      const endOffset = pageEndOffset$1(paginationMetadata, startOffset, pageSize);
      sink.startOffset = startOffset;
      sink.endOffset = endOffset;
      metadataProperties.currentPageToken = pageToken;
      const nextToken = getNextPageToken(paginationMetadata, endOffset);
      if (nextToken !== undefined) {
        metadataProperties.nextPageToken = nextToken;
      }
      const previousToken = getPreviousPageToken(paginationMetadata, startOffset, pageSize);
      if (previousToken !== undefined) {
        metadataProperties.previousPageToken = previousToken;
      }
      metadataProperties.pageSize = pageSize;
      metadataProperties.count = endOffset - startOffset;
      return sink;
    }
    function equals$Z(existing, incoming) {
      const existing_recentListsOnly = existing.recentListsOnly;
      const incoming_recentListsOnly = incoming.recentListsOnly;
      if (!(existing_recentListsOnly === incoming_recentListsOnly)) {
        return false;
      }
      const existing_count = existing.count;
      const incoming_count = incoming.count;
      if (!(existing_count === incoming_count)) {
        return false;
      }
      const existing_pageSize = existing.pageSize;
      const incoming_pageSize = incoming.pageSize;
      if (!(existing_pageSize === incoming_pageSize)) {
        return false;
      }
      const existing_currentPageToken = existing.currentPageToken;
      const incoming_currentPageToken = incoming.currentPageToken;
      if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
      }
      const existing_currentPageUrl = existing.currentPageUrl;
      const incoming_currentPageUrl = incoming.currentPageUrl;
      if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_objectApiName = existing.objectApiName;
      const incoming_objectApiName = incoming.objectApiName;
      if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
      }
      const existing_lists = existing.lists;
      const incoming_lists = incoming.lists;
      const equals_lists_items = equalsArray(existing_lists, incoming_lists, (existing_lists_item, incoming_lists_item) => {
        if (!(existing_lists_item.__ref === incoming_lists_item.__ref)) {
          return false;
        }
      });
      if (equals_lists_items === false) {
        return false;
      }
      const existing_nextPageToken = existing.nextPageToken;
      const incoming_nextPageToken = incoming.nextPageToken;
      if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
      }
      const existing_nextPageUrl = existing.nextPageUrl;
      const incoming_nextPageUrl = incoming.nextPageUrl;
      if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
      }
      const existing_previousPageToken = existing.previousPageToken;
      const incoming_previousPageToken = incoming.previousPageToken;
      if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
      }
      const existing_previousPageUrl = existing.previousPageUrl;
      const incoming_previousPageUrl = incoming.previousPageUrl;
      if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
      }
      const existing_queryString = existing.queryString;
      const incoming_queryString = incoming.queryString;
      if (!(existing_queryString === incoming_queryString)) {
        return false;
      }
      return true;
    }
    const ingest$I = function ListViewSummaryCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1P(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$x(luvio, input);
      const existingRecord = store.readEntry(key);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      let incomingRecord = normalize$I(input, store.readEntry(key), {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
        ttl: ttlToUse
      }, luvio, store, timestamp);
      const paginationKey = key + '__pagination';
      const existingPaginationMetadata = store.readEntry(paginationKey);
      const {
        count: count,
        currentPageToken: token,
        nextPageToken: nextToken,
        pageSize: pageSize,
        previousPageToken: previousToken,
        lists: items
      } = input;
      const startOffset = existingPaginationMetadata === undefined ? 0 : offsetFromToken(existingPaginationMetadata, token);
      {
        if (startOffset < 0 || existingRecord && existingRecord.lists && existingRecord.lists.length < startOffset) {
          throw new RangeError('currentPageToken value ' + token + ' is not recognized');
        }
      }
      const incomingPaginationMetadata = {
        [token]: startOffset
      };
      const nextOffset = startOffset + items.length;
      if (nextToken === null) {
        incomingPaginationMetadata.__END__ = nextOffset;
      } else {
        incomingPaginationMetadata[nextToken] = nextOffset;
        if (existingPaginationMetadata !== undefined) {
          const listEndOffset = existingPaginationMetadata.__END__;
          if (listEndOffset !== undefined && nextOffset >= listEndOffset) {
            incomingPaginationMetadata.__END__ = undefined;
          }
        }
      }
      if (previousToken !== null) {
        incomingPaginationMetadata[previousToken] = Math.max(startOffset - pageSize, 0);
      }
      const mergedPaginationMetadata = mergeMetadata$1(existingPaginationMetadata, incomingPaginationMetadata);
      if (existingPaginationMetadata === undefined || equalsObject(existingPaginationMetadata, mergedPaginationMetadata, (existingProp, incomingProp) => {
        return existingProp === incomingProp;
      }) === false) {
        luvio.storePublish(paginationKey, mergedPaginationMetadata);
        luvio.publishStoreMetadata(paginationKey, paginationStoreMetadata$1);
      }
      assignMetadataLink(incomingRecord, paginationKey);
      if (existingRecord !== undefined && existingRecord.lists !== undefined) {
        incomingRecord.lists = [...existingRecord.lists.slice(0, startOffset), ...incomingRecord.lists, ...existingRecord.lists.slice(nextOffset)];
      }
      if (existingRecord === undefined || equals$Z(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
      }
      if (ttlToUse !== undefined) {
        const storeMetadataParams = {
          ttl: ttlToUse,
          namespace: "UiApi",
          version: VERSION$17,
          representationName: RepresentationType$P,
          ingestionTimestamp: timestamp
        };
        luvio.publishStoreMetadata(key, storeMetadataParams);
      }
      return createLink(key);
    };
    function getTypeCacheKeys$P(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$x(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$P,
        mergeable: true
      });
      rootKeySet.set(rootKey + '__pagination', {
        namespace: keyPrefix,
        representationName: RepresentationType$P,
        mergeable: true
      });
      const input_lists_length = input.lists.length;
      for (let i = 0; i < input_lists_length; i++) {
        getTypeCacheKeys$Q(rootKeySet, luvio, input.lists[i]);
      }
    }
    const notifyUpdateAvailableFactory$2 = luvio => {
      return function notifyListViewSummaryUpdateAvailable(configs) {
        {
          const requiredKeyParams = ['objectApiName', 'queryString', 'recentListsOnly'];
          configs.forEach(config => {
            if (false === requiredKeyParams.every(req => req in config)) {
              throw new Error(`one of the configs did not contain all required parameters: ${JSONStringify(ObjectKeys(config))}`);
            }
          });
        }
        const keys = configs.map(c => keyBuilder$20(luvio, c));
        return luvio.notifyStoreUpdateAvailable(keys);
      };
    };
    function createPaginationParams$3(params) {
      const {
        queryParams
      } = params;
      return {
        token: queryParams.pageToken,
        pageSize: queryParams.pageSize === undefined ? 20 : queryParams.pageSize
      };
    }
    function select$1M(luvio, params) {
      const paginationParams = createPaginationParams$3(params);
      return select$1N(paginationParams);
    }
    function keyBuilder$1$(luvio, params) {
      return keyBuilder$20(luvio, {
        objectApiName: params.urlParams.objectApiName,
        queryString: params.queryParams.q || null,
        recentListsOnly: params.queryParams.recentListsOnly || false
      });
    }
    function getResponseCacheKeys$$(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$P(storeKeyMap, luvio, response);
    }
    function ingestSuccess$Q(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1$(luvio, resourceParams);
      luvio.storeIngest(key, ingest$I, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1M(luvio, resourceParams),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$J(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1$(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$15(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-ui/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$10 = 'getListViewSummaryCollection';
    const getListViewSummaryCollection_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageToken', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('q', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('recentListsOnly', false, 1 /* QueryParameter */, 1 /* Boolean */)];
    const getListViewSummaryCollection_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$10, getListViewSummaryCollection_ConfigPropertyMetadata);
    const createResourceParams$_ = /*#__PURE__*/luvioEngine.createResourceParams(getListViewSummaryCollection_ConfigPropertyMetadata);
    function keyBuilder$1_(luvio, config) {
      const resourceParams = createResourceParams$_(config);
      return keyBuilder$1$(luvio, resourceParams);
    }
    function typeCheckConfig$15(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getListViewSummaryCollection_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$17(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getListViewSummaryCollection_ConfigPropertyMetadata);
      const config = typeCheckConfig$15(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$I(luvio, config) {
      const resourceParams = createResourceParams$_(config);
      return select$1M(luvio, resourceParams);
    }
    function onFetchResponseSuccess$M(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$Q(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$14(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$N(luvio, config, resourceParams, response) {
      const snapshot = ingestError$J(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$14(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function prepareRequest$6(luvio, config, resourceParams, cacheSnapshot) {
      if (cacheSnapshot === undefined) {
        return createResourceRequest$15(resourceParams);
      }
      const [newToken, newPageSize] = minimizePaginationParams$2(luvio, resourceParams, cacheSnapshot);
      if (newToken === undefined) {
        return createResourceRequest$15(resourceParams);
      }
      return createResourceRequest$15(createResourceParams$_({
        ...config,
        pageSize: newPageSize,
        pageToken: newToken
      }));
    }
    function minimizePaginationParams$2(luvio, resourceParams, cacheSnapshot) {
      const num = getCachedItemsNumber$3(cacheSnapshot);
      if (num > 0) {
        const paginationMetadata = getPaginationMetadata$3(luvio, resourceParams);
        if (paginationMetadata !== undefined) {
          const {
            token: configToken,
            pageSize: configPageSize
          } = createPaginationParams$3(resourceParams);
          const configTokenOffset = offsetFromToken(paginationMetadata, configToken);
          if (configTokenOffset < 0) {
            return [undefined, -1];
          }
          const maxOffset = configTokenOffset + num;
          const [token, offset] = tokenForAtMost(paginationMetadata, maxOffset);
          if (token !== undefined) {
            return [token, configPageSize - (offset - configTokenOffset)];
          }
        }
      }
      return [undefined, -1];
    }
    function getCachedItemsNumber$3(cacheSnapshot) {
      const {
        data
      } = cacheSnapshot;
      if (data === undefined || !data.lists) {
        return 0;
      }
      const items = data.lists;
      for (let i = 0; i < items.length; i++) {
        if (items[i] === undefined) {
          return i;
        }
      }
      return items.length;
    }
    function getPaginationMetadata$3(luvio, resourceParams) {
      const key = keyBuilder$1$(luvio, resourceParams);
      const selector = {
        recordId: key,
        node: {
          kind: 'Fragment',
          version: VERSION$17,
          private: [],
          selections: [{
            kind: 'Link',
            name: '__metadata',
            fragment: {
              kind: 'Fragment',
              version: PAGINATION_VERSION$1,
              opaque: true,
              private: []
            }
          }]
        },
        variables: {}
      };
      const node = luvio.storeLookup(selector);
      if (node.state !== 'Fulfilled') {
        return;
      }
      return node.data.__metadata;
    }
    function buildNetworkSnapshot$14(luvio, config, options, cacheSnapshot) {
      const resourceParams = createResourceParams$_(config);
      const request = prepareRequest$6(luvio, config, resourceParams, cacheSnapshot);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$M(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$$(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$N(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$Q(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$14, undefined, true);
    }
    function buildCachedSnapshotCachePolicy$P(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1_(luvio, config),
        node: adapterFragment$I(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$14(luvio, config, snapshotRefreshOptions)
      });
      if (isUnfulfilledSnapshot$1(cacheSnapshot) && cacheSnapshot.data !== undefined) {
        context.cacheSnapshot = cacheSnapshot;
      }
      return cacheSnapshot;
    }
    const getListViewSummaryCollectionAdapterFactory = luvio => function UiApi__getListViewSummaryCollection(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$17(untrustedConfig, getListViewSummaryCollection_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$P, buildNetworkSnapshotCachePolicy$Q);
    };
    function createPaginationParams$2(params) {
      const {
        queryParams
      } = params;
      return {
        token: queryParams.pageToken,
        pageSize: queryParams.pageSize === undefined ? 50 : queryParams.pageSize
      };
    }
    function keyBuilder$1Z(luvio, params) {
      return keyBuilder$25(luvio, {
        listViewApiName: null,
        objectApiName: params.urlParams.objectApiName,
        type: "mru",
        sortBy: params.queryParams.sortBy || null
      });
    }
    function createResourceRequest$14(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/mru-list-ui/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$$ = 'getMruListUi';
    const getMruListUi_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('fields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('optionalFields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageToken', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('sortBy', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray)];
    const getMruListUi_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$$, getMruListUi_ConfigPropertyMetadata);
    const createResourceParams$Z = /*#__PURE__*/luvioEngine.createResourceParams(getMruListUi_ConfigPropertyMetadata);
    function typeCheckConfig$14(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getMruListUi_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$16(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getMruListUi_ConfigPropertyMetadata);
      const config = typeCheckConfig$14(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function createResourceRequest$13(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/mru-list-records/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }

    /**
     * Returns a BuildNetworkSnapshot function that always returns a Promise<ErrorSnapshot>.
     *
     * @param luvio Luvio instance
     * @param status status code for ErrorSnapshot, defaults to 400
     * @param statusText status text for ErrorSnapshot, defaults to 'data is not fetchable'
     * @returns BuildNetworkSnapshot that always returns Promise<ErrorSnapshot>
     */
    function buildNotFetchableNetworkSnapshot(luvio, status = 400, statusText = 'data is not fetchable') {
      return _context => Promise.resolve(luvio.errorSnapshot({
        status,
        statusText,
        ok: false,
        body: undefined,
        headers: {},
        errorType: 'fetchResponse'
      }));
    }
    function isPromise(value) {
      return value.then !== undefined;
    }

    // eslint-disable-next-line @salesforce/lds/no-invalid-todo
    // TODO RAML - this more properly goes in the generated resource files
    const DEFAULT_PAGE_SIZE$1 = 50;
    // make local copies of the adapter configs so we can ignore other getListUi config parameters to match
    // lds222 behavior
    const getMruListUi_ConfigPropertyNames_augmented = {
      ...getMruListUi_ConfigPropertyNames,
      parameters: {
        ...getMruListUi_ConfigPropertyNames.parameters,
        optional: [...getMruListUi_ConfigPropertyNames.parameters.optional, 'listViewApiName', 'listViewId']
      }
    };
    function buildListUiFragment$1(config, fields) {
      const resourceParams = createResourceParams$Z(config);
      const paginationParams = createPaginationParams$2(resourceParams);
      const recordSelectParams = {
        records: {
          name: 'records',
          kind: 'Link',
          fragment: {
            kind: 'Fragment',
            private: ['eTag', 'weakEtag'],
            selections: buildSelectionFromFields(...fields.getRecordSelectionFieldSets()),
            version: VERSION$1e
          }
        }
      };
      const listRecordCollectionSelect = dynamicSelect$7(recordSelectParams, paginationParams);
      const listRecordCollectionSelectParams = {
        records: {
          name: 'records',
          kind: 'Link',
          fragment: listRecordCollectionSelect
        }
      };
      return dynamicSelect$6(listRecordCollectionSelectParams, paginationParams);
    }
    function buildSnapshotRefresh_getMruListUi(luvio, config) {
      return {
        config,
        resolve: () => buildNetworkSnapshot_getMruListUi(luvio, config)
      };
    }
    function onResourceSuccess_getMruListUi(luvio, config, response) {
      const {
        body
      } = response;
      const listInfo = body.info;
      const listUiKey = keyBuilder$25(luvio, {
        ...listInfo.listReference,
        sortBy: body.records.sortBy
      });
      // grab relevant bits before ingest destroys the structure
      const fields = listFields(luvio, config, listInfo);
      fields.processRecords(body.records.records);
      // build the selector while the list info is still easily accessible
      const fragment = buildListUiFragment$1(config, fields);
      luvio.storeIngest(listUiKey, ingest$M, body);
      const snapshot = luvio.storeLookup({
        recordId: listUiKey,
        node: fragment,
        variables: {}
      }, buildSnapshotRefresh_getMruListUi(luvio, config));
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onResourceError_getMruListUi(luvio, config, err) {
      return Promise.resolve(luvio.errorSnapshot(err, buildSnapshotRefresh_getMruListUi(luvio, config)));
    }
    function buildCachedSnapshot$8(luvio, storeLookup, config, listInfo, fields) {
      const listFields_ = fields || listFields(luvio, config, listInfo);
      const resourceParams = createResourceParams$Z(config);
      const selector = {
        recordId: keyBuilder$1Z(luvio, resourceParams),
        node: buildListUiFragment$1(config, listFields_),
        variables: {}
      };
      return storeLookup(selector, buildSnapshotRefresh_getMruListUi(luvio, config));
    }
    /**
     * Builds, sends, and processes the result of a mru-list-ui request, ignoring any cached
     * data for the list.
     *
     * @param luvio Luvio engine
     * @param config wire config
     */
    function buildNetworkSnapshot_getMruListUi(luvio, config, dispatchOptions) {
      const params = createResourceParams$Z(config);
      const request = createResourceRequest$14(params);
      return luvio.dispatchResourceRequest(request, dispatchOptions).then(response => {
        const {
          body
        } = response;
        // response might have records.sortBy in csv format but keyBuilder/ingestion
        // functions expect it to be an array so coerce it here if needed
        const sortBy = body.records.sortBy;
        if (sortBy && typeof sortBy === 'string') {
          body.records.sortBy = sortBy.split(',');
        }
        return luvio.handleSuccessResponse(() => onResourceSuccess_getMruListUi(luvio, config, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getTypeCacheKeys$T(cache, luvio, body);
          return cache;
        });
      }, err => {
        return luvio.handleErrorResponse(() => onResourceError_getMruListUi(luvio, config, err));
      });
    }
    function prepareRequest_getMruListRecords(luvio, config, listInfo, snapshot) {
      const {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy
      } = config;
      const queryParams = {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy
      };
      const request = createResourceRequest$13({
        urlParams: {
          objectApiName: config.objectApiName
        },
        queryParams
      });
      if (snapshot) {
        const paginationKey = paginationKeyBuilder(luvio, {
          listViewId: listInfo.eTag,
          searchTerm: null,
          where: null,
          sortBy: config.sortBy === undefined ? null : config.sortBy,
          objectApiName: listInfo.listReference.objectApiName.toLowerCase(),
          listViewApiName: listInfo.listReference.listViewApiName ? listInfo.listReference.listViewApiName.toLowerCase() : listInfo.listReference.listViewApiName
        });
        const selector = {
          recordId: paginationKey,
          node: {
            kind: 'Fragment',
            private: [],
            opaque: true,
            version: PAGINATION_VERSION$1
          },
          variables: {}
        };
        const metadataSnapshot = luvio.storeLookup(selector);
        const paginationMetadata = metadataSnapshot.state === 'Fulfilled' ? metadataSnapshot.data : {};
        // compute the minimum number of records we need to request
        const {
          pageSize,
          pageToken
        } = minimizeRequest({
          data: snapshot.data ? snapshot.data.records : null,
          name: 'records',
          pageSize: config.pageSize || DEFAULT_PAGE_SIZE$1,
          pageToken: config.pageToken,
          pagination: {
            offsetFromToken,
            tokenForAtMost,
            paginationMetadata
          }
        });
        // update request, but don't harden default values unless they were already present
        if (pageSize !== DEFAULT_PAGE_SIZE$1 || request.queryParams.pageSize !== undefined) {
          request.queryParams.pageSize = pageSize;
        }
        if (pageToken !== undefined || request.queryParams.pageToken !== undefined) {
          request.queryParams.pageToken = pageToken;
        }
      }
      return request;
    }
    // Only call this function if you are certain the list view hasn't changed (ie:
    // the listInfoEtag in the body is the same as the cached listInfo.eTag)
    function onResourceSuccess_getMruListRecords(luvio, config, listInfo, response) {
      const {
        body
      } = response;
      const {
        listInfoETag
      } = body;
      const fields = listFields(luvio, config, listInfo).processRecords(body.records);
      luvio.storeIngest(keyBuilder$26(luvio, {
        listViewId: listInfoETag,
        searchTerm: null,
        where: null,
        sortBy: body.sortBy,
        objectApiName: listInfo.listReference.objectApiName.toLowerCase(),
        listViewApiName: listInfo.listReference.listViewApiName ? listInfo.listReference.listViewApiName.toLowerCase() : listInfo.listReference.listViewApiName
      }), ingest$N, body);
      const snapshot = buildCachedSnapshot$8(luvio, luvio.storeLookup.bind(luvio), config, listInfo, fields);
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onResourceError_getMruListRecords(luvio, config, listInfo, err) {
      const errorSnapshot = luvio.errorSnapshot(err, buildSnapshotRefresh_getMruListUi(luvio, config));
      luvio.storeIngestError(keyBuilder$25(luvio, {
        ...listInfo.listReference,
        sortBy: config.sortBy === undefined ? null : config.sortBy
      }), errorSnapshot);
      return luvio.storeBroadcast().then(() => errorSnapshot);
    }
    function buildNetworkSnapshot_getMruListRecords(luvio, config, listInfo, dispatchOptions, snapshot) {
      const request = prepareRequest_getMruListRecords(luvio, config, listInfo, snapshot);
      return luvio.dispatchResourceRequest(request, dispatchOptions).then(response => {
        const {
          body
        } = response;
        // fall back to mru-list-ui if list view has changed
        if (body.listInfoETag !== listInfo.eTag) {
          return buildNetworkSnapshot_getMruListUi(luvio, config, dispatchOptions);
        }
        // response might have records.sortBy in csv format but keyBuilder/ingestion
        // functions expect it to be an array so coerce it here if needed
        const {
          sortBy
        } = body;
        if (sortBy && typeof sortBy === 'string') {
          body.sortBy = sortBy.split(',');
        }
        // else ingest
        return luvio.handleSuccessResponse(() => onResourceSuccess_getMruListRecords(luvio, config, listInfo, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getTypeCacheKeys$U(cache, luvio, body);
          return cache;
        });
      }, err => {
        return luvio.handleErrorResponse(() => {
          return onResourceError_getMruListRecords(luvio, config, listInfo, err);
        });
      });
    }
    function buildCachedListInfoSnapshot$1(context, storeLookup, luvio) {
      const {
        config
      } = context;
      // try to get a list reference and a list info for the list; this should come back
      // non-null if we have the list info cached
      return getListInfo(luvio, {
        id: null,
        listViewApiName: null,
        objectApiName: config.objectApiName.toLowerCase(),
        type: 'mru'
      }, storeLookup);
    }
    function buildCachedListUiSnapshot$1(context, storeLookup) {
      const {
        config,
        listInfo,
        luvio
      } = context;
      if (listInfo !== undefined) {
        context.listUi = buildCachedSnapshot$8(luvio, storeLookup, config, listInfo);
        return context.listUi;
      }
    }
    function buildNetworkListUiSnapshot$1(context, coercedAdapterRequestContext) {
      const {
        config,
        listInfo,
        listUi,
        luvio
      } = context;
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      // make the full list ui request if any of the following is true:
      //
      // - the list info was not found
      // - we couldn't build enough of the list ui to locate any record data
      // - we found the complete cached list ui; this is somewhat counterintuitive,
      //   but it happens when the cache policy has decided to refetch cached data
      if (!listInfo || !listUi || !listUi.data || isFulfilledSnapshot(listUi) || isStaleSnapshot(listUi)) {
        return buildNetworkSnapshot_getMruListUi(luvio, config, dispatchOptions);
      }
      // we *should* only be missing records and/or tokens at this point; send a list-records
      // request to fill them in
      return buildNetworkSnapshot_getMruListRecords(luvio, config, listInfo, dispatchOptions, listUi);
    }
    const factory$i = luvio => function getMruListUi(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$16(untrustedConfig, getMruListUi_ConfigPropertyNames_augmented);
      if (config === null) {
        return null;
      }
      const definedRequestContext = requestContext || {};
      // try to find a cached ListInfoRepresentation
      const listInfoPromiseOrSnapshot = luvio.applyCachePolicy(definedRequestContext, {
        config,
        luvio
      }, buildCachedListInfoSnapshot$1, buildNotFetchableNetworkSnapshot(luvio));
      // build the ListUiRepresentation from the cached ListInfoRepresentation (if any)
      const processListInfo = listInfoSnapshot => {
        const listInfo = isFulfilledSnapshot(listInfoSnapshot) || isStaleSnapshot(listInfoSnapshot) ? listInfoSnapshot.data : undefined;
        return luvio.applyCachePolicy(definedRequestContext, {
          config,
          listInfo,
          luvio
        }, buildCachedListUiSnapshot$1, buildNetworkListUiSnapshot$1);
      };
      return isPromise(listInfoPromiseOrSnapshot) ? listInfoPromiseOrSnapshot.then(processListInfo) : processListInfo(listInfoPromiseOrSnapshot);
    };
    const contextId$5 = `${keyPrefix}__getListUi`;
    // eslint-disable-next-line @salesforce/lds/no-invalid-todo
    // TODO RAML - this more properly goes in the generated resource files
    const DEFAULT_PAGE_SIZE = 50;
    // make local copies of the adapter configs so we can have them ignore each other's config parameters
    // to match lds222 behavior
    const getListUiByApiName_ConfigPropertyNames_augmented = {
      ...getListUiByApiName_ConfigPropertyNames,
      parameters: {
        ...getListUiByApiName_ConfigPropertyNames.parameters,
        optional: [...getListUiByApiName_ConfigPropertyNames.parameters.optional, 'listViewId']
      }
    };
    const getListUiByListViewId_ConfigPropertyNames_augmented = {
      ...getListUiByListViewId_ConfigPropertyNames,
      parameters: {
        ...getListUiByListViewId_ConfigPropertyNames.parameters,
        optional: [...getListUiByListViewId_ConfigPropertyNames.parameters.optional, 'listViewApiName', 'objectApiName']
      }
    };
    function getSortBy(config, context) {
      if (config.sortBy !== undefined) {
        return config.sortBy;
      }
      const defaults = getServerDefaults(config, context);
      if (defaults.sortBy !== undefined) {
        return defaults.sortBy;
      }
      return null;
    }
    function buildListUiFragment(config, context, fields) {
      const defaultedConfig = {
        ...getServerDefaults(config, context),
        ...config
      };
      let paginationParams;
      if (isGetListUiByListViewIdConfig(defaultedConfig)) {
        const resourceParams = createResourceParams$$(defaultedConfig);
        paginationParams = createPaginationParams$5(resourceParams);
      } else if (isGetListUiByApiNameConfig(defaultedConfig)) {
        const resourceParams = createResourceParams$10(defaultedConfig);
        paginationParams = createPaginationParams$6(resourceParams);
      }
      const recordSelectParams = {
        records: {
          name: 'records',
          kind: 'Link',
          fragment: {
            kind: 'Fragment',
            private: ['eTag', 'weakEtag'],
            selections: buildSelectionFromFields(...fields.getRecordSelectionFieldSets()),
            version: VERSION$1e
          }
        }
      };
      const listRecordCollectionSelect = dynamicSelect$7(recordSelectParams, paginationParams);
      const listRecordCollectionSelectParams = {
        records: {
          name: 'records',
          kind: 'Link',
          fragment: listRecordCollectionSelect
        }
      };
      return dynamicSelect$6(listRecordCollectionSelectParams, paginationParams);
    }
    function buildCachedSnapshot$7(luvio, storeLookup, context, config, listInfo, fields) {
      const listUiKey = keyBuilder$25(luvio, {
        ...listInfo.listReference,
        sortBy: getSortBy(config, context)
      });
      // ok to pass luvio here since listFields() ignores TTL when getting cached field information
      const listFields_ = fields || listFields(luvio, config, listInfo);
      const selector = {
        recordId: listUiKey,
        node: buildListUiFragment(config, context, listFields_),
        variables: {}
      };
      return storeLookup(selector, buildSnapshotRefresh_getListUi(luvio, context, config));
    }
    function buildSnapshotRefresh_getListUi(luvio, context, config) {
      return {
        config,
        resolve: () => buildNetworkSnapshot_getListUi(luvio, context, config, undefined)
      };
    }
    function prepareRequest_getListUi(config) {
      const {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy
      } = config;
      const queryParams = {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy
      };
      let request;
      if (isGetListUiByApiNameConfig(config)) {
        request = createResourceRequest$19({
          urlParams: {
            listViewApiName: config.listViewApiName,
            objectApiName: config.objectApiName
          },
          queryParams
        });
      } else if (isGetListUiByListViewIdConfig(config)) {
        request = createResourceRequest$18({
          urlParams: {
            listViewId: config.listViewId
          },
          queryParams
        });
      } else {
        // eslint-disable-next-line @salesforce/lds/no-error-in-production
        throw new Error('unrecognized config');
      }
      return request;
    }
    function onResourceSuccess_getListUi(luvio, context, config, response) {
      const {
          body
        } = response,
        listInfo = body.info,
        {
          listReference
        } = listInfo;
      const listUiKey = keyBuilder$25(luvio, {
        ...listReference,
        sortBy: body.records.sortBy
      });
      // grab relevant bits before ingest destroys the structure
      const fields = listFields(luvio, config, listInfo);
      fields.processRecords(body.records.records);
      // remember the id/name of this list
      addListReference(listReference, context);
      // remember any default values that the server filled in
      addServerDefaults(config, body.records, listReference, context);
      // build the selector while the list info is still easily accessible
      const fragment = buildListUiFragment(config, context, fields);
      luvio.storeIngest(listUiKey, ingest$M, body);
      const snapshot = luvio.storeLookup({
        recordId: listUiKey,
        node: fragment,
        variables: {}
      }, buildSnapshotRefresh_getListUi(luvio, context, config));
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onResourceError_getListUi(luvio, context, config, err) {
      return Promise.resolve(luvio.errorSnapshot(err, buildSnapshotRefresh_getListUi(luvio, context, config)));
    }
    /**
     * Builds, sends, and processes the result of a list-ui request, ignoring any cached
     * data for the list view.
     *
     * @param luvio Luvio engine
     * @param config wire config
     */
    function buildNetworkSnapshot_getListUi(luvio, context, config, dispatchOptions) {
      const request = prepareRequest_getListUi(config);
      return luvio.dispatchResourceRequest(request, dispatchOptions).then(response => {
        const {
          body
        } = response;
        // response might have records.sortBy in csv format but keyBuilder/ingestion
        // functions expect it to be an array so coerce it here if needed
        const sortBy = body.records.sortBy;
        if (sortBy && typeof sortBy === 'string') {
          body.records.sortBy = sortBy.split(',');
        }
        return luvio.handleSuccessResponse(() => onResourceSuccess_getListUi(luvio, context, config, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getTypeCacheKeys$T(cache, luvio, body);
          return cache;
        });
      }, err => {
        return luvio.handleErrorResponse(() => {
          return onResourceError_getListUi(luvio, context, config, err);
        });
      });
    }
    function prepareRequest_getListRecords(luvio, context, config, listInfo, snapshot) {
      const {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy
      } = config;
      const queryParams = {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy
      };
      const body = {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy
      };
      let request;
      if (isGetListUiByApiNameConfig(config)) {
        request = createResourceRequest$16({
          urlParams: {
            listViewApiName: config.listViewApiName,
            objectApiName: config.objectApiName
          },
          body
        });
      } else if (isGetListUiByListViewIdConfig(config)) {
        request = createResourceRequest$17({
          urlParams: {
            listViewId: config.listViewId
          },
          queryParams
        });
      } else {
        // eslint-disable-next-line @salesforce/lds/no-error-in-production
        throw new Error('how did MRU config get here?');
      }
      let releaseKeys = () => {};
      if (snapshot) {
        if (snapshot.state !== 'Error') {
          const {
            recordId,
            seenRecords
          } = snapshot;
          const snapshotRetainedIds = seenRecords === undefined ? [recordId] : [recordId, ...seenRecords.keysAsArray()];
          const snapshotKeys = [];
          snapshotRetainedIds.forEach(key => snapshotKeys.push(key));
          releaseKeys = luvio.storeRetain(snapshotKeys);
        }
        const paginationKey = paginationKeyBuilder(luvio, {
          listViewId: listInfo.eTag,
          searchTerm: null,
          where: null,
          sortBy: getSortBy(config, context),
          objectApiName: listInfo.listReference.objectApiName.toLowerCase(),
          listViewApiName: listInfo.listReference.listViewApiName ? listInfo.listReference.listViewApiName.toLowerCase() : listInfo.listReference.listViewApiName
        });
        const selector = {
          recordId: paginationKey,
          node: {
            kind: 'Fragment',
            private: [],
            opaque: true,
            version: PAGINATION_VERSION$1
          },
          variables: {}
        };
        const metadataSnapshot = luvio.storeLookup(selector);
        const paginationMetadata = metadataSnapshot.state === 'Fulfilled' ? metadataSnapshot.data : {};
        // compute the minimum number of records we need to request
        const {
          pageSize,
          pageToken
        } = minimizeRequest({
          data: snapshot.data ? snapshot.data.records : null,
          name: 'records',
          pageSize: config.pageSize || DEFAULT_PAGE_SIZE,
          pageToken: config.pageToken,
          pagination: {
            offsetFromToken,
            tokenForAtMost,
            paginationMetadata
          }
        });
        // update request, but don't harden default values unless they were already present
        if (pageSize !== DEFAULT_PAGE_SIZE || request.queryParams.pageSize !== undefined) {
          request.queryParams.pageSize = pageSize;
        }
        if (pageToken || request.queryParams.pageToken !== undefined) {
          request.queryParams.pageToken = pageToken;
        }
      }
      return {
        request: request,
        releaseKeys: releaseKeys
      };
    }
    // Only call this function if you are certain the list view hasn't changed (ie:
    // the listInfoEtag in the body is the same as the cached listInfo.eTag)
    function onResourceSuccess_getListRecords(luvio, context, config, listInfo, response, releaseKeys) {
      const {
        body
      } = response;
      const {
        listInfoETag
      } = body;
      const fields = listFields(luvio, config, listInfo).processRecords(body.records);
      luvio.storeIngest(keyBuilder$26(luvio, {
        listViewId: listInfoETag,
        searchTerm: null,
        where: null,
        sortBy: body.sortBy,
        objectApiName: listInfo.listReference.objectApiName.toLowerCase(),
        listViewApiName: listInfo.listReference.listViewApiName ? listInfo.listReference.listViewApiName.toLowerCase() : listInfo.listReference.listViewApiName
      }), ingest$N, body);
      const snapshot = buildCachedSnapshot$7(luvio, luvio.storeLookup.bind(luvio), context, config, listInfo, fields);
      releaseKeys();
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onResourceError_getListRecords(luvio, context, config, listInfo, err, releaseKeys) {
      const errorSnapshot = luvio.errorSnapshot(err);
      luvio.storeIngestError(keyBuilder$25(luvio, {
        ...listInfo.listReference,
        sortBy: getSortBy(config, context)
      }), errorSnapshot);
      releaseKeys();
      return luvio.storeBroadcast().then(() => errorSnapshot);
    }
    function buildNetworkSnapshot_getListRecords(luvio, context, config, listInfo, dispatchOptions, snapshot) {
      const {
        request,
        releaseKeys
      } = prepareRequest_getListRecords(luvio, context, config, listInfo, snapshot);
      return luvio.dispatchResourceRequest(request).then(response => {
        const {
          body
        } = response;
        // fall back to list-ui if list view has changed
        if (body.listInfoETag !== listInfo.eTag) {
          return buildNetworkSnapshot_getListUi(luvio, context, config, dispatchOptions);
        }
        // response might have records.sortBy in csv format but keyBuilder/ingestion
        // functions expect it to be an array so coerce it here if needed
        const {
          sortBy
        } = body;
        if (sortBy && typeof sortBy === 'string') {
          body.sortBy = sortBy.split(',');
        }
        // else ingest
        return luvio.handleSuccessResponse(() => onResourceSuccess_getListRecords(luvio, context, config, listInfo, response, releaseKeys), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getTypeCacheKeys$U(cache, luvio, body);
          return cache;
        });
      }, err => {
        return luvio.handleErrorResponse(() => {
          return onResourceError_getListRecords(luvio, context, config, listInfo, err, releaseKeys);
        });
      });
    }
    function buildCachedListInfoSnapshot(context, storeLookup, luvio) {
      const {
        adapterContext,
        config
      } = context;
      // try to get a list reference and a list info for the list; this should come back
      // non-null if we have the list info cached
      const listRef = getListReference(config, adapterContext);
      // no listRef means we can't even attempt to build a cached snapshot
      // so make a full list-ui request
      if (listRef === undefined) {
        return;
      }
      return getListInfo(luvio, listRef, storeLookup);
    }
    function buildCachedListUiSnapshot(context, storeLookup) {
      const {
        adapterContext,
        config,
        listInfo,
        luvio
      } = context;
      if (listInfo !== undefined) {
        context.listUi = buildCachedSnapshot$7(luvio, storeLookup, adapterContext, config, listInfo);
        return context.listUi;
      }
    }
    function buildNetworkListUiSnapshot(context, coercedAdapterRequestContext) {
      const {
        adapterContext,
        config,
        listInfo,
        listUi,
        luvio
      } = context;
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      // make the full list ui request if any of the following is true:
      //
      // - the list info was not found
      // - we couldn't build enough of the list ui to locate any record data
      // - we found the complete cached list ui; this is somewhat counterintuitive,
      //   but it happens when the cache policy has decided to refetch cached data
      if (!listInfo || !listUi || !listUi.data || isFulfilledSnapshot(listUi) || isStaleSnapshot(listUi)) {
        return buildNetworkSnapshot_getListUi(luvio, adapterContext, config, dispatchOptions);
      }
      // we *should* only be missing records and/or tokens at this point; send a list-records
      // request to fill them in
      return buildNetworkSnapshot_getListRecords(luvio, adapterContext, config, listInfo, dispatchOptions, listUi);
    }
    // functions to discern config variations
    function isGetListUiByApiNameConfig(config) {
      return config.listViewApiName !== undefined;
    }
    function looksLikeGetListUiByApiNameConfig(untrustedConfig) {
      return untrustedIsObject(untrustedConfig) && untrustedConfig.objectApiName && untrustedConfig.listViewApiName;
    }
    function isGetListUiByListViewIdConfig(config) {
      return !!config.listViewId;
    }
    function looksLikeGetListUiByListViewIdConfig(untrustedConfig) {
      return untrustedIsObject(untrustedConfig) && untrustedConfig.listViewId;
    }
    function looksLikeGetListViewSummaryCollectionConfig(untrustedConfig) {
      return untrustedIsObject(untrustedConfig) && untrustedConfig.objectApiName && !untrustedConfig.listViewId && !untrustedConfig.listViewApiName;
    }
    function looksLikeGetMruListUiConfig(untrustedConfig) {
      // the MRU symbol is a carryover hack from 222 and doesn't show up in any
      // of the generated config types, so we cast to any in order to check for it
      return untrustedIsObject(untrustedConfig) && untrustedConfig.listViewApiName === MRU;
    }
    function validateGetListUiConfig(untrustedConfig) {
      return looksLikeGetListUiByApiNameConfig(untrustedConfig) ? validateAdapterConfig$19(untrustedConfig, getListUiByApiName_ConfigPropertyNames_augmented) : looksLikeGetListUiByListViewIdConfig(untrustedConfig) ? validateAdapterConfig$18(untrustedConfig, getListUiByListViewId_ConfigPropertyNames_augmented) : null;
    }
    // the listViewApiName value to pass to getListUi() to request the MRU list
    const MRU = Symbol.for('MRU');
    const factory$h = luvio => {
      // adapter implementation for getListUiBy*
      const listUiAdapter = (untrustedConfig, adapterContext, requestContext) => {
        const config = validateGetListUiConfig(untrustedConfig);
        if (config === null) {
          return null;
        }
        const definedRequestContext = requestContext || {};
        // try to find a cached ListInfoRepresentation
        const listInfoPromiseOrSnapshot = luvio.applyCachePolicy(definedRequestContext, {
          adapterContext,
          config,
          luvio
        }, buildCachedListInfoSnapshot, buildNotFetchableNetworkSnapshot(luvio));
        // build the ListUiRepresentation from the cached ListInfoRepresentation (if any)
        const processListInfo = listInfoSnapshot => {
          const listInfo = isFulfilledSnapshot(listInfoSnapshot) || isStaleSnapshot(listInfoSnapshot) ? listInfoSnapshot.data : undefined;
          return luvio.applyCachePolicy(definedRequestContext, {
            adapterContext,
            config,
            listInfo,
            luvio
          }, buildCachedListUiSnapshot, buildNetworkListUiSnapshot);
        };
        return isPromise(listInfoPromiseOrSnapshot) ? listInfoPromiseOrSnapshot.then(processListInfo) : processListInfo(listInfoPromiseOrSnapshot);
      };
      let listViewSummaryCollectionAdapter = null;
      let mruAdapter = null;
      // delegate to various other adapter based on what config looks like; note that the adapters
      // we delegate to are responsible for returning refreshable results
      return luvio.withContext(function UiApi__custom_getListUi(untrustedConfig, adapterContext, requestContext) {
        // if the MRU symbol is there then just return the getMruListUi adapter
        if (looksLikeGetMruListUiConfig(untrustedConfig)) {
          if (mruAdapter === null) {
            mruAdapter = factory$i(luvio);
          }
          // the symbol in the listViewApiName is just a hack so we can recognize the request as MRU
          const mruConfig = {
            ...untrustedConfig
          };
          delete mruConfig.listViewApiName;
          return mruAdapter(mruConfig, requestContext);
        }
        // if config has objectApiName but no listViewId or listViewApiName then hand off
        // to listViewSummaryCollectionAdapter
        if (looksLikeGetListViewSummaryCollectionConfig(untrustedConfig)) {
          if (listViewSummaryCollectionAdapter === null) {
            listViewSummaryCollectionAdapter = getListViewSummaryCollectionAdapterFactory(luvio);
          }
          return listViewSummaryCollectionAdapter(untrustedConfig, requestContext);
        }
        // see if config looks like a listViewId or listViewApiName request
        if (looksLikeGetListUiByApiNameConfig(untrustedConfig) || looksLikeGetListUiByListViewIdConfig(untrustedConfig)) {
          return listUiAdapter(untrustedConfig, adapterContext, requestContext);
        }
        return null;
      }, {
        contextId: contextId$5
      });
    };
    function validate$1O(obj, path = 'ChildRelationshipRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_childObjectApiName = obj.childObjectApiName;
        const path_childObjectApiName = path + '.childObjectApiName';
        if (typeof obj_childObjectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_childObjectApiName + '" (at "' + path_childObjectApiName + '")');
        }
        const obj_fieldName = obj.fieldName;
        const path_fieldName = path + '.fieldName';
        if (typeof obj_fieldName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldName + '" (at "' + path_fieldName + '")');
        }
        const obj_junctionIdListNames = obj.junctionIdListNames;
        const path_junctionIdListNames = path + '.junctionIdListNames';
        if (!ArrayIsArray(obj_junctionIdListNames)) {
          return new TypeError('Expected "array" but received "' + typeof obj_junctionIdListNames + '" (at "' + path_junctionIdListNames + '")');
        }
        for (let i = 0; i < obj_junctionIdListNames.length; i++) {
          const obj_junctionIdListNames_item = obj_junctionIdListNames[i];
          const path_junctionIdListNames_item = path_junctionIdListNames + '[' + i + ']';
          if (typeof obj_junctionIdListNames_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_junctionIdListNames_item + '" (at "' + path_junctionIdListNames_item + '")');
          }
        }
        const obj_junctionReferenceTo = obj.junctionReferenceTo;
        const path_junctionReferenceTo = path + '.junctionReferenceTo';
        if (!ArrayIsArray(obj_junctionReferenceTo)) {
          return new TypeError('Expected "array" but received "' + typeof obj_junctionReferenceTo + '" (at "' + path_junctionReferenceTo + '")');
        }
        for (let i = 0; i < obj_junctionReferenceTo.length; i++) {
          const obj_junctionReferenceTo_item = obj_junctionReferenceTo[i];
          const path_junctionReferenceTo_item = path_junctionReferenceTo + '[' + i + ']';
          if (typeof obj_junctionReferenceTo_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_junctionReferenceTo_item + '" (at "' + path_junctionReferenceTo_item + '")');
          }
        }
        const obj_relationshipName = obj.relationshipName;
        const path_relationshipName = path + '.relationshipName';
        if (typeof obj_relationshipName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_relationshipName + '" (at "' + path_relationshipName + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$1N(obj, path = 'FilteredLookupInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_controllingFields = obj.controllingFields;
        const path_controllingFields = path + '.controllingFields';
        if (!ArrayIsArray(obj_controllingFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_controllingFields + '" (at "' + path_controllingFields + '")');
        }
        for (let i = 0; i < obj_controllingFields.length; i++) {
          const obj_controllingFields_item = obj_controllingFields[i];
          const path_controllingFields_item = path_controllingFields + '[' + i + ']';
          if (typeof obj_controllingFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_controllingFields_item + '" (at "' + path_controllingFields_item + '")');
          }
        }
        const obj_dependent = obj.dependent;
        const path_dependent = path + '.dependent';
        if (typeof obj_dependent !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_dependent + '" (at "' + path_dependent + '")');
        }
        const obj_optionalFilter = obj.optionalFilter;
        const path_optionalFilter = path + '.optionalFilter';
        if (typeof obj_optionalFilter !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_optionalFilter + '" (at "' + path_optionalFilter + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$1M(obj, path = 'ReferenceToInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_nameFields = obj.nameFields;
        const path_nameFields = path + '.nameFields';
        if (!ArrayIsArray(obj_nameFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_nameFields + '" (at "' + path_nameFields + '")');
        }
        for (let i = 0; i < obj_nameFields.length; i++) {
          const obj_nameFields_item = obj_nameFields[i];
          const path_nameFields_item = path_nameFields + '[' + i + ']';
          if (typeof obj_nameFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nameFields_item + '" (at "' + path_nameFields_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$1L(obj, path = 'FieldRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_calculated = obj.calculated;
        const path_calculated = path + '.calculated';
        if (typeof obj_calculated !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_calculated + '" (at "' + path_calculated + '")');
        }
        const obj_compound = obj.compound;
        const path_compound = path + '.compound';
        if (typeof obj_compound !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_compound + '" (at "' + path_compound + '")');
        }
        const obj_compoundComponentName = obj.compoundComponentName;
        const path_compoundComponentName = path + '.compoundComponentName';
        let obj_compoundComponentName_union0 = null;
        const obj_compoundComponentName_union0_error = (() => {
          if (typeof obj_compoundComponentName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_compoundComponentName + '" (at "' + path_compoundComponentName + '")');
          }
        })();
        if (obj_compoundComponentName_union0_error != null) {
          obj_compoundComponentName_union0 = obj_compoundComponentName_union0_error.message;
        }
        let obj_compoundComponentName_union1 = null;
        const obj_compoundComponentName_union1_error = (() => {
          if (obj_compoundComponentName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_compoundComponentName + '" (at "' + path_compoundComponentName + '")');
          }
        })();
        if (obj_compoundComponentName_union1_error != null) {
          obj_compoundComponentName_union1 = obj_compoundComponentName_union1_error.message;
        }
        if (obj_compoundComponentName_union0 && obj_compoundComponentName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_compoundComponentName + '")';
          message += '\n' + obj_compoundComponentName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_compoundComponentName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_compoundFieldName = obj.compoundFieldName;
        const path_compoundFieldName = path + '.compoundFieldName';
        let obj_compoundFieldName_union0 = null;
        const obj_compoundFieldName_union0_error = (() => {
          if (typeof obj_compoundFieldName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_compoundFieldName + '" (at "' + path_compoundFieldName + '")');
          }
        })();
        if (obj_compoundFieldName_union0_error != null) {
          obj_compoundFieldName_union0 = obj_compoundFieldName_union0_error.message;
        }
        let obj_compoundFieldName_union1 = null;
        const obj_compoundFieldName_union1_error = (() => {
          if (obj_compoundFieldName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_compoundFieldName + '" (at "' + path_compoundFieldName + '")');
          }
        })();
        if (obj_compoundFieldName_union1_error != null) {
          obj_compoundFieldName_union1 = obj_compoundFieldName_union1_error.message;
        }
        if (obj_compoundFieldName_union0 && obj_compoundFieldName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_compoundFieldName + '")';
          message += '\n' + obj_compoundFieldName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_compoundFieldName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_controllerName = obj.controllerName;
        const path_controllerName = path + '.controllerName';
        let obj_controllerName_union0 = null;
        const obj_controllerName_union0_error = (() => {
          if (typeof obj_controllerName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_controllerName + '" (at "' + path_controllerName + '")');
          }
        })();
        if (obj_controllerName_union0_error != null) {
          obj_controllerName_union0 = obj_controllerName_union0_error.message;
        }
        let obj_controllerName_union1 = null;
        const obj_controllerName_union1_error = (() => {
          if (obj_controllerName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_controllerName + '" (at "' + path_controllerName + '")');
          }
        })();
        if (obj_controllerName_union1_error != null) {
          obj_controllerName_union1 = obj_controllerName_union1_error.message;
        }
        if (obj_controllerName_union0 && obj_controllerName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_controllerName + '")';
          message += '\n' + obj_controllerName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_controllerName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_controllingFields = obj.controllingFields;
        const path_controllingFields = path + '.controllingFields';
        if (!ArrayIsArray(obj_controllingFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_controllingFields + '" (at "' + path_controllingFields + '")');
        }
        for (let i = 0; i < obj_controllingFields.length; i++) {
          const obj_controllingFields_item = obj_controllingFields[i];
          const path_controllingFields_item = path_controllingFields + '[' + i + ']';
          if (typeof obj_controllingFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_controllingFields_item + '" (at "' + path_controllingFields_item + '")');
          }
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_custom = obj.custom;
        const path_custom = path + '.custom';
        if (typeof obj_custom !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_custom + '" (at "' + path_custom + '")');
        }
        const obj_dataType = obj.dataType;
        const path_dataType = path + '.dataType';
        if (typeof obj_dataType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_dataType + '" (at "' + path_dataType + '")');
        }
        const obj_externalId = obj.externalId;
        const path_externalId = path + '.externalId';
        if (typeof obj_externalId !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_externalId + '" (at "' + path_externalId + '")');
        }
        const obj_extraTypeInfo = obj.extraTypeInfo;
        const path_extraTypeInfo = path + '.extraTypeInfo';
        let obj_extraTypeInfo_union0 = null;
        const obj_extraTypeInfo_union0_error = (() => {
          if (typeof obj_extraTypeInfo !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_extraTypeInfo + '" (at "' + path_extraTypeInfo + '")');
          }
        })();
        if (obj_extraTypeInfo_union0_error != null) {
          obj_extraTypeInfo_union0 = obj_extraTypeInfo_union0_error.message;
        }
        let obj_extraTypeInfo_union1 = null;
        const obj_extraTypeInfo_union1_error = (() => {
          if (obj_extraTypeInfo !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_extraTypeInfo + '" (at "' + path_extraTypeInfo + '")');
          }
        })();
        if (obj_extraTypeInfo_union1_error != null) {
          obj_extraTypeInfo_union1 = obj_extraTypeInfo_union1_error.message;
        }
        if (obj_extraTypeInfo_union0 && obj_extraTypeInfo_union1) {
          let message = 'Object doesn\'t match union (at "' + path_extraTypeInfo + '")';
          message += '\n' + obj_extraTypeInfo_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_extraTypeInfo_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_filterable = obj.filterable;
        const path_filterable = path + '.filterable';
        if (typeof obj_filterable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_filterable + '" (at "' + path_filterable + '")');
        }
        const obj_filteredLookupInfo = obj.filteredLookupInfo;
        const path_filteredLookupInfo = path + '.filteredLookupInfo';
        let obj_filteredLookupInfo_union0 = null;
        const obj_filteredLookupInfo_union0_error = (() => {
          const referencepath_filteredLookupInfoValidationError = validate$1N(obj_filteredLookupInfo, path_filteredLookupInfo);
          if (referencepath_filteredLookupInfoValidationError !== null) {
            let message = 'Object doesn\'t match FilteredLookupInfoRepresentation (at "' + path_filteredLookupInfo + '")\n';
            message += referencepath_filteredLookupInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_filteredLookupInfo_union0_error != null) {
          obj_filteredLookupInfo_union0 = obj_filteredLookupInfo_union0_error.message;
        }
        let obj_filteredLookupInfo_union1 = null;
        const obj_filteredLookupInfo_union1_error = (() => {
          if (obj_filteredLookupInfo !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_filteredLookupInfo + '" (at "' + path_filteredLookupInfo + '")');
          }
        })();
        if (obj_filteredLookupInfo_union1_error != null) {
          obj_filteredLookupInfo_union1 = obj_filteredLookupInfo_union1_error.message;
        }
        if (obj_filteredLookupInfo_union0 && obj_filteredLookupInfo_union1) {
          let message = 'Object doesn\'t match union (at "' + path_filteredLookupInfo + '")';
          message += '\n' + obj_filteredLookupInfo_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_filteredLookupInfo_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_highScaleNumber = obj.highScaleNumber;
        const path_highScaleNumber = path + '.highScaleNumber';
        if (typeof obj_highScaleNumber !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_highScaleNumber + '" (at "' + path_highScaleNumber + '")');
        }
        const obj_htmlFormatted = obj.htmlFormatted;
        const path_htmlFormatted = path + '.htmlFormatted';
        if (typeof obj_htmlFormatted !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_htmlFormatted + '" (at "' + path_htmlFormatted + '")');
        }
        const obj_inlineHelpText = obj.inlineHelpText;
        const path_inlineHelpText = path + '.inlineHelpText';
        let obj_inlineHelpText_union0 = null;
        const obj_inlineHelpText_union0_error = (() => {
          if (typeof obj_inlineHelpText !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_inlineHelpText + '" (at "' + path_inlineHelpText + '")');
          }
        })();
        if (obj_inlineHelpText_union0_error != null) {
          obj_inlineHelpText_union0 = obj_inlineHelpText_union0_error.message;
        }
        let obj_inlineHelpText_union1 = null;
        const obj_inlineHelpText_union1_error = (() => {
          if (obj_inlineHelpText !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_inlineHelpText + '" (at "' + path_inlineHelpText + '")');
          }
        })();
        if (obj_inlineHelpText_union1_error != null) {
          obj_inlineHelpText_union1 = obj_inlineHelpText_union1_error.message;
        }
        if (obj_inlineHelpText_union0 && obj_inlineHelpText_union1) {
          let message = 'Object doesn\'t match union (at "' + path_inlineHelpText + '")';
          message += '\n' + obj_inlineHelpText_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_inlineHelpText_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_length = obj.length;
        const path_length = path + '.length';
        if (typeof obj_length !== 'number' || typeof obj_length === 'number' && Math.floor(obj_length) !== obj_length) {
          return new TypeError('Expected "integer" but received "' + typeof obj_length + '" (at "' + path_length + '")');
        }
        const obj_maskType = obj.maskType;
        const path_maskType = path + '.maskType';
        let obj_maskType_union0 = null;
        const obj_maskType_union0_error = (() => {
          if (typeof obj_maskType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_maskType + '" (at "' + path_maskType + '")');
          }
        })();
        if (obj_maskType_union0_error != null) {
          obj_maskType_union0 = obj_maskType_union0_error.message;
        }
        let obj_maskType_union1 = null;
        const obj_maskType_union1_error = (() => {
          if (obj_maskType !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_maskType + '" (at "' + path_maskType + '")');
          }
        })();
        if (obj_maskType_union1_error != null) {
          obj_maskType_union1 = obj_maskType_union1_error.message;
        }
        if (obj_maskType_union0 && obj_maskType_union1) {
          let message = 'Object doesn\'t match union (at "' + path_maskType + '")';
          message += '\n' + obj_maskType_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_maskType_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_nameField = obj.nameField;
        const path_nameField = path + '.nameField';
        if (typeof obj_nameField !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_nameField + '" (at "' + path_nameField + '")');
        }
        const obj_polymorphicForeignKey = obj.polymorphicForeignKey;
        const path_polymorphicForeignKey = path + '.polymorphicForeignKey';
        if (typeof obj_polymorphicForeignKey !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_polymorphicForeignKey + '" (at "' + path_polymorphicForeignKey + '")');
        }
        const obj_precision = obj.precision;
        const path_precision = path + '.precision';
        if (typeof obj_precision !== 'number' || typeof obj_precision === 'number' && Math.floor(obj_precision) !== obj_precision) {
          return new TypeError('Expected "integer" but received "' + typeof obj_precision + '" (at "' + path_precision + '")');
        }
        const obj_reference = obj.reference;
        const path_reference = path + '.reference';
        if (typeof obj_reference !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_reference + '" (at "' + path_reference + '")');
        }
        const obj_referenceTargetField = obj.referenceTargetField;
        const path_referenceTargetField = path + '.referenceTargetField';
        let obj_referenceTargetField_union0 = null;
        const obj_referenceTargetField_union0_error = (() => {
          if (typeof obj_referenceTargetField !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_referenceTargetField + '" (at "' + path_referenceTargetField + '")');
          }
        })();
        if (obj_referenceTargetField_union0_error != null) {
          obj_referenceTargetField_union0 = obj_referenceTargetField_union0_error.message;
        }
        let obj_referenceTargetField_union1 = null;
        const obj_referenceTargetField_union1_error = (() => {
          if (obj_referenceTargetField !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_referenceTargetField + '" (at "' + path_referenceTargetField + '")');
          }
        })();
        if (obj_referenceTargetField_union1_error != null) {
          obj_referenceTargetField_union1 = obj_referenceTargetField_union1_error.message;
        }
        if (obj_referenceTargetField_union0 && obj_referenceTargetField_union1) {
          let message = 'Object doesn\'t match union (at "' + path_referenceTargetField + '")';
          message += '\n' + obj_referenceTargetField_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_referenceTargetField_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_referenceToInfos = obj.referenceToInfos;
        const path_referenceToInfos = path + '.referenceToInfos';
        if (!ArrayIsArray(obj_referenceToInfos)) {
          return new TypeError('Expected "array" but received "' + typeof obj_referenceToInfos + '" (at "' + path_referenceToInfos + '")');
        }
        for (let i = 0; i < obj_referenceToInfos.length; i++) {
          const obj_referenceToInfos_item = obj_referenceToInfos[i];
          const path_referenceToInfos_item = path_referenceToInfos + '[' + i + ']';
          const referencepath_referenceToInfos_itemValidationError = validate$1M(obj_referenceToInfos_item, path_referenceToInfos_item);
          if (referencepath_referenceToInfos_itemValidationError !== null) {
            let message = 'Object doesn\'t match ReferenceToInfoRepresentation (at "' + path_referenceToInfos_item + '")\n';
            message += referencepath_referenceToInfos_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_relationshipName = obj.relationshipName;
        const path_relationshipName = path + '.relationshipName';
        let obj_relationshipName_union0 = null;
        const obj_relationshipName_union0_error = (() => {
          if (typeof obj_relationshipName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relationshipName + '" (at "' + path_relationshipName + '")');
          }
        })();
        if (obj_relationshipName_union0_error != null) {
          obj_relationshipName_union0 = obj_relationshipName_union0_error.message;
        }
        let obj_relationshipName_union1 = null;
        const obj_relationshipName_union1_error = (() => {
          if (obj_relationshipName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_relationshipName + '" (at "' + path_relationshipName + '")');
          }
        })();
        if (obj_relationshipName_union1_error != null) {
          obj_relationshipName_union1 = obj_relationshipName_union1_error.message;
        }
        if (obj_relationshipName_union0 && obj_relationshipName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_relationshipName + '")';
          message += '\n' + obj_relationshipName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_relationshipName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_required = obj.required;
        const path_required = path + '.required';
        if (typeof obj_required !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_required + '" (at "' + path_required + '")');
        }
        const obj_scale = obj.scale;
        const path_scale = path + '.scale';
        if (typeof obj_scale !== 'number' || typeof obj_scale === 'number' && Math.floor(obj_scale) !== obj_scale) {
          return new TypeError('Expected "integer" but received "' + typeof obj_scale + '" (at "' + path_scale + '")');
        }
        const obj_searchPrefilterable = obj.searchPrefilterable;
        const path_searchPrefilterable = path + '.searchPrefilterable';
        if (typeof obj_searchPrefilterable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_searchPrefilterable + '" (at "' + path_searchPrefilterable + '")');
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
        const obj_unique = obj.unique;
        const path_unique = path + '.unique';
        if (typeof obj_unique !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_unique + '" (at "' + path_unique + '")');
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$1K(obj, path = 'ThemeInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_color = obj.color;
        const path_color = path + '.color';
        if (typeof obj_color !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_color + '" (at "' + path_color + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        let obj_iconUrl_union0 = null;
        const obj_iconUrl_union0_error = (() => {
          if (typeof obj_iconUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
          }
        })();
        if (obj_iconUrl_union0_error != null) {
          obj_iconUrl_union0 = obj_iconUrl_union0_error.message;
        }
        let obj_iconUrl_union1 = null;
        const obj_iconUrl_union1_error = (() => {
          if (obj_iconUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
          }
        })();
        if (obj_iconUrl_union1_error != null) {
          obj_iconUrl_union1 = obj_iconUrl_union1_error.message;
        }
        if (obj_iconUrl_union0 && obj_iconUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_iconUrl + '")';
          message += '\n' + obj_iconUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_iconUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$x = 900000;
    const VERSION$16 = "2302a71ca718abb60353eb88dedb1c12";
    function validate$1J(obj, path = 'ObjectInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_associateEntityType = obj.associateEntityType;
        const path_associateEntityType = path + '.associateEntityType';
        let obj_associateEntityType_union0 = null;
        const obj_associateEntityType_union0_error = (() => {
          if (typeof obj_associateEntityType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_associateEntityType + '" (at "' + path_associateEntityType + '")');
          }
        })();
        if (obj_associateEntityType_union0_error != null) {
          obj_associateEntityType_union0 = obj_associateEntityType_union0_error.message;
        }
        let obj_associateEntityType_union1 = null;
        const obj_associateEntityType_union1_error = (() => {
          if (obj_associateEntityType !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_associateEntityType + '" (at "' + path_associateEntityType + '")');
          }
        })();
        if (obj_associateEntityType_union1_error != null) {
          obj_associateEntityType_union1 = obj_associateEntityType_union1_error.message;
        }
        if (obj_associateEntityType_union0 && obj_associateEntityType_union1) {
          let message = 'Object doesn\'t match union (at "' + path_associateEntityType + '")';
          message += '\n' + obj_associateEntityType_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_associateEntityType_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_associateParentEntity = obj.associateParentEntity;
        const path_associateParentEntity = path + '.associateParentEntity';
        let obj_associateParentEntity_union0 = null;
        const obj_associateParentEntity_union0_error = (() => {
          if (typeof obj_associateParentEntity !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_associateParentEntity + '" (at "' + path_associateParentEntity + '")');
          }
        })();
        if (obj_associateParentEntity_union0_error != null) {
          obj_associateParentEntity_union0 = obj_associateParentEntity_union0_error.message;
        }
        let obj_associateParentEntity_union1 = null;
        const obj_associateParentEntity_union1_error = (() => {
          if (obj_associateParentEntity !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_associateParentEntity + '" (at "' + path_associateParentEntity + '")');
          }
        })();
        if (obj_associateParentEntity_union1_error != null) {
          obj_associateParentEntity_union1 = obj_associateParentEntity_union1_error.message;
        }
        if (obj_associateParentEntity_union0 && obj_associateParentEntity_union1) {
          let message = 'Object doesn\'t match union (at "' + path_associateParentEntity + '")';
          message += '\n' + obj_associateParentEntity_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_associateParentEntity_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_childRelationships = obj.childRelationships;
        const path_childRelationships = path + '.childRelationships';
        if (!ArrayIsArray(obj_childRelationships)) {
          return new TypeError('Expected "array" but received "' + typeof obj_childRelationships + '" (at "' + path_childRelationships + '")');
        }
        for (let i = 0; i < obj_childRelationships.length; i++) {
          const obj_childRelationships_item = obj_childRelationships[i];
          const path_childRelationships_item = path_childRelationships + '[' + i + ']';
          const referencepath_childRelationships_itemValidationError = validate$1O(obj_childRelationships_item, path_childRelationships_item);
          if (referencepath_childRelationships_itemValidationError !== null) {
            let message = 'Object doesn\'t match ChildRelationshipRepresentation (at "' + path_childRelationships_item + '")\n';
            message += referencepath_childRelationships_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_compactLayoutable = obj.compactLayoutable;
        const path_compactLayoutable = path + '.compactLayoutable';
        if (typeof obj_compactLayoutable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_compactLayoutable + '" (at "' + path_compactLayoutable + '")');
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_custom = obj.custom;
        const path_custom = path + '.custom';
        if (typeof obj_custom !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_custom + '" (at "' + path_custom + '")');
        }
        const obj_defaultRecordTypeId = obj.defaultRecordTypeId;
        const path_defaultRecordTypeId = path + '.defaultRecordTypeId';
        let obj_defaultRecordTypeId_union0 = null;
        const obj_defaultRecordTypeId_union0_error = (() => {
          if (typeof obj_defaultRecordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_defaultRecordTypeId + '" (at "' + path_defaultRecordTypeId + '")');
          }
        })();
        if (obj_defaultRecordTypeId_union0_error != null) {
          obj_defaultRecordTypeId_union0 = obj_defaultRecordTypeId_union0_error.message;
        }
        let obj_defaultRecordTypeId_union1 = null;
        const obj_defaultRecordTypeId_union1_error = (() => {
          if (obj_defaultRecordTypeId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_defaultRecordTypeId + '" (at "' + path_defaultRecordTypeId + '")');
          }
        })();
        if (obj_defaultRecordTypeId_union1_error != null) {
          obj_defaultRecordTypeId_union1 = obj_defaultRecordTypeId_union1_error.message;
        }
        if (obj_defaultRecordTypeId_union0 && obj_defaultRecordTypeId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_defaultRecordTypeId + '")';
          message += '\n' + obj_defaultRecordTypeId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_defaultRecordTypeId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_deletable = obj.deletable;
        const path_deletable = path + '.deletable';
        if (typeof obj_deletable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_deletable + '" (at "' + path_deletable + '")');
        }
        const obj_dependentFields = obj.dependentFields;
        const path_dependentFields = path + '.dependentFields';
        if (typeof obj_dependentFields !== 'object' || ArrayIsArray(obj_dependentFields) || obj_dependentFields === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_dependentFields + '" (at "' + path_dependentFields + '")');
        }
        const obj_dependentFields_keys = ObjectKeys(obj_dependentFields);
        for (let i = 0; i < obj_dependentFields_keys.length; i++) {
          const key = obj_dependentFields_keys[i];
          const obj_dependentFields_prop = obj_dependentFields[key];
          const path_dependentFields_prop = path_dependentFields + '["' + key + '"]';
          if (typeof obj_dependentFields_prop !== 'object' || ArrayIsArray(obj_dependentFields_prop) || obj_dependentFields_prop === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_dependentFields_prop + '" (at "' + path_dependentFields_prop + '")');
          }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_feedEnabled = obj.feedEnabled;
        const path_feedEnabled = path + '.feedEnabled';
        if (typeof obj_feedEnabled !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_feedEnabled + '" (at "' + path_feedEnabled + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray(obj_fields) || obj_fields === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
          const key = obj_fields_keys[i];
          const obj_fields_prop = obj_fields[key];
          const path_fields_prop = path_fields + '["' + key + '"]';
          const referencepath_fields_propValidationError = validate$1L(obj_fields_prop, path_fields_prop);
          if (referencepath_fields_propValidationError !== null) {
            let message = 'Object doesn\'t match FieldRepresentation (at "' + path_fields_prop + '")\n';
            message += referencepath_fields_propValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_keyPrefix = obj.keyPrefix;
        const path_keyPrefix = path + '.keyPrefix';
        let obj_keyPrefix_union0 = null;
        const obj_keyPrefix_union0_error = (() => {
          if (typeof obj_keyPrefix !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
          }
        })();
        if (obj_keyPrefix_union0_error != null) {
          obj_keyPrefix_union0 = obj_keyPrefix_union0_error.message;
        }
        let obj_keyPrefix_union1 = null;
        const obj_keyPrefix_union1_error = (() => {
          if (obj_keyPrefix !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
          }
        })();
        if (obj_keyPrefix_union1_error != null) {
          obj_keyPrefix_union1 = obj_keyPrefix_union1_error.message;
        }
        if (obj_keyPrefix_union0 && obj_keyPrefix_union1) {
          let message = 'Object doesn\'t match union (at "' + path_keyPrefix + '")';
          message += '\n' + obj_keyPrefix_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_keyPrefix_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_labelPlural = obj.labelPlural;
        const path_labelPlural = path + '.labelPlural';
        if (typeof obj_labelPlural !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_labelPlural + '" (at "' + path_labelPlural + '")');
        }
        const obj_layoutable = obj.layoutable;
        const path_layoutable = path + '.layoutable';
        if (typeof obj_layoutable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_layoutable + '" (at "' + path_layoutable + '")');
        }
        const obj_mruEnabled = obj.mruEnabled;
        const path_mruEnabled = path + '.mruEnabled';
        if (typeof obj_mruEnabled !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_mruEnabled + '" (at "' + path_mruEnabled + '")');
        }
        const obj_nameFields = obj.nameFields;
        const path_nameFields = path + '.nameFields';
        if (!ArrayIsArray(obj_nameFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_nameFields + '" (at "' + path_nameFields + '")');
        }
        for (let i = 0; i < obj_nameFields.length; i++) {
          const obj_nameFields_item = obj_nameFields[i];
          const path_nameFields_item = path_nameFields + '[' + i + ']';
          if (typeof obj_nameFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nameFields_item + '" (at "' + path_nameFields_item + '")');
          }
        }
        const obj_queryable = obj.queryable;
        const path_queryable = path + '.queryable';
        if (typeof obj_queryable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_queryable + '" (at "' + path_queryable + '")');
        }
        const obj_recordTypeInfos = obj.recordTypeInfos;
        const path_recordTypeInfos = path + '.recordTypeInfos';
        if (typeof obj_recordTypeInfos !== 'object' || ArrayIsArray(obj_recordTypeInfos) || obj_recordTypeInfos === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_recordTypeInfos + '" (at "' + path_recordTypeInfos + '")');
        }
        const obj_recordTypeInfos_keys = ObjectKeys(obj_recordTypeInfos);
        for (let i = 0; i < obj_recordTypeInfos_keys.length; i++) {
          const key = obj_recordTypeInfos_keys[i];
          const obj_recordTypeInfos_prop = obj_recordTypeInfos[key];
          const path_recordTypeInfos_prop = path_recordTypeInfos + '["' + key + '"]';
          const referencepath_recordTypeInfos_propValidationError = validate$1Y(obj_recordTypeInfos_prop, path_recordTypeInfos_prop);
          if (referencepath_recordTypeInfos_propValidationError !== null) {
            let message = 'Object doesn\'t match RecordTypeInfoRepresentation (at "' + path_recordTypeInfos_prop + '")\n';
            message += referencepath_recordTypeInfos_propValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_searchLayoutable = obj.searchLayoutable;
        const path_searchLayoutable = path + '.searchLayoutable';
        if (typeof obj_searchLayoutable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_searchLayoutable + '" (at "' + path_searchLayoutable + '")');
        }
        const obj_searchable = obj.searchable;
        const path_searchable = path + '.searchable';
        if (typeof obj_searchable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_searchable + '" (at "' + path_searchable + '")');
        }
        const obj_themeInfo = obj.themeInfo;
        const path_themeInfo = path + '.themeInfo';
        let obj_themeInfo_union0 = null;
        const obj_themeInfo_union0_error = (() => {
          const referencepath_themeInfoValidationError = validate$1K(obj_themeInfo, path_themeInfo);
          if (referencepath_themeInfoValidationError !== null) {
            let message = 'Object doesn\'t match ThemeInfoRepresentation (at "' + path_themeInfo + '")\n';
            message += referencepath_themeInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_themeInfo_union0_error != null) {
          obj_themeInfo_union0 = obj_themeInfo_union0_error.message;
        }
        let obj_themeInfo_union1 = null;
        const obj_themeInfo_union1_error = (() => {
          if (obj_themeInfo !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_themeInfo + '" (at "' + path_themeInfo + '")');
          }
        })();
        if (obj_themeInfo_union1_error != null) {
          obj_themeInfo_union1 = obj_themeInfo_union1_error.message;
        }
        if (obj_themeInfo_union0 && obj_themeInfo_union1) {
          let message = 'Object doesn\'t match union (at "' + path_themeInfo + '")';
          message += '\n' + obj_themeInfo_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_themeInfo_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$O = 'ObjectInfoRepresentation';
    function keyBuilder$1Y(luvio, config) {
      return keyPrefix + '::' + RepresentationType$O + ':' + config.apiName;
    }
    function keyBuilderFromType$w(luvio, object) {
      const keyParams = {
        apiName: object.apiName
      };
      return keyBuilder$1Y(luvio, keyParams);
    }
    function normalize$H(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1L = function ObjectInfoRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$16,
        private: ['eTag'],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'associateEntityType',
          kind: 'Scalar'
        }, {
          name: 'associateParentEntity',
          kind: 'Scalar'
        }, {
          name: 'childRelationships',
          kind: 'Object',
          opaque: true
        }, {
          name: 'compactLayoutable',
          kind: 'Scalar'
        }, {
          name: 'createable',
          kind: 'Scalar'
        }, {
          name: 'custom',
          kind: 'Scalar'
        }, {
          name: 'defaultRecordTypeId',
          kind: 'Scalar'
        }, {
          name: 'deletable',
          kind: 'Scalar'
        }, {
          name: 'dependentFields',
          kind: 'Object',
          opaque: true
        }, {
          name: 'feedEnabled',
          kind: 'Scalar'
        }, {
          name: 'fields',
          kind: 'Object',
          opaque: true
        }, {
          name: 'keyPrefix',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'labelPlural',
          kind: 'Scalar'
        }, {
          name: 'layoutable',
          kind: 'Scalar'
        }, {
          name: 'mruEnabled',
          kind: 'Scalar'
        }, {
          name: 'nameFields',
          kind: 'Object',
          opaque: true
        }, {
          name: 'queryable',
          kind: 'Scalar'
        }, {
          name: 'recordTypeInfos',
          kind: 'Object',
          opaque: true
        }, {
          name: 'searchLayoutable',
          kind: 'Scalar'
        }, {
          name: 'searchable',
          kind: 'Scalar'
        }, {
          name: 'themeInfo',
          kind: 'Object',
          opaque: true
        }, {
          name: 'updateable',
          kind: 'Scalar'
        }]
      };
    };
    function equals$Y(existing, incoming) {
      if (existing.eTag !== incoming.eTag) {
        return false;
      }
      return true;
    }
    const ingest$H = function ObjectInfoRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1J(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$w(luvio, input);
      const ttlToUse = TTL$x;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$H, "UiApi", VERSION$16, RepresentationType$O, equals$Y);
      return createLink(key);
    };
    function getTypeCacheKeys$O(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$w(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$O,
        mergeable: false
      });
    }
    function select$1K(luvio, params) {
      return select$1L();
    }
    function keyBuilder$1X(luvio, params) {
      return keyBuilder$1Y(luvio, {
        apiName: params.urlParams.objectApiName
      });
    }
    function getResponseCacheKeys$_(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$O(storeKeyMap, luvio, response);
    }
    function ingestSuccess$P(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1X(luvio, resourceParams);
      luvio.storeIngest(key, ingest$H, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1K(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$I(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1X(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$x,
        namespace: keyPrefix,
        version: VERSION$16,
        representationName: RepresentationType$O
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$12(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/object-info/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$_ = 'getObjectInfo';
    const getObjectInfo_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1)];
    const getObjectInfo_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$_, getObjectInfo_ConfigPropertyMetadata);
    const createResourceParams$Y = /*#__PURE__*/luvioEngine.createResourceParams(getObjectInfo_ConfigPropertyMetadata);
    function keyBuilder$1W(luvio, config) {
      const resourceParams = createResourceParams$Y(config);
      return keyBuilder$1X(luvio, resourceParams);
    }
    function typeCheckConfig$13(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getObjectInfo_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$15(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getObjectInfo_ConfigPropertyMetadata);
      const config = typeCheckConfig$13(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$H(luvio, config) {
      createResourceParams$Y(config);
      return select$1K();
    }
    function onFetchResponseSuccess$L(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$P(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$13(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$M(luvio, config, resourceParams, response) {
      const snapshot = ingestError$I(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$13(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$13(luvio, config, options) {
      const resourceParams = createResourceParams$Y(config);
      const request = createResourceRequest$12(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$L(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$_(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$M(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$P(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$13, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$O(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1W(luvio, config),
        node: adapterFragment$H(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$13(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getObjectInfoAdapterFactory = luvio => function UiApi__getObjectInfo(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$15(untrustedConfig, getObjectInfo_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$O, buildNetworkSnapshotCachePolicy$P);
    };
    function validate$1I(obj, path = 'RecordLayoutSaveOptionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_defaultValue = obj.defaultValue;
        const path_defaultValue = path + '.defaultValue';
        if (typeof obj_defaultValue !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_defaultValue + '" (at "' + path_defaultValue + '")');
        }
        const obj_isDisplayed = obj.isDisplayed;
        const path_isDisplayed = path + '.isDisplayed';
        if (typeof obj_isDisplayed !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isDisplayed + '" (at "' + path_isDisplayed + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_restHeaderName = obj.restHeaderName;
        const path_restHeaderName = path + '.restHeaderName';
        if (typeof obj_restHeaderName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_restHeaderName + '" (at "' + path_restHeaderName + '")');
        }
        const obj_soapHeaderName = obj.soapHeaderName;
        const path_soapHeaderName = path + '.soapHeaderName';
        if (typeof obj_soapHeaderName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_soapHeaderName + '" (at "' + path_soapHeaderName + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    var DiscriminatorValues$5;
    (function (DiscriminatorValues) {
      DiscriminatorValues["EmptySpace"] = "EmptySpace";
      DiscriminatorValues["ReportChart"] = "ReportChart";
      DiscriminatorValues["VisualforcePage"] = "VisualforcePage";
      DiscriminatorValues["Canvas"] = "Canvas";
      DiscriminatorValues["Field"] = "Field";
      DiscriminatorValues["CustomLink"] = "CustomLink";
    })(DiscriminatorValues$5 || (DiscriminatorValues$5 = {}));
    function validate$1H(obj, path = 'AbstractRecordLayoutComponentRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        let obj_apiName_union0 = null;
        const obj_apiName_union0_error = (() => {
          if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
          }
        })();
        if (obj_apiName_union0_error != null) {
          obj_apiName_union0 = obj_apiName_union0_error.message;
        }
        let obj_apiName_union1 = null;
        const obj_apiName_union1_error = (() => {
          if (obj_apiName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
          }
        })();
        if (obj_apiName_union1_error != null) {
          obj_apiName_union1 = obj_apiName_union1_error.message;
        }
        if (obj_apiName_union0 && obj_apiName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_apiName + '")';
          message += '\n' + obj_apiName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_apiName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_componentType = obj.componentType;
        const path_componentType = path + '.componentType';
        if (typeof obj_componentType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_componentType + '" (at "' + path_componentType + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$1G(obj, path = 'RecordLayoutItemRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_editableForNew = obj.editableForNew;
        const path_editableForNew = path + '.editableForNew';
        if (typeof obj_editableForNew !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_editableForNew + '" (at "' + path_editableForNew + '")');
        }
        const obj_editableForUpdate = obj.editableForUpdate;
        const path_editableForUpdate = path + '.editableForUpdate';
        if (typeof obj_editableForUpdate !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_editableForUpdate + '" (at "' + path_editableForUpdate + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_layoutComponents = obj.layoutComponents;
        const path_layoutComponents = path + '.layoutComponents';
        if (!ArrayIsArray(obj_layoutComponents)) {
          return new TypeError('Expected "array" but received "' + typeof obj_layoutComponents + '" (at "' + path_layoutComponents + '")');
        }
        for (let i = 0; i < obj_layoutComponents.length; i++) {
          const obj_layoutComponents_item = obj_layoutComponents[i];
          const path_layoutComponents_item = path_layoutComponents + '[' + i + ']';
          const referencepath_layoutComponents_itemValidationError = validate$1H(obj_layoutComponents_item, path_layoutComponents_item);
          if (referencepath_layoutComponents_itemValidationError !== null) {
            let message = 'Object doesn\'t match AbstractRecordLayoutComponentRepresentation (at "' + path_layoutComponents_item + '")\n';
            message += referencepath_layoutComponents_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_lookupIdApiName = obj.lookupIdApiName;
        const path_lookupIdApiName = path + '.lookupIdApiName';
        let obj_lookupIdApiName_union0 = null;
        const obj_lookupIdApiName_union0_error = (() => {
          if (typeof obj_lookupIdApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lookupIdApiName + '" (at "' + path_lookupIdApiName + '")');
          }
        })();
        if (obj_lookupIdApiName_union0_error != null) {
          obj_lookupIdApiName_union0 = obj_lookupIdApiName_union0_error.message;
        }
        let obj_lookupIdApiName_union1 = null;
        const obj_lookupIdApiName_union1_error = (() => {
          if (obj_lookupIdApiName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lookupIdApiName + '" (at "' + path_lookupIdApiName + '")');
          }
        })();
        if (obj_lookupIdApiName_union1_error != null) {
          obj_lookupIdApiName_union1 = obj_lookupIdApiName_union1_error.message;
        }
        if (obj_lookupIdApiName_union0 && obj_lookupIdApiName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lookupIdApiName + '")';
          message += '\n' + obj_lookupIdApiName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lookupIdApiName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_required = obj.required;
        const path_required = path + '.required';
        if (typeof obj_required !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_required + '" (at "' + path_required + '")');
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$1F(obj, path = 'RecordLayoutRowRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_layoutItems = obj.layoutItems;
        const path_layoutItems = path + '.layoutItems';
        if (!ArrayIsArray(obj_layoutItems)) {
          return new TypeError('Expected "array" but received "' + typeof obj_layoutItems + '" (at "' + path_layoutItems + '")');
        }
        for (let i = 0; i < obj_layoutItems.length; i++) {
          const obj_layoutItems_item = obj_layoutItems[i];
          const path_layoutItems_item = path_layoutItems + '[' + i + ']';
          const referencepath_layoutItems_itemValidationError = validate$1G(obj_layoutItems_item, path_layoutItems_item);
          if (referencepath_layoutItems_itemValidationError !== null) {
            let message = 'Object doesn\'t match RecordLayoutItemRepresentation (at "' + path_layoutItems_item + '")\n';
            message += referencepath_layoutItems_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$1E(obj, path = 'RecordLayoutSectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_collapsible = obj.collapsible;
        const path_collapsible = path + '.collapsible';
        if (typeof obj_collapsible !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_collapsible + '" (at "' + path_collapsible + '")');
        }
        const obj_columns = obj.columns;
        const path_columns = path + '.columns';
        if (typeof obj_columns !== 'number' || typeof obj_columns === 'number' && Math.floor(obj_columns) !== obj_columns) {
          return new TypeError('Expected "integer" but received "' + typeof obj_columns + '" (at "' + path_columns + '")');
        }
        const obj_heading = obj.heading;
        const path_heading = path + '.heading';
        let obj_heading_union0 = null;
        const obj_heading_union0_error = (() => {
          if (typeof obj_heading !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_heading + '" (at "' + path_heading + '")');
          }
        })();
        if (obj_heading_union0_error != null) {
          obj_heading_union0 = obj_heading_union0_error.message;
        }
        let obj_heading_union1 = null;
        const obj_heading_union1_error = (() => {
          if (obj_heading !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_heading + '" (at "' + path_heading + '")');
          }
        })();
        if (obj_heading_union1_error != null) {
          obj_heading_union1 = obj_heading_union1_error.message;
        }
        if (obj_heading_union0 && obj_heading_union1) {
          let message = 'Object doesn\'t match union (at "' + path_heading + '")';
          message += '\n' + obj_heading_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_heading_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
          if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union0_error != null) {
          obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
          if (obj_id !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union1_error != null) {
          obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
          let message = 'Object doesn\'t match union (at "' + path_id + '")';
          message += '\n' + obj_id_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_id_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_layoutRows = obj.layoutRows;
        const path_layoutRows = path + '.layoutRows';
        if (!ArrayIsArray(obj_layoutRows)) {
          return new TypeError('Expected "array" but received "' + typeof obj_layoutRows + '" (at "' + path_layoutRows + '")');
        }
        for (let i = 0; i < obj_layoutRows.length; i++) {
          const obj_layoutRows_item = obj_layoutRows[i];
          const path_layoutRows_item = path_layoutRows + '[' + i + ']';
          const referencepath_layoutRows_itemValidationError = validate$1F(obj_layoutRows_item, path_layoutRows_item);
          if (referencepath_layoutRows_itemValidationError !== null) {
            let message = 'Object doesn\'t match RecordLayoutRowRepresentation (at "' + path_layoutRows_item + '")\n';
            message += referencepath_layoutRows_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_rows = obj.rows;
        const path_rows = path + '.rows';
        if (typeof obj_rows !== 'number' || typeof obj_rows === 'number' && Math.floor(obj_rows) !== obj_rows) {
          return new TypeError('Expected "integer" but received "' + typeof obj_rows + '" (at "' + path_rows + '")');
        }
        const obj_useHeading = obj.useHeading;
        const path_useHeading = path + '.useHeading';
        if (typeof obj_useHeading !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_useHeading + '" (at "' + path_useHeading + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$w = 900000;
    const VERSION$15 = "fb515e25a89ca1ec154dc865e72b913a";
    function validate$1D(obj, path = 'RecordLayoutRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
          if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union0_error != null) {
          obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
          if (obj_id !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union1_error != null) {
          obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
          let message = 'Object doesn\'t match union (at "' + path_id + '")';
          message += '\n' + obj_id_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_id_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_layoutType = obj.layoutType;
        const path_layoutType = path + '.layoutType';
        if (typeof obj_layoutType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_layoutType + '" (at "' + path_layoutType + '")');
        }
        const obj_mode = obj.mode;
        const path_mode = path + '.mode';
        if (typeof obj_mode !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_mode + '" (at "' + path_mode + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        let obj_objectApiName_union0 = null;
        const obj_objectApiName_union0_error = (() => {
          if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
          }
        })();
        if (obj_objectApiName_union0_error != null) {
          obj_objectApiName_union0 = obj_objectApiName_union0_error.message;
        }
        let obj_objectApiName_union1 = null;
        const obj_objectApiName_union1_error = (() => {
          if (obj_objectApiName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
          }
        })();
        if (obj_objectApiName_union1_error != null) {
          obj_objectApiName_union1 = obj_objectApiName_union1_error.message;
        }
        if (obj_objectApiName_union0 && obj_objectApiName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_objectApiName + '")';
          message += '\n' + obj_objectApiName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_objectApiName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
          if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union0_error != null) {
          obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
          if (obj_recordTypeId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union1_error != null) {
          obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
          message += '\n' + obj_recordTypeId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_recordTypeId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_saveOptions = obj.saveOptions;
        const path_saveOptions = path + '.saveOptions';
        if (!ArrayIsArray(obj_saveOptions)) {
          return new TypeError('Expected "array" but received "' + typeof obj_saveOptions + '" (at "' + path_saveOptions + '")');
        }
        for (let i = 0; i < obj_saveOptions.length; i++) {
          const obj_saveOptions_item = obj_saveOptions[i];
          const path_saveOptions_item = path_saveOptions + '[' + i + ']';
          const referencepath_saveOptions_itemValidationError = validate$1I(obj_saveOptions_item, path_saveOptions_item);
          if (referencepath_saveOptions_itemValidationError !== null) {
            let message = 'Object doesn\'t match RecordLayoutSaveOptionRepresentation (at "' + path_saveOptions_item + '")\n';
            message += referencepath_saveOptions_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_sections = obj.sections;
        const path_sections = path + '.sections';
        if (!ArrayIsArray(obj_sections)) {
          return new TypeError('Expected "array" but received "' + typeof obj_sections + '" (at "' + path_sections + '")');
        }
        for (let i = 0; i < obj_sections.length; i++) {
          const obj_sections_item = obj_sections[i];
          const path_sections_item = path_sections + '[' + i + ']';
          const referencepath_sections_itemValidationError = validate$1E(obj_sections_item, path_sections_item);
          if (referencepath_sections_itemValidationError !== null) {
            let message = 'Object doesn\'t match RecordLayoutSectionRepresentation (at "' + path_sections_item + '")\n';
            message += referencepath_sections_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$N = 'RecordLayoutRepresentation';
    function keyBuilder$1V(luvio, config) {
      return keyPrefix + '::' + RepresentationType$N + ':' + (config.recordTypeId === null ? '' : config.recordTypeId) + ':' + (config.objectApiName === null ? '' : config.objectApiName) + ':' + config.layoutType + ':' + config.mode;
    }
    function keyBuilderFromType$v(luvio, object) {
      const keyParams = {
        recordTypeId: object.recordTypeId,
        objectApiName: object.objectApiName,
        layoutType: object.layoutType,
        mode: object.mode
      };
      return keyBuilder$1V(luvio, keyParams);
    }
    function normalize$G(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1J = function RecordLayoutRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$15,
        private: ['eTag'],
        selections: [{
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'layoutType',
          kind: 'Scalar'
        }, {
          name: 'mode',
          kind: 'Scalar'
        }, {
          name: 'objectApiName',
          kind: 'Scalar'
        }, {
          name: 'recordTypeId',
          kind: 'Scalar'
        }, {
          name: 'saveOptions',
          kind: 'Object',
          opaque: true
        }, {
          name: 'sections',
          kind: 'Object',
          opaque: true
        }]
      };
    };
    function equals$X(existing, incoming) {
      if (existing.eTag !== incoming.eTag) {
        return false;
      }
      return true;
    }
    const ingest$G = function RecordLayoutRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1D(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$v(luvio, input);
      const ttlToUse = TTL$w;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$G, "UiApi", VERSION$15, RepresentationType$N, equals$X);
      return createLink(key);
    };
    function getTypeCacheKeys$N(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$v(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$N,
        mergeable: false
      });
    }

    /**
     * Returns the object API name.
     * @param value The value from which to get the object API name.
     * @returns The object API name.
     */
    function getRecordId18Array(value) {
      const valueArray = isArray(value) ? value : [value];
      const array = [];
      for (let i = 0, len = valueArray.length; i < len; i += 1) {
        const item = valueArray[i];
        const apiName = getRecordId18(item);
        if (apiName === undefined) {
          return undefined;
        }
        push.call(array, apiName);
      }
      if (array.length === 0) {
        return undefined;
      }
      return dedupe(array).sort();
    }
    function validate$1C(obj, path = 'RecordLayoutSectionUserStateRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_collapsed = obj.collapsed;
        const path_collapsed = path + '.collapsed';
        if (typeof obj_collapsed !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_collapsed + '" (at "' + path_collapsed + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$v = 900000;
    const VERSION$14 = "4ba42e1fa0fb00cf78fce86082da41c9";
    function validate$1B(obj, path = 'RecordLayoutUserStateRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_layoutType = obj.layoutType;
        const path_layoutType = path + '.layoutType';
        if (typeof obj_layoutType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_layoutType + '" (at "' + path_layoutType + '")');
        }
        const obj_mode = obj.mode;
        const path_mode = path + '.mode';
        if (typeof obj_mode !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_mode + '" (at "' + path_mode + '")');
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        if (typeof obj_recordTypeId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
        }
        const obj_sectionUserStates = obj.sectionUserStates;
        const path_sectionUserStates = path + '.sectionUserStates';
        if (typeof obj_sectionUserStates !== 'object' || ArrayIsArray(obj_sectionUserStates) || obj_sectionUserStates === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_sectionUserStates + '" (at "' + path_sectionUserStates + '")');
        }
        const obj_sectionUserStates_keys = ObjectKeys(obj_sectionUserStates);
        for (let i = 0; i < obj_sectionUserStates_keys.length; i++) {
          const key = obj_sectionUserStates_keys[i];
          const obj_sectionUserStates_prop = obj_sectionUserStates[key];
          const path_sectionUserStates_prop = path_sectionUserStates + '["' + key + '"]';
          const referencepath_sectionUserStates_propValidationError = validate$1C(obj_sectionUserStates_prop, path_sectionUserStates_prop);
          if (referencepath_sectionUserStates_propValidationError !== null) {
            let message = 'Object doesn\'t match RecordLayoutSectionUserStateRepresentation (at "' + path_sectionUserStates_prop + '")\n';
            message += referencepath_sectionUserStates_propValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$M = 'RecordLayoutUserStateRepresentation';
    function keyBuilder$1U(luvio, config) {
      return keyPrefix + '::' + RepresentationType$M + ':' + config.recordTypeId + ':' + config.apiName + ':' + config.layoutType + ':' + config.mode;
    }
    function keyBuilderFromType$u(luvio, object) {
      const keyParams = {
        recordTypeId: object.recordTypeId,
        apiName: object.apiName,
        layoutType: object.layoutType,
        mode: object.mode
      };
      return keyBuilder$1U(luvio, keyParams);
    }
    function normalize$F(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1I = function RecordLayoutUserStateRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$14,
        private: ['apiName', 'recordTypeId', 'layoutType', 'mode'],
        selections: [{
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'sectionUserStates',
          kind: 'Object',
          opaque: true
        }]
      };
    };
    function equals$W(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$F = function RecordLayoutUserStateRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1B(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$u(luvio, input);
      const ttlToUse = TTL$v;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$F, "UiApi", VERSION$14, RepresentationType$M, equals$W);
      return createLink(key);
    };
    function getTypeCacheKeys$M(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$u(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$M,
        mergeable: false
      });
    }
    const TTL$u = 900000;
    const VERSION$13 = "49cdd4bc235a6094c3559cc7735b3b6d";
    function validate$1A(obj, path = 'RecordUiRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_layoutUserStates = obj.layoutUserStates;
        const path_layoutUserStates = path + '.layoutUserStates';
        if (typeof obj_layoutUserStates !== 'object' || ArrayIsArray(obj_layoutUserStates) || obj_layoutUserStates === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_layoutUserStates + '" (at "' + path_layoutUserStates + '")');
        }
        const obj_layoutUserStates_keys = ObjectKeys(obj_layoutUserStates);
        for (let i = 0; i < obj_layoutUserStates_keys.length; i++) {
          const key = obj_layoutUserStates_keys[i];
          const obj_layoutUserStates_prop = obj_layoutUserStates[key];
          const path_layoutUserStates_prop = path_layoutUserStates + '["' + key + '"]';
          if (typeof obj_layoutUserStates_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_layoutUserStates_prop + '" (at "' + path_layoutUserStates_prop + '")');
          }
        }
        const obj_layouts = obj.layouts;
        const path_layouts = path + '.layouts';
        if (typeof obj_layouts !== 'object' || ArrayIsArray(obj_layouts) || obj_layouts === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_layouts + '" (at "' + path_layouts + '")');
        }
        const obj_layouts_keys = ObjectKeys(obj_layouts);
        for (let i = 0; i < obj_layouts_keys.length; i++) {
          const key = obj_layouts_keys[i];
          const obj_layouts_prop = obj_layouts[key];
          const path_layouts_prop = path_layouts + '["' + key + '"]';
          if (typeof obj_layouts_prop !== 'object' || ArrayIsArray(obj_layouts_prop) || obj_layouts_prop === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop + '" (at "' + path_layouts_prop + '")');
          }
          const obj_layouts_prop_keys = ObjectKeys(obj_layouts_prop);
          for (let i = 0; i < obj_layouts_prop_keys.length; i++) {
            const key = obj_layouts_prop_keys[i];
            const obj_layouts_prop_prop = obj_layouts_prop[key];
            const path_layouts_prop_prop = path_layouts_prop + '["' + key + '"]';
            if (typeof obj_layouts_prop_prop !== 'object' || ArrayIsArray(obj_layouts_prop_prop) || obj_layouts_prop_prop === null) {
              return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop_prop + '" (at "' + path_layouts_prop_prop + '")');
            }
            const obj_layouts_prop_prop_keys = ObjectKeys(obj_layouts_prop_prop);
            for (let i = 0; i < obj_layouts_prop_prop_keys.length; i++) {
              const key = obj_layouts_prop_prop_keys[i];
              const obj_layouts_prop_prop_prop = obj_layouts_prop_prop[key];
              const path_layouts_prop_prop_prop = path_layouts_prop_prop + '["' + key + '"]';
              if (typeof obj_layouts_prop_prop_prop !== 'object' || ArrayIsArray(obj_layouts_prop_prop_prop) || obj_layouts_prop_prop_prop === null) {
                return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop_prop_prop + '" (at "' + path_layouts_prop_prop_prop + '")');
              }
              const obj_layouts_prop_prop_prop_keys = ObjectKeys(obj_layouts_prop_prop_prop);
              for (let i = 0; i < obj_layouts_prop_prop_prop_keys.length; i++) {
                const key = obj_layouts_prop_prop_prop_keys[i];
                const obj_layouts_prop_prop_prop_prop = obj_layouts_prop_prop_prop[key];
                const path_layouts_prop_prop_prop_prop = path_layouts_prop_prop_prop + '["' + key + '"]';
                if (typeof obj_layouts_prop_prop_prop_prop !== 'object') {
                  return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop_prop_prop_prop + '" (at "' + path_layouts_prop_prop_prop_prop + '")');
                }
              }
            }
          }
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray(obj_objectInfos) || obj_objectInfos === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
          const key = obj_objectInfos_keys[i];
          const obj_objectInfos_prop = obj_objectInfos[key];
          const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
          if (typeof obj_objectInfos_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
          }
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (typeof obj_records !== 'object' || ArrayIsArray(obj_records) || obj_records === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        const obj_records_keys = ObjectKeys(obj_records);
        for (let i = 0; i < obj_records_keys.length; i++) {
          const key = obj_records_keys[i];
          const obj_records_prop = obj_records[key];
          const path_records_prop = path_records + '["' + key + '"]';
          if (typeof obj_records_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_records_prop + '" (at "' + path_records_prop + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$L = 'RecordUiRepresentation';
    function normalize$E(input, existing, path, luvio, store, timestamp) {
      const input_layoutUserStates = input.layoutUserStates;
      const input_layoutUserStates_id = path.fullPath + '__layoutUserStates';
      const input_layoutUserStates_keys = Object.keys(input_layoutUserStates);
      const input_layoutUserStates_length = input_layoutUserStates_keys.length;
      for (let i = 0; i < input_layoutUserStates_length; i++) {
        const key = input_layoutUserStates_keys[i];
        const input_layoutUserStates_prop = input_layoutUserStates[key];
        const input_layoutUserStates_prop_id = input_layoutUserStates_id + '__' + key;
        input_layoutUserStates[key] = ingest$F(input_layoutUserStates_prop, {
          fullPath: input_layoutUserStates_prop_id,
          propertyName: key,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      const input_layouts = input.layouts;
      const input_layouts_id = path.fullPath + '__layouts';
      const input_layouts_keys = Object.keys(input_layouts);
      const input_layouts_length = input_layouts_keys.length;
      for (let i = 0; i < input_layouts_length; i++) {
        const key = input_layouts_keys[i];
        const input_layouts_prop = input_layouts[key];
        const input_layouts_prop_id = input_layouts_id + '__' + key;
        const input_layouts_prop_keys = Object.keys(input_layouts_prop);
        const input_layouts_prop_length = input_layouts_prop_keys.length;
        for (let i = 0; i < input_layouts_prop_length; i++) {
          const key = input_layouts_prop_keys[i];
          const input_layouts_prop_prop = input_layouts_prop[key];
          const input_layouts_prop_prop_id = input_layouts_prop_id + '__' + key;
          const input_layouts_prop_prop_keys = Object.keys(input_layouts_prop_prop);
          const input_layouts_prop_prop_length = input_layouts_prop_prop_keys.length;
          for (let i = 0; i < input_layouts_prop_prop_length; i++) {
            const key = input_layouts_prop_prop_keys[i];
            const input_layouts_prop_prop_prop = input_layouts_prop_prop[key];
            const input_layouts_prop_prop_prop_id = input_layouts_prop_prop_id + '__' + key;
            const input_layouts_prop_prop_prop_keys = Object.keys(input_layouts_prop_prop_prop);
            const input_layouts_prop_prop_prop_length = input_layouts_prop_prop_prop_keys.length;
            for (let i = 0; i < input_layouts_prop_prop_prop_length; i++) {
              const key = input_layouts_prop_prop_prop_keys[i];
              const input_layouts_prop_prop_prop_prop = input_layouts_prop_prop_prop[key];
              const input_layouts_prop_prop_prop_prop_id = input_layouts_prop_prop_prop_id + '__' + key;
              input_layouts_prop_prop_prop[key] = ingest$G(input_layouts_prop_prop_prop_prop, {
                fullPath: input_layouts_prop_prop_prop_prop_id,
                propertyName: key,
                parent: {
                  data: input,
                  key: path.fullPath,
                  existing: existing
                },
                ttl: path.ttl
              }, luvio, store, timestamp);
            }
          }
        }
      }
      const input_objectInfos = input.objectInfos;
      const input_objectInfos_id = path.fullPath + '__objectInfos';
      const input_objectInfos_keys = Object.keys(input_objectInfos);
      const input_objectInfos_length = input_objectInfos_keys.length;
      for (let i = 0; i < input_objectInfos_length; i++) {
        const key = input_objectInfos_keys[i];
        const input_objectInfos_prop = input_objectInfos[key];
        const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
        input_objectInfos[key] = ingest$H(input_objectInfos_prop, {
          fullPath: input_objectInfos_prop_id,
          propertyName: key,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      const input_records = input.records;
      const input_records_id = path.fullPath + '__records';
      const input_records_keys = Object.keys(input_records);
      const input_records_length = input_records_keys.length;
      for (let i = 0; i < input_records_length; i++) {
        const key = input_records_keys[i];
        const input_records_prop = input_records[key];
        const input_records_prop_id = input_records_id + '__' + key;
        input_records[key] = ingest$O(input_records_prop, {
          fullPath: input_records_prop_id,
          propertyName: key,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    function equals$V(existing, incoming) {
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_layoutUserStates = existing.layoutUserStates;
      const incoming_layoutUserStates = incoming.layoutUserStates;
      const equals_layoutUserStates_props = equalsObject(existing_layoutUserStates, incoming_layoutUserStates, (existing_layoutUserStates_prop, incoming_layoutUserStates_prop) => {
        if (!(existing_layoutUserStates_prop.__ref === incoming_layoutUserStates_prop.__ref)) {
          return false;
        }
      });
      if (equals_layoutUserStates_props === false) {
        return false;
      }
      const existing_layouts = existing.layouts;
      const incoming_layouts = incoming.layouts;
      const equals_layouts_props = equalsObject(existing_layouts, incoming_layouts, (existing_layouts_prop, incoming_layouts_prop) => {
        const equals_layouts_props = equalsObject(existing_layouts_prop, incoming_layouts_prop, (existing_layouts_prop_prop, incoming_layouts_prop_prop) => {
          const equals_layouts_props = equalsObject(existing_layouts_prop_prop, incoming_layouts_prop_prop, (existing_layouts_prop_prop_prop, incoming_layouts_prop_prop_prop) => {
            const equals_layouts_props = equalsObject(existing_layouts_prop_prop_prop, incoming_layouts_prop_prop_prop, (existing_layouts_prop_prop_prop_prop, incoming_layouts_prop_prop_prop_prop) => {
              if (!(existing_layouts_prop_prop_prop_prop.__ref === incoming_layouts_prop_prop_prop_prop.__ref)) {
                return false;
              }
            });
            if (equals_layouts_props === false) {
              return false;
            }
          });
          if (equals_layouts_props === false) {
            return false;
          }
        });
        if (equals_layouts_props === false) {
          return false;
        }
      });
      if (equals_layouts_props === false) {
        return false;
      }
      const existing_objectInfos = existing.objectInfos;
      const incoming_objectInfos = incoming.objectInfos;
      const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
          return false;
        }
      });
      if (equals_objectInfos_props === false) {
        return false;
      }
      const existing_records = existing.records;
      const incoming_records = incoming.records;
      const equals_records_props = equalsObject(existing_records, incoming_records, (existing_records_prop, incoming_records_prop) => {
        if (!(existing_records_prop.__ref === incoming_records_prop.__ref)) {
          return false;
        }
      });
      if (equals_records_props === false) {
        return false;
      }
      return true;
    }
    const ingest$E = function RecordUiRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1A(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$u;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$E, "UiApi", VERSION$13, RepresentationType$L, equals$V);
      return createLink(key);
    };
    function createResourceRequest$11(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/record-ui/' + config.urlParams.recordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const getRecordUi_ConfigPropertyMetadata = [generateParamConfigMetadata('recordIds', true, 0 /* UrlParameter */, 0 /* String */, true, getRecordId18Array), generateParamConfigMetadata('childRelationships', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('layoutTypes', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray), generateParamConfigMetadata('modes', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray), generateParamConfigMetadata('optionalFields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('updateMru', false, 1 /* QueryParameter */, 1 /* Boolean */)];
    function typeCheckConfig$12(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRecordUi_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$14(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRecordUi_ConfigPropertyMetadata);
      const config = typeCheckConfig$12(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    const layoutSelections$2 = select$1J();
    const objectInfoPathSelection = select$1L();
    const layoutUserStatePathSelector = select$1I();
    function buildRecordUiSelector(recordDefs, layoutTypes, modes, recordOptionalFields) {
      const layoutTypeSelections = [];
      for (let i = 0, len = layoutTypes.length; i < len; i += 1) {
        const layoutType = layoutTypes[i];
        const modeSelections = [];
        const sel = {
          kind: 'Object',
          name: layoutType,
          selections: modeSelections
        };
        for (let m = 0; m < modes.length; m += 1) {
          const mode = modes[m];
          const modeSel = {
            kind: 'Link',
            name: mode,
            fragment: layoutSelections$2
          };
          push.call(modeSelections, modeSel);
        }
        push.call(layoutTypeSelections, sel);
      }
      const recordLayoutSelections = [];
      const recordSelections = [];
      for (let i = 0, len = recordDefs.length; i < len; i += 1) {
        const {
          recordId,
          recordData
        } = recordDefs[i];
        push.call(recordLayoutSelections, {
          kind: 'Object',
          name: recordData.apiName,
          required: false,
          map: true,
          selections: layoutTypeSelections
        });
        const optionalFields = recordOptionalFields[recordId];
        const fields = extractFields(recordData);
        push.call(recordSelections, {
          kind: 'Link',
          name: recordId,
          fragment: {
            kind: 'Fragment',
            selections: buildSelectionFromFields(fields, optionalFields),
            private: ['eTag', 'weakEtag']
          }
        });
      }
      return {
        kind: 'Fragment',
        private: ['eTag'],
        version: VERSION$13,
        selections: [{
          kind: 'Link',
          name: 'layoutUserStates',
          map: true,
          fragment: layoutUserStatePathSelector
        }, {
          kind: 'Object',
          name: 'layouts',
          selections: recordLayoutSelections
        }, {
          kind: 'Link',
          name: 'objectInfos',
          map: true,
          fragment: objectInfoPathSelection
        }, {
          name: 'records',
          kind: 'Object',
          selections: recordSelections
        }]
      };
    }
    const FIELD_ID = 'Id';
    const FIELD_NAME = 'Name';
    const COMPONENT_TYPE_FIELD = 'Field';
    function isFieldAReferenceWithRelationshipName(objectInfo, fieldApiName) {
      const field = objectInfo.fields[fieldApiName];
      if (field === undefined) {
        return false;
      }
      // eslint-disable-next-line @salesforce/lds/no-invalid-todo
      // TODO - can reference===true and relationshipName===null?
      return field.reference === true && field.relationshipName !== null;
    }
    function getRelationshipName(objectInfo, fieldApiName) {
      // eslint-disable-next-line @salesforce/lds/no-invalid-todo
      // TODO RAML - fix typing so isFieldAReferenceWithRelationshipName enables calling this without `relationshipName!`
      return objectInfo.fields[fieldApiName].relationshipName;
    }
    function getNameField(objectInfo, fieldApiName) {
      // eslint-disable-next-line @salesforce/lds/no-invalid-todo
      // TODO - this logic is adopted from lds222. It searches
      // ObjectInfoRep.ReferenceToInfoRep[].nameFields[]:
      // 1. If any of the arrays are empty returns `Name`
      // 2. If `Name` is found in any array position then returns it
      // 3. If the field has more than 1 references(polymorphic), return `Name`
      // 4. Else returns ObjectInfoRep.ReferenceToInfoRep[0].nameFields[0]
      // Rationale for this is unclear and needs clarification.
      const referenceToInfos = objectInfo.fields[fieldApiName].referenceToInfos;
      if (referenceToInfos.length !== 1) {
        return FIELD_NAME;
      }
      const firstReferenceNameFields = referenceToInfos[0].nameFields;
      if (firstReferenceNameFields.length < 1) {
        return FIELD_NAME;
      }
      for (let a = 0, alen = referenceToInfos.length; a < alen; a++) {
        const nameFields = referenceToInfos[a].nameFields;
        for (let b = 0, blen = nameFields.length; b < blen; b++) {
          const nameField = nameFields[b];
          if (nameField === FIELD_NAME) {
            return nameField;
          }
        }
      }
      return firstReferenceNameFields[0];
    }
    function getQualifiedFieldApiNamesFromLayout(layout, objectInfo) {
      const qualifiedFieldNames = [];
      const qualifiedOptionalFieldNames = [];
      for (let a = 0, alen = layout.sections.length; a < alen; a++) {
        const section = layout.sections[a];
        for (let b = 0, blen = section.layoutRows.length; b < blen; b++) {
          const row = section.layoutRows[b];
          for (let c = 0, clen = row.layoutItems.length; c < clen; c++) {
            const item = row.layoutItems[c];
            for (let d = 0, dlen = item.layoutComponents.length; d < dlen; d++) {
              const component = item.layoutComponents[d];
              const {
                apiName
              } = component;
              if (apiName && component.componentType === COMPONENT_TYPE_FIELD) {
                if (isFieldAReferenceWithRelationshipName(objectInfo, apiName)) {
                  const relationshipFieldApiName = getRelationshipName(objectInfo, apiName);
                  // By default, include the "Id" field on spanning records that are on the layout.
                  qualifiedFieldNames.push(`${objectInfo.apiName}.${relationshipFieldApiName}.${FIELD_ID}`);
                  const nameField = getNameField(objectInfo, apiName);
                  // W-15692973: Name field of referenced entites are moved to optionalFields since the Name field may not exist for few entites.
                  qualifiedOptionalFieldNames.push(`${objectInfo.apiName}.${relationshipFieldApiName}.${nameField}`);
                }
                qualifiedFieldNames.push(`${objectInfo.apiName}.${component.apiName}`);
              }
            }
          }
        }
      }
      return {
        fields: qualifiedFieldNames,
        optionalFields: qualifiedOptionalFieldNames
      };
    }
    function getMissingRecordLookupFields(record, objectInfo) {
      const lookupFields = {};
      const {
        apiName,
        fields: recordFields
      } = record;
      const {
        fields: objectInfoFields
      } = objectInfo;
      const objectInfoFieldNames = keys(objectInfoFields);
      for (let i = 0, len = objectInfoFieldNames.length; i < len; i += 1) {
        const fieldName = objectInfoFieldNames[i];
        const field = objectInfoFields[fieldName];
        const {
          relationshipName
        } = field;
        if (relationshipName === null) {
          continue;
        }
        const recordFieldValue = recordFields[relationshipName];
        // Only interested in record fields that are present and that are null
        if (recordFieldValue === undefined || recordFieldValue.value !== null) {
          continue;
        }
        // Include the Id field. Ex: Opportunity.Account.Id, Opportunity.relation1__r.Id
        const idFieldName = `${apiName}.${relationshipName}.Id`;
        lookupFields[idFieldName] = true;
        const nameField = `${apiName}.${relationshipName}.${getNameField(objectInfo, fieldName)}`;
        lookupFields[nameField] = true;
      }
      return keys(lookupFields);
    }
    function getRecordUiMissingRecordLookupFields(recordUi) {
      const {
        records,
        objectInfos
      } = recordUi;
      const recordLookupFields = {};
      const recordIds = keys(records);
      for (let i = 0, len = recordIds.length; i < len; i += 1) {
        const recordId = recordIds[i];
        const recordData = records[recordId];
        const {
          apiName
        } = recordData;
        const objectInfo = objectInfos[apiName];
        recordLookupFields[recordId] = getMissingRecordLookupFields(recordData, objectInfo);
      }
      return recordLookupFields;
    }

    // Custom adapter config due to `unsupported` items
    const GET_RECORDUI_ADAPTER_CONFIG = {
      displayName: 'getRecordUi',
      parameters: {
        required: ['recordIds', 'layoutTypes', 'modes'],
        optional: ['optionalFields'],
        unsupported: ['formFactor', 'childRelationships', 'pageSize', 'updateMru']
      }
    };
    const RECORD_UI_ERROR_STORE_METADATA_PARAMS_VERSION = 'RECORD_UI_ERROR_STORE_METADATA_PARAMS_VERSION_1';
    const RECORD_UI_ERROR_STORE_METADATA_PARAMS = {
      ttl: TTL$u,
      representationName: '',
      namespace: keyPrefix,
      version: RECORD_UI_ERROR_STORE_METADATA_PARAMS_VERSION
    };
    const RECORD_UI_CACHED_SELECTOR_VERSION = 'RECORD_UI_CACHED_SELECTOR_VERSION_1';
    function buildCachedSelectorKey(key) {
      return `${key}__selector`;
    }
    function eachLayout(recordUi, cb) {
      const {
        layouts
      } = recordUi;
      const layoutApiNames = keys(layouts);
      for (let a = 0, len = layoutApiNames.length; a < len; a += 1) {
        const apiName = layoutApiNames[a];
        const apiNameData = layouts[apiName];
        const recordTypeIds = keys(apiNameData);
        for (let b = 0, recordTypeIdsLen = recordTypeIds.length; b < recordTypeIdsLen; b += 1) {
          const recordTypeId = recordTypeIds[b];
          const recordTypeData = apiNameData[recordTypeId];
          const layoutTypes = keys(recordTypeData);
          for (let c = 0, layoutTypesLen = layoutTypes.length; c < layoutTypesLen; c += 1) {
            const layoutType = layoutTypes[c];
            const layoutTypeData = recordTypeData[layoutType];
            const modes = keys(layoutTypeData);
            for (let d = 0, modesLen = modes.length; d < modesLen; d += 1) {
              const mode = modes[d];
              const layout = layoutTypeData[mode];
              cb(apiName, recordTypeId, layout);
            }
          }
        }
      }
    }
    function collectRecordDefs(resp, recordIds) {
      const recordDefs = [];
      for (let i = 0, len = recordIds.length; i < len; i += 1) {
        const recordId = recordIds[i];
        const recordData = resp.records[recordId];
        push.call(recordDefs, {
          recordId,
          recordData,
          recordTypeId: getRecordTypeId$2(recordData)
        });
      }
      return recordDefs;
    }
    function keyBuilder$1T(recordIds, layoutTypes, modes, optionalFields) {
      const joinedRecordIds = recordIds.sort().join(',');
      const joinedOptionalFields = optionalFields.sort().join(',');
      const joinedLayoutTypes = layoutTypes.sort().join(',');
      const joinedModes = modes.sort().join(',');
      return `${keyPrefix}::RecordUiRepresentation:${joinedRecordIds}:${joinedLayoutTypes}:${joinedModes}:${joinedOptionalFields}`;
    }
    function buildSnapshotRefresh$4(luvio, config) {
      return {
        config,
        resolve: () => buildNetworkSnapshot$12(luvio, config)
      };
    }
    function markRecordUiNulledOutLookupFields(recordLookupFields, recordNodes) {
      for (let i = 0, len = recordNodes.length; i < len; i++) {
        const recordId = recordNodes[i].data.id;
        if (recordLookupFields[recordId] !== undefined) {
          markNulledOutRequiredFields(recordNodes[i], recordLookupFields[recordId]);
        }
      }
    }
    function markRecordUiOptionalFields(optionalFields, recordLookupFields, recordNodes) {
      for (let i = 0, len = recordNodes.length; i < len; i++) {
        const recordId = recordNodes[i].data.id;
        if (optionalFields.length > 0 || recordLookupFields[recordId] !== undefined) {
          markMissingOptionalFields(recordNodes[i], [...optionalFields, ...recordLookupFields[recordId]]);
        }
      }
    }
    function prepareRequest$5(luvio, config) {
      const {
        recordIds,
        layoutTypes,
        modes,
        optionalFields
      } = config;
      const key = keyBuilder$1T(recordIds, layoutTypes, modes, optionalFields);
      const selectorKey = buildCachedSelectorKey(key);
      const resourceRequest = createResourceRequest$11({
        urlParams: {
          recordIds
        },
        queryParams: {
          layoutTypes,
          modes,
          optionalFields: dedupe(optionalFields).sort()
        }
      });
      return {
        key,
        selectorKey,
        resourceRequest
      };
    }
    // NOTE: getRecordUi is special and we can't use the generated getResponseCacheKeys
    // (just like we don't use the generated ingestSuccess).  To get the cache keys
    // we have to run ingest code and look at the resulting snapshot's seenRecords.
    function getCacheKeys(keySet, luvio, config, key, originalResponseBody) {
      const {
        recordIds,
        layoutTypes,
        modes
      } = config;
      const responseBody = parse(stringify(originalResponseBody));
      eachLayout(responseBody, (apiName, recordTypeId, layout) => {
        if (layout.id === null) {
          return;
        }
        const layoutUserState = responseBody.layoutUserStates[layout.id];
        // Temporary hack since we can't match keys from getLayoutUserState response
        // to record ui's layout users states.
        if (layoutUserState === undefined) {
          return;
        }
        layoutUserState.apiName = apiName;
        layoutUserState.recordTypeId = recordTypeId;
        layoutUserState.mode = layout.mode;
        layoutUserState.layoutType = layout.layoutType;
      });
      const recordLookupFields = getRecordUiMissingRecordLookupFields(responseBody);
      const selPath = buildRecordUiSelector(collectRecordDefs(responseBody, recordIds), layoutTypes, modes, recordLookupFields);
      const sel = {
        recordId: key,
        node: selPath,
        variables: {}
      };
      luvio.storeIngest(key, ingest$E, responseBody);
      const snapshot = luvio.storeLookup(sel, buildSnapshotRefresh$4(luvio, config));
      if (snapshot.state === 'Error') {
        return new luvioEngine.StoreKeyMap();
      }
      const keys = [...snapshot.seenRecords.keysAsArray(), snapshot.recordId];
      for (let i = 0, len = keys.length; i < len; i++) {
        const key = keys[i];
        const namespace = key.split('::')[0];
        const representationName = key.split('::')[1].split(':')[0];
        keySet.set(key, {
          namespace,
          representationName,
          mergeable: representationName === RepresentationType$V
        });
      }
    }
    function onFetchResponseSuccess$K(luvio, config, selectorKey, key, responseBody) {
      const {
        recordIds,
        layoutTypes,
        modes,
        optionalFields
      } = config;
      // eslint-disable-next-line @salesforce/lds/no-invalid-todo
      // TODO fix API so we don't have to augment the response with request details in order
      // to support refresh. these are never emitted out per (private).
      eachLayout(responseBody, (apiName, recordTypeId, layout) => {
        if (layout.id === null) {
          return;
        }
        const layoutUserState = responseBody.layoutUserStates[layout.id];
        // Temporary hack since we can't match keys from getLayoutUserState response
        // to record ui's layout users states.
        if (layoutUserState === undefined) {
          return;
        }
        layoutUserState.apiName = apiName;
        layoutUserState.recordTypeId = recordTypeId;
        layoutUserState.mode = layout.mode;
        layoutUserState.layoutType = layout.layoutType;
      });
      const recordLookupFields = getRecordUiMissingRecordLookupFields(responseBody);
      const selPath = buildRecordUiSelector(collectRecordDefs(responseBody, recordIds), layoutTypes, modes, recordLookupFields);
      const sel = {
        recordId: key,
        node: selPath,
        variables: {}
      };
      luvio.storePublish(selectorKey, sel);
      luvio.storeIngest(key, ingest$E, responseBody);
      // During ingestion, only valid records are stored.
      const recordNodes = [];
      const validRecordIds = [];
      for (let i = 0, len = recordIds.length; i < len; i += 1) {
        const recordId = recordIds[i];
        const recordKey = keyBuilder$29(luvio, {
          recordId
        });
        const node = luvio.getNode(recordKey);
        if (isGraphNode(node)) {
          recordNodes.push(node);
          validRecordIds.push(recordId);
        }
      }
      markRecordUiNulledOutLookupFields(recordLookupFields, recordNodes);
      markRecordUiOptionalFields(optionalFields, recordLookupFields, recordNodes);
      publishDependencies(luvio, validRecordIds, [key, selectorKey]);
      const snapshot = luvio.storeLookup(sel, buildSnapshotRefresh$4(luvio, config));
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$L(luvio, config, selectorKey, key, err) {
      const errorSnapshot = luvio.errorSnapshot(err, buildSnapshotRefresh$4(luvio, config));
      luvio.storeIngestError(key, errorSnapshot, RECORD_UI_ERROR_STORE_METADATA_PARAMS);
      return luvio.storeBroadcast().then(() => {
        if (err.errorType === 'fetchResponse') {
          const {
            status
          } = err;
          if (status === 404) {
            const sel = {
              recordId: key,
              node: {
                kind: 'Fragment',
                private: [],
                opaque: true,
                version: RECORD_UI_CACHED_SELECTOR_VERSION
              },
              variables: {}
            };
            luvio.storePublish(selectorKey, sel);
            return luvio.storeLookup(sel, buildSnapshotRefresh$4(luvio, config));
          }
        }
        return errorSnapshot;
      });
    }
    function buildNetworkSnapshot$12(luvio, config, dispatchContext) {
      const {
        key,
        resourceRequest,
        selectorKey
      } = prepareRequest$5(luvio, config);
      return luvio.dispatchResourceRequest(resourceRequest, dispatchContext).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$K(luvio, config, selectorKey, key, response.body), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getCacheKeys(cache, luvio, config, key, response.body);
          return cache;
        });
      }, err => {
        return luvio.handleErrorResponse(() => {
          return onFetchResponseError$L(luvio, config, selectorKey, key, err);
        });
      });
    }
    function publishDependencies(luvio, recordIds, depKeys) {
      for (let i = 0, len = recordIds.length; i < len; i += 1) {
        const recordDepKey = dependencyKeyBuilder({
          recordId: recordIds[i]
        });
        const dependencies = create(null);
        for (let j = 0, len = depKeys.length; j < len; j++) {
          dependencies[depKeys[j]] = true;
        }
        const node = luvio.getNode(recordDepKey);
        if (isGraphNode(node)) {
          const recordDeps = node.retrieve();
          assign(dependencies, recordDeps);
        }
        luvio.storePublish(recordDepKey, dependencies);
      }
    }
    function buildCachedSelectorSnapshot(context, storeLookup) {
      const {
        config
      } = context;
      const {
        recordIds,
        layoutTypes,
        modes,
        optionalFields
      } = config;
      const key = keyBuilder$1T(recordIds, layoutTypes, modes, optionalFields);
      const cachedSelectorKey = buildCachedSelectorKey(key);
      return storeLookup({
        recordId: cachedSelectorKey,
        node: {
          kind: 'Fragment',
          private: [],
          opaque: true,
          version: RECORD_UI_CACHED_SELECTOR_VERSION
        },
        variables: {}
      });
    }
    function buildCachedRecordUiRepresentationSnapshot(context, storeLookup) {
      const {
        config,
        luvio,
        selector
      } = context;
      // try to resolve RecordUiRepresentation selector if previous steps were able to find one
      if (selector !== undefined) {
        return storeLookup(selector, buildSnapshotRefresh$4(luvio, config));
      }
    }
    function buildNetworkRecordUiRepresentationSnapshot(context, coercedAdapterRequestContext) {
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return buildNetworkSnapshot$12(context.luvio, context.config, dispatchOptions);
    }
    function coerceConfigWithDefaults$3(untrustedConfig) {
      const config = validateAdapterConfig$14(untrustedConfig, GET_RECORDUI_ADAPTER_CONFIG);
      if (config === null) {
        return null;
      }
      const {
        layoutTypes,
        modes
      } = config;
      // custom config validation
      if (layoutTypes === undefined || modes === undefined) {
        return null;
      }
      return {
        ...config,
        layoutTypes: layoutTypes,
        modes: modes,
        optionalFields: config.optionalFields === undefined ? [] : config.optionalFields
      };
    }
    const factory$g = luvio => function UiApi__getRecordUi(untrustedConfig, requestContext) {
      // standard config validation and coercion
      const config = coerceConfigWithDefaults$3(untrustedConfig);
      if (config === null) {
        return null;
      }
      const definedRequestContext = requestContext || {};
      const selectorPromiseOrSnapshot = luvio.applyCachePolicy(definedRequestContext, {
        config,
        luvio
      }, buildCachedSelectorSnapshot, buildNotFetchableNetworkSnapshot(luvio));
      const resolveSelector = selectorSnapshot => {
        const selector = isFulfilledSnapshot(selectorSnapshot) || isStaleSnapshot(selectorSnapshot) ? selectorSnapshot.data : undefined;
        return luvio.applyCachePolicy(definedRequestContext, {
          config,
          luvio,
          selector
        }, buildCachedRecordUiRepresentationSnapshot, buildNetworkRecordUiRepresentationSnapshot);
      };
      return isPromise(selectorPromiseOrSnapshot) ? selectorPromiseOrSnapshot.then(resolveSelector) : resolveSelector(selectorPromiseOrSnapshot);
    };
    var LayoutMode;
    (function (LayoutMode) {
      LayoutMode["View"] = "View";
      LayoutMode["Edit"] = "Edit";
      LayoutMode["Create"] = "Create";
    })(LayoutMode || (LayoutMode = {}));
    const DEFAULT_MODE = LayoutMode.View;
    const layoutSelections$1 = select$1J();
    function buildSnapshotRefresh$3(luvio, config) {
      return {
        config,
        resolve: () => refresh$1(luvio, config)
      };
    }
    function buildObjectInfoSelectorKey(luvio, objectInfo) {
      const key = keyBuilderFromType$w(luvio, objectInfo);
      return `${key}__implicit__fields__selector`;
    }
    function refresh$1(luvio, config) {
      const {
        recordId,
        layoutTypes,
        modes: configModes,
        optionalFields: configOptionalFields
      } = config;
      const modes = configModes === undefined ? [DEFAULT_MODE] : configModes;
      const optionalFields = configOptionalFields === undefined ? [] : configOptionalFields;
      const recordUiConfig = {
        recordIds: [recordId],
        layoutTypes,
        modes,
        optionalFields
      };
      return buildNetworkSnapshot$12(luvio, recordUiConfig).then(snapshot => {
        const refresh = buildSnapshotRefresh$3(luvio, config);
        if (isErrorSnapshot(snapshot)) {
          var recordKey = keyBuilder$29(luvio, {
            recordId
          });
          luvio.storeIngestError(recordKey, snapshot);
          return luvio.storeBroadcast().then(() => luvio.errorSnapshot(snapshot.error, refresh));
        }
        if (isUnfulfilledSnapshot(snapshot)) {
          {
            throw new Error(`RecordUi adapter resolved with a snapshot with missing data, missingPaths: ${keys(snapshot.missingPaths)}`);
          }
        }
        const {
          data
        } = snapshot;
        if (data === undefined) {
          // eslint-disable-next-line @salesforce/lds/no-error-in-production
          throw new Error(`RecordUi adapter resolved with a ${snapshot.state} snapshot with undefined data`);
        }
        const {
          layoutMap,
          objectInfo
        } = getLayoutMapAndObjectInfo(recordId, data);
        // W-15692973: Name field of referenced entites are moved to optionalFields since the Name field may not exist for few entites.
        const {
          fields,
          optionalFields: layoutOptionalFields
        } = getFieldsFromLayoutMap(layoutMap, objectInfo);
        const mergedOptionalFields = dedupe(optionalFields.concat(layoutOptionalFields));
        return buildCachedSnapshot$9(luvio, {
          recordId,
          fields,
          optionalFields: mergedOptionalFields
        }, refresh);
      });
    }
    function getLayoutMapAndObjectInfo(recordId, data) {
      const {
        objectInfos,
        layouts,
        records
      } = data;
      const record = records[recordId];
      const {
        apiName
      } = record;
      const objectInfo = objectInfos[apiName];
      const recordTypeId = getRecordTypeId$2(record);
      // W-12697744 - Return an empty layoutMap if the entity does not have a layout.
      // Temp fix until we can mimic the server behavior for non-layoutable entities.
      let layoutMap = {};
      if (hasOwnProperty.call(layouts, apiName)) {
        layoutMap = layouts[apiName][recordTypeId] || {};
      }
      return {
        layoutMap,
        objectInfo
      };
    }
    function getFields(recordId, data) {
      const {
        records
      } = data;
      const record = records[recordId];
      const {
        fields
      } = record;
      return fields;
    }
    function processRecordUiRepresentation(luvio, refresh, recordId, modes, snapshot, adapterContext, optionalFields) {
      if (isErrorSnapshot(snapshot)) {
        return luvio.errorSnapshot(snapshot.error, refresh);
      }
      if (isUnfulfilledSnapshot(snapshot)) {
        {
          throw new Error(`RecordUi adapter resolved with a snapshot with missing data, missingPaths: ${keys(snapshot.missingPaths)}`);
        }
      }
      const {
        data
      } = snapshot;
      if (data === undefined) {
        // eslint-disable-next-line @salesforce/lds/no-error-in-production
        throw new Error(`RecordUi adapter resolved with a ${snapshot.state} snapshot with undefined data`);
      }
      const {
        layoutMap,
        objectInfo
      } = getLayoutMapAndObjectInfo(recordId, data);
      if (objectInfo.layoutable) {
        return getRecordForLayoutableEntities(luvio, refresh, recordId, layoutMap, objectInfo, optionalFields);
      } else {
        return getRecordForNonLayoutableEntities(luvio, adapterContext, refresh, recordId, objectInfo, optionalFields, getFields(recordId, data));
      }
    }
    const recordLayoutFragmentSelector = [{
      name: 'apiName',
      kind: 'Scalar'
    }, {
      name: 'recordTypeId',
      kind: 'Scalar'
    }];
    function getFieldsFromLayoutMap(layoutMap, objectInfo) {
      let fields = [];
      let optionalFields = [];
      const layoutTypes = keys(layoutMap);
      for (let i = 0, layoutTypesLen = layoutTypes.length; i < layoutTypesLen; i += 1) {
        const layoutType = layoutTypes[i];
        const modesMap = layoutMap[layoutType];
        const modes = keys(modesMap);
        for (let m = 0, modesLen = modes.length; m < modesLen; m += 1) {
          const mode = modes[m];
          const {
            fields: modeFields,
            optionalFields: modeOptionalFields
          } = getQualifiedFieldApiNamesFromLayout(modesMap[mode], objectInfo);
          fields = fields.concat(modeFields);
          optionalFields = optionalFields.concat(modeOptionalFields);
        }
      }
      return {
        fields: dedupe(fields).sort(),
        optionalFields: dedupe(optionalFields).sort()
      };
    }
    /**
     * W-14696113
     * Merge fields into optionalFields and return the whole list.
     * @param {string[]} fields
     * @param {string[]} [optionalFields]
     */
    function convertToImplicitFields(fields, optionalFields) {
      const implicitFields = optionalFields || [];
      fields.forEach(field => {
        if (!(field in implicitFields)) implicitFields.push(field);
      });
      return implicitFields;
    }
    function getRecordForLayoutableEntities(luvio, refresh, recordId, layoutMap, objectInfo, configOptionalFields) {
      // W-15692973: Name field of referenced entites are moved to optionalFields since the Name field may not exist for few entites.
      let {
        fields,
        optionalFields
      } = getFieldsFromLayoutMap(layoutMap, objectInfo);
      if (configOptionalFields && configOptionalFields.length > 0) {
        optionalFields = dedupe(optionalFields.concat(configOptionalFields));
      }
      const implicitFields = convertToImplicitFields(fields, optionalFields);
      return getRecord$1(luvio, refresh, recordId, [], implicitFields);
    }
    function getRecordForNonLayoutableEntities(luvio, adapterContext, refresh, recordId, objectInfo, configOptionalFields, configFields) {
      const fields = keys(configFields ? configFields : {}).map(key => `${objectInfo.apiName}.${key}`);
      // W-12697744
      // Set the implicit fields received from the server in adapter context
      // This ensures that the implicit fields are available when data is read locally or from durable store
      const selectorKey = buildObjectInfoSelectorKey(luvio, objectInfo);
      adapterContext.set(selectorKey, fields);
      return getRecord$1(luvio, refresh, recordId, fields, configOptionalFields);
    }
    function getRecord$1(luvio, refresh, recordId, fields, configOptionalFields) {
      const optionalFields = configOptionalFields === undefined ? [] : dedupe(configOptionalFields).sort();
      // We know what fields we need so delegate to getRecordByFields
      // This should be a cache hit because we just fetched the record-ui
      const recordSnapshotOrPromise = getRecordByFields(luvio, {
        recordId,
        fields,
        optionalFields
      });
      // attach a record layout refresh
      if (isPromise(recordSnapshotOrPromise)) {
        recordSnapshotOrPromise.then(snapshot => {
          snapshot.refresh = refresh;
          return snapshot;
        });
      } else {
        recordSnapshotOrPromise.refresh = refresh;
      }
      return recordSnapshotOrPromise;
    }
    function buildNetworkSnapshot$11(context, coercedAdapterRequestContext) {
      const {
        config,
        luvio,
        adapterContext
      } = context;
      const {
        recordId
      } = config;
      const optionalFields = config.optionalFields === undefined ? [] : dedupe(config.optionalFields).sort();
      const refresh = buildSnapshotRefresh$3(luvio, config);
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      // if we were able to map the layouts to a set of fields then use GetRecordFields
      // to send a request for just those fields
      if (context.fields !== undefined) {
        const recordConfig = {
          recordId,
          fields: context.fields,
          optionalFields
        };
        return buildNetworkSnapshot$16(luvio, recordConfig, 0, coercedAdapterRequestContext).then(snapshot => {
          snapshot.refresh = refresh;
          return snapshot;
        });
      }
      // otherwise fallback to getRecordUi to get the full set of information
      const modes = config.modes !== undefined ? config.modes : [DEFAULT_MODE];
      const recordUiConfig = {
        recordIds: [recordId],
        layoutTypes: config.layoutTypes,
        modes,
        optionalFields
      };
      return buildNetworkSnapshot$12(luvio, recordUiConfig, dispatchOptions).then(snapshot => processRecordUiRepresentation(luvio, refresh, recordId, modes, snapshot, adapterContext, optionalFields));
    }
    function buildRecordLayoutCachedSnapshot(context, storeLookup) {
      const {
        config,
        luvio
      } = context;
      // get cached copy of the record
      const {
        recordId
      } = config;
      const storeKey = keyBuilder$29(luvio, {
        recordId
      });
      const recordSnapshot = storeLookup({
        recordId: storeKey,
        node: {
          kind: 'Fragment',
          private: [],
          selections: recordLayoutFragmentSelector,
          version: VERSION$1e
        },
        variables: {}
      });
      return recordSnapshot;
    }
    const buildObjectInfoCacheSnapshot = recordLayoutSnapshot => (context, storeLookup) => {
      const {
        luvio
      } = context;
      if (recordLayoutSnapshot.data === undefined) {
        return;
      }
      return buildCachedSnapshotCachePolicy$O({
        config: {
          objectApiName: recordLayoutSnapshot.data.apiName
        },
        luvio
      }, storeLookup);
    };
    const buildLayoutModeCacheSnapshot = (apiName, recordTypeId, layoutType, mode) => (context, storeLookup) => {
      const {
        luvio
      } = context;
      const key = keyBuilder$1V(luvio, {
        objectApiName: apiName,
        recordTypeId,
        layoutType,
        mode
      });
      return storeLookup({
        recordId: key,
        node: layoutSelections$1,
        variables: {}
      });
    };
    /**
     * Create a snapshot that will only attempt to build from cache
     * These are intermediate lookups to check if the record is in the L2 cache
     * @param  {Luvio} luvio
     * @param  {GetRecordLayoutTypeConfig} config
     * @param  {BuildCachedSnapshot<BuildSnapshotContext>} cachedSnapshot
     */
    function makeCacheOnlySnapshot(luvio, config, adapterContext, cachedSnapshot) {
      return luvio.applyCachePolicy(
      // Pass empty context so environment will use its default cache-policy
      {}, {
        config,
        luvio,
        adapterContext
      }, cachedSnapshot,
      // disallow hitting the network by returning a gateway timeout
      () => {
        return new Promise(resolve => {
          resolve({
            state: 'Error',
            data: undefined,
            error: {
              body: undefined,
              headers: {},
              ok: false,
              status: 504,
              statusText: 'Gateway Timeout',
              errorType: 'fetchResponse'
            }
          });
        });
      });
    }
    /**
     * Create a snapshot that will fail to pull from the cache
     * and force a network call
     * @param  {Luvio} luvio
     * @param  {GetRecordLayoutTypeConfig} config
     * @param  {AdapterRequestContext} requestContext?
     */
    function makeNetworkOnlySnapshot(luvio, config, adapterContext, requestContext) {
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio,
        adapterContext
      }, () => {
        return undefined;
      }, buildNetworkSnapshot$11);
    }
    function getRecordLayoutType(luvio, config, adapterContext, requestContext) {
      // lookup record layout
      const recordLayoutSnapshotOrPromise = makeCacheOnlySnapshot(luvio, config, adapterContext, buildRecordLayoutCachedSnapshot);
      return runSnapshotOrPromise(recordLayoutSnapshotOrPromise, recordLayoutSnapshot => {
        // if record layout is not fulfulled or data is undefined send to the network
        if (recordLayoutSnapshot.state === 'Unfulfilled' || recordLayoutSnapshot.state === 'Error' || recordLayoutSnapshot.data === undefined) {
          return makeNetworkOnlySnapshot(luvio, config, adapterContext, requestContext);
        }
        // lookup object info
        const objectInfoSnapshotOrPromise = makeCacheOnlySnapshot(luvio, config, adapterContext, buildObjectInfoCacheSnapshot(recordLayoutSnapshot));
        return runSnapshotOrPromise(objectInfoSnapshotOrPromise, objectInfoSnapshot => {
          const {
            layoutTypes
          } = config;
          // if not fulfilled or missing data send to the network
          if (objectInfoSnapshot.state === 'Unfulfilled' || objectInfoSnapshot.state === 'Error' || objectInfoSnapshot.data === undefined) {
            return makeNetworkOnlySnapshot(luvio, config, adapterContext, requestContext);
          }
          const {
            data: record
          } = recordLayoutSnapshot;
          // try to load all the requested layouts from cache
          const recordTypeId = getRecordTypeId$2(record);
          const modes = config.modes === undefined ? [DEFAULT_MODE] : config.modes;
          // W-12697744
          // For non-layoutable entities, use the implicit fields as the fields are not available in layout
          // Fields can be fetched from adapter context if the server request was already made at some point in the past
          // If fields are not available in adapter context, make a network request to get the data
          // and store implicit fields in adapter context.
          if (!objectInfoSnapshot.data.layoutable) {
            const selectorKey = buildObjectInfoSelectorKey(luvio, objectInfoSnapshot.data);
            const fields = adapterContext.get(selectorKey);
            if (!fields) {
              return makeNetworkOnlySnapshot(luvio, config, adapterContext, requestContext);
            }
            return luvio.applyCachePolicy(requestContext || {}, {
              config,
              luvio,
              adapterContext
            }, buildRecordSnapshot(luvio, config, recordLayoutSnapshot, objectInfoSnapshot, fields), buildNetworkSnapshot$11);
          }
          return makeRecordLayoutMap(luvio, config, objectInfoSnapshot.data.apiName, recordTypeId, layoutTypes, modes, adapterContext).then(recordLayoutMap => {
            return luvio.applyCachePolicy(requestContext || {}, {
              config,
              luvio,
              adapterContext
            }, buildRecordLayoutSnapshot(recordLayoutMap, luvio, config, recordLayoutSnapshot, objectInfoSnapshot), buildNetworkSnapshot$11);
          });
        });
      });
    }
    /**
     * Takes a views layout types and modes and returns the snapshot of a RecordLayoutRepresentation
     * for each type/mode
     * @param  {Luvio} luvio
     * @param  {GetRecordLayoutTypeConfig} config
     * @param  {string} apiName
     * @param  {string} recordTypeId
     * @param  {LayoutType[]} layoutTypes
     * @param  {LayoutMode[]} modes
     */
    function makeRecordLayoutMap(luvio, config, apiName, recordTypeId, layoutTypes, modes, adapterContext) {
      let promises = [];
      for (let i = 0; i < layoutTypes.length; i++) {
        const layoutType = layoutTypes[i];
        for (let m = 0; m < modes.length; m++) {
          const mode = modes[m];
          promises.push(Promise.resolve(makeCacheOnlySnapshot(luvio, config, adapterContext, buildLayoutModeCacheSnapshot(apiName, recordTypeId, layoutType, mode))).then(snapshot => {
            return {
              layoutType,
              mode,
              snapshot
            };
          }));
        }
      }
      return Promise.all(promises).then(containers => {
        let wrapper = {
          isStale: false
        };
        for (let i = 0; i < containers.length; i++) {
          const container = containers[i];
          if (container.snapshot.data === undefined) {
            wrapper.isStale = false;
            wrapper.layoutMap = undefined;
            //if we have no data then break and force the adapter to go to the network
            break;
          }
          if (wrapper.layoutMap === undefined) {
            wrapper.layoutMap = {};
          }
          const {
            layoutType,
            mode,
            snapshot
          } = container;
          if (wrapper.layoutMap[layoutType] === undefined) {
            wrapper.layoutMap = assign({}, wrapper.layoutMap, {
              [layoutType]: {}
            });
          }
          if (snapshot.data !== undefined) {
            wrapper.layoutMap[layoutType][mode] = snapshot.data;
          }
          wrapper.isStale = wrapper.isStale || isStaleSnapshot(snapshot);
        }
        return wrapper;
      });
    }
    function buildRecordLayoutSnapshot(recordLayout, luvio, config, recordLayoutSnapshot, objectInfoSnapshot) {
      return (context, storeLookup) => {
        const {
          layoutMap,
          isStale: isRecordLayoutStale
        } = recordLayout;
        if (layoutMap === undefined || objectInfoSnapshot.data === undefined) {
          return;
        }
        // transform the layouts & object info into a set of fields
        // // W-15692973: Name field of referenced entites are moved to optionalFields since the Name field may not exist for few entites.
        const {
          fields,
          optionalFields
        } = getFieldsFromLayoutMap(layoutMap, objectInfoSnapshot.data);
        let configWithModifiedOptionalFields = {
          ...config,
          optionalFields: config.optionalFields ? dedupe(config.optionalFields.concat(optionalFields)).sort() : optionalFields
        };
        return getRecordRepSnapshot(luvio, configWithModifiedOptionalFields, recordLayoutSnapshot, objectInfoSnapshot, fields, isRecordLayoutStale, context, storeLookup);
      };
    }
    function buildRecordSnapshot(luvio, config, recordLayoutSnapshot, objectInfoSnapshot, fields) {
      return (context, storeLookup) => {
        return getRecordRepSnapshot(luvio, config, recordLayoutSnapshot, objectInfoSnapshot, fields, false, context, storeLookup);
      };
    }
    function getRecordRepSnapshot(luvio, config, recordLayoutSnapshot, objectInfoSnapshot, fields, isRecordLayoutStale, context, storeLookup) {
      if (objectInfoSnapshot.data === undefined) {
        return;
      }
      // transform the layouts & object info into a set of fields
      const optionalFields = config.optionalFields === undefined ? [] : dedupe(config.optionalFields).sort();
      const {
        recordId
      } = config;
      // borrow GetRecordFields' logic to construct the RecordRepresentation with the necessary fields
      const sel = buildRecordSelector(luvio, recordId, fields, optionalFields);
      const recordRepSnapshot = storeLookup(sel, buildSnapshotRefresh$3(luvio, config));
      if (isFulfilledSnapshot(recordRepSnapshot)) {
        // mark snapshot as stale if any of the information used to construct it was stale
        if (isStaleSnapshot(objectInfoSnapshot) || isStaleSnapshot(recordLayoutSnapshot) || isRecordLayoutStale) {
          recordRepSnapshot.state = 'Stale';
        }
      }
      // allow buildNetworkSnapshot() to use GetRecordFields if we were just missing some fields in L1
      else if (isUnfulfilledSnapshot(recordRepSnapshot)) {
        context.fields = fields;
        // W-15692973: Update optionalFields of config as the optional fields may have Name fields of referenced entities
        context.config.optionalFields = optionalFields;
      }
      // return however much of the record we were able to find in L1; cache policy decides if we
      // should consult L2 or go to network
      return recordRepSnapshot;
    }
    function runSnapshotOrPromise(promiseOrSnapshot, next) {
      if (isPromise(promiseOrSnapshot)) {
        return promiseOrSnapshot.then(next);
      } else {
        return next(promiseOrSnapshot);
      }
    }
    const contextId$4 = `${keyPrefix}__${adapterName$13}`;
    // Custom adapter config due to `unsupported` items
    const GET_RECORD_ADAPTER_CONFIG = {
      displayName: 'getRecord',
      parameters: {
        required: ['recordId'],
        optional: ['fields', 'layoutTypes', 'modes', 'optionalFields'],
        unsupported: ['childRelationships', 'pageSize', 'updateMru']
      }
    };
    function hasLayoutTypes(config) {
      return 'layoutTypes' in config;
    }
    function hasFieldsOrOptionalFields(config) {
      return 'fields' in config || 'optionalFields' in config;
    }
    function createResourceRequestFromRepresentation(representation, optionalFields) {
      const config = {
        urlParams: {
          recordId: representation.id
        },
        queryParams: {
          optionalFields
        }
      };
      return createResourceRequest$1c(config);
    }
    // eslint-disable-next-line @salesforce/lds/no-invalid-todo
    // TODO: this should probably be code generated in RecordRepresentation
    function coerceKeyParams(config) {
      const coercedConfig = {};
      const recordId = getRecordId18(config.recordId);
      if (recordId !== undefined) {
        coercedConfig.recordId = recordId;
      }
      return coercedConfig;
    }
    const notifyChangeFactory = luvio => {
      return function getUiApiRecordsByRecordIdNotifyChange(configs) {
        const keys = configs.map(c => keyBuilder$29(luvio, coerceKeyParams(c)));
        luvio.getNotifyChangeStoreEntries(keys).then(entries => {
          const responsePromises = [];
          for (let i = 0, len = entries.length; i < len; i++) {
            const {
              key,
              record
            } = entries[i];
            const node = luvio.wrapNormalizedGraphNode(record, key);
            const optionalFields = getTrackedFields(key, node, {
              maxDepth: configurationForRestAdapters.getTrackedFieldDepthOnNotifyChange(),
              onlyFetchLeafNodeIdAndName: configurationForRestAdapters.getTrackedFieldLeafNodeIdAndNameOnly()
            });
            const refreshRequest = createResourceRequestFromRepresentation(record, optionalFields);
            const existingWeakEtag = record.weakEtag;
            const fieldTrie = convertFieldsToTrie([], false);
            const optionalFieldTrie = convertFieldsToTrie(optionalFields, true);
            const dispatchResourceRequestPromise = luvio.dispatchResourceRequest(refreshRequest).then(response => {
              return luvio.handleSuccessResponse(() => {
                const {
                  body
                } = response;
                luvio.storeIngest(key, createFieldsIngestSuccess$3({
                  fields: fieldTrie,
                  optionalFields: optionalFieldTrie,
                  trackedFields: optionalFieldTrie,
                  serverRequestCount: 1
                }), body);
                const result = luvio.storeBroadcast();
                instrumentation.getRecordNotifyChangeNetworkResult(existingWeakEtag !== body.weakEtag);
                return result;
              }, () => {
                const cache = new luvioEngine.StoreKeyMap();
                getTypeCacheKeys$V(cache, luvio, response.body);
                return cache;
              });
            }, error => {
              return luvio.handleErrorResponse(() => {
                const errorSnapshot = luvio.errorSnapshot(error);
                luvio.storeIngestError(key, errorSnapshot, RECORD_REPRESENTATION_ERROR_STORE_METADATA_PARAMS);
                const result = luvio.storeBroadcast();
                instrumentation.getRecordNotifyChangeNetworkResult(null, true);
                return result.then(() => errorSnapshot);
              });
            });
            responsePromises.push(dispatchResourceRequestPromise);
          }
          return Promise.all(responsePromises);
        });
      };
    };
    const factory$f = luvio => {
      return luvio.withContext(function getRecord(untrustedConfig, adapterContext, requestContext) {
        // standard config validation and coercion
        const config = validateAdapterConfig$1a(untrustedConfig, GET_RECORD_ADAPTER_CONFIG);
        if (config === null) {
          return null;
        }
        if (hasLayoutTypes(config)) {
          return getRecordLayoutType(luvio, config, adapterContext, requestContext);
        } else if (hasFieldsOrOptionalFields(config)) {
          return getRecordByFields(luvio, config, requestContext);
        }
        return null;
      }, {
        contextId: contextId$4
      });
    };
    const notifyUpdateAvailableFactory$1 = luvio => {
      return function notifyListInfoUpdateAvailable(configs) {
        const generated_notifyUpdateAvailable = notifyUpdateAvailableFactory$6(luvio);
        // Taken from getUiApiListInfoByListViewApiNameAndObjectApiName/keyBuilder artifact
        // We automatically set the type based on the listViewApiName, and we need to do the same
        // here for key matching and validation
        configs.forEach(config => {
          config.listViewApiName = config.listViewApiName ? config.listViewApiName.toLowerCase() : config.listViewApiName;
          config.objectApiName = config.objectApiName ? config.objectApiName.toLowerCase() : config.objectApiName;
          if (!config.type) {
            config.type = config.listViewApiName === '__recent' ? 'mru' : 'listView';
          }
        });
        return generated_notifyUpdateAvailable(configs);
      };
    };
    const VERSION$12 = "4aa37812ee37c752a099b29026217c85";
    function validate$1z(obj, path = 'ObjectInfoDirectoryEntryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_keyPrefix = obj.keyPrefix;
        const path_keyPrefix = path + '.keyPrefix';
        let obj_keyPrefix_union0 = null;
        const obj_keyPrefix_union0_error = (() => {
          if (typeof obj_keyPrefix !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
          }
        })();
        if (obj_keyPrefix_union0_error != null) {
          obj_keyPrefix_union0 = obj_keyPrefix_union0_error.message;
        }
        let obj_keyPrefix_union1 = null;
        const obj_keyPrefix_union1_error = (() => {
          if (obj_keyPrefix !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
          }
        })();
        if (obj_keyPrefix_union1_error != null) {
          obj_keyPrefix_union1 = obj_keyPrefix_union1_error.message;
        }
        if (obj_keyPrefix_union0 && obj_keyPrefix_union1) {
          let message = 'Object doesn\'t match union (at "' + path_keyPrefix + '")';
          message += '\n' + obj_keyPrefix_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_keyPrefix_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_labelPlural = obj.labelPlural;
        const path_labelPlural = path + '.labelPlural';
        if (typeof obj_labelPlural !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_labelPlural + '" (at "' + path_labelPlural + '")');
        }
        const obj_nameFields = obj.nameFields;
        const path_nameFields = path + '.nameFields';
        if (!ArrayIsArray(obj_nameFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_nameFields + '" (at "' + path_nameFields + '")');
        }
        for (let i = 0; i < obj_nameFields.length; i++) {
          const obj_nameFields_item = obj_nameFields[i];
          const path_nameFields_item = path_nameFields + '[' + i + ']';
          if (typeof obj_nameFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nameFields_item + '" (at "' + path_nameFields_item + '")');
          }
        }
        const obj_objectInfoUrl = obj.objectInfoUrl;
        const path_objectInfoUrl = path + '.objectInfoUrl';
        if (typeof obj_objectInfoUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectInfoUrl + '" (at "' + path_objectInfoUrl + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$K = 'ObjectInfoDirectoryEntryRepresentation';
    function keyBuilder$1S(luvio, config) {
      return keyPrefix + '::' + RepresentationType$K + ':' + config.objectInfoUrl;
    }
    function keyBuilderFromType$t(luvio, object) {
      const keyParams = {
        objectInfoUrl: object.objectInfoUrl
      };
      return keyBuilder$1S(luvio, keyParams);
    }
    function normalize$D(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1H = function ObjectInfoDirectoryEntryRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$12,
        private: [],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'keyPrefix',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'labelPlural',
          kind: 'Scalar'
        }, {
          name: 'nameFields',
          kind: 'Scalar',
          plural: true
        }, {
          name: 'objectInfoUrl',
          kind: 'Scalar'
        }]
      };
    };
    function equals$U(existing, incoming) {
      const existing_apiName = existing.apiName;
      const incoming_apiName = incoming.apiName;
      if (!(existing_apiName === incoming_apiName)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      const existing_labelPlural = existing.labelPlural;
      const incoming_labelPlural = incoming.labelPlural;
      if (!(existing_labelPlural === incoming_labelPlural)) {
        return false;
      }
      const existing_objectInfoUrl = existing.objectInfoUrl;
      const incoming_objectInfoUrl = incoming.objectInfoUrl;
      if (!(existing_objectInfoUrl === incoming_objectInfoUrl)) {
        return false;
      }
      const existing_keyPrefix = existing.keyPrefix;
      const incoming_keyPrefix = incoming.keyPrefix;
      if (!(existing_keyPrefix === incoming_keyPrefix)) {
        return false;
      }
      const existing_nameFields = existing.nameFields;
      const incoming_nameFields = incoming.nameFields;
      const equals_nameFields_items = equalsArray(existing_nameFields, incoming_nameFields, (existing_nameFields_item, incoming_nameFields_item) => {
        if (!(existing_nameFields_item === incoming_nameFields_item)) {
          return false;
        }
      });
      if (equals_nameFields_items === false) {
        return false;
      }
      return true;
    }
    const ingest$D = function ObjectInfoDirectoryEntryRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1z(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$t(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$D, "UiApi", VERSION$12, RepresentationType$K, equals$U);
      return createLink(key);
    };
    function getTypeCacheKeys$L(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$t(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$K,
        mergeable: false
      });
    }
    const VERSION$11 = "37fd8c0154ee743c9defbf03e9b4b067";
    function validate$1y(obj, path = 'ObjectInfoDirectoryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_objects = obj.objects;
        const path_objects = path + '.objects';
        if (typeof obj_objects !== 'object' || ArrayIsArray(obj_objects) || obj_objects === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_objects + '" (at "' + path_objects + '")');
        }
        const obj_objects_keys = ObjectKeys(obj_objects);
        for (let i = 0; i < obj_objects_keys.length; i++) {
          const key = obj_objects_keys[i];
          const obj_objects_prop = obj_objects[key];
          const path_objects_prop = path_objects + '["' + key + '"]';
          if (typeof obj_objects_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_objects_prop + '" (at "' + path_objects_prop + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$J = 'ObjectInfoDirectoryRepresentation';
    function normalize$C(input, existing, path, luvio, store, timestamp) {
      const input_objects = input.objects;
      const input_objects_id = path.fullPath + '__objects';
      const input_objects_keys = Object.keys(input_objects);
      const input_objects_length = input_objects_keys.length;
      for (let i = 0; i < input_objects_length; i++) {
        const key = input_objects_keys[i];
        const input_objects_prop = input_objects[key];
        const input_objects_prop_id = input_objects_id + '__' + key;
        input_objects[key] = ingest$D(input_objects_prop, {
          fullPath: input_objects_prop_id,
          propertyName: key,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1G = function ObjectInfoDirectoryRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$11,
        private: [],
        selections: [{
          name: 'objects',
          kind: 'Link',
          map: true,
          fragment: select$1H()
        }]
      };
    };
    function equals$T(existing, incoming) {
      const existing_objects = existing.objects;
      const incoming_objects = incoming.objects;
      const equals_objects_props = equalsObject(existing_objects, incoming_objects, (existing_objects_prop, incoming_objects_prop) => {
        if (!(existing_objects_prop.__ref === incoming_objects_prop.__ref)) {
          return false;
        }
      });
      if (equals_objects_props === false) {
        return false;
      }
      return true;
    }
    const ingest$C = function ObjectInfoDirectoryRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1y(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$C, "UiApi", VERSION$11, RepresentationType$J, equals$T);
      return createLink(key);
    };
    function getTypeCacheKeys$K(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$J,
        mergeable: false
      });
      const input_objects = input.objects;
      const input_objects_keys = ObjectKeys(input_objects);
      const input_objects_length = input_objects_keys.length;
      for (let i = 0; i < input_objects_length; i++) {
        const key = input_objects_keys[i];
        getTypeCacheKeys$L(rootKeySet, luvio, input_objects[key]);
      }
    }
    const VERSION$10 = "7e00c51105cbf56a79ab8fcddf462c1e";
    function validate$1x(obj, path = 'QuickActionExecutionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contextId = obj.contextId;
        const path_contextId = path + '.contextId';
        let obj_contextId_union0 = null;
        const obj_contextId_union0_error = (() => {
          if (typeof obj_contextId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_contextId + '" (at "' + path_contextId + '")');
          }
        })();
        if (obj_contextId_union0_error != null) {
          obj_contextId_union0 = obj_contextId_union0_error.message;
        }
        let obj_contextId_union1 = null;
        const obj_contextId_union1_error = (() => {
          if (obj_contextId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_contextId + '" (at "' + path_contextId + '")');
          }
        })();
        if (obj_contextId_union1_error != null) {
          obj_contextId_union1 = obj_contextId_union1_error.message;
        }
        if (obj_contextId_union0 && obj_contextId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_contextId + '")';
          message += '\n' + obj_contextId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_contextId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_feedItemId = obj.feedItemId;
        const path_feedItemId = path + '.feedItemId';
        let obj_feedItemId_union0 = null;
        const obj_feedItemId_union0_error = (() => {
          if (typeof obj_feedItemId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_feedItemId + '" (at "' + path_feedItemId + '")');
          }
        })();
        if (obj_feedItemId_union0_error != null) {
          obj_feedItemId_union0 = obj_feedItemId_union0_error.message;
        }
        let obj_feedItemId_union1 = null;
        const obj_feedItemId_union1_error = (() => {
          if (obj_feedItemId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_feedItemId + '" (at "' + path_feedItemId + '")');
          }
        })();
        if (obj_feedItemId_union1_error != null) {
          obj_feedItemId_union1 = obj_feedItemId_union1_error.message;
        }
        if (obj_feedItemId_union0 && obj_feedItemId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_feedItemId + '")';
          message += '\n' + obj_feedItemId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_feedItemId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_isCreated = obj.isCreated;
        const path_isCreated = path + '.isCreated';
        if (typeof obj_isCreated !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isCreated + '" (at "' + path_isCreated + '")');
        }
        const obj_isSuccess = obj.isSuccess;
        const path_isSuccess = path + '.isSuccess';
        if (typeof obj_isSuccess !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isSuccess + '" (at "' + path_isSuccess + '")');
        }
        const obj_successMessage = obj.successMessage;
        const path_successMessage = path + '.successMessage';
        if (typeof obj_successMessage !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_successMessage + '" (at "' + path_successMessage + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$I = 'QuickActionExecutionRepresentation';
    function keyBuilder$1R(luvio, config) {
      return keyPrefix + '::' + RepresentationType$I + ':' + config.id;
    }
    function keyBuilderFromType$s(luvio, object) {
      const keyParams = {
        id: object.id
      };
      return keyBuilder$1R(luvio, keyParams);
    }
    function normalize$B(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1F = function QuickActionExecutionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$10,
        private: ['eTag'],
        selections: [{
          name: 'contextId',
          kind: 'Scalar'
        }, {
          name: 'feedItemId',
          kind: 'Scalar'
        }, {
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'isCreated',
          kind: 'Scalar'
        }, {
          name: 'isSuccess',
          kind: 'Scalar'
        }, {
          name: 'successMessage',
          kind: 'Scalar'
        }]
      };
    };
    function equals$S(existing, incoming) {
      const existing_isCreated = existing.isCreated;
      const incoming_isCreated = incoming.isCreated;
      if (!(existing_isCreated === incoming_isCreated)) {
        return false;
      }
      const existing_isSuccess = existing.isSuccess;
      const incoming_isSuccess = incoming.isSuccess;
      if (!(existing_isSuccess === incoming_isSuccess)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_successMessage = existing.successMessage;
      const incoming_successMessage = incoming.successMessage;
      if (!(existing_successMessage === incoming_successMessage)) {
        return false;
      }
      const existing_contextId = existing.contextId;
      const incoming_contextId = incoming.contextId;
      if (!(existing_contextId === incoming_contextId)) {
        return false;
      }
      const existing_feedItemId = existing.feedItemId;
      const incoming_feedItemId = incoming.feedItemId;
      if (!(existing_feedItemId === incoming_feedItemId)) {
        return false;
      }
      return true;
    }
    const ingest$B = function QuickActionExecutionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1x(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$s(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$B, "UiApi", VERSION$10, RepresentationType$I, equals$S);
      return createLink(key);
    };
    function getTypeCacheKeys$J(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$s(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$I,
        mergeable: false
      });
    }
    const TTL$t = 900000;
    const VERSION$$ = "993b0a7bce6056c4f57ed300ec153d9c";
    function validate$1w(obj, path = 'QuickActionDefaultsRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actionApiName = obj.actionApiName;
        const path_actionApiName = path + '.actionApiName';
        if (typeof obj_actionApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_actionApiName + '" (at "' + path_actionApiName + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray(obj_fields) || obj_fields === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
          const key = obj_fields_keys[i];
          const obj_fields_prop = obj_fields[key];
          const path_fields_prop = path_fields + '["' + key + '"]';
          if (typeof obj_fields_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
          }
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$H = 'QuickActionDefaultsRepresentation';
    function keyBuilder$1Q(luvio, config) {
      return keyPrefix + '::' + RepresentationType$H + ':' + config.actionApiName;
    }
    function keyBuilderFromType$r(luvio, object) {
      const keyParams = {
        actionApiName: object.actionApiName
      };
      return keyBuilder$1Q(luvio, keyParams);
    }
    function dynamicNormalize$4(ingestParams) {
      return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_fields = input.fields;
        const input_fields_id = path.fullPath + '__fields';
        const input_fields_keys = Object.keys(input_fields);
        const input_fields_length = input_fields_keys.length;
        for (let i = 0; i < input_fields_length; i++) {
          const key = input_fields_keys[i];
          const input_fields_prop = input_fields[key];
          const input_fields_prop_id = input_fields_id + '__' + key;
          input_fields[key] = ingestParams.fields(input_fields_prop, {
            fullPath: input_fields_prop_id,
            propertyName: key,
            parent: {
              data: input,
              key: path.fullPath,
              existing: existing
            },
            ttl: path.ttl
          }, luvio, store, timestamp);
        }
        return input;
      };
    }
    const dynamicSelect$5 = function dynamicQuickActionDefaultsRepresentationSelect(params) {
      const fieldsPathSelection = params.fields === undefined ? {
        name: 'fields',
        kind: 'Link',
        map: true,
        fragment: select$1V()
      } : params.fields;
      return {
        kind: 'Fragment',
        version: VERSION$$,
        private: ['eTag'],
        selections: [{
          name: 'actionApiName',
          kind: 'Scalar'
        }, fieldsPathSelection, {
          name: 'objectApiName',
          kind: 'Scalar'
        }]
      };
    };
    function equals$R(existing, incoming) {
      const existing_actionApiName = existing.actionApiName;
      const incoming_actionApiName = incoming.actionApiName;
      if (!(existing_actionApiName === incoming_actionApiName)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_objectApiName = existing.objectApiName;
      const incoming_objectApiName = incoming.objectApiName;
      if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
      }
      const existing_fields = existing.fields;
      const incoming_fields = incoming.fields;
      const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
          return false;
        }
      });
      if (equals_fields_props === false) {
        return false;
      }
      return true;
    }
    function getTypeCacheKeys$I(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$r(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$H,
        mergeable: false
      });
      const input_fields = input.fields;
      const input_fields_keys = ObjectKeys(input_fields);
      const input_fields_length = input_fields_keys.length;
      for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        getTypeCacheKeys$Y(rootKeySet, luvio, input_fields[key], () => rootKey + "__fields" + "__" + key);
      }
    }
    const notifyUpdateAvailableFactory = luvio => {
      return function notifyQuickActionDefaultsUpdateAvailable(configs) {
        {
          const requiredKeyParams = ['actionApiName'];
          configs.forEach(config => {
            if (false === requiredKeyParams.every(req => req in config)) {
              throw new Error(`one of the configs did not contain all required parameters: ${JSONStringify(ObjectKeys(config))}`);
            }
          });
        }
        const keys = configs.map(c => keyBuilder$1Q(luvio, c));
        return luvio.notifyStoreUpdateAvailable(keys);
      };
    };
    function toSortedStringArrayAllowEmpty(value) {
      const valueArray = isArray(value) ? value : [value];
      if (valueArray.length === 0) {
        return valueArray;
      }
      return toSortedStringArray(valueArray);
    }
    var FormFactor;
    (function (FormFactor) {
      FormFactor["Large"] = "Large";
      FormFactor["Medium"] = "Medium";
      FormFactor["Small"] = "Small";
    })(FormFactor || (FormFactor = {}));
    function coerceFormFactor(form) {
      if (form === FormFactor.Large || form === FormFactor.Medium || form === FormFactor.Small) {
        return form;
      }
      return undefined;
    }
    const VERSION$_ = "3f49d751896cf66e6e29788d8880e2cc";
    function validate$1v(obj, path = 'PlatformActionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actionListContext = obj.actionListContext;
        const path_actionListContext = path + '.actionListContext';
        if (typeof obj_actionListContext !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_actionListContext + '" (at "' + path_actionListContext + '")');
        }
        const obj_actionTarget = obj.actionTarget;
        const path_actionTarget = path + '.actionTarget';
        let obj_actionTarget_union0 = null;
        const obj_actionTarget_union0_error = (() => {
          if (typeof obj_actionTarget !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_actionTarget + '" (at "' + path_actionTarget + '")');
          }
        })();
        if (obj_actionTarget_union0_error != null) {
          obj_actionTarget_union0 = obj_actionTarget_union0_error.message;
        }
        let obj_actionTarget_union1 = null;
        const obj_actionTarget_union1_error = (() => {
          if (obj_actionTarget !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_actionTarget + '" (at "' + path_actionTarget + '")');
          }
        })();
        if (obj_actionTarget_union1_error != null) {
          obj_actionTarget_union1 = obj_actionTarget_union1_error.message;
        }
        if (obj_actionTarget_union0 && obj_actionTarget_union1) {
          let message = 'Object doesn\'t match union (at "' + path_actionTarget + '")';
          message += '\n' + obj_actionTarget_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_actionTarget_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_actionTargetType = obj.actionTargetType;
        const path_actionTargetType = path + '.actionTargetType';
        let obj_actionTargetType_union0 = null;
        const obj_actionTargetType_union0_error = (() => {
          if (typeof obj_actionTargetType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_actionTargetType + '" (at "' + path_actionTargetType + '")');
          }
        })();
        if (obj_actionTargetType_union0_error != null) {
          obj_actionTargetType_union0 = obj_actionTargetType_union0_error.message;
        }
        let obj_actionTargetType_union1 = null;
        const obj_actionTargetType_union1_error = (() => {
          if (obj_actionTargetType !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_actionTargetType + '" (at "' + path_actionTargetType + '")');
          }
        })();
        if (obj_actionTargetType_union1_error != null) {
          obj_actionTargetType_union1 = obj_actionTargetType_union1_error.message;
        }
        if (obj_actionTargetType_union0 && obj_actionTargetType_union1) {
          let message = 'Object doesn\'t match union (at "' + path_actionTargetType + '")';
          message += '\n' + obj_actionTargetType_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_actionTargetType_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_externalId = obj.externalId;
        const path_externalId = path + '.externalId';
        if (typeof obj_externalId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_externalId + '" (at "' + path_externalId + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        let obj_iconUrl_union0 = null;
        const obj_iconUrl_union0_error = (() => {
          if (typeof obj_iconUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
          }
        })();
        if (obj_iconUrl_union0_error != null) {
          obj_iconUrl_union0 = obj_iconUrl_union0_error.message;
        }
        let obj_iconUrl_union1 = null;
        const obj_iconUrl_union1_error = (() => {
          if (obj_iconUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
          }
        })();
        if (obj_iconUrl_union1_error != null) {
          obj_iconUrl_union1 = obj_iconUrl_union1_error.message;
        }
        if (obj_iconUrl_union0 && obj_iconUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_iconUrl + '")';
          message += '\n' + obj_iconUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_iconUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_isMassAction = obj.isMassAction;
        const path_isMassAction = path + '.isMassAction';
        if (typeof obj_isMassAction !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_isMassAction + '" (at "' + path_isMassAction + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_lwcComponent = obj.lwcComponent;
        const path_lwcComponent = path + '.lwcComponent';
        let obj_lwcComponent_union0 = null;
        const obj_lwcComponent_union0_error = (() => {
          if (typeof obj_lwcComponent !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lwcComponent + '" (at "' + path_lwcComponent + '")');
          }
        })();
        if (obj_lwcComponent_union0_error != null) {
          obj_lwcComponent_union0 = obj_lwcComponent_union0_error.message;
        }
        let obj_lwcComponent_union1 = null;
        const obj_lwcComponent_union1_error = (() => {
          if (obj_lwcComponent !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lwcComponent + '" (at "' + path_lwcComponent + '")');
          }
        })();
        if (obj_lwcComponent_union1_error != null) {
          obj_lwcComponent_union1 = obj_lwcComponent_union1_error.message;
        }
        if (obj_lwcComponent_union0 && obj_lwcComponent_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lwcComponent + '")';
          message += '\n' + obj_lwcComponent_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lwcComponent_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_primaryColor = obj.primaryColor;
        const path_primaryColor = path + '.primaryColor';
        let obj_primaryColor_union0 = null;
        const obj_primaryColor_union0_error = (() => {
          if (typeof obj_primaryColor !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_primaryColor + '" (at "' + path_primaryColor + '")');
          }
        })();
        if (obj_primaryColor_union0_error != null) {
          obj_primaryColor_union0 = obj_primaryColor_union0_error.message;
        }
        let obj_primaryColor_union1 = null;
        const obj_primaryColor_union1_error = (() => {
          if (obj_primaryColor !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_primaryColor + '" (at "' + path_primaryColor + '")');
          }
        })();
        if (obj_primaryColor_union1_error != null) {
          obj_primaryColor_union1 = obj_primaryColor_union1_error.message;
        }
        if (obj_primaryColor_union0 && obj_primaryColor_union1) {
          let message = 'Object doesn\'t match union (at "' + path_primaryColor + '")';
          message += '\n' + obj_primaryColor_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_primaryColor_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_relatedListRecordId = obj.relatedListRecordId;
        const path_relatedListRecordId = path + '.relatedListRecordId';
        let obj_relatedListRecordId_union0 = null;
        const obj_relatedListRecordId_union0_error = (() => {
          if (typeof obj_relatedListRecordId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relatedListRecordId + '" (at "' + path_relatedListRecordId + '")');
          }
        })();
        if (obj_relatedListRecordId_union0_error != null) {
          obj_relatedListRecordId_union0 = obj_relatedListRecordId_union0_error.message;
        }
        let obj_relatedListRecordId_union1 = null;
        const obj_relatedListRecordId_union1_error = (() => {
          if (obj_relatedListRecordId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_relatedListRecordId + '" (at "' + path_relatedListRecordId + '")');
          }
        })();
        if (obj_relatedListRecordId_union1_error != null) {
          obj_relatedListRecordId_union1 = obj_relatedListRecordId_union1_error.message;
        }
        if (obj_relatedListRecordId_union0 && obj_relatedListRecordId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_relatedListRecordId + '")';
          message += '\n' + obj_relatedListRecordId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_relatedListRecordId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_relatedSourceObject = obj.relatedSourceObject;
        const path_relatedSourceObject = path + '.relatedSourceObject';
        let obj_relatedSourceObject_union0 = null;
        const obj_relatedSourceObject_union0_error = (() => {
          if (typeof obj_relatedSourceObject !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relatedSourceObject + '" (at "' + path_relatedSourceObject + '")');
          }
        })();
        if (obj_relatedSourceObject_union0_error != null) {
          obj_relatedSourceObject_union0 = obj_relatedSourceObject_union0_error.message;
        }
        let obj_relatedSourceObject_union1 = null;
        const obj_relatedSourceObject_union1_error = (() => {
          if (obj_relatedSourceObject !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_relatedSourceObject + '" (at "' + path_relatedSourceObject + '")');
          }
        })();
        if (obj_relatedSourceObject_union1_error != null) {
          obj_relatedSourceObject_union1 = obj_relatedSourceObject_union1_error.message;
        }
        if (obj_relatedSourceObject_union0 && obj_relatedSourceObject_union1) {
          let message = 'Object doesn\'t match union (at "' + path_relatedSourceObject + '")';
          message += '\n' + obj_relatedSourceObject_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_relatedSourceObject_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_section = obj.section;
        const path_section = path + '.section';
        let obj_section_union0 = null;
        const obj_section_union0_error = (() => {
          if (typeof obj_section !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_section + '" (at "' + path_section + '")');
          }
        })();
        if (obj_section_union0_error != null) {
          obj_section_union0 = obj_section_union0_error.message;
        }
        let obj_section_union1 = null;
        const obj_section_union1_error = (() => {
          if (obj_section !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_section + '" (at "' + path_section + '")');
          }
        })();
        if (obj_section_union1_error != null) {
          obj_section_union1 = obj_section_union1_error.message;
        }
        if (obj_section_union0 && obj_section_union1) {
          let message = 'Object doesn\'t match union (at "' + path_section + '")';
          message += '\n' + obj_section_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_section_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_sourceObject = obj.sourceObject;
        const path_sourceObject = path + '.sourceObject';
        if (typeof obj_sourceObject !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_sourceObject + '" (at "' + path_sourceObject + '")');
        }
        const obj_subtype = obj.subtype;
        const path_subtype = path + '.subtype';
        let obj_subtype_union0 = null;
        const obj_subtype_union0_error = (() => {
          if (typeof obj_subtype !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_subtype + '" (at "' + path_subtype + '")');
          }
        })();
        if (obj_subtype_union0_error != null) {
          obj_subtype_union0 = obj_subtype_union0_error.message;
        }
        let obj_subtype_union1 = null;
        const obj_subtype_union1_error = (() => {
          if (obj_subtype !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_subtype + '" (at "' + path_subtype + '")');
          }
        })();
        if (obj_subtype_union1_error != null) {
          obj_subtype_union1 = obj_subtype_union1_error.message;
        }
        if (obj_subtype_union0 && obj_subtype_union1) {
          let message = 'Object doesn\'t match union (at "' + path_subtype + '")';
          message += '\n' + obj_subtype_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_subtype_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_targetObject = obj.targetObject;
        const path_targetObject = path + '.targetObject';
        let obj_targetObject_union0 = null;
        const obj_targetObject_union0_error = (() => {
          if (typeof obj_targetObject !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_targetObject + '" (at "' + path_targetObject + '")');
          }
        })();
        if (obj_targetObject_union0_error != null) {
          obj_targetObject_union0 = obj_targetObject_union0_error.message;
        }
        let obj_targetObject_union1 = null;
        const obj_targetObject_union1_error = (() => {
          if (obj_targetObject !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_targetObject + '" (at "' + path_targetObject + '")');
          }
        })();
        if (obj_targetObject_union1_error != null) {
          obj_targetObject_union1 = obj_targetObject_union1_error.message;
        }
        if (obj_targetObject_union0 && obj_targetObject_union1) {
          let message = 'Object doesn\'t match union (at "' + path_targetObject + '")';
          message += '\n' + obj_targetObject_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_targetObject_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_targetUrl = obj.targetUrl;
        const path_targetUrl = path + '.targetUrl';
        let obj_targetUrl_union0 = null;
        const obj_targetUrl_union0_error = (() => {
          if (typeof obj_targetUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_targetUrl + '" (at "' + path_targetUrl + '")');
          }
        })();
        if (obj_targetUrl_union0_error != null) {
          obj_targetUrl_union0 = obj_targetUrl_union0_error.message;
        }
        let obj_targetUrl_union1 = null;
        const obj_targetUrl_union1_error = (() => {
          if (obj_targetUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_targetUrl + '" (at "' + path_targetUrl + '")');
          }
        })();
        if (obj_targetUrl_union1_error != null) {
          obj_targetUrl_union1 = obj_targetUrl_union1_error.message;
        }
        if (obj_targetUrl_union0 && obj_targetUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_targetUrl + '")';
          message += '\n' + obj_targetUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_targetUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$G = 'PlatformActionRepresentation';
    function keyBuilder$1P(luvio, config) {
      return keyPrefix + '::' + RepresentationType$G + ':' + config.externalId + ':' + (config.relatedSourceObject === null ? '' : config.relatedSourceObject) + ':' + (config.relatedListRecordId === null ? '' : config.relatedListRecordId);
    }
    function keyBuilderFromType$q(luvio, object) {
      const keyParams = {
        externalId: object.externalId,
        relatedSourceObject: object.relatedSourceObject,
        relatedListRecordId: object.relatedListRecordId
      };
      return keyBuilder$1P(luvio, keyParams);
    }
    function normalize$A(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1E = function PlatformActionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$_,
        private: ['id'],
        selections: [{
          name: 'actionListContext',
          kind: 'Scalar'
        }, {
          name: 'actionTarget',
          kind: 'Scalar'
        }, {
          name: 'actionTargetType',
          kind: 'Scalar'
        }, {
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'externalId',
          kind: 'Scalar'
        }, {
          name: 'iconUrl',
          kind: 'Scalar'
        }, {
          name: 'isMassAction',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'lwcComponent',
          kind: 'Scalar'
        }, {
          name: 'primaryColor',
          kind: 'Scalar'
        }, {
          name: 'relatedListRecordId',
          kind: 'Scalar'
        }, {
          name: 'relatedSourceObject',
          kind: 'Scalar'
        }, {
          name: 'section',
          kind: 'Scalar'
        }, {
          name: 'sourceObject',
          kind: 'Scalar'
        }, {
          name: 'subtype',
          kind: 'Scalar'
        }, {
          name: 'targetObject',
          kind: 'Scalar'
        }, {
          name: 'targetUrl',
          kind: 'Scalar'
        }, {
          name: 'type',
          kind: 'Scalar'
        }]
      };
    };
    function equals$Q(existing, incoming) {
      const existing_actionListContext = existing.actionListContext;
      const incoming_actionListContext = incoming.actionListContext;
      if (!(existing_actionListContext === incoming_actionListContext)) {
        return false;
      }
      const existing_apiName = existing.apiName;
      const incoming_apiName = incoming.apiName;
      if (!(existing_apiName === incoming_apiName)) {
        return false;
      }
      const existing_externalId = existing.externalId;
      const incoming_externalId = incoming.externalId;
      if (!(existing_externalId === incoming_externalId)) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_isMassAction = existing.isMassAction;
      const incoming_isMassAction = incoming.isMassAction;
      if (!(existing_isMassAction === incoming_isMassAction)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      const existing_sourceObject = existing.sourceObject;
      const incoming_sourceObject = incoming.sourceObject;
      if (!(existing_sourceObject === incoming_sourceObject)) {
        return false;
      }
      const existing_type = existing.type;
      const incoming_type = incoming.type;
      if (!(existing_type === incoming_type)) {
        return false;
      }
      const existing_actionTarget = existing.actionTarget;
      const incoming_actionTarget = incoming.actionTarget;
      if (!(existing_actionTarget === incoming_actionTarget)) {
        return false;
      }
      const existing_actionTargetType = existing.actionTargetType;
      const incoming_actionTargetType = incoming.actionTargetType;
      if (!(existing_actionTargetType === incoming_actionTargetType)) {
        return false;
      }
      const existing_iconUrl = existing.iconUrl;
      const incoming_iconUrl = incoming.iconUrl;
      if (!(existing_iconUrl === incoming_iconUrl)) {
        return false;
      }
      const existing_lwcComponent = existing.lwcComponent;
      const incoming_lwcComponent = incoming.lwcComponent;
      if (!(existing_lwcComponent === incoming_lwcComponent)) {
        return false;
      }
      const existing_primaryColor = existing.primaryColor;
      const incoming_primaryColor = incoming.primaryColor;
      if (!(existing_primaryColor === incoming_primaryColor)) {
        return false;
      }
      const existing_relatedListRecordId = existing.relatedListRecordId;
      const incoming_relatedListRecordId = incoming.relatedListRecordId;
      if (!(existing_relatedListRecordId === incoming_relatedListRecordId)) {
        return false;
      }
      const existing_relatedSourceObject = existing.relatedSourceObject;
      const incoming_relatedSourceObject = incoming.relatedSourceObject;
      if (!(existing_relatedSourceObject === incoming_relatedSourceObject)) {
        return false;
      }
      const existing_section = existing.section;
      const incoming_section = incoming.section;
      if (!(existing_section === incoming_section)) {
        return false;
      }
      const existing_subtype = existing.subtype;
      const incoming_subtype = incoming.subtype;
      if (!(existing_subtype === incoming_subtype)) {
        return false;
      }
      const existing_targetObject = existing.targetObject;
      const incoming_targetObject = incoming.targetObject;
      if (!(existing_targetObject === incoming_targetObject)) {
        return false;
      }
      const existing_targetUrl = existing.targetUrl;
      const incoming_targetUrl = incoming.targetUrl;
      if (!(existing_targetUrl === incoming_targetUrl)) {
        return false;
      }
      return true;
    }
    const ingest$A = function PlatformActionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1v(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$q(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$A, "UiApi", VERSION$_, RepresentationType$G, equals$Q);
      return createLink(key);
    };
    function getTypeCacheKeys$H(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$q(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$G,
        mergeable: false
      });
    }
    const VERSION$Z = "378d506f563a4bd724b322d440df33d1";
    function validate$1u(obj, path = 'EntityActionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actions = obj.actions;
        const path_actions = path + '.actions';
        if (!ArrayIsArray(obj_actions)) {
          return new TypeError('Expected "array" but received "' + typeof obj_actions + '" (at "' + path_actions + '")');
        }
        for (let i = 0; i < obj_actions.length; i++) {
          const obj_actions_item = obj_actions[i];
          const path_actions_item = path_actions + '[' + i + ']';
          if (typeof obj_actions_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_actions_item + '" (at "' + path_actions_item + '")');
          }
        }
        const obj_links = obj.links;
        const path_links = path + '.links';
        if (!ArrayIsArray(obj_links)) {
          return new TypeError('Expected "array" but received "' + typeof obj_links + '" (at "' + path_links + '")');
        }
        for (let i = 0; i < obj_links.length; i++) {
          const obj_links_item = obj_links[i];
          const path_links_item = path_links + '[' + i + ']';
          if (typeof obj_links_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_links_item + '" (at "' + path_links_item + '")');
          }
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$F = 'EntityActionRepresentation';
    function keyBuilder$1O(luvio, config) {
      return keyPrefix + '::' + RepresentationType$F + ':' + config.url;
    }
    function keyBuilderFromType$p(luvio, object) {
      const keyParams = {
        url: object.url
      };
      return keyBuilder$1O(luvio, keyParams);
    }
    function normalize$z(input, existing, path, luvio, store, timestamp) {
      const input_actions = input.actions;
      const input_actions_id = path.fullPath + '__actions';
      for (let i = 0; i < input_actions.length; i++) {
        const input_actions_item = input_actions[i];
        let input_actions_item_id = input_actions_id + '__' + i;
        input_actions[i] = ingest$A(input_actions_item, {
          fullPath: input_actions_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1D = function EntityActionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$Z,
        private: ['links', 'url'],
        selections: [{
          name: 'actions',
          kind: 'Link',
          plural: true,
          fragment: select$1E()
        }]
      };
    };
    function equals$P(existing, incoming) {
      const existing_url = existing.url;
      const incoming_url = incoming.url;
      if (!(existing_url === incoming_url)) {
        return false;
      }
      const existing_actions = existing.actions;
      const incoming_actions = incoming.actions;
      const equals_actions_items = equalsArray(existing_actions, incoming_actions, (existing_actions_item, incoming_actions_item) => {
        if (!(existing_actions_item.__ref === incoming_actions_item.__ref)) {
          return false;
        }
      });
      if (equals_actions_items === false) {
        return false;
      }
      const existing_links = existing.links;
      const incoming_links = incoming.links;
      const equals_links_items = equalsArray(existing_links, incoming_links, (existing_links_item, incoming_links_item) => {
        if (!(existing_links_item === incoming_links_item)) {
          return false;
        }
      });
      if (equals_links_items === false) {
        return false;
      }
      return true;
    }
    const ingest$z = function EntityActionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1u(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$p(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$z, "UiApi", VERSION$Z, RepresentationType$F, equals$P);
      return createLink(key);
    };
    function getTypeCacheKeys$G(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$p(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$F,
        mergeable: false
      });
      const input_actions_length = input.actions.length;
      for (let i = 0; i < input_actions_length; i++) {
        getTypeCacheKeys$H(rootKeySet, luvio, input.actions[i]);
      }
    }
    const TTL$s = 300000;
    const VERSION$Y = "e485d96c1402a9ca2f56e56485af0216";
    function validate$1t(obj, path = 'ActionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actions = obj.actions;
        const path_actions = path + '.actions';
        if (typeof obj_actions !== 'object' || ArrayIsArray(obj_actions) || obj_actions === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_actions + '" (at "' + path_actions + '")');
        }
        const obj_actions_keys = ObjectKeys(obj_actions);
        for (let i = 0; i < obj_actions_keys.length; i++) {
          const key = obj_actions_keys[i];
          const obj_actions_prop = obj_actions[key];
          const path_actions_prop = path_actions + '["' + key + '"]';
          if (typeof obj_actions_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_actions_prop + '" (at "' + path_actions_prop + '")');
          }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$E = 'ActionRepresentation';
    function normalize$y(input, existing, path, luvio, store, timestamp) {
      const input_actions = input.actions;
      const input_actions_id = path.fullPath + '__actions';
      const input_actions_keys = Object.keys(input_actions);
      const input_actions_length = input_actions_keys.length;
      for (let i = 0; i < input_actions_length; i++) {
        const key = input_actions_keys[i];
        const input_actions_prop = input_actions[key];
        const input_actions_prop_id = input_actions_id + '__' + key;
        input_actions[key] = ingest$z(input_actions_prop, {
          fullPath: input_actions_prop_id,
          propertyName: key,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1C = function ActionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$Y,
        private: ['eTag', 'url'],
        selections: [{
          name: 'actions',
          kind: 'Link',
          map: true,
          fragment: select$1D()
        }]
      };
    };
    function equals$O(existing, incoming) {
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_url = existing.url;
      const incoming_url = incoming.url;
      if (!(existing_url === incoming_url)) {
        return false;
      }
      const existing_actions = existing.actions;
      const incoming_actions = incoming.actions;
      const equals_actions_props = equalsObject(existing_actions, incoming_actions, (existing_actions_prop, incoming_actions_prop) => {
        if (!(existing_actions_prop.__ref === incoming_actions_prop.__ref)) {
          return false;
        }
      });
      if (equals_actions_props === false) {
        return false;
      }
      return true;
    }
    const ingest$y = function ActionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1t(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$s;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$y, "UiApi", VERSION$Y, RepresentationType$E, equals$O);
      return createLink(key);
    };
    function getTypeCacheKeys$F(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$E,
        mergeable: false
      });
      const input_actions = input.actions;
      const input_actions_keys = ObjectKeys(input_actions);
      const input_actions_length = input_actions_keys.length;
      for (let i = 0; i < input_actions_length; i++) {
        const key = input_actions_keys[i];
        getTypeCacheKeys$G(rootKeySet, luvio, input_actions[key]);
      }
    }
    function select$1B(luvio, params) {
      return select$1C();
    }
    function keyBuilder$1N(luvio, params) {
      return keyPrefix + '::ActionRepresentation:(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'apiNames:' + params.queryParams.apiNames + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'retrievalMode:' + params.queryParams.retrievalMode + ',' + 'sections:' + params.queryParams.sections + ')';
    }
    function getResponseCacheKeys$Z(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$F(storeKeyMap, luvio, response, () => keyBuilder$1N(luvio, resourceParams));
    }
    function ingestSuccess$O(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1N(luvio, resourceParams);
      luvio.storeIngest(key, ingest$y, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1B(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$H(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1N(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$s,
        namespace: keyPrefix,
        version: VERSION$Y,
        representationName: RepresentationType$E
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$10(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/global',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$Z = 'getGlobalActions';
    const getGlobalActions_ConfigPropertyMetadata = [generateParamConfigMetadata('actionTypes', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('apiNames', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArrayAllowEmpty), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */, false, coerceFormFactor), generateParamConfigMetadata('retrievalMode', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('sections', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray)];
    const getGlobalActions_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$Z, getGlobalActions_ConfigPropertyMetadata);
    const createResourceParams$X = /*#__PURE__*/luvioEngine.createResourceParams(getGlobalActions_ConfigPropertyMetadata);
    function keyBuilder$1M(luvio, config) {
      const resourceParams = createResourceParams$X(config);
      return keyBuilder$1N(luvio, resourceParams);
    }
    function typeCheckConfig$11(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getGlobalActions_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$13(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getGlobalActions_ConfigPropertyMetadata);
      const config = typeCheckConfig$11(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$G(luvio, config) {
      createResourceParams$X(config);
      return select$1B();
    }
    function onFetchResponseSuccess$J(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$O(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$10(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$K(luvio, config, resourceParams, response) {
      const snapshot = ingestError$H(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$10(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$10(luvio, config, options) {
      const resourceParams = createResourceParams$X(config);
      const request = createResourceRequest$10(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$J(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$Z(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$K(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$O(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$10, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$N(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1M(luvio, config),
        node: adapterFragment$G(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$10(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getGlobalActionsAdapterFactory = luvio => function UiApi__getGlobalActions(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$13(untrustedConfig, getGlobalActions_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$N, buildNetworkSnapshotCachePolicy$O);
    };
    const TTL$r = 900000;
    const VERSION$X = "35f3eec8ce7f6001c6d5d17821b75bb9";
    function validate$1s(obj, path = 'QuickActionLayoutRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actionApiName = obj.actionApiName;
        const path_actionApiName = path + '.actionApiName';
        if (typeof obj_actionApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_actionApiName + '" (at "' + path_actionApiName + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_layout = obj.layout;
        const path_layout = path + '.layout';
        const referencepath_layoutValidationError = validate$1D(obj_layout, path_layout);
        if (referencepath_layoutValidationError !== null) {
          let message = 'Object doesn\'t match RecordLayoutRepresentation (at "' + path_layout + '")\n';
          message += referencepath_layoutValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$D = 'QuickActionLayoutRepresentation';
    function keyBuilder$1L(luvio, config) {
      return keyPrefix + '::' + RepresentationType$D + ':' + config.actionApiName;
    }
    function keyBuilderFromType$o(luvio, object) {
      const keyParams = {
        actionApiName: object.actionApiName
      };
      return keyBuilder$1L(luvio, keyParams);
    }
    function normalize$x(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1A = function QuickActionLayoutRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$X,
        private: ['eTag'],
        selections: [{
          name: 'actionApiName',
          kind: 'Scalar'
        }, {
          name: 'layout',
          kind: 'Object',
          opaque: true
        }]
      };
    };
    function equals$N(existing, incoming) {
      if (existing.eTag !== incoming.eTag) {
        return false;
      }
      return true;
    }
    const ingest$x = function QuickActionLayoutRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1s(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$o(luvio, input);
      const ttlToUse = TTL$r;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$x, "UiApi", VERSION$X, RepresentationType$D, equals$N);
      return createLink(key);
    };
    function getTypeCacheKeys$E(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$o(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$D,
        mergeable: false
      });
    }
    function select$1z(luvio, params) {
      return select$1A();
    }
    function keyBuilder$1K(luvio, params) {
      return keyBuilder$1L(luvio, {
        actionApiName: params.urlParams.actionApiName
      });
    }
    function getResponseCacheKeys$Y(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$E(storeKeyMap, luvio, response);
    }
    function ingestSuccess$N(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1K(luvio, resourceParams);
      luvio.storeIngest(key, ingest$x, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1z(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$G(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1K(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$r,
        namespace: keyPrefix,
        version: VERSION$X,
        representationName: RepresentationType$D
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$$(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/layout/' + config.urlParams.actionApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$Y = 'getQuickActionLayout';
    const getQuickActionLayout_ConfigPropertyMetadata = [generateParamConfigMetadata('actionApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('objectApiName', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */)];
    const getQuickActionLayout_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$Y, getQuickActionLayout_ConfigPropertyMetadata);
    const createResourceParams$W = /*#__PURE__*/luvioEngine.createResourceParams(getQuickActionLayout_ConfigPropertyMetadata);
    function keyBuilder$1J(luvio, config) {
      const resourceParams = createResourceParams$W(config);
      return keyBuilder$1K(luvio, resourceParams);
    }
    function typeCheckConfig$10(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getQuickActionLayout_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$12(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$10(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$F(luvio, config) {
      createResourceParams$W(config);
      return select$1z();
    }
    function onFetchResponseSuccess$I(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$N(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$$(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$J(luvio, config, resourceParams, response) {
      const snapshot = ingestError$G(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$$(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$$(luvio, config, options) {
      const resourceParams = createResourceParams$W(config);
      const request = createResourceRequest$$(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$I(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$Y(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$J(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$N(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$$, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$M(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1J(luvio, config),
        node: adapterFragment$F(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$$(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getQuickActionLayoutAdapterFactory = luvio => function UiApi__getQuickActionLayout(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$12(untrustedConfig, getQuickActionLayout_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$M, buildNetworkSnapshotCachePolicy$N);
    };

    /**
     * Returns the object API name.
     * @param value The value from which to get the object API name.
     * @returns The object API name.
     */
    function getObjectApiNamesArray(value) {
      const valueArray = isArray(value) ? value : [value];
      const array = [];
      for (let i = 0, len = valueArray.length; i < len; i += 1) {
        const item = valueArray[i];
        const apiName = getObjectApiName$1(item);
        if (apiName === undefined) {
          return undefined;
        }
        push.call(array, apiName);
      }
      if (array.length === 0) {
        return undefined;
      }
      return dedupe(array);
    }

    /**
     * Returns the object API name.
     * @param value The value from which to get the object API name.
     * @returns The object API name.
     */
    function getSortedObjectApiNamesArray(value) {
      const unsortedArray = getObjectApiNamesArray(value);
      return unsortedArray === undefined ? undefined : unsortedArray.sort();
    }
    function select$1y(luvio, params) {
      return select$1C();
    }
    function keyBuilder$1I(luvio, params) {
      return keyPrefix + '::ActionRepresentation:(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'objectApiNames:' + params.urlParams.objectApiNames + ')';
    }
    function getResponseCacheKeys$X(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$F(storeKeyMap, luvio, response, () => keyBuilder$1I(luvio, resourceParams));
    }
    function ingestSuccess$M(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1I(luvio, resourceParams);
      luvio.storeIngest(key, ingest$y, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1y(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$F(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1I(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$s,
        namespace: keyPrefix,
        version: VERSION$Y,
        representationName: RepresentationType$E
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$_(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/lookup/' + config.urlParams.objectApiNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$X = 'getLookupActions';
    const getLookupActions_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiNames', true, 0 /* UrlParameter */, 0 /* String */, true, getSortedObjectApiNamesArray), generateParamConfigMetadata('actionTypes', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */, false, coerceFormFactor), generateParamConfigMetadata('sections', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray)];
    const getLookupActions_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$X, getLookupActions_ConfigPropertyMetadata);
    const createResourceParams$V = /*#__PURE__*/luvioEngine.createResourceParams(getLookupActions_ConfigPropertyMetadata);
    function keyBuilder$1H(luvio, config) {
      const resourceParams = createResourceParams$V(config);
      return keyBuilder$1I(luvio, resourceParams);
    }
    function typeCheckConfig$$(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getLookupActions_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$11(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getLookupActions_ConfigPropertyMetadata);
      const config = typeCheckConfig$$(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$E(luvio, config) {
      createResourceParams$V(config);
      return select$1y();
    }
    function onFetchResponseSuccess$H(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$M(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$_(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$I(luvio, config, resourceParams, response) {
      const snapshot = ingestError$F(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$_(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$_(luvio, config, options) {
      const resourceParams = createResourceParams$V(config);
      const request = createResourceRequest$_(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$H(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$X(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$I(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$M(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$_, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$L(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1H(luvio, config),
        node: adapterFragment$E(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$_(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getLookupActionsAdapterFactory = luvio => function UiApi__getLookupActions(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$11(untrustedConfig, getLookupActions_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$L, buildNetworkSnapshotCachePolicy$M);
    };
    function select$1x(luvio, params) {
      return select$1C();
    }
    function keyBuilder$1G(luvio, params) {
      return keyPrefix + '::ActionRepresentation:(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'objectApiName:' + params.urlParams.objectApiName + ')';
    }
    function getResponseCacheKeys$W(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$F(storeKeyMap, luvio, response, () => keyBuilder$1G(luvio, resourceParams));
    }
    function ingestSuccess$L(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1G(luvio, resourceParams);
      luvio.storeIngest(key, ingest$y, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1x(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$E(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1G(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$s,
        namespace: keyPrefix,
        version: VERSION$Y,
        representationName: RepresentationType$E
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$Z(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/object/' + config.urlParams.objectApiName + '/record-create',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$W = 'getObjectCreateActions';
    const getObjectCreateActions_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('actionTypes', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */, false, coerceFormFactor), generateParamConfigMetadata('sections', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray)];
    const getObjectCreateActions_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$W, getObjectCreateActions_ConfigPropertyMetadata);
    const createResourceParams$U = /*#__PURE__*/luvioEngine.createResourceParams(getObjectCreateActions_ConfigPropertyMetadata);
    function keyBuilder$1F(luvio, config) {
      const resourceParams = createResourceParams$U(config);
      return keyBuilder$1G(luvio, resourceParams);
    }
    function typeCheckConfig$_(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getObjectCreateActions_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$10(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getObjectCreateActions_ConfigPropertyMetadata);
      const config = typeCheckConfig$_(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$D(luvio, config) {
      createResourceParams$U(config);
      return select$1x();
    }
    function onFetchResponseSuccess$G(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$L(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$Z(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$H(luvio, config, resourceParams, response) {
      const snapshot = ingestError$E(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$Z(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$Z(luvio, config, options) {
      const resourceParams = createResourceParams$U(config);
      const request = createResourceRequest$Z(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$G(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$W(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$H(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$L(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$Z, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$K(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1F(luvio, config),
        node: adapterFragment$D(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$Z(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getObjectCreateActionsAdapterFactory = luvio => function UiApi__getObjectCreateActions(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$10(untrustedConfig, getObjectCreateActions_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$K, buildNetworkSnapshotCachePolicy$L);
    };
    const VERSION$W = "fecd80e9e24a1c1e75fd5395cd34ff2e";
    function validate$1r(obj, path = 'ActionOverrideRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (typeof obj_records !== 'object' || ArrayIsArray(obj_records) || obj_records === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$C = 'ActionOverrideRepresentation';
    function normalize$w(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1w = function ActionOverrideRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$W,
        private: [],
        opaque: true
      };
    };
    function equals$M(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$w = function ActionOverrideRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1r(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$w, "UiApi", VERSION$W, RepresentationType$C, equals$M);
      return createLink(key);
    };
    function getTypeCacheKeys$D(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$C,
        mergeable: false
      });
    }
    function select$1v(luvio, params) {
      return select$1w();
    }
    function keyBuilder$1E(luvio, params) {
      return keyPrefix + '::ActionOverrideRepresentation:(' + 'type:' + params.queryParams.type + ',' + 'defaultTemplateOnly:' + params.queryParams.defaultTemplateOnly + ',' + 'objectApiName:' + params.urlParams.objectApiName + ')';
    }
    function getResponseCacheKeys$V(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$D(storeKeyMap, luvio, response, () => keyBuilder$1E(luvio, resourceParams));
    }
    function ingestSuccess$K(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1E(luvio, resourceParams);
      luvio.storeIngest(key, ingest$w, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1v(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$D(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1E(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$Y(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/overrides/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$V = 'getActionOverrides';
    const getActionOverrides_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('type', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('defaultTemplateOnly', false, 1 /* QueryParameter */, 1 /* Boolean */)];
    const getActionOverrides_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$V, getActionOverrides_ConfigPropertyMetadata);
    const createResourceParams$T = /*#__PURE__*/luvioEngine.createResourceParams(getActionOverrides_ConfigPropertyMetadata);
    function keyBuilder$1D(luvio, config) {
      const resourceParams = createResourceParams$T(config);
      return keyBuilder$1E(luvio, resourceParams);
    }
    function typeCheckConfig$Z(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getActionOverrides_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$$(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getActionOverrides_ConfigPropertyMetadata);
      const config = typeCheckConfig$Z(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$C(luvio, config) {
      createResourceParams$T(config);
      return select$1v();
    }
    function onFetchResponseSuccess$F(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$K(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$Y(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$G(luvio, config, resourceParams, response) {
      const snapshot = ingestError$D(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$Y(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$Y(luvio, config, options) {
      const resourceParams = createResourceParams$T(config);
      const request = createResourceRequest$Y(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$F(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$V(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$G(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$K(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$Y, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$J(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1D(luvio, config),
        node: adapterFragment$C(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$Y(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getActionOverridesAdapterFactory = luvio => function UiApi__getActionOverrides(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$$(untrustedConfig, getActionOverrides_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$J, buildNetworkSnapshotCachePolicy$K);
    };
    function validate$1q(obj, path = 'FormulaOverridesInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldNames = obj.fieldNames;
        const path_fieldNames = path + '.fieldNames';
        if (!ArrayIsArray(obj_fieldNames)) {
          return new TypeError('Expected "array" but received "' + typeof obj_fieldNames + '" (at "' + path_fieldNames + '")');
        }
        for (let i = 0; i < obj_fieldNames.length; i++) {
          const obj_fieldNames_item = obj_fieldNames[i];
          const path_fieldNames_item = path_fieldNames + '[' + i + ']';
          if (typeof obj_fieldNames_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldNames_item + '" (at "' + path_fieldNames_item + '")');
          }
        }
        const obj_flexipageName = obj.flexipageName;
        const path_flexipageName = path + '.flexipageName';
        if (typeof obj_flexipageName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_flexipageName + '" (at "' + path_flexipageName + '")');
        }
        const obj_jsFormula = obj.jsFormula;
        const path_jsFormula = path + '.jsFormula';
        if (typeof obj_jsFormula !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_jsFormula + '" (at "' + path_jsFormula + '")');
        }
        const obj_order = obj.order;
        const path_order = path + '.order';
        if (typeof obj_order !== 'number' || typeof obj_order === 'number' && Math.floor(obj_order) !== obj_order) {
          return new TypeError('Expected "integer" but received "' + typeof obj_order + '" (at "' + path_order + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$q = 300000;
    const VERSION$V = "c57b66c259b23683db7b763e132e8633";
    function validate$1p(obj, path = 'FlexipageFormulaActivationRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_activations = obj.activations;
        const path_activations = path + '.activations';
        if (typeof obj_activations !== 'object' || ArrayIsArray(obj_activations) || obj_activations === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_activations + '" (at "' + path_activations + '")');
        }
        const obj_activations_keys = ObjectKeys(obj_activations);
        for (let i = 0; i < obj_activations_keys.length; i++) {
          const key = obj_activations_keys[i];
          const obj_activations_prop = obj_activations[key];
          const path_activations_prop = path_activations + '["' + key + '"]';
          if (!ArrayIsArray(obj_activations_prop)) {
            return new TypeError('Expected "array" but received "' + typeof obj_activations_prop + '" (at "' + path_activations_prop + '")');
          }
          for (let i = 0; i < obj_activations_prop.length; i++) {
            const obj_activations_prop_item = obj_activations_prop[i];
            const path_activations_prop_item = path_activations_prop + '[' + i + ']';
            const referencepath_activations_prop_itemValidationError = validate$1q(obj_activations_prop_item, path_activations_prop_item);
            if (referencepath_activations_prop_itemValidationError !== null) {
              let message = 'Object doesn\'t match FormulaOverridesInfoRepresentation (at "' + path_activations_prop_item + '")\n';
              message += referencepath_activations_prop_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
              return new TypeError(message);
            }
          }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$B = 'FlexipageFormulaActivationRepresentation';
    function normalize$v(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1u = function FlexipageFormulaActivationRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$V,
        private: ['eTag'],
        selections: [{
          name: 'activations',
          kind: 'Object',
          opaque: true
        }]
      };
    };
    function equals$L(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$v = function FlexipageFormulaActivationRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1p(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$q;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$v, "UiApi", VERSION$V, RepresentationType$B, equals$L);
      return createLink(key);
    };
    function getTypeCacheKeys$C(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$B,
        mergeable: false
      });
    }
    function select$1t(luvio, params) {
      return select$1u();
    }
    function keyBuilder$1C(luvio, params) {
      return keyPrefix + '::FlexipageFormulaActivationRepresentation:(' + 'application:' + params.queryParams.application + ',' + 'objectApiNames:' + params.queryParams.objectApiNames + ',' + 'actionFeature:' + params.urlParams.actionFeature + ')';
    }
    function getResponseCacheKeys$U(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$C(storeKeyMap, luvio, response, () => keyBuilder$1C(luvio, resourceParams));
    }
    function ingestSuccess$J(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1C(luvio, resourceParams);
      luvio.storeIngest(key, ingest$v, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1t(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$C(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1C(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$q,
        namespace: keyPrefix,
        version: VERSION$V,
        representationName: RepresentationType$B
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$X(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/formula-activation/' + config.urlParams.actionFeature + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$U = 'getFlexipageFormulaOverrides';
    const getFlexipageFormulaOverrides_ConfigPropertyMetadata = [generateParamConfigMetadata('actionFeature', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('application', false, 1 /* QueryParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('objectApiNames', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray)];
    const getFlexipageFormulaOverrides_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$U, getFlexipageFormulaOverrides_ConfigPropertyMetadata);
    const createResourceParams$S = /*#__PURE__*/luvioEngine.createResourceParams(getFlexipageFormulaOverrides_ConfigPropertyMetadata);
    function keyBuilder$1B(luvio, config) {
      const resourceParams = createResourceParams$S(config);
      return keyBuilder$1C(luvio, resourceParams);
    }
    function typeCheckConfig$Y(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getFlexipageFormulaOverrides_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$_(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getFlexipageFormulaOverrides_ConfigPropertyMetadata);
      const config = typeCheckConfig$Y(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$B(luvio, config) {
      createResourceParams$S(config);
      return select$1t();
    }
    function onFetchResponseSuccess$E(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$J(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$X(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$F(luvio, config, resourceParams, response) {
      const snapshot = ingestError$C(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$X(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$X(luvio, config, options) {
      const resourceParams = createResourceParams$S(config);
      const request = createResourceRequest$X(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$E(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$U(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$F(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$J(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$X, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$I(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1B(luvio, config),
        node: adapterFragment$B(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$X(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getFlexipageFormulaOverridesAdapterFactory = luvio => function UiApi__getFlexipageFormulaOverrides(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$_(untrustedConfig, getFlexipageFormulaOverrides_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$I, buildNetworkSnapshotCachePolicy$J);
    };
    const VERSION$U = "7a5e66e0b88fe9d2233bb3158931bfa6";
    function validate$1o(obj, path = 'QuickActionColorRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_color = obj.color;
        const path_color = path + '.color';
        if (typeof obj_color !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_color + '" (at "' + path_color + '")');
        }
        const obj_colorContext = obj.colorContext;
        const path_colorContext = path + '.colorContext';
        if (typeof obj_colorContext !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_colorContext + '" (at "' + path_colorContext + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_theme = obj.theme;
        const path_theme = path + '.theme';
        if (typeof obj_theme !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_theme + '" (at "' + path_theme + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1s = function QuickActionColorRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$U,
        private: ['eTag'],
        selections: [{
          name: 'color',
          kind: 'Scalar'
        }, {
          name: 'colorContext',
          kind: 'Scalar'
        }, {
          name: 'theme',
          kind: 'Scalar'
        }]
      };
    };
    function equals$K(existing, incoming) {
      const existing_color = existing.color;
      const incoming_color = incoming.color;
      if (!(existing_color === incoming_color)) {
        return false;
      }
      const existing_colorContext = existing.colorContext;
      const incoming_colorContext = incoming.colorContext;
      if (!(existing_colorContext === incoming_colorContext)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_theme = existing.theme;
      const incoming_theme = incoming.theme;
      if (!(existing_theme === incoming_theme)) {
        return false;
      }
      return true;
    }
    const VERSION$T = "5e970aa7dacfdd8e0c6d5daca575ec58";
    function validate$1n(obj, path = 'CopilotQuickActionInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_inputName = obj.inputName;
        const path_inputName = path + '.inputName';
        if (typeof obj_inputName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_inputName + '" (at "' + path_inputName + '")');
        }
        const obj_inputValue = obj.inputValue;
        const path_inputValue = path + '.inputValue';
        if (typeof obj_inputValue !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_inputValue + '" (at "' + path_inputValue + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1r = function CopilotQuickActionInputRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$T,
        private: ['eTag'],
        selections: [{
          name: 'inputName',
          kind: 'Scalar'
        }, {
          name: 'inputValue',
          kind: 'Scalar'
        }]
      };
    };
    function equals$J(existing, incoming) {
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_inputName = existing.inputName;
      const incoming_inputName = incoming.inputName;
      if (!(existing_inputName === incoming_inputName)) {
        return false;
      }
      const existing_inputValue = existing.inputValue;
      const incoming_inputValue = incoming.inputValue;
      if (!(existing_inputValue === incoming_inputValue)) {
        return false;
      }
      return true;
    }
    const VERSION$S = "53b489083ef57944d2a9d4a2aaf72ec3";
    function validate$1m(obj, path = 'QuickActionIconRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentType = obj.contentType;
        const path_contentType = path + '.contentType';
        if (typeof obj_contentType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentType + '" (at "' + path_contentType + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_height = obj.height;
        const path_height = path + '.height';
        if (typeof obj_height !== 'number' || typeof obj_height === 'number' && Math.floor(obj_height) !== obj_height) {
          return new TypeError('Expected "integer" but received "' + typeof obj_height + '" (at "' + path_height + '")');
        }
        const obj_theme = obj.theme;
        const path_theme = path + '.theme';
        if (typeof obj_theme !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_theme + '" (at "' + path_theme + '")');
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
        const obj_width = obj.width;
        const path_width = path + '.width';
        if (typeof obj_width !== 'number' || typeof obj_width === 'number' && Math.floor(obj_width) !== obj_width) {
          return new TypeError('Expected "integer" but received "' + typeof obj_width + '" (at "' + path_width + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1q = function QuickActionIconRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$S,
        private: ['eTag'],
        selections: [{
          name: 'contentType',
          kind: 'Scalar'
        }, {
          name: 'height',
          kind: 'Scalar'
        }, {
          name: 'theme',
          kind: 'Scalar'
        }, {
          name: 'url',
          kind: 'Scalar'
        }, {
          name: 'width',
          kind: 'Scalar'
        }]
      };
    };
    function equals$I(existing, incoming) {
      const existing_height = existing.height;
      const incoming_height = incoming.height;
      if (!(existing_height === incoming_height)) {
        return false;
      }
      const existing_width = existing.width;
      const incoming_width = incoming.width;
      if (!(existing_width === incoming_width)) {
        return false;
      }
      const existing_contentType = existing.contentType;
      const incoming_contentType = incoming.contentType;
      if (!(existing_contentType === incoming_contentType)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_theme = existing.theme;
      const incoming_theme = incoming.theme;
      if (!(existing_theme === incoming_theme)) {
        return false;
      }
      const existing_url = existing.url;
      const incoming_url = incoming.url;
      if (!(existing_url === incoming_url)) {
        return false;
      }
      return true;
    }
    const TTL$p = 900000;
    const VERSION$R = "fa106dcb7d887c1e9b3e958336280ac8";
    function validate$1l(obj, path = 'QuickActionInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_accessLevelRequired = obj.accessLevelRequired;
        const path_accessLevelRequired = path + '.accessLevelRequired';
        let obj_accessLevelRequired_union0 = null;
        const obj_accessLevelRequired_union0_error = (() => {
          if (typeof obj_accessLevelRequired !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_accessLevelRequired + '" (at "' + path_accessLevelRequired + '")');
          }
        })();
        if (obj_accessLevelRequired_union0_error != null) {
          obj_accessLevelRequired_union0 = obj_accessLevelRequired_union0_error.message;
        }
        let obj_accessLevelRequired_union1 = null;
        const obj_accessLevelRequired_union1_error = (() => {
          if (obj_accessLevelRequired !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_accessLevelRequired + '" (at "' + path_accessLevelRequired + '")');
          }
        })();
        if (obj_accessLevelRequired_union1_error != null) {
          obj_accessLevelRequired_union1 = obj_accessLevelRequired_union1_error.message;
        }
        if (obj_accessLevelRequired_union0 && obj_accessLevelRequired_union1) {
          let message = 'Object doesn\'t match union (at "' + path_accessLevelRequired + '")';
          message += '\n' + obj_accessLevelRequired_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_accessLevelRequired_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_actionApiName = obj.actionApiName;
        const path_actionApiName = path + '.actionApiName';
        if (typeof obj_actionApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_actionApiName + '" (at "' + path_actionApiName + '")');
        }
        const obj_colors = obj.colors;
        const path_colors = path + '.colors';
        if (!ArrayIsArray(obj_colors)) {
          return new TypeError('Expected "array" but received "' + typeof obj_colors + '" (at "' + path_colors + '")');
        }
        for (let i = 0; i < obj_colors.length; i++) {
          const obj_colors_item = obj_colors[i];
          const path_colors_item = path_colors + '[' + i + ']';
          const referencepath_colors_itemValidationError = validate$1o(obj_colors_item, path_colors_item);
          if (referencepath_colors_itemValidationError !== null) {
            let message = 'Object doesn\'t match QuickActionColorRepresentation (at "' + path_colors_item + '")\n';
            message += referencepath_colors_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_copilotActionDescription = obj.copilotActionDescription;
        const path_copilotActionDescription = path + '.copilotActionDescription';
        let obj_copilotActionDescription_union0 = null;
        const obj_copilotActionDescription_union0_error = (() => {
          if (typeof obj_copilotActionDescription !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_copilotActionDescription + '" (at "' + path_copilotActionDescription + '")');
          }
        })();
        if (obj_copilotActionDescription_union0_error != null) {
          obj_copilotActionDescription_union0 = obj_copilotActionDescription_union0_error.message;
        }
        let obj_copilotActionDescription_union1 = null;
        const obj_copilotActionDescription_union1_error = (() => {
          if (obj_copilotActionDescription !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_copilotActionDescription + '" (at "' + path_copilotActionDescription + '")');
          }
        })();
        if (obj_copilotActionDescription_union1_error != null) {
          obj_copilotActionDescription_union1 = obj_copilotActionDescription_union1_error.message;
        }
        if (obj_copilotActionDescription_union0 && obj_copilotActionDescription_union1) {
          let message = 'Object doesn\'t match union (at "' + path_copilotActionDescription + '")';
          message += '\n' + obj_copilotActionDescription_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_copilotActionDescription_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_copilotInputs = obj.copilotInputs;
        const path_copilotInputs = path + '.copilotInputs';
        if (!ArrayIsArray(obj_copilotInputs)) {
          return new TypeError('Expected "array" but received "' + typeof obj_copilotInputs + '" (at "' + path_copilotInputs + '")');
        }
        for (let i = 0; i < obj_copilotInputs.length; i++) {
          const obj_copilotInputs_item = obj_copilotInputs[i];
          const path_copilotInputs_item = path_copilotInputs + '[' + i + ']';
          const referencepath_copilotInputs_itemValidationError = validate$1n(obj_copilotInputs_item, path_copilotInputs_item);
          if (referencepath_copilotInputs_itemValidationError !== null) {
            let message = 'Object doesn\'t match CopilotQuickActionInputRepresentation (at "' + path_copilotInputs_item + '")\n';
            message += referencepath_copilotInputs_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_copilotIntent = obj.copilotIntent;
        const path_copilotIntent = path + '.copilotIntent';
        let obj_copilotIntent_union0 = null;
        const obj_copilotIntent_union0_error = (() => {
          if (typeof obj_copilotIntent !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_copilotIntent + '" (at "' + path_copilotIntent + '")');
          }
        })();
        if (obj_copilotIntent_union0_error != null) {
          obj_copilotIntent_union0 = obj_copilotIntent_union0_error.message;
        }
        let obj_copilotIntent_union1 = null;
        const obj_copilotIntent_union1_error = (() => {
          if (obj_copilotIntent !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_copilotIntent + '" (at "' + path_copilotIntent + '")');
          }
        })();
        if (obj_copilotIntent_union1_error != null) {
          obj_copilotIntent_union1 = obj_copilotIntent_union1_error.message;
        }
        if (obj_copilotIntent_union0 && obj_copilotIntent_union1) {
          let message = 'Object doesn\'t match union (at "' + path_copilotIntent + '")';
          message += '\n' + obj_copilotIntent_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_copilotIntent_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_copilotPlanTemplateId = obj.copilotPlanTemplateId;
        const path_copilotPlanTemplateId = path + '.copilotPlanTemplateId';
        let obj_copilotPlanTemplateId_union0 = null;
        const obj_copilotPlanTemplateId_union0_error = (() => {
          if (typeof obj_copilotPlanTemplateId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_copilotPlanTemplateId + '" (at "' + path_copilotPlanTemplateId + '")');
          }
        })();
        if (obj_copilotPlanTemplateId_union0_error != null) {
          obj_copilotPlanTemplateId_union0 = obj_copilotPlanTemplateId_union0_error.message;
        }
        let obj_copilotPlanTemplateId_union1 = null;
        const obj_copilotPlanTemplateId_union1_error = (() => {
          if (obj_copilotPlanTemplateId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_copilotPlanTemplateId + '" (at "' + path_copilotPlanTemplateId + '")');
          }
        })();
        if (obj_copilotPlanTemplateId_union1_error != null) {
          obj_copilotPlanTemplateId_union1 = obj_copilotPlanTemplateId_union1_error.message;
        }
        if (obj_copilotPlanTemplateId_union0 && obj_copilotPlanTemplateId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_copilotPlanTemplateId + '")';
          message += '\n' + obj_copilotPlanTemplateId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_copilotPlanTemplateId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_copilotUserUtterance = obj.copilotUserUtterance;
        const path_copilotUserUtterance = path + '.copilotUserUtterance';
        let obj_copilotUserUtterance_union0 = null;
        const obj_copilotUserUtterance_union0_error = (() => {
          if (typeof obj_copilotUserUtterance !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_copilotUserUtterance + '" (at "' + path_copilotUserUtterance + '")');
          }
        })();
        if (obj_copilotUserUtterance_union0_error != null) {
          obj_copilotUserUtterance_union0 = obj_copilotUserUtterance_union0_error.message;
        }
        let obj_copilotUserUtterance_union1 = null;
        const obj_copilotUserUtterance_union1_error = (() => {
          if (obj_copilotUserUtterance !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_copilotUserUtterance + '" (at "' + path_copilotUserUtterance + '")');
          }
        })();
        if (obj_copilotUserUtterance_union1_error != null) {
          obj_copilotUserUtterance_union1 = obj_copilotUserUtterance_union1_error.message;
        }
        if (obj_copilotUserUtterance_union0 && obj_copilotUserUtterance_union1) {
          let message = 'Object doesn\'t match union (at "' + path_copilotUserUtterance + '")';
          message += '\n' + obj_copilotUserUtterance_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_copilotUserUtterance_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_flowDevName = obj.flowDevName;
        const path_flowDevName = path + '.flowDevName';
        let obj_flowDevName_union0 = null;
        const obj_flowDevName_union0_error = (() => {
          if (typeof obj_flowDevName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_flowDevName + '" (at "' + path_flowDevName + '")');
          }
        })();
        if (obj_flowDevName_union0_error != null) {
          obj_flowDevName_union0 = obj_flowDevName_union0_error.message;
        }
        let obj_flowDevName_union1 = null;
        const obj_flowDevName_union1_error = (() => {
          if (obj_flowDevName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_flowDevName + '" (at "' + path_flowDevName + '")');
          }
        })();
        if (obj_flowDevName_union1_error != null) {
          obj_flowDevName_union1 = obj_flowDevName_union1_error.message;
        }
        if (obj_flowDevName_union0 && obj_flowDevName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_flowDevName + '")';
          message += '\n' + obj_flowDevName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_flowDevName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_flowRecordIdVar = obj.flowRecordIdVar;
        const path_flowRecordIdVar = path + '.flowRecordIdVar';
        let obj_flowRecordIdVar_union0 = null;
        const obj_flowRecordIdVar_union0_error = (() => {
          if (typeof obj_flowRecordIdVar !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_flowRecordIdVar + '" (at "' + path_flowRecordIdVar + '")');
          }
        })();
        if (obj_flowRecordIdVar_union0_error != null) {
          obj_flowRecordIdVar_union0 = obj_flowRecordIdVar_union0_error.message;
        }
        let obj_flowRecordIdVar_union1 = null;
        const obj_flowRecordIdVar_union1_error = (() => {
          if (obj_flowRecordIdVar !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_flowRecordIdVar + '" (at "' + path_flowRecordIdVar + '")');
          }
        })();
        if (obj_flowRecordIdVar_union1_error != null) {
          obj_flowRecordIdVar_union1 = obj_flowRecordIdVar_union1_error.message;
        }
        if (obj_flowRecordIdVar_union0 && obj_flowRecordIdVar_union1) {
          let message = 'Object doesn\'t match union (at "' + path_flowRecordIdVar + '")';
          message += '\n' + obj_flowRecordIdVar_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_flowRecordIdVar_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_iconName = obj.iconName;
        const path_iconName = path + '.iconName';
        let obj_iconName_union0 = null;
        const obj_iconName_union0_error = (() => {
          if (typeof obj_iconName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_iconName + '" (at "' + path_iconName + '")');
          }
        })();
        if (obj_iconName_union0_error != null) {
          obj_iconName_union0 = obj_iconName_union0_error.message;
        }
        let obj_iconName_union1 = null;
        const obj_iconName_union1_error = (() => {
          if (obj_iconName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_iconName + '" (at "' + path_iconName + '")');
          }
        })();
        if (obj_iconName_union1_error != null) {
          obj_iconName_union1 = obj_iconName_union1_error.message;
        }
        if (obj_iconName_union0 && obj_iconName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_iconName + '")';
          message += '\n' + obj_iconName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_iconName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_icons = obj.icons;
        const path_icons = path + '.icons';
        if (!ArrayIsArray(obj_icons)) {
          return new TypeError('Expected "array" but received "' + typeof obj_icons + '" (at "' + path_icons + '")');
        }
        for (let i = 0; i < obj_icons.length; i++) {
          const obj_icons_item = obj_icons[i];
          const path_icons_item = path_icons + '[' + i + ']';
          const referencepath_icons_itemValidationError = validate$1m(obj_icons_item, path_icons_item);
          if (referencepath_icons_itemValidationError !== null) {
            let message = 'Object doesn\'t match QuickActionIconRepresentation (at "' + path_icons_item + '")\n';
            message += referencepath_icons_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_lightningComponentBundleName = obj.lightningComponentBundleName;
        const path_lightningComponentBundleName = path + '.lightningComponentBundleName';
        let obj_lightningComponentBundleName_union0 = null;
        const obj_lightningComponentBundleName_union0_error = (() => {
          if (typeof obj_lightningComponentBundleName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lightningComponentBundleName + '" (at "' + path_lightningComponentBundleName + '")');
          }
        })();
        if (obj_lightningComponentBundleName_union0_error != null) {
          obj_lightningComponentBundleName_union0 = obj_lightningComponentBundleName_union0_error.message;
        }
        let obj_lightningComponentBundleName_union1 = null;
        const obj_lightningComponentBundleName_union1_error = (() => {
          if (obj_lightningComponentBundleName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lightningComponentBundleName + '" (at "' + path_lightningComponentBundleName + '")');
          }
        })();
        if (obj_lightningComponentBundleName_union1_error != null) {
          obj_lightningComponentBundleName_union1 = obj_lightningComponentBundleName_union1_error.message;
        }
        if (obj_lightningComponentBundleName_union0 && obj_lightningComponentBundleName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lightningComponentBundleName + '")';
          message += '\n' + obj_lightningComponentBundleName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lightningComponentBundleName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lightningComponentQualifiedName = obj.lightningComponentQualifiedName;
        const path_lightningComponentQualifiedName = path + '.lightningComponentQualifiedName';
        let obj_lightningComponentQualifiedName_union0 = null;
        const obj_lightningComponentQualifiedName_union0_error = (() => {
          if (typeof obj_lightningComponentQualifiedName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lightningComponentQualifiedName + '" (at "' + path_lightningComponentQualifiedName + '")');
          }
        })();
        if (obj_lightningComponentQualifiedName_union0_error != null) {
          obj_lightningComponentQualifiedName_union0 = obj_lightningComponentQualifiedName_union0_error.message;
        }
        let obj_lightningComponentQualifiedName_union1 = null;
        const obj_lightningComponentQualifiedName_union1_error = (() => {
          if (obj_lightningComponentQualifiedName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lightningComponentQualifiedName + '" (at "' + path_lightningComponentQualifiedName + '")');
          }
        })();
        if (obj_lightningComponentQualifiedName_union1_error != null) {
          obj_lightningComponentQualifiedName_union1 = obj_lightningComponentQualifiedName_union1_error.message;
        }
        if (obj_lightningComponentQualifiedName_union0 && obj_lightningComponentQualifiedName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lightningComponentQualifiedName + '")';
          message += '\n' + obj_lightningComponentQualifiedName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lightningComponentQualifiedName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lightningWebComponentBundleName = obj.lightningWebComponentBundleName;
        const path_lightningWebComponentBundleName = path + '.lightningWebComponentBundleName';
        let obj_lightningWebComponentBundleName_union0 = null;
        const obj_lightningWebComponentBundleName_union0_error = (() => {
          if (typeof obj_lightningWebComponentBundleName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lightningWebComponentBundleName + '" (at "' + path_lightningWebComponentBundleName + '")');
          }
        })();
        if (obj_lightningWebComponentBundleName_union0_error != null) {
          obj_lightningWebComponentBundleName_union0 = obj_lightningWebComponentBundleName_union0_error.message;
        }
        let obj_lightningWebComponentBundleName_union1 = null;
        const obj_lightningWebComponentBundleName_union1_error = (() => {
          if (obj_lightningWebComponentBundleName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lightningWebComponentBundleName + '" (at "' + path_lightningWebComponentBundleName + '")');
          }
        })();
        if (obj_lightningWebComponentBundleName_union1_error != null) {
          obj_lightningWebComponentBundleName_union1 = obj_lightningWebComponentBundleName_union1_error.message;
        }
        if (obj_lightningWebComponentBundleName_union0 && obj_lightningWebComponentBundleName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lightningWebComponentBundleName + '")';
          message += '\n' + obj_lightningWebComponentBundleName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lightningWebComponentBundleName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lightningWebComponentQualifiedName = obj.lightningWebComponentQualifiedName;
        const path_lightningWebComponentQualifiedName = path + '.lightningWebComponentQualifiedName';
        let obj_lightningWebComponentQualifiedName_union0 = null;
        const obj_lightningWebComponentQualifiedName_union0_error = (() => {
          if (typeof obj_lightningWebComponentQualifiedName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lightningWebComponentQualifiedName + '" (at "' + path_lightningWebComponentQualifiedName + '")');
          }
        })();
        if (obj_lightningWebComponentQualifiedName_union0_error != null) {
          obj_lightningWebComponentQualifiedName_union0 = obj_lightningWebComponentQualifiedName_union0_error.message;
        }
        let obj_lightningWebComponentQualifiedName_union1 = null;
        const obj_lightningWebComponentQualifiedName_union1_error = (() => {
          if (obj_lightningWebComponentQualifiedName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lightningWebComponentQualifiedName + '" (at "' + path_lightningWebComponentQualifiedName + '")');
          }
        })();
        if (obj_lightningWebComponentQualifiedName_union1_error != null) {
          obj_lightningWebComponentQualifiedName_union1 = obj_lightningWebComponentQualifiedName_union1_error.message;
        }
        if (obj_lightningWebComponentQualifiedName_union0 && obj_lightningWebComponentQualifiedName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lightningWebComponentQualifiedName + '")';
          message += '\n' + obj_lightningWebComponentQualifiedName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lightningWebComponentQualifiedName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_targetParentField = obj.targetParentField;
        const path_targetParentField = path + '.targetParentField';
        let obj_targetParentField_union0 = null;
        const obj_targetParentField_union0_error = (() => {
          if (typeof obj_targetParentField !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_targetParentField + '" (at "' + path_targetParentField + '")');
          }
        })();
        if (obj_targetParentField_union0_error != null) {
          obj_targetParentField_union0 = obj_targetParentField_union0_error.message;
        }
        let obj_targetParentField_union1 = null;
        const obj_targetParentField_union1_error = (() => {
          if (obj_targetParentField !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_targetParentField + '" (at "' + path_targetParentField + '")');
          }
        })();
        if (obj_targetParentField_union1_error != null) {
          obj_targetParentField_union1 = obj_targetParentField_union1_error.message;
        }
        if (obj_targetParentField_union0 && obj_targetParentField_union1) {
          let message = 'Object doesn\'t match union (at "' + path_targetParentField + '")';
          message += '\n' + obj_targetParentField_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_targetParentField_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_targetRecordTypeId = obj.targetRecordTypeId;
        const path_targetRecordTypeId = path + '.targetRecordTypeId';
        let obj_targetRecordTypeId_union0 = null;
        const obj_targetRecordTypeId_union0_error = (() => {
          if (typeof obj_targetRecordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_targetRecordTypeId + '" (at "' + path_targetRecordTypeId + '")');
          }
        })();
        if (obj_targetRecordTypeId_union0_error != null) {
          obj_targetRecordTypeId_union0 = obj_targetRecordTypeId_union0_error.message;
        }
        let obj_targetRecordTypeId_union1 = null;
        const obj_targetRecordTypeId_union1_error = (() => {
          if (obj_targetRecordTypeId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_targetRecordTypeId + '" (at "' + path_targetRecordTypeId + '")');
          }
        })();
        if (obj_targetRecordTypeId_union1_error != null) {
          obj_targetRecordTypeId_union1 = obj_targetRecordTypeId_union1_error.message;
        }
        if (obj_targetRecordTypeId_union0 && obj_targetRecordTypeId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_targetRecordTypeId + '")';
          message += '\n' + obj_targetRecordTypeId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_targetRecordTypeId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_targetSobjectType = obj.targetSobjectType;
        const path_targetSobjectType = path + '.targetSobjectType';
        let obj_targetSobjectType_union0 = null;
        const obj_targetSobjectType_union0_error = (() => {
          if (typeof obj_targetSobjectType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_targetSobjectType + '" (at "' + path_targetSobjectType + '")');
          }
        })();
        if (obj_targetSobjectType_union0_error != null) {
          obj_targetSobjectType_union0 = obj_targetSobjectType_union0_error.message;
        }
        let obj_targetSobjectType_union1 = null;
        const obj_targetSobjectType_union1_error = (() => {
          if (obj_targetSobjectType !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_targetSobjectType + '" (at "' + path_targetSobjectType + '")');
          }
        })();
        if (obj_targetSobjectType_union1_error != null) {
          obj_targetSobjectType_union1 = obj_targetSobjectType_union1_error.message;
        }
        if (obj_targetSobjectType_union0 && obj_targetSobjectType_union1) {
          let message = 'Object doesn\'t match union (at "' + path_targetSobjectType + '")';
          message += '\n' + obj_targetSobjectType_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_targetSobjectType_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$A = 'QuickActionInfoRepresentation';
    function keyBuilder$1A(luvio, config) {
      return keyPrefix + '::' + RepresentationType$A + ':' + config.actionApiName;
    }
    function keyBuilderFromType$n(luvio, object) {
      const keyParams = {
        actionApiName: object.actionApiName
      };
      return keyBuilder$1A(luvio, keyParams);
    }
    function normalize$u(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1p = function QuickActionInfoRepresentationSelect() {
      const {
        selections: QuickActionColorRepresentation__selections,
        opaque: QuickActionColorRepresentation__opaque
      } = select$1s();
      const {
        selections: CopilotQuickActionInputRepresentation__selections,
        opaque: CopilotQuickActionInputRepresentation__opaque
      } = select$1r();
      const {
        selections: QuickActionIconRepresentation__selections,
        opaque: QuickActionIconRepresentation__opaque
      } = select$1q();
      return {
        kind: 'Fragment',
        version: VERSION$R,
        private: ['eTag'],
        selections: [{
          name: 'accessLevelRequired',
          kind: 'Scalar'
        }, {
          name: 'actionApiName',
          kind: 'Scalar'
        }, {
          name: 'colors',
          kind: 'Object',
          plural: true,
          selections: QuickActionColorRepresentation__selections
        }, {
          name: 'copilotActionDescription',
          kind: 'Scalar'
        }, {
          name: 'copilotInputs',
          kind: 'Object',
          plural: true,
          selections: CopilotQuickActionInputRepresentation__selections
        }, {
          name: 'copilotIntent',
          kind: 'Scalar'
        }, {
          name: 'copilotPlanTemplateId',
          kind: 'Scalar'
        }, {
          name: 'copilotUserUtterance',
          kind: 'Scalar'
        }, {
          name: 'flowDevName',
          kind: 'Scalar'
        }, {
          name: 'flowRecordIdVar',
          kind: 'Scalar'
        }, {
          name: 'iconName',
          kind: 'Scalar'
        }, {
          name: 'icons',
          kind: 'Object',
          plural: true,
          selections: QuickActionIconRepresentation__selections
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'lightningComponentBundleName',
          kind: 'Scalar'
        }, {
          name: 'lightningComponentQualifiedName',
          kind: 'Scalar'
        }, {
          name: 'lightningWebComponentBundleName',
          kind: 'Scalar'
        }, {
          name: 'lightningWebComponentQualifiedName',
          kind: 'Scalar'
        }, {
          name: 'targetParentField',
          kind: 'Scalar'
        }, {
          name: 'targetRecordTypeId',
          kind: 'Scalar'
        }, {
          name: 'targetSobjectType',
          kind: 'Scalar'
        }, {
          name: 'type',
          kind: 'Scalar'
        }]
      };
    };
    function equals$H(existing, incoming) {
      const existing_actionApiName = existing.actionApiName;
      const incoming_actionApiName = incoming.actionApiName;
      if (!(existing_actionApiName === incoming_actionApiName)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      const existing_type = existing.type;
      const incoming_type = incoming.type;
      if (!(existing_type === incoming_type)) {
        return false;
      }
      const existing_accessLevelRequired = existing.accessLevelRequired;
      const incoming_accessLevelRequired = incoming.accessLevelRequired;
      if (!(existing_accessLevelRequired === incoming_accessLevelRequired)) {
        return false;
      }
      const existing_colors = existing.colors;
      const incoming_colors = incoming.colors;
      const equals_colors_items = equalsArray(existing_colors, incoming_colors, (existing_colors_item, incoming_colors_item) => {
        if (!equals$K(existing_colors_item, incoming_colors_item)) {
          return false;
        }
      });
      if (equals_colors_items === false) {
        return false;
      }
      const existing_copilotActionDescription = existing.copilotActionDescription;
      const incoming_copilotActionDescription = incoming.copilotActionDescription;
      if (!(existing_copilotActionDescription === incoming_copilotActionDescription)) {
        return false;
      }
      const existing_copilotInputs = existing.copilotInputs;
      const incoming_copilotInputs = incoming.copilotInputs;
      const equals_copilotInputs_items = equalsArray(existing_copilotInputs, incoming_copilotInputs, (existing_copilotInputs_item, incoming_copilotInputs_item) => {
        if (!equals$J(existing_copilotInputs_item, incoming_copilotInputs_item)) {
          return false;
        }
      });
      if (equals_copilotInputs_items === false) {
        return false;
      }
      const existing_copilotIntent = existing.copilotIntent;
      const incoming_copilotIntent = incoming.copilotIntent;
      if (!(existing_copilotIntent === incoming_copilotIntent)) {
        return false;
      }
      const existing_copilotPlanTemplateId = existing.copilotPlanTemplateId;
      const incoming_copilotPlanTemplateId = incoming.copilotPlanTemplateId;
      if (!(existing_copilotPlanTemplateId === incoming_copilotPlanTemplateId)) {
        return false;
      }
      const existing_copilotUserUtterance = existing.copilotUserUtterance;
      const incoming_copilotUserUtterance = incoming.copilotUserUtterance;
      if (!(existing_copilotUserUtterance === incoming_copilotUserUtterance)) {
        return false;
      }
      const existing_flowDevName = existing.flowDevName;
      const incoming_flowDevName = incoming.flowDevName;
      if (!(existing_flowDevName === incoming_flowDevName)) {
        return false;
      }
      const existing_flowRecordIdVar = existing.flowRecordIdVar;
      const incoming_flowRecordIdVar = incoming.flowRecordIdVar;
      if (!(existing_flowRecordIdVar === incoming_flowRecordIdVar)) {
        return false;
      }
      const existing_iconName = existing.iconName;
      const incoming_iconName = incoming.iconName;
      if (!(existing_iconName === incoming_iconName)) {
        return false;
      }
      const existing_icons = existing.icons;
      const incoming_icons = incoming.icons;
      const equals_icons_items = equalsArray(existing_icons, incoming_icons, (existing_icons_item, incoming_icons_item) => {
        if (!equals$I(existing_icons_item, incoming_icons_item)) {
          return false;
        }
      });
      if (equals_icons_items === false) {
        return false;
      }
      const existing_lightningComponentBundleName = existing.lightningComponentBundleName;
      const incoming_lightningComponentBundleName = incoming.lightningComponentBundleName;
      if (!(existing_lightningComponentBundleName === incoming_lightningComponentBundleName)) {
        return false;
      }
      const existing_lightningComponentQualifiedName = existing.lightningComponentQualifiedName;
      const incoming_lightningComponentQualifiedName = incoming.lightningComponentQualifiedName;
      if (!(existing_lightningComponentQualifiedName === incoming_lightningComponentQualifiedName)) {
        return false;
      }
      const existing_lightningWebComponentBundleName = existing.lightningWebComponentBundleName;
      const incoming_lightningWebComponentBundleName = incoming.lightningWebComponentBundleName;
      if (!(existing_lightningWebComponentBundleName === incoming_lightningWebComponentBundleName)) {
        return false;
      }
      const existing_lightningWebComponentQualifiedName = existing.lightningWebComponentQualifiedName;
      const incoming_lightningWebComponentQualifiedName = incoming.lightningWebComponentQualifiedName;
      if (!(existing_lightningWebComponentQualifiedName === incoming_lightningWebComponentQualifiedName)) {
        return false;
      }
      const existing_targetParentField = existing.targetParentField;
      const incoming_targetParentField = incoming.targetParentField;
      if (!(existing_targetParentField === incoming_targetParentField)) {
        return false;
      }
      const existing_targetRecordTypeId = existing.targetRecordTypeId;
      const incoming_targetRecordTypeId = incoming.targetRecordTypeId;
      if (!(existing_targetRecordTypeId === incoming_targetRecordTypeId)) {
        return false;
      }
      const existing_targetSobjectType = existing.targetSobjectType;
      const incoming_targetSobjectType = incoming.targetSobjectType;
      if (!(existing_targetSobjectType === incoming_targetSobjectType)) {
        return false;
      }
      return true;
    }
    const ingest$u = function QuickActionInfoRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1l(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$n(luvio, input);
      const ttlToUse = TTL$p;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$u, "UiApi", VERSION$R, RepresentationType$A, equals$H);
      return createLink(key);
    };
    function getTypeCacheKeys$B(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$n(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$A,
        mergeable: false
      });
    }
    function select$1o(luvio, params) {
      return select$1p();
    }
    function keyBuilder$1z(luvio, params) {
      return keyBuilder$1A(luvio, {
        actionApiName: params.urlParams.actionApiName
      });
    }
    function getResponseCacheKeys$T(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$B(storeKeyMap, luvio, response);
    }
    function ingestSuccess$I(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1z(luvio, resourceParams);
      luvio.storeIngest(key, ingest$u, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1o(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$B(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1z(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$p,
        namespace: keyPrefix,
        version: VERSION$R,
        representationName: RepresentationType$A
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$W(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/quick-action-info/' + config.urlParams.actionApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$T = 'getQuickActionInfo';
    const getQuickActionInfo_ConfigPropertyMetadata = [generateParamConfigMetadata('actionApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('parentRecordId', false, 1 /* QueryParameter */, 0 /* String */, false, getRecordId18)];
    const getQuickActionInfo_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$T, getQuickActionInfo_ConfigPropertyMetadata);
    const createResourceParams$R = /*#__PURE__*/luvioEngine.createResourceParams(getQuickActionInfo_ConfigPropertyMetadata);
    function keyBuilder$1y(luvio, config) {
      const resourceParams = createResourceParams$R(config);
      return keyBuilder$1z(luvio, resourceParams);
    }
    function typeCheckConfig$X(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getQuickActionInfo_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$Z(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getQuickActionInfo_ConfigPropertyMetadata);
      const config = typeCheckConfig$X(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$A(luvio, config) {
      createResourceParams$R(config);
      return select$1o();
    }
    function onFetchResponseSuccess$D(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$I(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$W(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$E(luvio, config, resourceParams, response) {
      const snapshot = ingestError$B(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$W(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$W(luvio, config, options) {
      const resourceParams = createResourceParams$R(config);
      const request = createResourceRequest$W(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$D(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$T(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$E(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$I(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$W, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$H(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1y(luvio, config),
        node: adapterFragment$A(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$W(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getQuickActionInfoAdapterFactory = luvio => function UiApi__getQuickActionInfo(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$Z(untrustedConfig, getQuickActionInfo_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$H, buildNetworkSnapshotCachePolicy$I);
    };
    const QUICK_ACTION_DEFAULTS_STORE_METADATA_PARAMS = {
      ttl: TTL$t,
      namespace: keyPrefix,
      representationName: RepresentationType$H,
      version: VERSION$$
    };
    function merge$1(existing, incoming) {
      if (existing === undefined) {
        return incoming;
      }
      // Merge QuickActionDefaultsRepresentation field values together
      return {
        ...incoming,
        fields: {
          ...existing.fields,
          ...incoming.fields
        }
      };
    }
    const dynamicIngest$4 = ingestParams => {
      return function QuickActionDefaultsRepresentationIngest(input, path, luvio, store, timestamp) {
        {
          const validateError = validate$1w(input);
          if (validateError !== null) {
            throw validateError;
          }
        }
        const key = keyBuilderFromType$r(luvio, input);
        const existingRecord = store.readEntry(key);
        let incomingRecord = dynamicNormalize$4(ingestParams)(input, store.readEntry(key), {
          fullPath: key,
          parent: path.parent,
          propertyName: path.propertyName
        }, luvio, store, timestamp);
        incomingRecord = merge$1(existingRecord, incomingRecord);
        if (existingRecord === undefined || equals$R(existingRecord, incomingRecord) === false) {
          luvio.storePublish(key, incomingRecord);
        }
        luvio.publishStoreMetadata(key, {
          ...QUICK_ACTION_DEFAULTS_STORE_METADATA_PARAMS,
          ingestionTimestamp: timestamp
        });
        return createLink(key);
      };
    };
    function createFieldsIngest$4(params) {
      const {
        fields,
        optionalFields,
        trackedFields,
        recordConflictMap
      } = params;
      const ingest = dynamicIngest$4({
        fields: createFieldsIngestion(fields, optionalFields, recordConflictMap)
      });
      return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
      };
    }
    function selectFields$7(fields) {
      return dynamicSelect$5({
        fields: createPathSelection('fields', fields)
      });
    }
    function createFieldsIngestSuccess$2(params) {
      const {
        trackedFields
      } = params;
      const recordConflictMap = {
        conflicts: {},
        serverRequestCount: 1
      };
      const ingest = createFieldsIngest$4({
        ...params,
        recordConflictMap
      });
      return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        resolveConflict(luvio, recordConflictMap);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
      };
    }
    function selectFields$6(luvio, params) {
      const optionalFields = params.queryParams.optionalFields || [];
      const fields = [];
      const trie = convertRecordFieldsArrayToTrie(fields, optionalFields);
      return selectFields$7(trie);
    }
    function keyBuilder$1x(luvio, params) {
      return keyBuilder$1Q(luvio, {
        actionApiName: params.urlParams.actionApiName
      });
    }
    function getResponseCacheKeys$S(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$I(storeKeyMap, luvio, response);
    }
    function ingestError$A(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1x(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$t,
        namespace: keyPrefix,
        version: VERSION$$,
        representationName: RepresentationType$H
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$V(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/record-defaults/' + config.urlParams.actionApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function adapterFragment$z(luvio, config) {
      const resourceParams = createResourceParams$Q(config);
      return selectFields$6(luvio, resourceParams);
    }
    function buildNetworkSnapshot$V(luvio, config, options) {
      const resourceParams = createResourceParams$Q(config);
      const request = createResourceRequest$V(resourceParams);
      const key = keyBuilder$1w(luvio, config);
      const trackedFieldsConfig = {
        maxDepth: configurationForRestAdapters.getTrackedFieldDepthOnCacheMiss(),
        onlyFetchLeafNodeIdAndName: configurationForRestAdapters.getTrackedFieldLeafNodeIdAndNameOnly()
      };
      const optionalFieldsTrie = convertFieldsToTrie(getTrackedFields(key, luvio.getNode(key), trackedFieldsConfig, config.optionalFields));
      const fieldsTrie = BLANK_RECORD_FIELDS_TRIE;
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const ingest = createFieldsIngestSuccess$2({
            fields: fieldsTrie,
            optionalFields: optionalFieldsTrie,
            trackedFields: optionalFieldsTrie
          });
          luvio.storeIngest(key, ingest, response.body);
          const snapshot = buildCachedSnapshot$6(luvio, config);
          {
            if (snapshot.state !== 'Fulfilled') {
              throw new Error('Invalid network response. Expected network response to result in Fulfilled snapshot');
            }
          }
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$S(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => {
          return onFetchResponseError$D(luvio, config, resourceParams, response);
        });
      });
    }
    const adapterName$S = 'getQuickActionDefaults';
    const getQuickActionDefaults_ConfigPropertyMetadata = [generateParamConfigMetadata('actionApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('optionalFields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('parentRecordId', false, 1 /* QueryParameter */, 0 /* String */)];
    const getQuickActionDefaults_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$S, getQuickActionDefaults_ConfigPropertyMetadata);
    const createResourceParams$Q = /*#__PURE__*/luvioEngine.createResourceParams(getQuickActionDefaults_ConfigPropertyMetadata);
    function keyBuilder$1w(luvio, config) {
      const resourceParams = createResourceParams$Q(config);
      return keyBuilder$1x(luvio, resourceParams);
    }
    function typeCheckConfig$W(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getQuickActionDefaults_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$Y(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getQuickActionDefaults_ConfigPropertyMetadata);
      const config = typeCheckConfig$W(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildCachedSnapshot$6(luvio, config) {
      const selector = {
        recordId: keyBuilder$1w(luvio, config),
        node: adapterFragment$z(luvio, config),
        variables: {}
      };
      return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$V(luvio, config, snapshotRefreshOptions)
      });
    }
    function onFetchResponseError$D(luvio, config, resourceParams, response) {
      const snapshot = ingestError$A(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$V(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshotCachePolicy$H(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$V, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$G(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1w(luvio, config),
        node: adapterFragment$z(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$V(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getQuickActionDefaultsAdapterFactory = luvio => function UiApi__getQuickActionDefaults(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$Y(untrustedConfig, getQuickActionDefaults_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$G, buildNetworkSnapshotCachePolicy$H);
    };
    function select$1n(luvio, params) {
      return select$1C();
    }
    function keyBuilder$1v(luvio, params) {
      return keyPrefix + '::ActionRepresentation:(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'apiNames:' + params.queryParams.apiNames + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'retrievalMode:' + params.queryParams.retrievalMode + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ')';
    }
    function getResponseCacheKeys$R(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$F(storeKeyMap, luvio, response, () => keyBuilder$1v(luvio, resourceParams));
    }
    function ingestSuccess$H(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1v(luvio, resourceParams);
      luvio.storeIngest(key, ingest$y, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1n(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$z(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1v(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$s,
        namespace: keyPrefix,
        version: VERSION$Y,
        representationName: RepresentationType$E
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$U(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$R = 'getRecordActions';
    const oneOfConfigPropertiesIdentifier = ['sections', 'apiNames'];
    const getRecordActions_ConfigPropertyMetadata = [generateParamConfigMetadata('recordIds', true, 0 /* UrlParameter */, 0 /* String */, true, getRecordId18Array), generateParamConfigMetadata('actionTypes', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('apiNames', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArrayAllowEmpty), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */, false, coerceFormFactor), generateParamConfigMetadata('retrievalMode', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('sections', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray)];
    const getRecordActions_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$R, getRecordActions_ConfigPropertyMetadata);
    const createResourceParams$P = /*#__PURE__*/luvioEngine.createResourceParams(getRecordActions_ConfigPropertyMetadata);
    function keyBuilder$1u(luvio, config) {
      const resourceParams = createResourceParams$P(config);
      return keyBuilder$1v(luvio, resourceParams);
    }
    function typeCheckConfig$V(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRecordActions_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$X(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames, oneOfConfigPropertiesIdentifier);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRecordActions_ConfigPropertyMetadata);
      const config = typeCheckConfig$V(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      if (config.sections === undefined && config.apiNames === undefined) {
        return null;
      }
      return config;
    }
    function adapterFragment$y(luvio, config) {
      createResourceParams$P(config);
      return select$1n();
    }
    function onFetchResponseSuccess$C(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$H(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$U(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$C(luvio, config, resourceParams, response) {
      const snapshot = ingestError$z(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$U(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$U(luvio, config, options) {
      const resourceParams = createResourceParams$P(config);
      const request = createResourceRequest$U(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$C(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$R(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$C(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$G(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$U, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$F(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1u(luvio, config),
        node: adapterFragment$y(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$U(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRecordActionsAdapterFactory = luvio => function UiApi__getRecordActions(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$X(untrustedConfig, getRecordActions_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$F, buildNetworkSnapshotCachePolicy$G);
    };
    function select$1m(luvio, params) {
      return select$1C();
    }
    function keyBuilder$1t(luvio, params) {
      return keyPrefix + '::ActionRepresentation:(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ')';
    }
    function getResponseCacheKeys$Q(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$F(storeKeyMap, luvio, response, () => keyBuilder$1t(luvio, resourceParams));
    }
    function ingestSuccess$G(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1t(luvio, resourceParams);
      luvio.storeIngest(key, ingest$y, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1m(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$y(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1t(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$s,
        namespace: keyPrefix,
        version: VERSION$Y,
        representationName: RepresentationType$E
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$T(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/record-edit',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$Q = 'getRecordEditActions';
    const getRecordEditActions_ConfigPropertyMetadata = [generateParamConfigMetadata('recordIds', true, 0 /* UrlParameter */, 0 /* String */, true, getRecordId18Array), generateParamConfigMetadata('actionTypes', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */, false, coerceFormFactor), generateParamConfigMetadata('sections', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray)];
    const getRecordEditActions_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$Q, getRecordEditActions_ConfigPropertyMetadata);
    const createResourceParams$O = /*#__PURE__*/luvioEngine.createResourceParams(getRecordEditActions_ConfigPropertyMetadata);
    function keyBuilder$1s(luvio, config) {
      const resourceParams = createResourceParams$O(config);
      return keyBuilder$1t(luvio, resourceParams);
    }
    function typeCheckConfig$U(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRecordEditActions_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$W(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRecordEditActions_ConfigPropertyMetadata);
      const config = typeCheckConfig$U(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$x(luvio, config) {
      createResourceParams$O(config);
      return select$1m();
    }
    function onFetchResponseSuccess$B(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$G(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$T(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$B(luvio, config, resourceParams, response) {
      const snapshot = ingestError$y(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$T(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$T(luvio, config, options) {
      const resourceParams = createResourceParams$O(config);
      const request = createResourceRequest$T(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$B(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$Q(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$B(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$F(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$T, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$E(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1s(luvio, config),
        node: adapterFragment$x(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$T(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRecordEditActionsAdapterFactory = luvio => function UiApi__getRecordEditActions(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$W(untrustedConfig, getRecordEditActions_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$E, buildNetworkSnapshotCachePolicy$F);
    };
    function validate$1k(obj, path = 'ActionRelatedListSingleBatchInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.actionTypes !== undefined) {
          const obj_actionTypes = obj.actionTypes;
          const path_actionTypes = path + '.actionTypes';
          if (!ArrayIsArray(obj_actionTypes)) {
            return new TypeError('Expected "array" but received "' + typeof obj_actionTypes + '" (at "' + path_actionTypes + '")');
          }
          for (let i = 0; i < obj_actionTypes.length; i++) {
            const obj_actionTypes_item = obj_actionTypes[i];
            const path_actionTypes_item = path_actionTypes + '[' + i + ']';
            if (typeof obj_actionTypes_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_actionTypes_item + '" (at "' + path_actionTypes_item + '")');
            }
          }
        }
        if (obj.apiNames !== undefined) {
          const obj_apiNames = obj.apiNames;
          const path_apiNames = path + '.apiNames';
          if (!ArrayIsArray(obj_apiNames)) {
            return new TypeError('Expected "array" but received "' + typeof obj_apiNames + '" (at "' + path_apiNames + '")');
          }
          for (let i = 0; i < obj_apiNames.length; i++) {
            const obj_apiNames_item = obj_apiNames[i];
            const path_apiNames_item = path_apiNames + '[' + i + ']';
            if (typeof obj_apiNames_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_apiNames_item + '" (at "' + path_apiNames_item + '")');
            }
          }
        }
        if (obj.formFactor !== undefined) {
          const obj_formFactor = obj.formFactor;
          const path_formFactor = path + '.formFactor';
          if (typeof obj_formFactor !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_formFactor + '" (at "' + path_formFactor + '")');
          }
        }
        const obj_relatedListId = obj.relatedListId;
        const path_relatedListId = path + '.relatedListId';
        if (typeof obj_relatedListId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_relatedListId + '" (at "' + path_relatedListId + '")');
        }
        if (obj.retrievalMode !== undefined) {
          const obj_retrievalMode = obj.retrievalMode;
          const path_retrievalMode = path + '.retrievalMode';
          if (typeof obj_retrievalMode !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_retrievalMode + '" (at "' + path_retrievalMode + '")');
          }
        }
        if (obj.sections !== undefined) {
          const obj_sections = obj.sections;
          const path_sections = path + '.sections';
          if (!ArrayIsArray(obj_sections)) {
            return new TypeError('Expected "array" but received "' + typeof obj_sections + '" (at "' + path_sections + '")');
          }
          for (let i = 0; i < obj_sections.length; i++) {
            const obj_sections_item = obj_sections[i];
            const path_sections_item = path_sections + '[' + i + ']';
            if (typeof obj_sections_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_sections_item + '" (at "' + path_sections_item + '")');
            }
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function select$1l(luvio, params) {
      return select$1C();
    }
    function keyBuilder$1r(luvio, params) {
      return keyPrefix + '::ActionRepresentation:(' + 'recordIds:' + params.urlParams.recordIds + ',' + 'relatedListId:' + params.urlParams.relatedListId + ',' + (params.body.actionTypes === undefined ? 'actionTypes' : 'actionTypes:' + params.body.actionTypes) + '::' + (params.body.apiNames === undefined ? 'apiNames' : 'apiNames:' + params.body.apiNames) + '::' + (params.body.formFactor === undefined ? 'formFactor' : 'formFactor:' + params.body.formFactor) + '::' + (params.body.retrievalMode === undefined ? 'retrievalMode' : 'retrievalMode:' + params.body.retrievalMode) + '::' + (params.body.sections === undefined ? 'sections' : 'sections:' + params.body.sections) + ')';
    }
    function getResponseCacheKeys$P(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$F(storeKeyMap, luvio, response, () => keyBuilder$1r(luvio, resourceParams));
    }
    function ingestSuccess$F(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1r(luvio, resourceParams);
      luvio.storeIngest(key, ingest$y, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1l(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$x(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1r(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$s,
        namespace: keyPrefix,
        version: VERSION$Y,
        representationName: RepresentationType$E
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$S(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/related-list/' + config.urlParams.relatedListId + '',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function createChildResourceParams$9(resourceParams) {
      const childConfigs = [];
      for (let index = 0, len = resourceParams.body.relatedListsActionParameters.length; index < len; index += 1) {
        let childConfig = {
          urlParams: {
            recordIds: resourceParams.urlParams.recordIds,
            relatedListId: resourceParams.body.relatedListsActionParameters[index].relatedListId
          },
          body: {}
        };
        let relatedListConfig = resourceParams.body.relatedListsActionParameters[index];
        // manually populate childConfig body
        if ('apiNames' in relatedListConfig) {
          childConfig.body.apiNames = toSortedStringArrayAllowEmpty(relatedListConfig.apiNames);
        }
        if ('retrievalMode' in relatedListConfig) {
          childConfig.body.retrievalMode = relatedListConfig.retrievalMode;
        }
        if ('formFactor' in relatedListConfig) {
          childConfig.body.formFactor = coerceFormFactor(relatedListConfig.formFactor);
        }
        if ('actionTypes' in relatedListConfig) {
          childConfig.body.actionTypes = relatedListConfig.actionTypes;
        }
        if ('sections' in relatedListConfig) {
          childConfig.body.sections = toSortedStringArray(relatedListConfig.sections);
        }
        childConfigs.push(childConfig);
      }
      return childConfigs;
    }
    const nonCachedErrors$6 = ObjectCreate$1(null);
    function createChildResourceParams$8(resourceParams) {
      return createChildResourceParams$9(resourceParams);
    }
    function selectChildResourceParams$6(luvio, childResources, resourceParams) {
      const envelopeBodyPath = 'result';
      const envelopeStatusCodePath = 'statusCode';
      const envelopePath = 'results';
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: reader => {
          // Top-level 404 lookup
          const result = reader.storeLookup(keyBuilder$1q(luvio, resourceParams));
          if (result.state === reader.StoreResolveResultState.Error && result.value.status === 404) {
            return {
              state: 'Error',
              value: result.value
            };
          }
          const sink = {};
          reader.enterPath(envelopePath);
          const results = [];
          for (let i = 0, len = childResources.length; i < len; i += 1) {
            reader.enterPath(i);
            reader.enterPath(envelopeBodyPath);
            const childResource = childResources[i];
            const childKey = keyBuilder$1r(luvio, childResource);
            const childFragment = select$1l();
            const isMissingDataBeforeChildRead = reader.getIsDataMissing();
            const childSnapshot = reader.read({
              recordId: childKey,
              node: childFragment,
              variables: {}
            });
            reader.exitPath();
            const childSink = {};
            reader.markSeenId(childKey);
            switch (childSnapshot.state) {
              case 'Stale':
                reader.markStale();
              // Stale needs envelope bodies filled in so don't break
              case 'Fulfilled':
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                reader.exitPath();
                break;
              case 'Error':
                const childSnapshotError = childSnapshot.error;
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                reader.exitPath();
                break;
              case 'Unfulfilled':
                // if child snapshot doesn't have any data then
                // that means the child record key is missing
                if (childSnapshot.data === undefined) {
                  if (reader.isRebuilding() === false) {
                    // not a rebuild, mark as missing and move on
                    reader.markMissingLink(childKey);
                    break;
                  }
                  // On rebuilds we have to check if there is a non-cached
                  // error that we know about.  If we don't do this then
                  // rebuilds will go into endless refresh loop if a child
                  // has non-cached errors (since the top-level composite
                  // snapshot will look like an Unfulfilled snapshot
                  // instead of an error snapshot).
                  const nonCachedError = nonCachedErrors$6[childKey];
                  if (nonCachedError === undefined || nonCachedError.expiration < reader.getTimeStamp()) {
                    reader.markMissingLink(childKey);
                  } else {
                    // if this child error was the only reason the reader
                    // is marked as missing then we want to undo that
                    if (isMissingDataBeforeChildRead === false) {
                      reader.unMarkMissing();
                    }
                    // put status code and body into reader path
                    const {
                      response: nonCachedBody,
                      status: nonCachedStatus
                    } = nonCachedError;
                    reader.enterPath(envelopeStatusCodePath);
                    reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                    reader.exitPath();
                    reader.enterPath(envelopeBodyPath);
                    reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                    reader.exitPath();
                  }
                }
                break;
              case 'Pending':
                reader.markPending();
                break;
            }
            ArrayPrototypePush.call(results, childSink);
            reader.exitPath();
          }
          reader.assignNonScalar(sink, envelopePath, results);
          reader.exitPath();
          return sink;
        }
      };
    }
    function select$1k(luvio, resourceParams) {
      const childResources = createChildResourceParams$8(resourceParams);
      return selectChildResourceParams$6(luvio, childResources, resourceParams);
    }
    function keyBuilder$1q(luvio, params) {
      return keyPrefix + '::ActionRelatedListsCollectionBatchRepresentation:(' + 'recordIds:' + params.urlParams.recordIds + ',' + '[' + params.body.relatedListsActionParameters.map(element => (element.actionTypes === undefined ? 'relatedListsActionParameters.actionTypes' : 'relatedListsActionParameters.actionTypes:' + element.actionTypes) + '::' + (element.apiNames === undefined ? 'relatedListsActionParameters.apiNames' : 'relatedListsActionParameters.apiNames:' + element.apiNames) + '::' + (element.formFactor === undefined ? 'relatedListsActionParameters.formFactor' : 'relatedListsActionParameters.formFactor:' + element.formFactor) + '::' + 'relatedListsActionParameters.relatedListId:' + element.relatedListId + '::' + (element.retrievalMode === undefined ? 'relatedListsActionParameters.retrievalMode' : 'relatedListsActionParameters.retrievalMode:' + element.retrievalMode) + '::' + (element.sections === undefined ? 'relatedListsActionParameters.sections' : 'relatedListsActionParameters.sections:' + element.sections)).join(',') + ']' + ')';
    }
    function getResponseCacheKeys$O(keys, luvio, resourceParams, response) {
      const childEnvelopes = response.results;
      const childResourceParamsArray = createChildResourceParams$8(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      // get children keys
      for (let index = 0, len = childResourceParamsArray.length; index < len; index++) {
        const childResourceParams = childResourceParamsArray[index];
        const childResult = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = childResult;
        if (childStatusCode === 200) {
          getResponseCacheKeys$P(keys, luvio, childResourceParams, childBody);
        } else if (childStatusCode === 404) {
          const childKey = keyBuilder$1r(luvio, childResourceParams);
          keys.set(childKey, {
            namespace: keyPrefix,
            representationName: RepresentationType$E,
            mergeable: false
          });
        }
      }
    }
    function ingestSuccessChildResourceParams$7(luvio, childResourceParamsArray, childEnvelopes) {
      const childSnapshotDataResponses = [];
      let seenRecords = new luvioEngine.StoreKeySet();
      let snapshotState = 'Fulfilled';
      const now = Date.now();
      for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$1r(luvio, childResourceParams);
        const result = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = result;
        if (childStatusCode === 200) {
          const childResponse = {
            status: 200,
            body: childBody,
            ok: true,
            statusText: 'OK',
            headers: {}
          };
          const childSnapshot = ingestSuccess$F(luvio, childResourceParams, childResponse);
          if (childSnapshot.state === "Stale") {
            snapshotState = "Stale";
          }
          seenRecords.merge(childSnapshot.seenRecords);
          seenRecords.add(childSnapshot.recordId);
          const childValue = {
            statusCode: 200,
            result: childSnapshot.data
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        } else {
          const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
          const childResponse = {
            status: childStatusCode,
            body: childBody,
            ok: false,
            statusText: childStatusCodeText,
            headers: {},
            errorType: 'fetchResponse'
          };
          ingestError$x(luvio, childResourceParams, childResponse);
          seenRecords.add(childKey);
          const childValue = {
            statusCode: childStatusCode,
            result: childBody
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
          nonCachedErrors$6[childKey] = {
            expiration: now + TTL$s,
            response: childBody,
            status: childStatusCode
          };
        } else {
          delete nonCachedErrors$6[childKey];
        }
      }
      const childSnapshotData = {
        results: childSnapshotDataResponses
      };
      luvioEngine.deepFreeze(childSnapshotData);
      return {
        childSnapshotData: childSnapshotData,
        seenRecords,
        snapshotState
      };
    }
    function ingestSuccess$E(luvio, resourceParams, response, snapshotRefresh) {
      const childEnvelopes = response.body.results;
      const childResourceParamsArray = createChildResourceParams$8(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      const key = keyBuilder$1q(luvio, resourceParams);
      const {
        childSnapshotData,
        seenRecords,
        snapshotState
      } = ingestSuccessChildResourceParams$7(luvio, childResourceParamsArray, childEnvelopes);
      const syntheticSnapshot = {
        recordId: key,
        data: childSnapshotData,
        state: snapshotState,
        seenRecords: seenRecords,
        select: {
          recordId: key,
          node: select$1k(luvio, resourceParams),
          variables: {}
        },
        refresh: snapshotRefresh,
        variables: {}
      };
      // evict top level composite record from the store. This covers the case where a previous resource request returned a 404.
      luvio.storeEvict(key);
      return syntheticSnapshot;
    }
    function ingestError$w(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1q(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$R(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/related-list/batch',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$P = 'getRelatedListsActions';
    const getRelatedListsActions_ConfigPropertyMetadata = [generateParamConfigMetadata('recordIds', true, 0 /* UrlParameter */, 0 /* String */, true, getRecordId18Array), generateParamConfigMetadata('relatedListsActionParameters', true, 2 /* Body */, 4 /* Unsupported */, true)];
    const getRelatedListsActions_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$P, getRelatedListsActions_ConfigPropertyMetadata);
    const createResourceParams$N = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListsActions_ConfigPropertyMetadata);
    function keyBuilder$1p(luvio, config) {
      const resourceParams = createResourceParams$N(config);
      return keyBuilder$1q(luvio, resourceParams);
    }
    function typeCheckConfig$T(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListsActions_ConfigPropertyMetadata);
      const untrustedConfig_relatedListsActionParameters = untrustedConfig.relatedListsActionParameters;
      if (ArrayIsArray$1(untrustedConfig_relatedListsActionParameters)) {
        const untrustedConfig_relatedListsActionParameters_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedListsActionParameters.length; i < arrayLength; i++) {
          const untrustedConfig_relatedListsActionParameters_item = untrustedConfig_relatedListsActionParameters[i];
          const referenceActionRelatedListSingleBatchInputRepresentationValidationError = validate$1k(untrustedConfig_relatedListsActionParameters_item);
          if (referenceActionRelatedListSingleBatchInputRepresentationValidationError === null) {
            untrustedConfig_relatedListsActionParameters_array.push(untrustedConfig_relatedListsActionParameters_item);
          }
        }
        config.relatedListsActionParameters = untrustedConfig_relatedListsActionParameters_array;
      }
      return config;
    }
    function validateAdapterConfig$V(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRelatedListsActions_ConfigPropertyMetadata);
      const config = typeCheckConfig$T(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$w(luvio, config) {
      const resourceParams = createResourceParams$N(config);
      return select$1k(luvio, resourceParams);
    }
    function onFetchResponseSuccess$A(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$E(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$S(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$A(luvio, config, resourceParams, response) {
      const snapshot = ingestError$w(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$S(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$S(luvio, config, options) {
      const resourceParams = createResourceParams$N(config);
      const request = createResourceRequest$R(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$A(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$O(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$A(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$E(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$S, 'get', false);
    }
    function buildCachedSnapshotCachePolicy$D(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1p(luvio, config),
        node: adapterFragment$w(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$S(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRelatedListsActionsAdapterFactory = luvio => function UiApi__getRelatedListsActions(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$V(untrustedConfig, getRelatedListsActions_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$D, buildNetworkSnapshotCachePolicy$E);
    };
    const adapterName$O = 'getRelatedListActions';
    const getRelatedListActions_ConfigPropertyMetadata = [generateParamConfigMetadata('recordIds', true, 0 /* UrlParameter */, 0 /* String */, true, getRecordId18Array), generateParamConfigMetadata('relatedListId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('actionTypes', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('apiNames', false, 2 /* Body */, 0 /* String */, true, toSortedStringArrayAllowEmpty), generateParamConfigMetadata('formFactor', false, 2 /* Body */, 0 /* String */, false, coerceFormFactor), generateParamConfigMetadata('retrievalMode', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('sections', false, 2 /* Body */, 0 /* String */, true, toSortedStringArray)];
    const getRelatedListActions_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$O, getRelatedListActions_ConfigPropertyMetadata);
    const createResourceParams$M = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListActions_ConfigPropertyMetadata);
    function keyBuilder$1o(luvio, config) {
      const resourceParams = createResourceParams$M(config);
      return keyBuilder$1r(luvio, resourceParams);
    }
    function typeCheckConfig$S(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListActions_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$U(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRelatedListActions_ConfigPropertyMetadata);
      const config = typeCheckConfig$S(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$v(luvio, config) {
      createResourceParams$M(config);
      return select$1l();
    }
    function onFetchResponseSuccess$z(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$F(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$R(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$z(luvio, config, resourceParams, response) {
      const snapshot = ingestError$x(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$R(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$R(luvio, config, options) {
      const resourceParams = createResourceParams$M(config);
      const request = createResourceRequest$S(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$z(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$P(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$z(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$D(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$R, 'get', false);
    }
    function buildCachedSnapshotCachePolicy$C(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1o(luvio, config),
        node: adapterFragment$v(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$R(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRelatedListActionsAdapterFactory = luvio => function UiApi__getRelatedListActions(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$U(untrustedConfig, getRelatedListActions_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$C, buildNetworkSnapshotCachePolicy$D);
    };
    function select$1j(luvio, params) {
      return select$1C();
    }
    function keyBuilder$1n(luvio, params) {
      return keyPrefix + '::ActionRepresentation:(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ',' + 'relatedListRecordIds:' + params.urlParams.relatedListRecordIds + ')';
    }
    function getResponseCacheKeys$N(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$F(storeKeyMap, luvio, response, () => keyBuilder$1n(luvio, resourceParams));
    }
    function ingestSuccess$D(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1n(luvio, resourceParams);
      luvio.storeIngest(key, ingest$y, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1j(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$v(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1n(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$s,
        namespace: keyPrefix,
        version: VERSION$Y,
        representationName: RepresentationType$E
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$Q(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/related-list-record/' + config.urlParams.relatedListRecordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$N = 'getRelatedListRecordActions';
    const getRelatedListRecordActions_ConfigPropertyMetadata = [generateParamConfigMetadata('recordIds', true, 0 /* UrlParameter */, 0 /* String */, true, getRecordId18Array), generateParamConfigMetadata('relatedListRecordIds', true, 0 /* UrlParameter */, 0 /* String */, true, getRecordId18Array), generateParamConfigMetadata('actionTypes', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */, false, coerceFormFactor), generateParamConfigMetadata('sections', false, 1 /* QueryParameter */, 0 /* String */, true, toSortedStringArray)];
    const getRelatedListRecordActions_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$N, getRelatedListRecordActions_ConfigPropertyMetadata);
    const createResourceParams$L = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListRecordActions_ConfigPropertyMetadata);
    function keyBuilder$1m(luvio, config) {
      const resourceParams = createResourceParams$L(config);
      return keyBuilder$1n(luvio, resourceParams);
    }
    function typeCheckConfig$R(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListRecordActions_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$T(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRelatedListRecordActions_ConfigPropertyMetadata);
      const config = typeCheckConfig$R(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$u(luvio, config) {
      createResourceParams$L(config);
      return select$1j();
    }
    function onFetchResponseSuccess$y(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$D(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$Q(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$y(luvio, config, resourceParams, response) {
      const snapshot = ingestError$v(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$Q(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$Q(luvio, config, options) {
      const resourceParams = createResourceParams$L(config);
      const request = createResourceRequest$Q(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$y(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$N(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$y(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$C(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$Q, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$B(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1m(luvio, config),
        node: adapterFragment$u(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$Q(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRelatedListRecordActionsAdapterFactory = luvio => function UiApi__getRelatedListRecordActions(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$T(untrustedConfig, getRelatedListRecordActions_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$B, buildNetworkSnapshotCachePolicy$C);
    };
    const VERSION$Q = "a316b3bba367f54adc67d7552ed7d36d";
    function validate$1j(obj, path = 'PageReferenceRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_attributes = obj.attributes;
        const path_attributes = path + '.attributes';
        if (typeof obj_attributes !== 'object' || ArrayIsArray(obj_attributes) || obj_attributes === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_attributes + '" (at "' + path_attributes + '")');
        }
        const obj_attributes_keys = ObjectKeys(obj_attributes);
        for (let i = 0; i < obj_attributes_keys.length; i++) {
          const key = obj_attributes_keys[i];
          const obj_attributes_prop = obj_attributes[key];
          const path_attributes_prop = path_attributes + '["' + key + '"]';
          if (obj_attributes_prop === undefined) {
            return new TypeError('Expected "defined" but received "' + typeof obj_attributes_prop + '" (at "' + path_attributes_prop + '")');
          }
        }
        const obj_state = obj.state;
        const path_state = path + '.state';
        if (typeof obj_state !== 'object' || ArrayIsArray(obj_state) || obj_state === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_state + '" (at "' + path_state + '")');
        }
        const obj_state_keys = ObjectKeys(obj_state);
        for (let i = 0; i < obj_state_keys.length; i++) {
          const key = obj_state_keys[i];
          const obj_state_prop = obj_state[key];
          const path_state_prop = path_state + '["' + key + '"]';
          if (typeof obj_state_prop !== 'object' || ArrayIsArray(obj_state_prop) || obj_state_prop === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_state_prop + '" (at "' + path_state_prop + '")');
          }
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$z = 'PageReferenceRepresentation';
    function normalize$t(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1i = function PageReferenceRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$Q,
        private: [],
        opaque: true
      };
    };
    function equals$G(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$t = function PageReferenceRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1j(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$t, "UiApi", VERSION$Q, RepresentationType$z, equals$G);
      return createLink(key);
    };
    function getTypeCacheKeys$A(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$z,
        mergeable: false
      });
    }
    const TTL$o = 120000;
    const VERSION$P = "09884ca5bf90ea4662092a4e48817081";
    function validate$1i(obj, path = 'NavItemRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_availableInClassic = obj.availableInClassic;
        const path_availableInClassic = path + '.availableInClassic';
        if (typeof obj_availableInClassic !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_availableInClassic + '" (at "' + path_availableInClassic + '")');
        }
        const obj_availableInLightning = obj.availableInLightning;
        const path_availableInLightning = path + '.availableInLightning';
        if (typeof obj_availableInLightning !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_availableInLightning + '" (at "' + path_availableInLightning + '")');
        }
        const obj_color = obj.color;
        const path_color = path + '.color';
        if (typeof obj_color !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_color + '" (at "' + path_color + '")');
        }
        const obj_content = obj.content;
        const path_content = path + '.content';
        let obj_content_union0 = null;
        const obj_content_union0_error = (() => {
          if (typeof obj_content !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_content + '" (at "' + path_content + '")');
          }
        })();
        if (obj_content_union0_error != null) {
          obj_content_union0 = obj_content_union0_error.message;
        }
        let obj_content_union1 = null;
        const obj_content_union1_error = (() => {
          if (obj_content !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_content + '" (at "' + path_content + '")');
          }
        })();
        if (obj_content_union1_error != null) {
          obj_content_union1 = obj_content_union1_error.message;
        }
        if (obj_content_union0 && obj_content_union1) {
          let message = 'Object doesn\'t match union (at "' + path_content + '")';
          message += '\n' + obj_content_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_content_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_custom = obj.custom;
        const path_custom = path + '.custom';
        if (typeof obj_custom !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_custom + '" (at "' + path_custom + '")');
        }
        const obj_developerName = obj.developerName;
        const path_developerName = path + '.developerName';
        if (typeof obj_developerName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_developerName + '" (at "' + path_developerName + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        if (typeof obj_iconUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
          if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union0_error != null) {
          obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
          if (obj_id !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union1_error != null) {
          obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
          let message = 'Object doesn\'t match union (at "' + path_id + '")';
          message += '\n' + obj_id_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_id_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_itemType = obj.itemType;
        const path_itemType = path + '.itemType';
        if (typeof obj_itemType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_itemType + '" (at "' + path_itemType + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_objectLabel = obj.objectLabel;
        const path_objectLabel = path + '.objectLabel';
        let obj_objectLabel_union0 = null;
        const obj_objectLabel_union0_error = (() => {
          if (typeof obj_objectLabel !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectLabel + '" (at "' + path_objectLabel + '")');
          }
        })();
        if (obj_objectLabel_union0_error != null) {
          obj_objectLabel_union0 = obj_objectLabel_union0_error.message;
        }
        let obj_objectLabel_union1 = null;
        const obj_objectLabel_union1_error = (() => {
          if (obj_objectLabel !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_objectLabel + '" (at "' + path_objectLabel + '")');
          }
        })();
        if (obj_objectLabel_union1_error != null) {
          obj_objectLabel_union1 = obj_objectLabel_union1_error.message;
        }
        if (obj_objectLabel_union0 && obj_objectLabel_union1) {
          let message = 'Object doesn\'t match union (at "' + path_objectLabel + '")';
          message += '\n' + obj_objectLabel_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_objectLabel_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_objectLabelPlural = obj.objectLabelPlural;
        const path_objectLabelPlural = path + '.objectLabelPlural';
        let obj_objectLabelPlural_union0 = null;
        const obj_objectLabelPlural_union0_error = (() => {
          if (typeof obj_objectLabelPlural !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectLabelPlural + '" (at "' + path_objectLabelPlural + '")');
          }
        })();
        if (obj_objectLabelPlural_union0_error != null) {
          obj_objectLabelPlural_union0 = obj_objectLabelPlural_union0_error.message;
        }
        let obj_objectLabelPlural_union1 = null;
        const obj_objectLabelPlural_union1_error = (() => {
          if (obj_objectLabelPlural !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_objectLabelPlural + '" (at "' + path_objectLabelPlural + '")');
          }
        })();
        if (obj_objectLabelPlural_union1_error != null) {
          obj_objectLabelPlural_union1 = obj_objectLabelPlural_union1_error.message;
        }
        if (obj_objectLabelPlural_union0 && obj_objectLabelPlural_union1) {
          let message = 'Object doesn\'t match union (at "' + path_objectLabelPlural + '")';
          message += '\n' + obj_objectLabelPlural_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_objectLabelPlural_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_pageReference = obj.pageReference;
        const path_pageReference = path + '.pageReference';
        let obj_pageReference_union0 = null;
        const obj_pageReference_union0_error = (() => {
          if (typeof obj_pageReference !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_pageReference + '" (at "' + path_pageReference + '")');
          }
        })();
        if (obj_pageReference_union0_error != null) {
          obj_pageReference_union0 = obj_pageReference_union0_error.message;
        }
        let obj_pageReference_union1 = null;
        const obj_pageReference_union1_error = (() => {
          if (obj_pageReference !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_pageReference + '" (at "' + path_pageReference + '")');
          }
        })();
        if (obj_pageReference_union1_error != null) {
          obj_pageReference_union1 = obj_pageReference_union1_error.message;
        }
        if (obj_pageReference_union0 && obj_pageReference_union1) {
          let message = 'Object doesn\'t match union (at "' + path_pageReference + '")';
          message += '\n' + obj_pageReference_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_pageReference_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_standardType = obj.standardType;
        const path_standardType = path + '.standardType';
        let obj_standardType_union0 = null;
        const obj_standardType_union0_error = (() => {
          if (typeof obj_standardType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_standardType + '" (at "' + path_standardType + '")');
          }
        })();
        if (obj_standardType_union0_error != null) {
          obj_standardType_union0 = obj_standardType_union0_error.message;
        }
        let obj_standardType_union1 = null;
        const obj_standardType_union1_error = (() => {
          if (obj_standardType !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_standardType + '" (at "' + path_standardType + '")');
          }
        })();
        if (obj_standardType_union1_error != null) {
          obj_standardType_union1 = obj_standardType_union1_error.message;
        }
        if (obj_standardType_union0 && obj_standardType_union1) {
          let message = 'Object doesn\'t match union (at "' + path_standardType + '")';
          message += '\n' + obj_standardType_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_standardType_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$y = 'NavItemRepresentation';
    function keyBuilder$1l(luvio, config) {
      return keyPrefix + '::' + RepresentationType$y + ':' + config.developerName;
    }
    function keyBuilderFromType$m(luvio, object) {
      const keyParams = {
        developerName: object.developerName
      };
      return keyBuilder$1l(luvio, keyParams);
    }
    function normalize$s(input, existing, path, luvio, store, timestamp) {
      const input_pageReference = input.pageReference;
      const input_pageReference_id = path.fullPath + '__pageReference';
      if (input_pageReference !== null && typeof input_pageReference === 'object') {
        input.pageReference = ingest$t(input_pageReference, {
          fullPath: input_pageReference_id,
          propertyName: 'pageReference',
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1h = function NavItemRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$P,
        private: [],
        selections: [{
          name: 'availableInClassic',
          kind: 'Scalar'
        }, {
          name: 'availableInLightning',
          kind: 'Scalar'
        }, {
          name: 'color',
          kind: 'Scalar'
        }, {
          name: 'content',
          kind: 'Scalar'
        }, {
          name: 'custom',
          kind: 'Scalar'
        }, {
          name: 'developerName',
          kind: 'Scalar'
        }, {
          name: 'iconUrl',
          kind: 'Scalar'
        }, {
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'itemType',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'objectApiName',
          kind: 'Scalar'
        }, {
          name: 'objectLabel',
          kind: 'Scalar'
        }, {
          name: 'objectLabelPlural',
          kind: 'Scalar'
        }, {
          name: 'pageReference',
          kind: 'Link',
          nullable: true,
          fragment: select$1i()
        }, {
          name: 'standardType',
          kind: 'Scalar'
        }]
      };
    };
    function equals$F(existing, incoming) {
      const existing_availableInClassic = existing.availableInClassic;
      const incoming_availableInClassic = incoming.availableInClassic;
      if (!(existing_availableInClassic === incoming_availableInClassic)) {
        return false;
      }
      const existing_availableInLightning = existing.availableInLightning;
      const incoming_availableInLightning = incoming.availableInLightning;
      if (!(existing_availableInLightning === incoming_availableInLightning)) {
        return false;
      }
      const existing_custom = existing.custom;
      const incoming_custom = incoming.custom;
      if (!(existing_custom === incoming_custom)) {
        return false;
      }
      const existing_color = existing.color;
      const incoming_color = incoming.color;
      if (!(existing_color === incoming_color)) {
        return false;
      }
      const existing_developerName = existing.developerName;
      const incoming_developerName = incoming.developerName;
      if (!(existing_developerName === incoming_developerName)) {
        return false;
      }
      const existing_iconUrl = existing.iconUrl;
      const incoming_iconUrl = incoming.iconUrl;
      if (!(existing_iconUrl === incoming_iconUrl)) {
        return false;
      }
      const existing_itemType = existing.itemType;
      const incoming_itemType = incoming.itemType;
      if (!(existing_itemType === incoming_itemType)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      const existing_objectApiName = existing.objectApiName;
      const incoming_objectApiName = incoming.objectApiName;
      if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
      }
      const existing_content = existing.content;
      const incoming_content = incoming.content;
      if (!(existing_content === incoming_content)) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_objectLabel = existing.objectLabel;
      const incoming_objectLabel = incoming.objectLabel;
      if (!(existing_objectLabel === incoming_objectLabel)) {
        return false;
      }
      const existing_objectLabelPlural = existing.objectLabelPlural;
      const incoming_objectLabelPlural = incoming.objectLabelPlural;
      if (!(existing_objectLabelPlural === incoming_objectLabelPlural)) {
        return false;
      }
      const existing_pageReference = existing.pageReference;
      const incoming_pageReference = incoming.pageReference;
      if (!(existing_pageReference === incoming_pageReference || existing_pageReference != null && incoming_pageReference != null && existing_pageReference.__ref != null && incoming_pageReference.__ref != null && existing_pageReference.__ref === incoming_pageReference.__ref)) {
        return false;
      }
      const existing_standardType = existing.standardType;
      const incoming_standardType = incoming.standardType;
      if (!(existing_standardType === incoming_standardType)) {
        return false;
      }
      return true;
    }
    const ingest$s = function NavItemRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1i(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$m(luvio, input);
      const ttlToUse = TTL$o;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$s, "UiApi", VERSION$P, RepresentationType$y, equals$F);
      return createLink(key);
    };
    function getTypeCacheKeys$z(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$m(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$y,
        mergeable: false
      });
      if (input.pageReference !== null && typeof input.pageReference === 'object') {
        getTypeCacheKeys$A(rootKeySet, luvio, input.pageReference, () => rootKey + "__" + "pageReference");
      }
    }
    const TTL$n = 300000;
    const VERSION$O = "0cd492fdd6c713c206ef53dc02175f71";
    function validate$1h(obj, path = 'AppRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_appId = obj.appId;
        const path_appId = path + '.appId';
        let obj_appId_union0 = null;
        const obj_appId_union0_error = (() => {
          if (typeof obj_appId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_appId + '" (at "' + path_appId + '")');
          }
        })();
        if (obj_appId_union0_error != null) {
          obj_appId_union0 = obj_appId_union0_error.message;
        }
        let obj_appId_union1 = null;
        const obj_appId_union1_error = (() => {
          if (obj_appId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_appId + '" (at "' + path_appId + '")');
          }
        })();
        if (obj_appId_union1_error != null) {
          obj_appId_union1 = obj_appId_union1_error.message;
        }
        if (obj_appId_union0 && obj_appId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_appId + '")';
          message += '\n' + obj_appId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_appId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_description = obj.description;
        const path_description = path + '.description';
        let obj_description_union0 = null;
        const obj_description_union0_error = (() => {
          if (typeof obj_description !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_description + '" (at "' + path_description + '")');
          }
        })();
        if (obj_description_union0_error != null) {
          obj_description_union0 = obj_description_union0_error.message;
        }
        let obj_description_union1 = null;
        const obj_description_union1_error = (() => {
          if (obj_description !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_description + '" (at "' + path_description + '")');
          }
        })();
        if (obj_description_union1_error != null) {
          obj_description_union1 = obj_description_union1_error.message;
        }
        if (obj_description_union0 && obj_description_union1) {
          let message = 'Object doesn\'t match union (at "' + path_description + '")';
          message += '\n' + obj_description_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_description_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_developerName = obj.developerName;
        const path_developerName = path + '.developerName';
        if (typeof obj_developerName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_developerName + '" (at "' + path_developerName + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_formFactors = obj.formFactors;
        const path_formFactors = path + '.formFactors';
        if (!ArrayIsArray(obj_formFactors)) {
          return new TypeError('Expected "array" but received "' + typeof obj_formFactors + '" (at "' + path_formFactors + '")');
        }
        for (let i = 0; i < obj_formFactors.length; i++) {
          const obj_formFactors_item = obj_formFactors[i];
          const path_formFactors_item = path_formFactors + '[' + i + ']';
          if (typeof obj_formFactors_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_formFactors_item + '" (at "' + path_formFactors_item + '")');
          }
        }
        const obj_headerColor = obj.headerColor;
        const path_headerColor = path + '.headerColor';
        let obj_headerColor_union0 = null;
        const obj_headerColor_union0_error = (() => {
          if (typeof obj_headerColor !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_headerColor + '" (at "' + path_headerColor + '")');
          }
        })();
        if (obj_headerColor_union0_error != null) {
          obj_headerColor_union0 = obj_headerColor_union0_error.message;
        }
        let obj_headerColor_union1 = null;
        const obj_headerColor_union1_error = (() => {
          if (obj_headerColor !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_headerColor + '" (at "' + path_headerColor + '")');
          }
        })();
        if (obj_headerColor_union1_error != null) {
          obj_headerColor_union1 = obj_headerColor_union1_error.message;
        }
        if (obj_headerColor_union0 && obj_headerColor_union1) {
          let message = 'Object doesn\'t match union (at "' + path_headerColor + '")';
          message += '\n' + obj_headerColor_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_headerColor_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        let obj_iconUrl_union0 = null;
        const obj_iconUrl_union0_error = (() => {
          if (typeof obj_iconUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
          }
        })();
        if (obj_iconUrl_union0_error != null) {
          obj_iconUrl_union0 = obj_iconUrl_union0_error.message;
        }
        let obj_iconUrl_union1 = null;
        const obj_iconUrl_union1_error = (() => {
          if (obj_iconUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
          }
        })();
        if (obj_iconUrl_union1_error != null) {
          obj_iconUrl_union1 = obj_iconUrl_union1_error.message;
        }
        if (obj_iconUrl_union0 && obj_iconUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_iconUrl + '")';
          message += '\n' + obj_iconUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_iconUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_isNavAutoTempTabsDisabled = obj.isNavAutoTempTabsDisabled;
        const path_isNavAutoTempTabsDisabled = path + '.isNavAutoTempTabsDisabled';
        if (typeof obj_isNavAutoTempTabsDisabled !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isNavAutoTempTabsDisabled + '" (at "' + path_isNavAutoTempTabsDisabled + '")');
        }
        const obj_isNavPersonalizationDisabled = obj.isNavPersonalizationDisabled;
        const path_isNavPersonalizationDisabled = path + '.isNavPersonalizationDisabled';
        if (typeof obj_isNavPersonalizationDisabled !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isNavPersonalizationDisabled + '" (at "' + path_isNavPersonalizationDisabled + '")');
        }
        const obj_isNavTabPersistenceDisabled = obj.isNavTabPersistenceDisabled;
        const path_isNavTabPersistenceDisabled = path + '.isNavTabPersistenceDisabled';
        if (typeof obj_isNavTabPersistenceDisabled !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isNavTabPersistenceDisabled + '" (at "' + path_isNavTabPersistenceDisabled + '")');
        }
        const obj_isOmniPinnedViewEnabled = obj.isOmniPinnedViewEnabled;
        const path_isOmniPinnedViewEnabled = path + '.isOmniPinnedViewEnabled';
        if (typeof obj_isOmniPinnedViewEnabled !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isOmniPinnedViewEnabled + '" (at "' + path_isOmniPinnedViewEnabled + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_logoUrl = obj.logoUrl;
        const path_logoUrl = path + '.logoUrl';
        if (typeof obj_logoUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_logoUrl + '" (at "' + path_logoUrl + '")');
        }
        const obj_mobileStartUrl = obj.mobileStartUrl;
        const path_mobileStartUrl = path + '.mobileStartUrl';
        let obj_mobileStartUrl_union0 = null;
        const obj_mobileStartUrl_union0_error = (() => {
          if (typeof obj_mobileStartUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_mobileStartUrl + '" (at "' + path_mobileStartUrl + '")');
          }
        })();
        if (obj_mobileStartUrl_union0_error != null) {
          obj_mobileStartUrl_union0 = obj_mobileStartUrl_union0_error.message;
        }
        let obj_mobileStartUrl_union1 = null;
        const obj_mobileStartUrl_union1_error = (() => {
          if (obj_mobileStartUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_mobileStartUrl + '" (at "' + path_mobileStartUrl + '")');
          }
        })();
        if (obj_mobileStartUrl_union1_error != null) {
          obj_mobileStartUrl_union1 = obj_mobileStartUrl_union1_error.message;
        }
        if (obj_mobileStartUrl_union0 && obj_mobileStartUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_mobileStartUrl + '")';
          message += '\n' + obj_mobileStartUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_mobileStartUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_navItems = obj.navItems;
        const path_navItems = path + '.navItems';
        if (!ArrayIsArray(obj_navItems)) {
          return new TypeError('Expected "array" but received "' + typeof obj_navItems + '" (at "' + path_navItems + '")');
        }
        for (let i = 0; i < obj_navItems.length; i++) {
          const obj_navItems_item = obj_navItems[i];
          const path_navItems_item = path_navItems + '[' + i + ']';
          if (typeof obj_navItems_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_navItems_item + '" (at "' + path_navItems_item + '")');
          }
        }
        const obj_selected = obj.selected;
        const path_selected = path + '.selected';
        if (typeof obj_selected !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_selected + '" (at "' + path_selected + '")');
        }
        const obj_startUrl = obj.startUrl;
        const path_startUrl = path + '.startUrl';
        if (typeof obj_startUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_startUrl + '" (at "' + path_startUrl + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
        const obj_userNavItems = obj.userNavItems;
        const path_userNavItems = path + '.userNavItems';
        if (!ArrayIsArray(obj_userNavItems)) {
          return new TypeError('Expected "array" but received "' + typeof obj_userNavItems + '" (at "' + path_userNavItems + '")');
        }
        for (let i = 0; i < obj_userNavItems.length; i++) {
          const obj_userNavItems_item = obj_userNavItems[i];
          const path_userNavItems_item = path_userNavItems + '[' + i + ']';
          if (typeof obj_userNavItems_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_userNavItems_item + '" (at "' + path_userNavItems_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$x = 'AppRepresentation';
    function keyBuilder$1k(luvio, config) {
      return keyPrefix + '::' + RepresentationType$x + ':' + (config.appId === null ? '' : config.appId);
    }
    function keyBuilderFromType$l(luvio, object) {
      const keyParams = {
        appId: object.appId
      };
      return keyBuilder$1k(luvio, keyParams);
    }
    function normalize$r(input, existing, path, luvio, store, timestamp) {
      const input_navItems = input.navItems;
      const input_navItems_id = path.fullPath + '__navItems';
      for (let i = 0; i < input_navItems.length; i++) {
        const input_navItems_item = input_navItems[i];
        let input_navItems_item_id = input_navItems_id + '__' + i;
        input_navItems[i] = ingest$s(input_navItems_item, {
          fullPath: input_navItems_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      const input_userNavItems = input.userNavItems;
      const input_userNavItems_id = path.fullPath + '__userNavItems';
      for (let i = 0; i < input_userNavItems.length; i++) {
        const input_userNavItems_item = input_userNavItems[i];
        let input_userNavItems_item_id = input_userNavItems_id + '__' + i;
        input_userNavItems[i] = ingest$s(input_userNavItems_item, {
          fullPath: input_userNavItems_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1g = function AppRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$O,
        private: ['eTag'],
        selections: [{
          name: 'appId',
          kind: 'Scalar'
        }, {
          name: 'description',
          kind: 'Scalar'
        }, {
          name: 'developerName',
          kind: 'Scalar'
        }, {
          name: 'formFactors',
          kind: 'Scalar',
          plural: true
        }, {
          name: 'headerColor',
          kind: 'Scalar'
        }, {
          name: 'iconUrl',
          kind: 'Scalar'
        }, {
          name: 'isNavAutoTempTabsDisabled',
          kind: 'Scalar'
        }, {
          name: 'isNavPersonalizationDisabled',
          kind: 'Scalar'
        }, {
          name: 'isNavTabPersistenceDisabled',
          kind: 'Scalar'
        }, {
          name: 'isOmniPinnedViewEnabled',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'logoUrl',
          kind: 'Scalar'
        }, {
          name: 'mobileStartUrl',
          kind: 'Scalar'
        }, {
          name: 'navItems',
          kind: 'Link',
          plural: true,
          fragment: select$1h()
        }, {
          name: 'selected',
          kind: 'Scalar'
        }, {
          name: 'startUrl',
          kind: 'Scalar'
        }, {
          name: 'type',
          kind: 'Scalar'
        }, {
          name: 'userNavItems',
          kind: 'Link',
          plural: true,
          fragment: select$1h()
        }]
      };
    };
    function equals$E(existing, incoming) {
      const existing_isNavAutoTempTabsDisabled = existing.isNavAutoTempTabsDisabled;
      const incoming_isNavAutoTempTabsDisabled = incoming.isNavAutoTempTabsDisabled;
      if (!(existing_isNavAutoTempTabsDisabled === incoming_isNavAutoTempTabsDisabled)) {
        return false;
      }
      const existing_isNavPersonalizationDisabled = existing.isNavPersonalizationDisabled;
      const incoming_isNavPersonalizationDisabled = incoming.isNavPersonalizationDisabled;
      if (!(existing_isNavPersonalizationDisabled === incoming_isNavPersonalizationDisabled)) {
        return false;
      }
      const existing_isNavTabPersistenceDisabled = existing.isNavTabPersistenceDisabled;
      const incoming_isNavTabPersistenceDisabled = incoming.isNavTabPersistenceDisabled;
      if (!(existing_isNavTabPersistenceDisabled === incoming_isNavTabPersistenceDisabled)) {
        return false;
      }
      const existing_isOmniPinnedViewEnabled = existing.isOmniPinnedViewEnabled;
      const incoming_isOmniPinnedViewEnabled = incoming.isOmniPinnedViewEnabled;
      if (!(existing_isOmniPinnedViewEnabled === incoming_isOmniPinnedViewEnabled)) {
        return false;
      }
      const existing_selected = existing.selected;
      const incoming_selected = incoming.selected;
      if (!(existing_selected === incoming_selected)) {
        return false;
      }
      const existing_developerName = existing.developerName;
      const incoming_developerName = incoming.developerName;
      if (!(existing_developerName === incoming_developerName)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      const existing_logoUrl = existing.logoUrl;
      const incoming_logoUrl = incoming.logoUrl;
      if (!(existing_logoUrl === incoming_logoUrl)) {
        return false;
      }
      const existing_startUrl = existing.startUrl;
      const incoming_startUrl = incoming.startUrl;
      if (!(existing_startUrl === incoming_startUrl)) {
        return false;
      }
      const existing_type = existing.type;
      const incoming_type = incoming.type;
      if (!(existing_type === incoming_type)) {
        return false;
      }
      const existing_appId = existing.appId;
      const incoming_appId = incoming.appId;
      if (!(existing_appId === incoming_appId)) {
        return false;
      }
      const existing_description = existing.description;
      const incoming_description = incoming.description;
      if (!(existing_description === incoming_description)) {
        return false;
      }
      const existing_formFactors = existing.formFactors;
      const incoming_formFactors = incoming.formFactors;
      const equals_formFactors_items = equalsArray(existing_formFactors, incoming_formFactors, (existing_formFactors_item, incoming_formFactors_item) => {
        if (!(existing_formFactors_item === incoming_formFactors_item)) {
          return false;
        }
      });
      if (equals_formFactors_items === false) {
        return false;
      }
      const existing_headerColor = existing.headerColor;
      const incoming_headerColor = incoming.headerColor;
      if (!(existing_headerColor === incoming_headerColor)) {
        return false;
      }
      const existing_iconUrl = existing.iconUrl;
      const incoming_iconUrl = incoming.iconUrl;
      if (!(existing_iconUrl === incoming_iconUrl)) {
        return false;
      }
      const existing_mobileStartUrl = existing.mobileStartUrl;
      const incoming_mobileStartUrl = incoming.mobileStartUrl;
      if (!(existing_mobileStartUrl === incoming_mobileStartUrl)) {
        return false;
      }
      const existing_navItems = existing.navItems;
      const incoming_navItems = incoming.navItems;
      const equals_navItems_items = equalsArray(existing_navItems, incoming_navItems, (existing_navItems_item, incoming_navItems_item) => {
        if (!(existing_navItems_item.__ref === incoming_navItems_item.__ref)) {
          return false;
        }
      });
      if (equals_navItems_items === false) {
        return false;
      }
      const existing_userNavItems = existing.userNavItems;
      const incoming_userNavItems = incoming.userNavItems;
      const equals_userNavItems_items = equalsArray(existing_userNavItems, incoming_userNavItems, (existing_userNavItems_item, incoming_userNavItems_item) => {
        if (!(existing_userNavItems_item.__ref === incoming_userNavItems_item.__ref)) {
          return false;
        }
      });
      if (equals_userNavItems_items === false) {
        return false;
      }
      return true;
    }
    const ingest$r = function AppRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1h(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$l(luvio, input);
      const ttlToUse = TTL$n;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$r, "UiApi", VERSION$O, RepresentationType$x, equals$E);
      return createLink(key);
    };
    function getTypeCacheKeys$y(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$l(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$x,
        mergeable: false
      });
      const input_navItems_length = input.navItems.length;
      for (let i = 0; i < input_navItems_length; i++) {
        getTypeCacheKeys$z(rootKeySet, luvio, input.navItems[i]);
      }
      const input_userNavItems_length = input.userNavItems.length;
      for (let i = 0; i < input_userNavItems_length; i++) {
        getTypeCacheKeys$z(rootKeySet, luvio, input.userNavItems[i]);
      }
    }
    const TTL$m = 300000;
    const VERSION$N = "a254babf0b6414315db7808a157fd9fc";
    function validate$1g(obj, path = 'AppsRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apps = obj.apps;
        const path_apps = path + '.apps';
        if (!ArrayIsArray(obj_apps)) {
          return new TypeError('Expected "array" but received "' + typeof obj_apps + '" (at "' + path_apps + '")');
        }
        for (let i = 0; i < obj_apps.length; i++) {
          const obj_apps_item = obj_apps[i];
          const path_apps_item = path_apps + '[' + i + ']';
          if (typeof obj_apps_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_apps_item + '" (at "' + path_apps_item + '")');
          }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$w = 'AppsRepresentation';
    function normalize$q(input, existing, path, luvio, store, timestamp) {
      const input_apps = input.apps;
      const input_apps_id = path.fullPath + '__apps';
      for (let i = 0; i < input_apps.length; i++) {
        const input_apps_item = input_apps[i];
        let input_apps_item_id = input_apps_id + '__' + i;
        input_apps[i] = ingest$r(input_apps_item, {
          fullPath: input_apps_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$1f = function AppsRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$N,
        private: ['eTag'],
        selections: [{
          name: 'apps',
          kind: 'Link',
          plural: true,
          fragment: select$1g()
        }]
      };
    };
    function equals$D(existing, incoming) {
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_apps = existing.apps;
      const incoming_apps = incoming.apps;
      const equals_apps_items = equalsArray(existing_apps, incoming_apps, (existing_apps_item, incoming_apps_item) => {
        if (!(existing_apps_item.__ref === incoming_apps_item.__ref)) {
          return false;
        }
      });
      if (equals_apps_items === false) {
        return false;
      }
      return true;
    }
    const ingest$q = function AppsRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1g(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$m;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$q, "UiApi", VERSION$N, RepresentationType$w, equals$D);
      return createLink(key);
    };
    function getTypeCacheKeys$x(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$w,
        mergeable: false
      });
      const input_apps_length = input.apps.length;
      for (let i = 0; i < input_apps_length; i++) {
        getTypeCacheKeys$y(rootKeySet, luvio, input.apps[i]);
      }
    }
    function select$1e(luvio, params) {
      return select$1f();
    }
    function keyBuilder$1j(luvio, params) {
      return keyPrefix + '::AppsRepresentation:(' + 'formFactor:' + params.queryParams.formFactor + ',' + 'userCustomizations:' + params.queryParams.userCustomizations + ')';
    }
    function getResponseCacheKeys$M(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$x(storeKeyMap, luvio, response, () => keyBuilder$1j(luvio, resourceParams));
    }
    function ingestSuccess$C(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1j(luvio, resourceParams);
      luvio.storeIngest(key, ingest$q, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1e(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$u(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1j(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$m,
        namespace: keyPrefix,
        version: VERSION$N,
        representationName: RepresentationType$w
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$P(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/apps',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$M = 'getAllApps';
    const getAllApps_ConfigPropertyMetadata = [generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */, false, coerceFormFactor), generateParamConfigMetadata('userCustomizations', false, 1 /* QueryParameter */, 1 /* Boolean */)];
    const getAllApps_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$M, getAllApps_ConfigPropertyMetadata);
    const createResourceParams$K = /*#__PURE__*/luvioEngine.createResourceParams(getAllApps_ConfigPropertyMetadata);
    function keyBuilder$1i(luvio, config) {
      const resourceParams = createResourceParams$K(config);
      return keyBuilder$1j(luvio, resourceParams);
    }
    function typeCheckConfig$Q(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getAllApps_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$S(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getAllApps_ConfigPropertyMetadata);
      const config = typeCheckConfig$Q(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$t(luvio, config) {
      createResourceParams$K(config);
      return select$1e();
    }
    function onFetchResponseSuccess$x(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$C(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$P(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$x(luvio, config, resourceParams, response) {
      const snapshot = ingestError$u(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$P(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$P(luvio, config, options) {
      const resourceParams = createResourceParams$K(config);
      const request = createResourceRequest$P(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$x(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$M(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$x(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$B(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$P, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$A(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1i(luvio, config),
        node: adapterFragment$t(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$P(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getAllAppsAdapterFactory = luvio => function UiApi__getAllApps(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$S(untrustedConfig, getAllApps_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$A, buildNetworkSnapshotCachePolicy$B);
    };
    function select$1d(luvio, params) {
      return select$1g();
    }
    function keyBuilder$1h(luvio, params) {
      return keyBuilder$1k(luvio, {
        appId: params.urlParams.appId
      });
    }
    function getResponseCacheKeys$L(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$y(storeKeyMap, luvio, response);
    }
    function ingestSuccess$B(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1h(luvio, resourceParams);
      luvio.storeIngest(key, ingest$r, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1d(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$t(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1h(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$n,
        namespace: keyPrefix,
        version: VERSION$O,
        representationName: RepresentationType$x
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$O(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/apps/' + config.urlParams.appId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$L = 'getAppDetails';
    const getAppDetails_ConfigPropertyMetadata = [generateParamConfigMetadata('appId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */, false, coerceFormFactor), generateParamConfigMetadata('userCustomizations', false, 1 /* QueryParameter */, 1 /* Boolean */)];
    const getAppDetails_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$L, getAppDetails_ConfigPropertyMetadata);
    const createResourceParams$J = /*#__PURE__*/luvioEngine.createResourceParams(getAppDetails_ConfigPropertyMetadata);
    function keyBuilder$1g(luvio, config) {
      const resourceParams = createResourceParams$J(config);
      return keyBuilder$1h(luvio, resourceParams);
    }
    function typeCheckConfig$P(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getAppDetails_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$R(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getAppDetails_ConfigPropertyMetadata);
      const config = typeCheckConfig$P(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$s(luvio, config) {
      createResourceParams$J(config);
      return select$1d();
    }
    function onFetchResponseSuccess$w(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$B(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$O(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$w(luvio, config, resourceParams, response) {
      const snapshot = ingestError$t(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$O(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$O(luvio, config, options) {
      const resourceParams = createResourceParams$J(config);
      const request = createResourceRequest$O(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$w(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$L(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$w(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$A(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$O, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$z(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1g(luvio, config),
        node: adapterFragment$s(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$O(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getAppDetailsAdapterFactory = luvio => function UiApi__getAppDetails(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$R(untrustedConfig, getAppDetails_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$z, buildNetworkSnapshotCachePolicy$A);
    };
    const VERSION$M = "f43ef90ffde4d488414d6868e3aaefcb";
    function validate$1f(obj, path = 'DuplicateRuleFilterItemRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_field = obj.field;
        const path_field = path + '.field';
        if (typeof obj_field !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_field + '" (at "' + path_field + '")');
        }
        const obj_operation = obj.operation;
        const path_operation = path + '.operation';
        if (typeof obj_operation !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_operation + '" (at "' + path_operation + '")');
        }
        const obj_sortOrder = obj.sortOrder;
        const path_sortOrder = path + '.sortOrder';
        if (typeof obj_sortOrder !== 'number' || typeof obj_sortOrder === 'number' && Math.floor(obj_sortOrder) !== obj_sortOrder) {
          return new TypeError('Expected "integer" but received "' + typeof obj_sortOrder + '" (at "' + path_sortOrder + '")');
        }
        const obj_value = obj.value;
        const path_value = path + '.value';
        if (typeof obj_value !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_value + '" (at "' + path_value + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1c = function DuplicateRuleFilterItemRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$M,
        private: ['eTag'],
        selections: [{
          name: 'field',
          kind: 'Scalar'
        }, {
          name: 'operation',
          kind: 'Scalar'
        }, {
          name: 'sortOrder',
          kind: 'Scalar'
        }, {
          name: 'value',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$L = "320d7f254687278f2763d4b490dab3fb";
    function validate$1e(obj, path = 'DuplicateRuleFilterRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_booleanFilter = obj.booleanFilter;
        const path_booleanFilter = path + '.booleanFilter';
        if (typeof obj_booleanFilter !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_booleanFilter + '" (at "' + path_booleanFilter + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_filterItems = obj.filterItems;
        const path_filterItems = path + '.filterItems';
        if (!ArrayIsArray(obj_filterItems)) {
          return new TypeError('Expected "array" but received "' + typeof obj_filterItems + '" (at "' + path_filterItems + '")');
        }
        for (let i = 0; i < obj_filterItems.length; i++) {
          const obj_filterItems_item = obj_filterItems[i];
          const path_filterItems_item = path_filterItems + '[' + i + ']';
          const referencepath_filterItems_itemValidationError = validate$1f(obj_filterItems_item, path_filterItems_item);
          if (referencepath_filterItems_itemValidationError !== null) {
            let message = 'Object doesn\'t match DuplicateRuleFilterItemRepresentation (at "' + path_filterItems_item + '")\n';
            message += referencepath_filterItems_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_ruleCritera = obj.ruleCritera;
        const path_ruleCritera = path + '.ruleCritera';
        if (typeof obj_ruleCritera !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_ruleCritera + '" (at "' + path_ruleCritera + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1b = function DuplicateRuleFilterRepresentationSelect() {
      const {
        selections: DuplicateRuleFilterItemRepresentation__selections,
        opaque: DuplicateRuleFilterItemRepresentation__opaque
      } = select$1c();
      return {
        kind: 'Fragment',
        version: VERSION$L,
        private: ['eTag'],
        selections: [{
          name: 'booleanFilter',
          kind: 'Scalar'
        }, {
          name: 'filterItems',
          kind: 'Object',
          plural: true,
          selections: DuplicateRuleFilterItemRepresentation__selections
        }, {
          name: 'ruleCritera',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$K = "b47b44e260e5ce777beaf3da9088997c";
    function validate$1d(obj, path = 'MatchRuleRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_matchEngine = obj.matchEngine;
        const path_matchEngine = path + '.matchEngine';
        if (typeof obj_matchEngine !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_matchEngine + '" (at "' + path_matchEngine + '")');
        }
        const obj_matchFields = obj.matchFields;
        const path_matchFields = path + '.matchFields';
        if (!ArrayIsArray(obj_matchFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_matchFields + '" (at "' + path_matchFields + '")');
        }
        for (let i = 0; i < obj_matchFields.length; i++) {
          const obj_matchFields_item = obj_matchFields[i];
          const path_matchFields_item = path_matchFields + '[' + i + ']';
          if (typeof obj_matchFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_matchFields_item + '" (at "' + path_matchFields_item + '")');
          }
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1a = function MatchRuleRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$K,
        private: ['eTag'],
        selections: [{
          name: 'matchEngine',
          kind: 'Scalar'
        }, {
          name: 'matchFields',
          kind: 'Scalar',
          plural: true
        }, {
          name: 'name',
          kind: 'Scalar'
        }, {
          name: 'objectApiName',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$J = "bb83d7210bb1d7861b6188bc5f552617";
    function validate$1c(obj, path = 'DuplicateRuleRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actionOnInsert = obj.actionOnInsert;
        const path_actionOnInsert = path + '.actionOnInsert';
        if (typeof obj_actionOnInsert !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_actionOnInsert + '" (at "' + path_actionOnInsert + '")');
        }
        const obj_actionOnUpdate = obj.actionOnUpdate;
        const path_actionOnUpdate = path + '.actionOnUpdate';
        if (typeof obj_actionOnUpdate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_actionOnUpdate + '" (at "' + path_actionOnUpdate + '")');
        }
        const obj_active = obj.active;
        const path_active = path + '.active';
        if (typeof obj_active !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_active + '" (at "' + path_active + '")');
        }
        const obj_duplicateRuleFilters = obj.duplicateRuleFilters;
        const path_duplicateRuleFilters = path + '.duplicateRuleFilters';
        if (!ArrayIsArray(obj_duplicateRuleFilters)) {
          return new TypeError('Expected "array" but received "' + typeof obj_duplicateRuleFilters + '" (at "' + path_duplicateRuleFilters + '")');
        }
        for (let i = 0; i < obj_duplicateRuleFilters.length; i++) {
          const obj_duplicateRuleFilters_item = obj_duplicateRuleFilters[i];
          const path_duplicateRuleFilters_item = path_duplicateRuleFilters + '[' + i + ']';
          const referencepath_duplicateRuleFilters_itemValidationError = validate$1e(obj_duplicateRuleFilters_item, path_duplicateRuleFilters_item);
          if (referencepath_duplicateRuleFilters_itemValidationError !== null) {
            let message = 'Object doesn\'t match DuplicateRuleFilterRepresentation (at "' + path_duplicateRuleFilters_item + '")\n';
            message += referencepath_duplicateRuleFilters_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_matchRules = obj.matchRules;
        const path_matchRules = path + '.matchRules';
        if (!ArrayIsArray(obj_matchRules)) {
          return new TypeError('Expected "array" but received "' + typeof obj_matchRules + '" (at "' + path_matchRules + '")');
        }
        for (let i = 0; i < obj_matchRules.length; i++) {
          const obj_matchRules_item = obj_matchRules[i];
          const path_matchRules_item = path_matchRules + '[' + i + ']';
          const referencepath_matchRules_itemValidationError = validate$1d(obj_matchRules_item, path_matchRules_item);
          if (referencepath_matchRules_itemValidationError !== null) {
            let message = 'Object doesn\'t match MatchRuleRepresentation (at "' + path_matchRules_item + '")\n';
            message += referencepath_matchRules_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_operationsOnInsert = obj.operationsOnInsert;
        const path_operationsOnInsert = path + '.operationsOnInsert';
        if (!ArrayIsArray(obj_operationsOnInsert)) {
          return new TypeError('Expected "array" but received "' + typeof obj_operationsOnInsert + '" (at "' + path_operationsOnInsert + '")');
        }
        for (let i = 0; i < obj_operationsOnInsert.length; i++) {
          const obj_operationsOnInsert_item = obj_operationsOnInsert[i];
          const path_operationsOnInsert_item = path_operationsOnInsert + '[' + i + ']';
          if (typeof obj_operationsOnInsert_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_operationsOnInsert_item + '" (at "' + path_operationsOnInsert_item + '")');
          }
        }
        const obj_operationsOnUpdate = obj.operationsOnUpdate;
        const path_operationsOnUpdate = path + '.operationsOnUpdate';
        if (!ArrayIsArray(obj_operationsOnUpdate)) {
          return new TypeError('Expected "array" but received "' + typeof obj_operationsOnUpdate + '" (at "' + path_operationsOnUpdate + '")');
        }
        for (let i = 0; i < obj_operationsOnUpdate.length; i++) {
          const obj_operationsOnUpdate_item = obj_operationsOnUpdate[i];
          const path_operationsOnUpdate_item = path_operationsOnUpdate + '[' + i + ']';
          if (typeof obj_operationsOnUpdate_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_operationsOnUpdate_item + '" (at "' + path_operationsOnUpdate_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$19 = function DuplicateRuleRepresentationSelect() {
      const {
        selections: DuplicateRuleFilterRepresentation__selections,
        opaque: DuplicateRuleFilterRepresentation__opaque
      } = select$1b();
      const {
        selections: MatchRuleRepresentation__selections,
        opaque: MatchRuleRepresentation__opaque
      } = select$1a();
      return {
        kind: 'Fragment',
        version: VERSION$J,
        private: ['eTag'],
        selections: [{
          name: 'actionOnInsert',
          kind: 'Scalar'
        }, {
          name: 'actionOnUpdate',
          kind: 'Scalar'
        }, {
          name: 'active',
          kind: 'Scalar'
        }, {
          name: 'duplicateRuleFilters',
          kind: 'Object',
          plural: true,
          selections: DuplicateRuleFilterRepresentation__selections
        }, {
          name: 'matchRules',
          kind: 'Object',
          plural: true,
          selections: MatchRuleRepresentation__selections
        }, {
          name: 'name',
          kind: 'Scalar'
        }, {
          name: 'operationsOnInsert',
          kind: 'Scalar',
          plural: true
        }, {
          name: 'operationsOnUpdate',
          kind: 'Scalar',
          plural: true
        }]
      };
    };
    const TTL$l = 900000;
    const VERSION$I = "be27ee99dc0dc43a1f66b8fe98dc532c";
    function validate$1b(obj, path = 'DuplicatesConfigurationRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_dedupeEnabled = obj.dedupeEnabled;
        const path_dedupeEnabled = path + '.dedupeEnabled';
        if (typeof obj_dedupeEnabled !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_dedupeEnabled + '" (at "' + path_dedupeEnabled + '")');
        }
        const obj_dedupeFields = obj.dedupeFields;
        const path_dedupeFields = path + '.dedupeFields';
        if (!ArrayIsArray(obj_dedupeFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_dedupeFields + '" (at "' + path_dedupeFields + '")');
        }
        for (let i = 0; i < obj_dedupeFields.length; i++) {
          const obj_dedupeFields_item = obj_dedupeFields[i];
          const path_dedupeFields_item = path_dedupeFields + '[' + i + ']';
          if (typeof obj_dedupeFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_dedupeFields_item + '" (at "' + path_dedupeFields_item + '")');
          }
        }
        const obj_duplicateRules = obj.duplicateRules;
        const path_duplicateRules = path + '.duplicateRules';
        if (!ArrayIsArray(obj_duplicateRules)) {
          return new TypeError('Expected "array" but received "' + typeof obj_duplicateRules + '" (at "' + path_duplicateRules + '")');
        }
        for (let i = 0; i < obj_duplicateRules.length; i++) {
          const obj_duplicateRules_item = obj_duplicateRules[i];
          const path_duplicateRules_item = path_duplicateRules + '[' + i + ']';
          const referencepath_duplicateRules_itemValidationError = validate$1c(obj_duplicateRules_item, path_duplicateRules_item);
          if (referencepath_duplicateRules_itemValidationError !== null) {
            let message = 'Object doesn\'t match DuplicateRuleRepresentation (at "' + path_duplicateRules_item + '")\n';
            message += referencepath_duplicateRules_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_predupeEnabled = obj.predupeEnabled;
        const path_predupeEnabled = path + '.predupeEnabled';
        if (typeof obj_predupeEnabled !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_predupeEnabled + '" (at "' + path_predupeEnabled + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$v = 'DuplicatesConfigurationRepresentation';
    function normalize$p(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$18 = function DuplicatesConfigurationRepresentationSelect() {
      const {
        selections: DuplicateRuleRepresentation__selections,
        opaque: DuplicateRuleRepresentation__opaque
      } = select$19();
      return {
        kind: 'Fragment',
        version: VERSION$I,
        private: ['eTag'],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'dedupeEnabled',
          kind: 'Scalar'
        }, {
          name: 'dedupeFields',
          kind: 'Scalar',
          plural: true
        }, {
          name: 'duplicateRules',
          kind: 'Object',
          plural: true,
          selections: DuplicateRuleRepresentation__selections
        }, {
          name: 'predupeEnabled',
          kind: 'Scalar'
        }]
      };
    };
    function equals$C(existing, incoming) {
      if (existing.eTag !== incoming.eTag) {
        return false;
      }
      return true;
    }
    const ingest$p = function DuplicatesConfigurationRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$1b(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$l;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$p, "UiApi", VERSION$I, RepresentationType$v, equals$C);
      return createLink(key);
    };
    function getTypeCacheKeys$w(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$v,
        mergeable: false
      });
    }
    function select$17(luvio, params) {
      return select$18();
    }
    function keyBuilder$1f(luvio, params) {
      return keyPrefix + '::DuplicatesConfigurationRepresentation:(' + 'recordTypeId:' + params.queryParams.recordTypeId + ',' + 'objectApiName:' + params.urlParams.objectApiName + ')';
    }
    function getResponseCacheKeys$K(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$w(storeKeyMap, luvio, response, () => keyBuilder$1f(luvio, resourceParams));
    }
    function ingestSuccess$A(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1f(luvio, resourceParams);
      luvio.storeIngest(key, ingest$p, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$17(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$s(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1f(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$l,
        namespace: keyPrefix,
        version: VERSION$I,
        representationName: RepresentationType$v
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$N(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/duplicates/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$K = 'getDuplicateConfiguration';
    const getDuplicateConfiguration_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */)];
    const getDuplicateConfiguration_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$K, getDuplicateConfiguration_ConfigPropertyMetadata);
    const createResourceParams$I = /*#__PURE__*/luvioEngine.createResourceParams(getDuplicateConfiguration_ConfigPropertyMetadata);
    function keyBuilder$1e(luvio, config) {
      const resourceParams = createResourceParams$I(config);
      return keyBuilder$1f(luvio, resourceParams);
    }
    function typeCheckConfig$O(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getDuplicateConfiguration_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$Q(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$O(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$r(luvio, config) {
      createResourceParams$I(config);
      return select$17();
    }
    function onFetchResponseSuccess$v(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$A(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$N(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$v(luvio, config, resourceParams, response) {
      const snapshot = ingestError$s(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$N(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$N(luvio, config, options) {
      const resourceParams = createResourceParams$I(config);
      const request = createResourceRequest$N(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$v(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$K(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$v(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$z(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$N, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$y(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1e(luvio, config),
        node: adapterFragment$r(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$N(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getDuplicateConfigurationAdapterFactory = luvio => function UiApi__getDuplicateConfiguration(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$Q(untrustedConfig, getDuplicateConfiguration_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$y, buildNetworkSnapshotCachePolicy$z);
    };
    var LayoutType;
    (function (LayoutType) {
      LayoutType["Full"] = "Full";
      LayoutType["Compact"] = "Compact";
    })(LayoutType || (LayoutType = {}));
    function coerceLayoutType(value) {
      if (value === LayoutType.Full || value === LayoutType.Compact) {
        return value;
      }
      return undefined;
    }
    function coerceLayoutMode(value) {
      if (value === LayoutMode.Create || value === LayoutMode.Edit || value === LayoutMode.View) {
        return value;
      }
      return undefined;
    }
    function keyBuilder$1d(luvio, params) {
      return keyPrefix + '::RecordLayoutRepresentation:(' + 'formFactor:' + params.queryParams.formFactor + ',' + 'layoutType:' + params.queryParams.layoutType + ',' + 'mode:' + params.queryParams.mode + ',' + 'recordTypeId:' + params.queryParams.recordTypeId + ',' + 'objectApiName:' + params.urlParams.objectApiName + ')';
    }
    function getResponseCacheKeys$J(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$N(storeKeyMap, luvio, response);
    }
    function ingestError$r(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1d(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$w,
        namespace: keyPrefix,
        version: VERSION$15,
        representationName: RepresentationType$N
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$M(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/layout/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function onFetchResponseSuccess$u(luvio, config, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilder$1V(luvio, config);
      luvio.storeIngest(key, ingest$G, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1J(),
        variables: {}
      }, {
        config,
        resolve: () => buildNetworkSnapshot$M(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }

    // FYI stricter required set than RAML, matches lds222 behavior
    const getLayout_ConfigPropertyNames = {
      displayName: 'getLayout',
      parameters: {
        required: ['objectApiName', 'layoutType', 'mode'],
        optional: ['recordTypeId']
      }
    };
    function validateAdapterConfig$P(untrustedConfig, _configPropertyNames) {
      const config = validateAdapterConfig$O(untrustedConfig, getLayout_ConfigPropertyNames);
      if (config === null) {
        return null;
      }
      let recordTypeId = config.recordTypeId;
      if (recordTypeId === undefined) {
        // must check untrusted bc config has been coerced
        if (untrustedConfig.recordTypeId !== null && untrustedConfig.recordTypeId !== undefined) {
          return null;
        }
        recordTypeId = MAIN_RECORD_TYPE_ID;
      }
      // layoutType and mode are required during validation.
      // They will always be valid at this point.
      return {
        ...config,
        recordTypeId,
        layoutType: config.layoutType,
        mode: config.mode
      };
    }
    function buildCachedSnapshotCachePolicy$x(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1V(luvio, config),
        node: select$1J(),
        variables: {}
      };
      return storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$M(luvio, config, snapshotRefreshOptions)
      });
    }
    const adapterName$J = 'getLayout';
    const getLayout_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('layoutType', false, 1 /* QueryParameter */, 0 /* String */, false, coerceLayoutType), generateParamConfigMetadata('mode', false, 1 /* QueryParameter */, 0 /* String */, false, coerceLayoutMode), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */, false, getRecordId18)];
    const createResourceParams$H = /*#__PURE__*/luvioEngine.createResourceParams(getLayout_ConfigPropertyMetadata);
    function typeCheckConfig$N(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getLayout_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$O(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getLayout_ConfigPropertyMetadata);
      const config = typeCheckConfig$N(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function onFetchResponseError$u(luvio, config, resourceParams, response) {
      const snapshot = ingestError$r(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$M(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$M(luvio, config, options) {
      const resourceParams = createResourceParams$H(config);
      const request = createResourceRequest$M(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$u(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$J(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$u(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$y(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$M, undefined, false);
    }
    const getLayoutAdapterFactory = luvio => function UiApi__getLayout(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$P(untrustedConfig);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$x, buildNetworkSnapshotCachePolicy$y);
    };
    function getResponseCacheKeys$I(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$M(storeKeyMap, luvio, response);
    }
    function createResourceRequest$L(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/layout/' + config.urlParams.objectApiName + '/user-state',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function buildCachedSnapshot$5(luvio, config) {
      const {
        objectApiName,
        recordTypeId,
        layoutType,
        mode
      } = config;
      const key = keyBuilder$1U(luvio, {
        apiName: objectApiName,
        recordTypeId,
        layoutType,
        mode
      });
      const selector = {
        recordId: key,
        node: select$1I(),
        variables: {}
      };
      return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$L(luvio, config)
      });
    }
    function buildNetworkSnapshot$L(luvio, config, context) {
      const {
        resourceParams,
        request,
        key
      } = prepareRequest$4(luvio, config);
      return luvio.dispatchResourceRequest(request, context).then(response => {
        return luvio.handleSuccessResponse(() => {
          return onFetchResponseSuccess$t(luvio, config, key, response);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$I(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, error => {
        return luvio.handleErrorResponse(() => onFetchResponseError$t(luvio, config, key, error));
      });
    }
    function onFetchResponseSuccess$t(luvio, config, key, response) {
      const {
        body
      } = response;
      const {
        recordTypeId,
        layoutType,
        mode
      } = config;
      // Hack- adding in this params so record-ui will be able to use normed values.
      body.apiName = config.objectApiName;
      body.recordTypeId = recordTypeId;
      body.layoutType = layoutType;
      body.mode = mode;
      luvio.storeIngest(key, ingest$F, body);
      const snapshot = buildCachedSnapshot$5(luvio, config);
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$t(luvio, config, key, error) {
      const errorSnapshot = luvio.errorSnapshot(error, {
        config,
        resolve: () => buildNetworkSnapshot$L(luvio, config)
      });
      luvio.storeIngestError(key, errorSnapshot);
      return luvio.storeBroadcast().then(() => errorSnapshot);
    }
    function prepareRequest$4(luvio, config) {
      const {
        recordTypeId,
        layoutType,
        mode,
        objectApiName
      } = config;
      const key = keyBuilder$1U(luvio, {
        apiName: objectApiName,
        recordTypeId,
        layoutType,
        mode
      });
      const resourceParams = {
        urlParams: {
          objectApiName: config.objectApiName
        },
        queryParams: {
          layoutType: config.layoutType,
          mode: config.mode,
          recordTypeId: config.recordTypeId
        }
      };
      const request = createResourceRequest$L(resourceParams);
      return {
        resourceParams,
        request,
        key
      };
    }
    function validateAdapterConfig$N(untrustedConfig, configPropertyNames) {
      const config = validateAdapterConfig$M(untrustedConfig, configPropertyNames);
      if (config === null) {
        return null;
      }
      // recordTypeId is overridden to be required
      const recordTypeId = config.recordTypeId;
      const untrusted = untrustedConfig;
      let layoutType = config.layoutType;
      if (layoutType === undefined) {
        if (untrusted.layoutType === undefined) {
          layoutType = LayoutType.Full;
        } else {
          return null;
        }
      }
      let mode = config.mode;
      if (mode === undefined) {
        if (untrusted.mode === undefined) {
          mode = LayoutMode.View;
        } else {
          return null;
        }
      }
      return {
        ...config,
        recordTypeId,
        layoutType,
        mode
      };
    }

    // FYI stricter required set than RAML defines, matches lds222 behavior
    const getLayoutUserState_ConfigPropertyNames = {
      displayName: 'getLayoutUserState',
      parameters: {
        required: ['objectApiName', 'recordTypeId'],
        optional: ['formFactor', 'layoutType', 'mode']
      }
    };
    function buildCachedSnapshotCachePolicy$w(context, storeLookup) {
      const {
        config,
        luvio
      } = context;
      const {
        objectApiName,
        recordTypeId,
        layoutType,
        mode
      } = config;
      const selector = {
        recordId: keyBuilder$1U(luvio, {
          apiName: objectApiName,
          recordTypeId,
          layoutType,
          mode
        }),
        node: select$1I(),
        variables: {}
      };
      return storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$L(luvio, config)
      });
    }
    const adapterName$I = 'getLayoutUserState';
    const getLayoutUserState_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('layoutType', false, 1 /* QueryParameter */, 0 /* String */, false, coerceLayoutType), generateParamConfigMetadata('mode', false, 1 /* QueryParameter */, 0 /* String */, false, coerceLayoutMode), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */, false, getRecordId18)];
    function typeCheckConfig$M(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getLayoutUserState_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$M(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getLayoutUserState_ConfigPropertyMetadata);
      const config = typeCheckConfig$M(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshotCachePolicy$x(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$L, undefined, false);
    }
    const getLayoutUserStateAdapterFactory = luvio => function UiApi__getLayoutUserState(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$N(untrustedConfig, getLayoutUserState_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$w, buildNetworkSnapshotCachePolicy$x);
    };
    function keyBuilder$1c(luvio, params) {
      return keyBuilder$2a(luvio, {
        objectApiName: params.urlParams.objectApiName.toLowerCase(),
        listViewApiName: params.urlParams.listViewApiName.toLowerCase(),
        type: params.urlParams.listViewApiName.toLowerCase() === '__recent' ? 'mru' : 'listView'
      });
    }
    function select$16(luvio, params) {
      return select$1X();
    }
    function getResponseCacheKeys$H(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$Z(storeKeyMap, luvio, response);
    }
    function ingestSuccess$z(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$1c(luvio, resourceParams);
      luvio.storeIngest(key, ingest$R, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$16(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$q(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1c(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$B,
        namespace: keyPrefix,
        version: VERSION$1i,
        representationName: RepresentationType$Y
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$K(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-info/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function createChildResourceParams$7(resourceParams) {
      const childConfigs = [];
      const {
        queryParams
      } = resourceParams;
      const {
        names = []
      } = queryParams;
      for (const name of names) {
        const [objectApiName, listViewApiName] = name.split('.');
        childConfigs.push({
          urlParams: {
            objectApiName,
            listViewApiName
          }
        });
      }
      return childConfigs;
    }
    const nonCachedErrors$5 = ObjectCreate$1(null);
    function createChildResourceParams$6(resourceParams) {
      return createChildResourceParams$7(resourceParams);
    }
    function selectChildResourceParams$5(luvio, childResources, resourceParams) {
      const envelopeBodyPath = 'result';
      const envelopeStatusCodePath = 'statusCode';
      const envelopePath = 'results';
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: reader => {
          // Top-level 404 lookup
          const result = reader.storeLookup(keyBuilder$1b(luvio, resourceParams));
          if (result.state === reader.StoreResolveResultState.Error && result.value.status === 404) {
            return {
              state: 'Error',
              value: result.value
            };
          }
          const sink = {};
          reader.enterPath(envelopePath);
          const results = [];
          for (let i = 0, len = childResources.length; i < len; i += 1) {
            reader.enterPath(i);
            reader.enterPath(envelopeBodyPath);
            const childResource = childResources[i];
            const childKey = keyBuilder$1c(luvio, childResource);
            const childFragment = select$16();
            const isMissingDataBeforeChildRead = reader.getIsDataMissing();
            const childSnapshot = reader.read({
              recordId: childKey,
              node: childFragment,
              variables: {}
            });
            reader.exitPath();
            const childSink = {};
            reader.markSeenId(childKey);
            switch (childSnapshot.state) {
              case 'Stale':
                reader.markStale();
              // Stale needs envelope bodies filled in so don't break
              case 'Fulfilled':
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                reader.exitPath();
                break;
              case 'Error':
                const childSnapshotError = childSnapshot.error;
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                reader.exitPath();
                break;
              case 'Unfulfilled':
                // if child snapshot doesn't have any data then
                // that means the child record key is missing
                if (childSnapshot.data === undefined) {
                  if (reader.isRebuilding() === false) {
                    // not a rebuild, mark as missing and move on
                    reader.markMissingLink(childKey);
                    break;
                  }
                  // On rebuilds we have to check if there is a non-cached
                  // error that we know about.  If we don't do this then
                  // rebuilds will go into endless refresh loop if a child
                  // has non-cached errors (since the top-level composite
                  // snapshot will look like an Unfulfilled snapshot
                  // instead of an error snapshot).
                  const nonCachedError = nonCachedErrors$5[childKey];
                  if (nonCachedError === undefined || nonCachedError.expiration < reader.getTimeStamp()) {
                    reader.markMissingLink(childKey);
                  } else {
                    // if this child error was the only reason the reader
                    // is marked as missing then we want to undo that
                    if (isMissingDataBeforeChildRead === false) {
                      reader.unMarkMissing();
                    }
                    // put status code and body into reader path
                    const {
                      response: nonCachedBody,
                      status: nonCachedStatus
                    } = nonCachedError;
                    reader.enterPath(envelopeStatusCodePath);
                    reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                    reader.exitPath();
                    reader.enterPath(envelopeBodyPath);
                    reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                    reader.exitPath();
                  }
                }
                break;
              case 'Pending':
                reader.markPending();
                break;
            }
            ArrayPrototypePush.call(results, childSink);
            reader.exitPath();
          }
          reader.assignNonScalar(sink, envelopePath, results);
          reader.exitPath();
          return sink;
        }
      };
    }
    function select$15(luvio, resourceParams) {
      const childResources = createChildResourceParams$6(resourceParams);
      return selectChildResourceParams$5(luvio, childResources, resourceParams);
    }
    function keyBuilder$1b(luvio, params) {
      return keyPrefix + '::ListInfoBatchRepresentation:(' + 'ids:' + params.queryParams.ids + ',' + 'names:' + params.queryParams.names + ')';
    }
    function getResponseCacheKeys$G(keys, luvio, resourceParams, response) {
      const childEnvelopes = response.results;
      const childResourceParamsArray = createChildResourceParams$6(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      // get children keys
      for (let index = 0, len = childResourceParamsArray.length; index < len; index++) {
        const childResourceParams = childResourceParamsArray[index];
        const childResult = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = childResult;
        if (childStatusCode === 200) {
          getResponseCacheKeys$H(keys, luvio, childResourceParams, childBody);
        } else if (childStatusCode === 404) {
          const childKey = keyBuilder$1c(luvio, childResourceParams);
          keys.set(childKey, {
            namespace: keyPrefix,
            representationName: RepresentationType$Y,
            mergeable: false
          });
        }
      }
    }
    function ingestSuccessChildResourceParams$6(luvio, childResourceParamsArray, childEnvelopes) {
      const childSnapshotDataResponses = [];
      let seenRecords = new luvioEngine.StoreKeySet();
      let snapshotState = 'Fulfilled';
      const now = Date.now();
      for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$1c(luvio, childResourceParams);
        const result = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = result;
        if (childStatusCode === 200) {
          const childResponse = {
            status: 200,
            body: childBody,
            ok: true,
            statusText: 'OK',
            headers: {}
          };
          const childSnapshot = ingestSuccess$z(luvio, childResourceParams, childResponse);
          if (childSnapshot.state === "Stale") {
            snapshotState = "Stale";
          }
          seenRecords.merge(childSnapshot.seenRecords);
          seenRecords.add(childSnapshot.recordId);
          const childValue = {
            statusCode: 200,
            result: childSnapshot.data
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        } else {
          const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
          const childResponse = {
            status: childStatusCode,
            body: childBody,
            ok: false,
            statusText: childStatusCodeText,
            headers: {},
            errorType: 'fetchResponse'
          };
          ingestError$q(luvio, childResourceParams, childResponse);
          seenRecords.add(childKey);
          const childValue = {
            statusCode: childStatusCode,
            result: childBody
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
          nonCachedErrors$5[childKey] = {
            expiration: now + TTL$B,
            response: childBody,
            status: childStatusCode
          };
        } else {
          delete nonCachedErrors$5[childKey];
        }
      }
      const childSnapshotData = {
        results: childSnapshotDataResponses
      };
      luvioEngine.deepFreeze(childSnapshotData);
      return {
        childSnapshotData: childSnapshotData,
        seenRecords,
        snapshotState
      };
    }
    function ingestSuccess$y(luvio, resourceParams, response, snapshotRefresh) {
      const childEnvelopes = response.body.results;
      const childResourceParamsArray = createChildResourceParams$6(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      const key = keyBuilder$1b(luvio, resourceParams);
      const {
        childSnapshotData,
        seenRecords,
        snapshotState
      } = ingestSuccessChildResourceParams$6(luvio, childResourceParamsArray, childEnvelopes);
      const syntheticSnapshot = {
        recordId: key,
        data: childSnapshotData,
        state: snapshotState,
        seenRecords: seenRecords,
        select: {
          recordId: key,
          node: select$15(luvio, resourceParams),
          variables: {}
        },
        refresh: snapshotRefresh,
        variables: {}
      };
      // evict top level composite record from the store. This covers the case where a previous resource request returned a 404.
      luvio.storeEvict(key);
      return syntheticSnapshot;
    }
    function ingestError$p(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$1b(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$J(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-info/batch',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$H = 'getListInfosByName';
    const getListInfosByName_ConfigPropertyMetadata = [generateParamConfigMetadata('ids', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('names', false, 1 /* QueryParameter */, 0 /* String */, true)];
    const getListInfosByName_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$H, getListInfosByName_ConfigPropertyMetadata);
    const createResourceParams$G = /*#__PURE__*/luvioEngine.createResourceParams(getListInfosByName_ConfigPropertyMetadata);
    function keyBuilder$1a(luvio, config) {
      const resourceParams = createResourceParams$G(config);
      return keyBuilder$1b(luvio, resourceParams);
    }
    function typeCheckConfig$L(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getListInfosByName_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$L(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$L(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$q(luvio, config) {
      const resourceParams = createResourceParams$G(config);
      return select$15(luvio, resourceParams);
    }
    function onFetchResponseSuccess$s(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$y(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$K(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$s(luvio, config, resourceParams, response) {
      const snapshot = ingestError$p(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$K(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$K(luvio, config, options) {
      const resourceParams = createResourceParams$G(config);
      const request = createResourceRequest$J(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$s(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$G(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$s(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$w(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$K, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$v(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$1a(luvio, config),
        node: adapterFragment$q(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$K(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getListInfosByNameAdapterFactory = luvio => function UiApi__getListInfosByName(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$L(untrustedConfig, getListInfosByName_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$v, buildNetworkSnapshotCachePolicy$w);
    };
    function createPaginationParams$1(params) {
      const {
        queryParams
      } = params;
      return {
        token: queryParams.pageToken,
        pageSize: queryParams.pageSize === undefined ? 20 : queryParams.pageSize
      };
    }
    function select$14(luvio, params) {
      const paginationParams = createPaginationParams$1(params);
      return select$1Q(paginationParams);
    }
    function keyBuilder$19(luvio, params) {
      return keyBuilder$23(luvio, {
        objectApiName: params.urlParams.objectApiName,
        queryString: params.queryParams.q || null,
        recentListsOnly: params.queryParams.recentListsOnly || false
      });
    }
    function getResponseCacheKeys$F(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$R(storeKeyMap, luvio, response);
    }
    function ingestSuccess$x(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$19(luvio, resourceParams);
      luvio.storeIngest(key, ingest$K, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$14(luvio, resourceParams),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$o(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$19(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$I(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-info/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$G = 'getListInfosByObjectName';
    const getListInfosByObjectName_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageToken', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('q', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('recentListsOnly', false, 1 /* QueryParameter */, 1 /* Boolean */)];
    const getListInfosByObjectName_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$G, getListInfosByObjectName_ConfigPropertyMetadata);
    const createResourceParams$F = /*#__PURE__*/luvioEngine.createResourceParams(getListInfosByObjectName_ConfigPropertyMetadata);
    function keyBuilder$18(luvio, config) {
      const resourceParams = createResourceParams$F(config);
      return keyBuilder$19(luvio, resourceParams);
    }
    function typeCheckConfig$K(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getListInfosByObjectName_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$K(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$K(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$p(luvio, config) {
      const resourceParams = createResourceParams$F(config);
      return select$14(luvio, resourceParams);
    }
    function onFetchResponseSuccess$r(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$x(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$J(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$r(luvio, config, resourceParams, response) {
      const snapshot = ingestError$o(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$J(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function prepareRequest$3(luvio, config, resourceParams, cacheSnapshot) {
      if (cacheSnapshot === undefined) {
        return createResourceRequest$I(resourceParams);
      }
      const [newToken, newPageSize] = minimizePaginationParams$1(luvio, resourceParams, cacheSnapshot);
      if (newToken === undefined) {
        return createResourceRequest$I(resourceParams);
      }
      return createResourceRequest$I(createResourceParams$F({
        ...config,
        pageSize: newPageSize,
        pageToken: newToken
      }));
    }
    function minimizePaginationParams$1(luvio, resourceParams, cacheSnapshot) {
      const num = getCachedItemsNumber$2(cacheSnapshot);
      if (num > 0) {
        const paginationMetadata = getPaginationMetadata$2(luvio, resourceParams);
        if (paginationMetadata !== undefined) {
          const {
            token: configToken,
            pageSize: configPageSize
          } = createPaginationParams$1(resourceParams);
          const configTokenOffset = offsetFromToken(paginationMetadata, configToken);
          if (configTokenOffset < 0) {
            return [undefined, -1];
          }
          const maxOffset = configTokenOffset + num;
          const [token, offset] = tokenForAtMost(paginationMetadata, maxOffset);
          if (token !== undefined) {
            return [token, configPageSize - (offset - configTokenOffset)];
          }
        }
      }
      return [undefined, -1];
    }
    function getCachedItemsNumber$2(cacheSnapshot) {
      const {
        data
      } = cacheSnapshot;
      if (data === undefined || !data.lists) {
        return 0;
      }
      const items = data.lists;
      for (let i = 0; i < items.length; i++) {
        if (items[i] === undefined) {
          return i;
        }
      }
      return items.length;
    }
    function getPaginationMetadata$2(luvio, resourceParams) {
      const key = keyBuilder$19(luvio, resourceParams);
      const selector = {
        recordId: key,
        node: {
          kind: 'Fragment',
          version: VERSION$19,
          private: [],
          selections: [{
            kind: 'Link',
            name: '__metadata',
            fragment: {
              kind: 'Fragment',
              version: PAGINATION_VERSION$1,
              opaque: true,
              private: []
            }
          }]
        },
        variables: {}
      };
      const node = luvio.storeLookup(selector);
      if (node.state !== 'Fulfilled') {
        return;
      }
      return node.data.__metadata;
    }
    function buildNetworkSnapshot$J(luvio, config, options, cacheSnapshot) {
      const resourceParams = createResourceParams$F(config);
      const request = prepareRequest$3(luvio, config, resourceParams, cacheSnapshot);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$r(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$F(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$r(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$v(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$J, undefined, true);
    }
    function buildCachedSnapshotCachePolicy$u(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$18(luvio, config),
        node: adapterFragment$p(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$J(luvio, config, snapshotRefreshOptions)
      });
      if (isUnfulfilledSnapshot$1(cacheSnapshot) && cacheSnapshot.data !== undefined) {
        context.cacheSnapshot = cacheSnapshot;
      }
      return cacheSnapshot;
    }
    const getListInfosByObjectNameAdapterFactory = luvio => function UiApi__getListInfosByObjectName(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$K(untrustedConfig, getListInfosByObjectName_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$u, buildNetworkSnapshotCachePolicy$v);
    };
    function validate$1a(obj, path = 'ListFilterByInfoInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_operandLabels = obj.operandLabels;
        const path_operandLabels = path + '.operandLabels';
        if (!ArrayIsArray(obj_operandLabels)) {
          return new TypeError('Expected "array" but received "' + typeof obj_operandLabels + '" (at "' + path_operandLabels + '")');
        }
        for (let i = 0; i < obj_operandLabels.length; i++) {
          const obj_operandLabels_item = obj_operandLabels[i];
          const path_operandLabels_item = path_operandLabels + '[' + i + ']';
          if (typeof obj_operandLabels_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_operandLabels_item + '" (at "' + path_operandLabels_item + '")');
          }
        }
        const obj_operator = obj.operator;
        const path_operator = path + '.operator';
        if (typeof obj_operator !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_operator + '" (at "' + path_operator + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$19(obj, path = 'ListScopeInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        if (obj.entityId !== undefined) {
          const obj_entityId = obj.entityId;
          const path_entityId = path + '.entityId';
          let obj_entityId_union0 = null;
          const obj_entityId_union0_error = (() => {
            if (typeof obj_entityId !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_entityId + '" (at "' + path_entityId + '")');
            }
          })();
          if (obj_entityId_union0_error != null) {
            obj_entityId_union0 = obj_entityId_union0_error.message;
          }
          let obj_entityId_union1 = null;
          const obj_entityId_union1_error = (() => {
            if (obj_entityId !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_entityId + '" (at "' + path_entityId + '")');
            }
          })();
          if (obj_entityId_union1_error != null) {
            obj_entityId_union1 = obj_entityId_union1_error.message;
          }
          if (obj_entityId_union0 && obj_entityId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_entityId + '")';
            message += '\n' + obj_entityId_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_entityId_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        if (obj.relatedEntityId !== undefined) {
          const obj_relatedEntityId = obj.relatedEntityId;
          const path_relatedEntityId = path + '.relatedEntityId';
          let obj_relatedEntityId_union0 = null;
          const obj_relatedEntityId_union0_error = (() => {
            if (typeof obj_relatedEntityId !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_relatedEntityId + '" (at "' + path_relatedEntityId + '")');
            }
          })();
          if (obj_relatedEntityId_union0_error != null) {
            obj_relatedEntityId_union0 = obj_relatedEntityId_union0_error.message;
          }
          let obj_relatedEntityId_union1 = null;
          const obj_relatedEntityId_union1_error = (() => {
            if (obj_relatedEntityId !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_relatedEntityId + '" (at "' + path_relatedEntityId + '")');
            }
          })();
          if (obj_relatedEntityId_union1_error != null) {
            obj_relatedEntityId_union1 = obj_relatedEntityId_union1_error.message;
          }
          if (obj_relatedEntityId_union0 && obj_relatedEntityId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_relatedEntityId + '")';
            message += '\n' + obj_relatedEntityId_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_relatedEntityId_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function select$13(luvio, params) {
      return select$1X();
    }
    function getResponseCacheKeys$E(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$Z(storeKeyMap, luvio, response);
    }
    function ingestSuccess$w(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$F(luvio, body);
      luvio.storeIngest(key, ingest$R, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$13(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$H(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-info/' + config.urlParams.objectApiName + '',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$F = 'createListInfo';
    const createListInfo_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('displayColumns', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('filterLogicString', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('filteredByInfo', false, 2 /* Body */, 4 /* Unsupported */, true), generateParamConfigMetadata('label', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('listShares', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('listViewApiName', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('scope', false, 2 /* Body */, 4 /* Unsupported */), generateParamConfigMetadata('visibility', false, 2 /* Body */, 0 /* String */)];
    const createListInfo_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$F, createListInfo_ConfigPropertyMetadata);
    const createResourceParams$E = /*#__PURE__*/luvioEngine.createResourceParams(createListInfo_ConfigPropertyMetadata);
    function typeCheckConfig$J(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, createListInfo_ConfigPropertyMetadata);
      const untrustedConfig_filteredByInfo = untrustedConfig.filteredByInfo;
      if (ArrayIsArray$1(untrustedConfig_filteredByInfo)) {
        const untrustedConfig_filteredByInfo_array = [];
        for (let i = 0, arrayLength = untrustedConfig_filteredByInfo.length; i < arrayLength; i++) {
          const untrustedConfig_filteredByInfo_item = untrustedConfig_filteredByInfo[i];
          const referenceListFilterByInfoInputRepresentationValidationError = validate$1a(untrustedConfig_filteredByInfo_item);
          if (referenceListFilterByInfoInputRepresentationValidationError === null) {
            untrustedConfig_filteredByInfo_array.push(untrustedConfig_filteredByInfo_item);
          }
        }
        config.filteredByInfo = untrustedConfig_filteredByInfo_array;
      }
      const untrustedConfig_scope = untrustedConfig.scope;
      const referenceListScopeInputRepresentationValidationError = validate$19(untrustedConfig_scope);
      if (referenceListScopeInputRepresentationValidationError === null) {
        config.scope = untrustedConfig_scope;
      }
      return config;
    }
    function validateAdapterConfig$J(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, createListInfo_ConfigPropertyMetadata);
      const config = typeCheckConfig$J(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$I(luvio, config, options) {
      const resourceParams = createResourceParams$E(config);
      const request = createResourceRequest$H(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$w(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$E(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const createListInfoAdapterFactory = luvio => {
      return function createListInfo(untrustedConfig) {
        const config = validateAdapterConfig$J(untrustedConfig, createListInfo_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "createListInfo"');
        }
        return buildNetworkSnapshot$I(luvio, config);
      };
    };
    function keyBuilder$17(luvio, params) {
      return keyBuilder$2a(luvio, {
        objectApiName: params.urlParams.objectApiName,
        listViewApiName: params.urlParams.listViewApiName,
        type: "listView"
      });
    }
    function getResponseCacheKeys$D(cacheKeyMap, luvio, resourceParams) {
      const key = keyBuilder$17(luvio, resourceParams);
      cacheKeyMap.set(key, {
        namespace: keyPrefix,
        representationName: RepresentationType$Y,
        mergeable: false
      });
    }
    function evictSuccess$1(luvio, resourceParams) {
      const key = keyBuilder$17(luvio, resourceParams);
      luvio.storeEvict(key);
    }
    function createResourceRequest$G(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-info/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'delete',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$E = 'deleteListInfo';
    const deleteListInfo_ConfigPropertyMetadata = [generateParamConfigMetadata('listViewApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */)];
    const deleteListInfo_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$E, deleteListInfo_ConfigPropertyMetadata);
    const createResourceParams$D = /*#__PURE__*/luvioEngine.createResourceParams(deleteListInfo_ConfigPropertyMetadata);
    function typeCheckConfig$I(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, deleteListInfo_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$I(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$I(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$H(luvio, config, options) {
      const resourceParams = createResourceParams$D(config);
      const request = createResourceRequest$G(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(() => {
        return luvio.handleSuccessResponse(() => {
          evictSuccess$1(luvio, resourceParams);
          return luvio.storeBroadcast();
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$D(cache, luvio, resourceParams);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const deleteListInfoAdapterFactory = luvio => {
      return function UiApideleteListInfo(untrustedConfig) {
        const config = validateAdapterConfig$I(untrustedConfig, deleteListInfo_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error(`Invalid config for "${adapterName$E}"`);
        }
        return buildNetworkSnapshot$H(luvio, config);
      };
    };
    const adapterName$D = 'getListInfoByName';
    const getListInfoByName_ConfigPropertyMetadata = [generateParamConfigMetadata('listViewApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */)];
    const getListInfoByName_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$D, getListInfoByName_ConfigPropertyMetadata);
    const createResourceParams$C = /*#__PURE__*/luvioEngine.createResourceParams(getListInfoByName_ConfigPropertyMetadata);
    function keyBuilder$16(luvio, config) {
      const resourceParams = createResourceParams$C(config);
      return keyBuilder$1c(luvio, resourceParams);
    }
    function typeCheckConfig$H(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getListInfoByName_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$H(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$H(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$o(luvio, config) {
      createResourceParams$C(config);
      return select$16();
    }
    function onFetchResponseSuccess$q(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$z(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$G(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$q(luvio, config, resourceParams, response) {
      const snapshot = ingestError$q(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$G(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$G(luvio, config, options) {
      const resourceParams = createResourceParams$C(config);
      const request = createResourceRequest$K(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$q(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$H(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$q(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$u(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$G, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$t(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$16(luvio, config),
        node: adapterFragment$o(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$G(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getListInfoByNameAdapterFactory = luvio => function UiApi__getListInfoByName(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$H(untrustedConfig, getListInfoByName_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$t, buildNetworkSnapshotCachePolicy$u);
    };
    function select$12(luvio, params) {
      return select$1X();
    }
    function getResponseCacheKeys$C(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$Z(storeKeyMap, luvio, response);
    }
    function ingestSuccess$v(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$F(luvio, body);
      luvio.storeIngest(key, ingest$R, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$12(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$F(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-info/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$C = 'updateListInfoByName';
    const updateListInfoByName_ConfigPropertyMetadata = [generateParamConfigMetadata('listViewApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('displayColumns', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('filterLogicString', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('filteredByInfo', false, 2 /* Body */, 4 /* Unsupported */, true), generateParamConfigMetadata('label', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('listShares', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('scope', false, 2 /* Body */, 4 /* Unsupported */), generateParamConfigMetadata('visibility', false, 2 /* Body */, 0 /* String */)];
    const updateListInfoByName_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$C, updateListInfoByName_ConfigPropertyMetadata);
    const createResourceParams$B = /*#__PURE__*/luvioEngine.createResourceParams(updateListInfoByName_ConfigPropertyMetadata);
    function typeCheckConfig$G(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, updateListInfoByName_ConfigPropertyMetadata);
      const untrustedConfig_filteredByInfo = untrustedConfig.filteredByInfo;
      if (ArrayIsArray$1(untrustedConfig_filteredByInfo)) {
        const untrustedConfig_filteredByInfo_array = [];
        for (let i = 0, arrayLength = untrustedConfig_filteredByInfo.length; i < arrayLength; i++) {
          const untrustedConfig_filteredByInfo_item = untrustedConfig_filteredByInfo[i];
          const referenceListFilterByInfoInputRepresentationValidationError = validate$1a(untrustedConfig_filteredByInfo_item);
          if (referenceListFilterByInfoInputRepresentationValidationError === null) {
            untrustedConfig_filteredByInfo_array.push(untrustedConfig_filteredByInfo_item);
          }
        }
        config.filteredByInfo = untrustedConfig_filteredByInfo_array;
      }
      const untrustedConfig_scope = untrustedConfig.scope;
      const referenceListScopeInputRepresentationValidationError = validate$19(untrustedConfig_scope);
      if (referenceListScopeInputRepresentationValidationError === null) {
        config.scope = untrustedConfig_scope;
      }
      return config;
    }
    function validateAdapterConfig$G(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, updateListInfoByName_ConfigPropertyMetadata);
      const config = typeCheckConfig$G(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$F(luvio, config, options) {
      const resourceParams = createResourceParams$B(config);
      const request = createResourceRequest$F(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$v(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$C(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const updateListInfoByNameAdapterFactory = luvio => {
      return function updateListInfoByName(untrustedConfig) {
        const config = validateAdapterConfig$G(untrustedConfig, updateListInfoByName_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "updateListInfoByName"');
        }
        return buildNetworkSnapshot$F(luvio, config);
      };
    };
    const VERSION$H = "d77026c4d63ef00cdd7e3d600687a40d";
    function validate$18(obj, path = 'ListObjectScopeAvailableEntityRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$11 = function ListObjectScopeAvailableEntityRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$H,
        private: [],
        selections: [{
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }]
      };
    };
    function equals$B(existing, incoming) {
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      return true;
    }
    const VERSION$G = "355933ff2970aa91a2848a94565e956a";
    function validate$17(obj, path = 'ListObjectScopeRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_availableEntities = obj.availableEntities;
        const path_availableEntities = path + '.availableEntities';
        if (!ArrayIsArray(obj_availableEntities)) {
          return new TypeError('Expected "array" but received "' + typeof obj_availableEntities + '" (at "' + path_availableEntities + '")');
        }
        for (let i = 0; i < obj_availableEntities.length; i++) {
          const obj_availableEntities_item = obj_availableEntities[i];
          const path_availableEntities_item = path_availableEntities + '[' + i + ']';
          const referencepath_availableEntities_itemValidationError = validate$18(obj_availableEntities_item, path_availableEntities_item);
          if (referencepath_availableEntities_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListObjectScopeAvailableEntityRepresentation (at "' + path_availableEntities_item + '")\n';
            message += referencepath_availableEntities_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$10 = function ListObjectScopeRepresentationSelect() {
      const {
        selections: ListObjectScopeAvailableEntityRepresentation__selections,
        opaque: ListObjectScopeAvailableEntityRepresentation__opaque
      } = select$11();
      return {
        kind: 'Fragment',
        version: VERSION$G,
        private: [],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'availableEntities',
          kind: 'Object',
          plural: true,
          selections: ListObjectScopeAvailableEntityRepresentation__selections
        }, {
          name: 'label',
          kind: 'Scalar'
        }]
      };
    };
    function equals$A(existing, incoming) {
      const existing_apiName = existing.apiName;
      const incoming_apiName = incoming.apiName;
      if (!(existing_apiName === incoming_apiName)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      const existing_availableEntities = existing.availableEntities;
      const incoming_availableEntities = incoming.availableEntities;
      const equals_availableEntities_items = equalsArray(existing_availableEntities, incoming_availableEntities, (existing_availableEntities_item, incoming_availableEntities_item) => {
        if (!equals$B(existing_availableEntities_item, incoming_availableEntities_item)) {
          return false;
        }
      });
      if (equals_availableEntities_items === false) {
        return false;
      }
      return true;
    }
    const VERSION$F = "c5c08ea834378670c9d6f235ff71c9f0";
    function validate$16(obj, path = 'ListObjectPicklistValueRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$$ = function ListObjectPicklistValueRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$F,
        private: [],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }]
      };
    };
    function equals$z(existing, incoming) {
      const existing_apiName = existing.apiName;
      const incoming_apiName = incoming.apiName;
      if (!(existing_apiName === incoming_apiName)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      return true;
    }
    const VERSION$E = "2c35f797fead79b5c45b521e77dd6ace";
    function validate$15(obj, path = 'ListObjectColumnRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_alias = obj.alias;
        const path_alias = path + '.alias';
        if (typeof obj_alias !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_alias + '" (at "' + path_alias + '")');
        }
        const obj_dataType = obj.dataType;
        const path_dataType = path + '.dataType';
        let obj_dataType_union0 = null;
        const obj_dataType_union0_error = (() => {
          if (typeof obj_dataType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_dataType + '" (at "' + path_dataType + '")');
          }
        })();
        if (obj_dataType_union0_error != null) {
          obj_dataType_union0 = obj_dataType_union0_error.message;
        }
        let obj_dataType_union1 = null;
        const obj_dataType_union1_error = (() => {
          if (obj_dataType !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_dataType + '" (at "' + path_dataType + '")');
          }
        })();
        if (obj_dataType_union1_error != null) {
          obj_dataType_union1 = obj_dataType_union1_error.message;
        }
        if (obj_dataType_union0 && obj_dataType_union1) {
          let message = 'Object doesn\'t match union (at "' + path_dataType + '")';
          message += '\n' + obj_dataType_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_dataType_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_defaultFilterOperator = obj.defaultFilterOperator;
        const path_defaultFilterOperator = path + '.defaultFilterOperator';
        if (typeof obj_defaultFilterOperator !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_defaultFilterOperator + '" (at "' + path_defaultFilterOperator + '")');
        }
        const obj_displayable = obj.displayable;
        const path_displayable = path + '.displayable';
        if (typeof obj_displayable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_displayable + '" (at "' + path_displayable + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_filterable = obj.filterable;
        const path_filterable = path + '.filterable';
        if (typeof obj_filterable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_filterable + '" (at "' + path_filterable + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_picklistValues = obj.picklistValues;
        const path_picklistValues = path + '.picklistValues';
        if (!ArrayIsArray(obj_picklistValues)) {
          return new TypeError('Expected "array" but received "' + typeof obj_picklistValues + '" (at "' + path_picklistValues + '")');
        }
        for (let i = 0; i < obj_picklistValues.length; i++) {
          const obj_picklistValues_item = obj_picklistValues[i];
          const path_picklistValues_item = path_picklistValues + '[' + i + ']';
          const referencepath_picklistValues_itemValidationError = validate$16(obj_picklistValues_item, path_picklistValues_item);
          if (referencepath_picklistValues_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListObjectPicklistValueRepresentation (at "' + path_picklistValues_item + '")\n';
            message += referencepath_picklistValues_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
        const obj_supportedFilterOperators = obj.supportedFilterOperators;
        const path_supportedFilterOperators = path + '.supportedFilterOperators';
        if (!ArrayIsArray(obj_supportedFilterOperators)) {
          return new TypeError('Expected "array" but received "' + typeof obj_supportedFilterOperators + '" (at "' + path_supportedFilterOperators + '")');
        }
        for (let i = 0; i < obj_supportedFilterOperators.length; i++) {
          const obj_supportedFilterOperators_item = obj_supportedFilterOperators[i];
          const path_supportedFilterOperators_item = path_supportedFilterOperators + '[' + i + ']';
          if (typeof obj_supportedFilterOperators_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_supportedFilterOperators_item + '" (at "' + path_supportedFilterOperators_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$_ = function ListObjectColumnRepresentationSelect() {
      const {
        selections: ListObjectPicklistValueRepresentation__selections,
        opaque: ListObjectPicklistValueRepresentation__opaque
      } = select$$();
      return {
        kind: 'Fragment',
        version: VERSION$E,
        private: [],
        selections: [{
          name: 'alias',
          kind: 'Scalar'
        }, {
          name: 'dataType',
          kind: 'Scalar'
        }, {
          name: 'defaultFilterOperator',
          kind: 'Scalar'
        }, {
          name: 'displayable',
          kind: 'Scalar'
        }, {
          name: 'fieldApiName',
          kind: 'Scalar'
        }, {
          name: 'filterable',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'picklistValues',
          kind: 'Object',
          plural: true,
          selections: ListObjectPicklistValueRepresentation__selections
        }, {
          name: 'sortable',
          kind: 'Scalar'
        }, {
          name: 'supportedFilterOperators',
          kind: 'Scalar',
          plural: true
        }]
      };
    };
    function equals$y(existing, incoming) {
      const existing_displayable = existing.displayable;
      const incoming_displayable = incoming.displayable;
      if (!(existing_displayable === incoming_displayable)) {
        return false;
      }
      const existing_filterable = existing.filterable;
      const incoming_filterable = incoming.filterable;
      if (!(existing_filterable === incoming_filterable)) {
        return false;
      }
      const existing_sortable = existing.sortable;
      const incoming_sortable = incoming.sortable;
      if (!(existing_sortable === incoming_sortable)) {
        return false;
      }
      const existing_alias = existing.alias;
      const incoming_alias = incoming.alias;
      if (!(existing_alias === incoming_alias)) {
        return false;
      }
      const existing_defaultFilterOperator = existing.defaultFilterOperator;
      const incoming_defaultFilterOperator = incoming.defaultFilterOperator;
      if (!(existing_defaultFilterOperator === incoming_defaultFilterOperator)) {
        return false;
      }
      const existing_fieldApiName = existing.fieldApiName;
      const incoming_fieldApiName = incoming.fieldApiName;
      if (!(existing_fieldApiName === incoming_fieldApiName)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      const existing_dataType = existing.dataType;
      const incoming_dataType = incoming.dataType;
      if (!(existing_dataType === incoming_dataType)) {
        return false;
      }
      const existing_picklistValues = existing.picklistValues;
      const incoming_picklistValues = incoming.picklistValues;
      const equals_picklistValues_items = equalsArray(existing_picklistValues, incoming_picklistValues, (existing_picklistValues_item, incoming_picklistValues_item) => {
        if (!equals$z(existing_picklistValues_item, incoming_picklistValues_item)) {
          return false;
        }
      });
      if (equals_picklistValues_items === false) {
        return false;
      }
      const existing_supportedFilterOperators = existing.supportedFilterOperators;
      const incoming_supportedFilterOperators = incoming.supportedFilterOperators;
      const equals_supportedFilterOperators_items = equalsArray(existing_supportedFilterOperators, incoming_supportedFilterOperators, (existing_supportedFilterOperators_item, incoming_supportedFilterOperators_item) => {
        if (!(existing_supportedFilterOperators_item === incoming_supportedFilterOperators_item)) {
          return false;
        }
      });
      if (equals_supportedFilterOperators_items === false) {
        return false;
      }
      return true;
    }
    const TTL$k = 900000;
    const VERSION$D = "2405a0b25c2c00f82e88b600edc16387";
    function validate$14(obj, path = 'ListObjectInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_availableScopes = obj.availableScopes;
        const path_availableScopes = path + '.availableScopes';
        if (!ArrayIsArray(obj_availableScopes)) {
          return new TypeError('Expected "array" but received "' + typeof obj_availableScopes + '" (at "' + path_availableScopes + '")');
        }
        for (let i = 0; i < obj_availableScopes.length; i++) {
          const obj_availableScopes_item = obj_availableScopes[i];
          const path_availableScopes_item = path_availableScopes + '[' + i + ']';
          const referencepath_availableScopes_itemValidationError = validate$17(obj_availableScopes_item, path_availableScopes_item);
          if (referencepath_availableScopes_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListObjectScopeRepresentation (at "' + path_availableScopes_item + '")\n';
            message += referencepath_availableScopes_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_columns = obj.columns;
        const path_columns = path + '.columns';
        if (!ArrayIsArray(obj_columns)) {
          return new TypeError('Expected "array" but received "' + typeof obj_columns + '" (at "' + path_columns + '")');
        }
        for (let i = 0; i < obj_columns.length; i++) {
          const obj_columns_item = obj_columns[i];
          const path_columns_item = path_columns + '[' + i + ']';
          const referencepath_columns_itemValidationError = validate$15(obj_columns_item, path_columns_item);
          if (referencepath_columns_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListObjectColumnRepresentation (at "' + path_columns_item + '")\n';
            message += referencepath_columns_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_publicOrSharedCreateable = obj.publicOrSharedCreateable;
        const path_publicOrSharedCreateable = path + '.publicOrSharedCreateable';
        if (typeof obj_publicOrSharedCreateable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_publicOrSharedCreateable + '" (at "' + path_publicOrSharedCreateable + '")');
        }
        const obj_relatedEntityApiName = obj.relatedEntityApiName;
        const path_relatedEntityApiName = path + '.relatedEntityApiName';
        let obj_relatedEntityApiName_union0 = null;
        const obj_relatedEntityApiName_union0_error = (() => {
          if (typeof obj_relatedEntityApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relatedEntityApiName + '" (at "' + path_relatedEntityApiName + '")');
          }
        })();
        if (obj_relatedEntityApiName_union0_error != null) {
          obj_relatedEntityApiName_union0 = obj_relatedEntityApiName_union0_error.message;
        }
        let obj_relatedEntityApiName_union1 = null;
        const obj_relatedEntityApiName_union1_error = (() => {
          if (obj_relatedEntityApiName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_relatedEntityApiName + '" (at "' + path_relatedEntityApiName + '")');
          }
        })();
        if (obj_relatedEntityApiName_union1_error != null) {
          obj_relatedEntityApiName_union1 = obj_relatedEntityApiName_union1_error.message;
        }
        if (obj_relatedEntityApiName_union0 && obj_relatedEntityApiName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_relatedEntityApiName + '")';
          message += '\n' + obj_relatedEntityApiName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_relatedEntityApiName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$u = 'ListObjectInfoRepresentation';
    function keyBuilder$15(luvio, config) {
      return keyPrefix + '::' + RepresentationType$u + ':' + config.objectApiName;
    }
    function keyBuilderFromType$k(luvio, object) {
      const keyParams = {
        objectApiName: object.objectApiName
      };
      return keyBuilder$15(luvio, keyParams);
    }
    function normalize$o(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$Z = function ListObjectInfoRepresentationSelect() {
      const {
        selections: ListObjectScopeRepresentation__selections,
        opaque: ListObjectScopeRepresentation__opaque
      } = select$10();
      const {
        selections: ListObjectColumnRepresentation__selections,
        opaque: ListObjectColumnRepresentation__opaque
      } = select$_();
      return {
        kind: 'Fragment',
        version: VERSION$D,
        private: [],
        selections: [{
          name: 'availableScopes',
          kind: 'Object',
          plural: true,
          selections: ListObjectScopeRepresentation__selections
        }, {
          name: 'columns',
          kind: 'Object',
          plural: true,
          selections: ListObjectColumnRepresentation__selections
        }, {
          name: 'createable',
          kind: 'Scalar'
        }, {
          name: 'objectApiName',
          kind: 'Scalar'
        }, {
          name: 'publicOrSharedCreateable',
          kind: 'Scalar'
        }, {
          name: 'relatedEntityApiName',
          kind: 'Scalar'
        }]
      };
    };
    function equals$x(existing, incoming) {
      const existing_createable = existing.createable;
      const incoming_createable = incoming.createable;
      if (!(existing_createable === incoming_createable)) {
        return false;
      }
      const existing_publicOrSharedCreateable = existing.publicOrSharedCreateable;
      const incoming_publicOrSharedCreateable = incoming.publicOrSharedCreateable;
      if (!(existing_publicOrSharedCreateable === incoming_publicOrSharedCreateable)) {
        return false;
      }
      const existing_objectApiName = existing.objectApiName;
      const incoming_objectApiName = incoming.objectApiName;
      if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
      }
      const existing_availableScopes = existing.availableScopes;
      const incoming_availableScopes = incoming.availableScopes;
      const equals_availableScopes_items = equalsArray(existing_availableScopes, incoming_availableScopes, (existing_availableScopes_item, incoming_availableScopes_item) => {
        if (!equals$A(existing_availableScopes_item, incoming_availableScopes_item)) {
          return false;
        }
      });
      if (equals_availableScopes_items === false) {
        return false;
      }
      const existing_columns = existing.columns;
      const incoming_columns = incoming.columns;
      const equals_columns_items = equalsArray(existing_columns, incoming_columns, (existing_columns_item, incoming_columns_item) => {
        if (!equals$y(existing_columns_item, incoming_columns_item)) {
          return false;
        }
      });
      if (equals_columns_items === false) {
        return false;
      }
      const existing_relatedEntityApiName = existing.relatedEntityApiName;
      const incoming_relatedEntityApiName = incoming.relatedEntityApiName;
      if (!(existing_relatedEntityApiName === incoming_relatedEntityApiName)) {
        return false;
      }
      return true;
    }
    const ingest$o = function ListObjectInfoRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$14(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$k(luvio, input);
      const ttlToUse = TTL$k;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$o, "UiApi", VERSION$D, RepresentationType$u, equals$x);
      return createLink(key);
    };
    function getTypeCacheKeys$v(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$k(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$u,
        mergeable: false
      });
    }
    function select$Y(luvio, params) {
      return select$Z();
    }
    function keyBuilder$14(luvio, params) {
      return keyBuilder$15(luvio, {
        objectApiName: params.urlParams.objectApiName
      });
    }
    function getResponseCacheKeys$B(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$v(storeKeyMap, luvio, response);
    }
    function ingestSuccess$u(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$14(luvio, resourceParams);
      luvio.storeIngest(key, ingest$o, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$Y(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$n(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$14(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$k,
        namespace: keyPrefix,
        version: VERSION$D,
        representationName: RepresentationType$u
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$E(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-object-info/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$B = 'getListObjectInfo';
    const getListObjectInfo_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1)];
    const getListObjectInfo_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$B, getListObjectInfo_ConfigPropertyMetadata);
    const createResourceParams$A = /*#__PURE__*/luvioEngine.createResourceParams(getListObjectInfo_ConfigPropertyMetadata);
    function keyBuilder$13(luvio, config) {
      const resourceParams = createResourceParams$A(config);
      return keyBuilder$14(luvio, resourceParams);
    }
    function typeCheckConfig$F(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getListObjectInfo_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$F(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getListObjectInfo_ConfigPropertyMetadata);
      const config = typeCheckConfig$F(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$n(luvio, config) {
      createResourceParams$A(config);
      return select$Y();
    }
    function onFetchResponseSuccess$p(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$u(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$E(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$p(luvio, config, resourceParams, response) {
      const snapshot = ingestError$n(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$E(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$E(luvio, config, options) {
      const resourceParams = createResourceParams$A(config);
      const request = createResourceRequest$E(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$p(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$B(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$p(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$t(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$E, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$s(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$13(luvio, config),
        node: adapterFragment$n(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$E(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getListObjectInfoAdapterFactory = luvio => function UiApi__getListObjectInfo(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$F(untrustedConfig, getListObjectInfo_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$s, buildNetworkSnapshotCachePolicy$t);
    };
    const TTL$j = 900000;
    const VERSION$C = "458d4a6a30201e422e8daec5fcb03845";
    function validate$13(obj, path = 'ListPreferencesRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_columnWidths = obj.columnWidths;
        const path_columnWidths = path + '.columnWidths';
        if (typeof obj_columnWidths !== 'object' || ArrayIsArray(obj_columnWidths) || obj_columnWidths === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_columnWidths + '" (at "' + path_columnWidths + '")');
        }
        const obj_columnWidths_keys = ObjectKeys(obj_columnWidths);
        for (let i = 0; i < obj_columnWidths_keys.length; i++) {
          const key = obj_columnWidths_keys[i];
          const obj_columnWidths_prop = obj_columnWidths[key];
          const path_columnWidths_prop = path_columnWidths + '["' + key + '"]';
          if (typeof obj_columnWidths_prop !== 'number' || typeof obj_columnWidths_prop === 'number' && Math.floor(obj_columnWidths_prop) !== obj_columnWidths_prop) {
            return new TypeError('Expected "integer" but received "' + typeof obj_columnWidths_prop + '" (at "' + path_columnWidths_prop + '")');
          }
        }
        const obj_columnWrap = obj.columnWrap;
        const path_columnWrap = path + '.columnWrap';
        if (typeof obj_columnWrap !== 'object' || ArrayIsArray(obj_columnWrap) || obj_columnWrap === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_columnWrap + '" (at "' + path_columnWrap + '")');
        }
        const obj_columnWrap_keys = ObjectKeys(obj_columnWrap);
        for (let i = 0; i < obj_columnWrap_keys.length; i++) {
          const key = obj_columnWrap_keys[i];
          const obj_columnWrap_prop = obj_columnWrap[key];
          const path_columnWrap_prop = path_columnWrap + '["' + key + '"]';
          if (typeof obj_columnWrap_prop !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_columnWrap_prop + '" (at "' + path_columnWrap_prop + '")');
          }
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referencepath_listReferenceValidationError = validate$28(obj_listReference, path_listReference);
        if (referencepath_listReferenceValidationError !== null) {
          let message = 'Object doesn\'t match ListReferenceRepresentation (at "' + path_listReference + '")\n';
          message += referencepath_listReferenceValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_orderedBy = obj.orderedBy;
        const path_orderedBy = path + '.orderedBy';
        if (!ArrayIsArray(obj_orderedBy)) {
          return new TypeError('Expected "array" but received "' + typeof obj_orderedBy + '" (at "' + path_orderedBy + '")');
        }
        for (let i = 0; i < obj_orderedBy.length; i++) {
          const obj_orderedBy_item = obj_orderedBy[i];
          const path_orderedBy_item = path_orderedBy + '[' + i + ']';
          const referencepath_orderedBy_itemValidationError = validate$25(obj_orderedBy_item, path_orderedBy_item);
          if (referencepath_orderedBy_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListOrderByInfoRepresentation (at "' + path_orderedBy_item + '")\n';
            message += referencepath_orderedBy_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$t = 'ListPreferencesRepresentation';
    function keyBuilder$12(luvio, config) {
      return keyPrefix + '::' + RepresentationType$t + ':' + config.objectApiName + ':' + (config.listViewApiName === null ? '' : config.listViewApiName);
    }
    function keyBuilderFromType$j(luvio, object) {
      const keyParams = {
        objectApiName: object.listReference.objectApiName,
        listViewApiName: object.listReference.listViewApiName
      };
      return keyBuilder$12(luvio, keyParams);
    }
    function normalize$n(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$X = function ListPreferencesRepresentationSelect() {
      const {
        selections: ListReferenceRepresentation__selections,
        opaque: ListReferenceRepresentation__opaque
      } = select$24();
      const {
        selections: ListOrderByInfoRepresentation__selections,
        opaque: ListOrderByInfoRepresentation__opaque
      } = select$21();
      return {
        kind: 'Fragment',
        version: VERSION$C,
        private: [],
        selections: [{
          name: 'columnWidths',
          kind: 'Scalar',
          map: true
        }, {
          name: 'columnWrap',
          kind: 'Scalar',
          map: true
        }, {
          name: 'listReference',
          kind: 'Object',
          selections: ListReferenceRepresentation__selections
        }, {
          name: 'orderedBy',
          kind: 'Object',
          plural: true,
          selections: ListOrderByInfoRepresentation__selections
        }]
      };
    };
    function equals$w(existing, incoming) {
      const existing_columnWidths = existing.columnWidths;
      const incoming_columnWidths = incoming.columnWidths;
      const equals_columnWidths_props = equalsObject(existing_columnWidths, incoming_columnWidths, (existing_columnWidths_prop, incoming_columnWidths_prop) => {
        if (!(existing_columnWidths_prop === incoming_columnWidths_prop)) {
          return false;
        }
      });
      if (equals_columnWidths_props === false) {
        return false;
      }
      const existing_columnWrap = existing.columnWrap;
      const incoming_columnWrap = incoming.columnWrap;
      const equals_columnWrap_props = equalsObject(existing_columnWrap, incoming_columnWrap, (existing_columnWrap_prop, incoming_columnWrap_prop) => {
        if (!(existing_columnWrap_prop === incoming_columnWrap_prop)) {
          return false;
        }
      });
      if (equals_columnWrap_props === false) {
        return false;
      }
      const existing_listReference = existing.listReference;
      const incoming_listReference = incoming.listReference;
      if (!equals$1a(existing_listReference, incoming_listReference)) {
        return false;
      }
      const existing_orderedBy = existing.orderedBy;
      const incoming_orderedBy = incoming.orderedBy;
      const equals_orderedBy_items = equalsArray(existing_orderedBy, incoming_orderedBy, (existing_orderedBy_item, incoming_orderedBy_item) => {
        if (!equals$19(existing_orderedBy_item, incoming_orderedBy_item)) {
          return false;
        }
      });
      if (equals_orderedBy_items === false) {
        return false;
      }
      return true;
    }
    const ingest$n = function ListPreferencesRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$13(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$j(luvio, input);
      const ttlToUse = TTL$j;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$n, "UiApi", VERSION$C, RepresentationType$t, equals$w);
      return createLink(key);
    };
    function getTypeCacheKeys$u(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$j(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$t,
        mergeable: false
      });
    }
    function select$W(luvio, params) {
      return select$X();
    }
    function keyBuilder$11(luvio, params) {
      return keyBuilder$12(luvio, {
        objectApiName: params.urlParams.objectApiName,
        listViewApiName: params.urlParams.listViewApiName
      });
    }
    function getResponseCacheKeys$A(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$u(storeKeyMap, luvio, response);
    }
    function ingestSuccess$t(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$11(luvio, resourceParams);
      luvio.storeIngest(key, ingest$n, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$W(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$m(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$11(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$j,
        namespace: keyPrefix,
        version: VERSION$C,
        representationName: RepresentationType$t
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$D(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-preferences/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$A = 'getListPreferences';
    const getListPreferences_ConfigPropertyMetadata = [generateParamConfigMetadata('listViewApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1)];
    const getListPreferences_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$A, getListPreferences_ConfigPropertyMetadata);
    const createResourceParams$z = /*#__PURE__*/luvioEngine.createResourceParams(getListPreferences_ConfigPropertyMetadata);
    function keyBuilder$10(luvio, config) {
      const resourceParams = createResourceParams$z(config);
      return keyBuilder$11(luvio, resourceParams);
    }
    function typeCheckConfig$E(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getListPreferences_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$E(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getListPreferences_ConfigPropertyMetadata);
      const config = typeCheckConfig$E(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$m(luvio, config) {
      createResourceParams$z(config);
      return select$W();
    }
    function onFetchResponseSuccess$o(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$t(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$D(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$o(luvio, config, resourceParams, response) {
      const snapshot = ingestError$m(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$D(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$D(luvio, config, options) {
      const resourceParams = createResourceParams$z(config);
      const request = createResourceRequest$D(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$o(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$A(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$o(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$s(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$D, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$r(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$10(luvio, config),
        node: adapterFragment$m(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$D(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getListPreferencesAdapterFactory = luvio => function UiApi__getListPreferences(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$E(untrustedConfig, getListPreferences_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$r, buildNetworkSnapshotCachePolicy$s);
    };
    function validate$12(obj, path = 'ListOrderedByInfoInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_isAscending = obj.isAscending;
        const path_isAscending = path + '.isAscending';
        if (typeof obj_isAscending !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isAscending + '" (at "' + path_isAscending + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function select$V(luvio, params) {
      return select$X();
    }
    function getResponseCacheKeys$z(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$u(storeKeyMap, luvio, response);
    }
    function ingestSuccess$s(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$j(luvio, body);
      luvio.storeIngest(key, ingest$n, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$V(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$C(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/list-preferences/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$z = 'updateListPreferences';
    const updateListPreferences_ConfigPropertyMetadata = [generateParamConfigMetadata('listViewApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('columnWidths', false, 2 /* Body */, 4 /* Unsupported */), generateParamConfigMetadata('columnWrap', false, 2 /* Body */, 4 /* Unsupported */), generateParamConfigMetadata('orderedBy', false, 2 /* Body */, 4 /* Unsupported */, true)];
    const updateListPreferences_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$z, updateListPreferences_ConfigPropertyMetadata);
    const createResourceParams$y = /*#__PURE__*/luvioEngine.createResourceParams(updateListPreferences_ConfigPropertyMetadata);
    function typeCheckConfig$D(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, updateListPreferences_ConfigPropertyMetadata);
      const untrustedConfig_columnWidths = untrustedConfig.columnWidths;
      if (untrustedIsObject(untrustedConfig_columnWidths)) {
        const untrustedConfig_columnWidths_object = {};
        const untrustedConfig_columnWidths_keys = Object.keys(untrustedConfig_columnWidths);
        for (let i = 0, arrayLength = untrustedConfig_columnWidths_keys.length; i < arrayLength; i++) {
          const key = untrustedConfig_columnWidths_keys[i];
          const untrustedConfig_columnWidths_prop = untrustedConfig_columnWidths[key];
          if (typeof untrustedConfig_columnWidths_prop === 'number' && Math.floor(untrustedConfig_columnWidths_prop) === untrustedConfig_columnWidths_prop) {
            if (untrustedConfig_columnWidths_object !== undefined) {
              untrustedConfig_columnWidths_object[key] = untrustedConfig_columnWidths_prop;
            }
          }
        }
        if (untrustedConfig_columnWidths_object !== undefined && Object.keys(untrustedConfig_columnWidths_object).length >= 0) {
          config.columnWidths = untrustedConfig_columnWidths_object;
        }
      }
      const untrustedConfig_columnWrap = untrustedConfig.columnWrap;
      if (untrustedIsObject(untrustedConfig_columnWrap)) {
        const untrustedConfig_columnWrap_object = {};
        const untrustedConfig_columnWrap_keys = Object.keys(untrustedConfig_columnWrap);
        for (let i = 0, arrayLength = untrustedConfig_columnWrap_keys.length; i < arrayLength; i++) {
          const key = untrustedConfig_columnWrap_keys[i];
          const untrustedConfig_columnWrap_prop = untrustedConfig_columnWrap[key];
          if (typeof untrustedConfig_columnWrap_prop === 'boolean') {
            if (untrustedConfig_columnWrap_object !== undefined) {
              untrustedConfig_columnWrap_object[key] = untrustedConfig_columnWrap_prop;
            }
          }
        }
        if (untrustedConfig_columnWrap_object !== undefined && Object.keys(untrustedConfig_columnWrap_object).length >= 0) {
          config.columnWrap = untrustedConfig_columnWrap_object;
        }
      }
      const untrustedConfig_orderedBy = untrustedConfig.orderedBy;
      if (ArrayIsArray$1(untrustedConfig_orderedBy)) {
        const untrustedConfig_orderedBy_array = [];
        for (let i = 0, arrayLength = untrustedConfig_orderedBy.length; i < arrayLength; i++) {
          const untrustedConfig_orderedBy_item = untrustedConfig_orderedBy[i];
          const referenceListOrderedByInfoInputRepresentationValidationError = validate$12(untrustedConfig_orderedBy_item);
          if (referenceListOrderedByInfoInputRepresentationValidationError === null) {
            untrustedConfig_orderedBy_array.push(untrustedConfig_orderedBy_item);
          }
        }
        config.orderedBy = untrustedConfig_orderedBy_array;
      }
      return config;
    }
    function validateAdapterConfig$D(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, updateListPreferences_ConfigPropertyMetadata);
      const config = typeCheckConfig$D(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$C(luvio, config, options) {
      const resourceParams = createResourceParams$y(config);
      const request = createResourceRequest$C(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$s(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$z(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const updateListPreferencesAdapterFactory = luvio => {
      return function updateListPreferences(untrustedConfig) {
        const config = validateAdapterConfig$D(untrustedConfig, updateListPreferences_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "updateListPreferences"');
        }
        return buildNetworkSnapshot$C(luvio, config);
      };
    };
    const TTL$i = 120000;
    const VERSION$B = "756779d0d7e137dd72c743544afbad82";
    function validate$11(obj, path = 'NavItemsRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_navItems = obj.navItems;
        const path_navItems = path + '.navItems';
        if (!ArrayIsArray(obj_navItems)) {
          return new TypeError('Expected "array" but received "' + typeof obj_navItems + '" (at "' + path_navItems + '")');
        }
        for (let i = 0; i < obj_navItems.length; i++) {
          const obj_navItems_item = obj_navItems[i];
          const path_navItems_item = path_navItems + '[' + i + ']';
          if (typeof obj_navItems_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_navItems_item + '" (at "' + path_navItems_item + '")');
          }
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
          if (typeof obj_nextPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union0_error != null) {
          obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
          if (obj_nextPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union1_error != null) {
          obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
          message += '\n' + obj_nextPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$s = 'NavItemsRepresentation';
    function normalize$m(input, existing, path, luvio, store, timestamp) {
      const input_navItems = input.navItems;
      const input_navItems_id = path.fullPath + '__navItems';
      for (let i = 0; i < input_navItems.length; i++) {
        const input_navItems_item = input_navItems[i];
        let input_navItems_item_id = input_navItems_id + '__' + i;
        input_navItems[i] = ingest$s(input_navItems_item, {
          fullPath: input_navItems_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$U = function NavItemsRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$B,
        private: ['eTag', 'currentPageUrl'],
        selections: [{
          name: 'navItems',
          kind: 'Link',
          plural: true,
          fragment: select$1h()
        }, {
          name: 'nextPageUrl',
          kind: 'Scalar'
        }]
      };
    };
    function equals$v(existing, incoming) {
      const existing_currentPageUrl = existing.currentPageUrl;
      const incoming_currentPageUrl = incoming.currentPageUrl;
      if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_navItems = existing.navItems;
      const incoming_navItems = incoming.navItems;
      const equals_navItems_items = equalsArray(existing_navItems, incoming_navItems, (existing_navItems_item, incoming_navItems_item) => {
        if (!(existing_navItems_item.__ref === incoming_navItems_item.__ref)) {
          return false;
        }
      });
      if (equals_navItems_items === false) {
        return false;
      }
      const existing_nextPageUrl = existing.nextPageUrl;
      const incoming_nextPageUrl = incoming.nextPageUrl;
      if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
      }
      return true;
    }
    const ingest$m = function NavItemsRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$11(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$i;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$m, "UiApi", VERSION$B, RepresentationType$s, equals$v);
      return createLink(key);
    };
    function getTypeCacheKeys$t(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$s,
        mergeable: false
      });
      const input_navItems_length = input.navItems.length;
      for (let i = 0; i < input_navItems_length; i++) {
        getTypeCacheKeys$z(rootKeySet, luvio, input.navItems[i]);
      }
    }
    function select$T(luvio, params) {
      return select$U();
    }
    function keyBuilder$$(luvio, params) {
      return keyPrefix + '::NavItemsRepresentation:(' + 'formFactor:' + params.queryParams.formFactor + ',' + 'navItemNames:' + params.queryParams.navItemNames + ',' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ')';
    }
    function getResponseCacheKeys$y(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$t(storeKeyMap, luvio, response, () => keyBuilder$$(luvio, resourceParams));
    }
    function ingestSuccess$r(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$$(luvio, resourceParams);
      luvio.storeIngest(key, ingest$m, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$T(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$l(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$$(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$i,
        namespace: keyPrefix,
        version: VERSION$B,
        representationName: RepresentationType$s
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$B(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/nav-items',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$y = 'getNavItems';
    const getNavItems_ConfigPropertyMetadata = [generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */, false, coerceFormFactor), generateParamConfigMetadata('navItemNames', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('page', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */)];
    const getNavItems_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$y, getNavItems_ConfigPropertyMetadata);
    const createResourceParams$x = /*#__PURE__*/luvioEngine.createResourceParams(getNavItems_ConfigPropertyMetadata);
    function keyBuilder$_(luvio, config) {
      const resourceParams = createResourceParams$x(config);
      return keyBuilder$$(luvio, resourceParams);
    }
    function typeCheckConfig$C(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getNavItems_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$C(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getNavItems_ConfigPropertyMetadata);
      const config = typeCheckConfig$C(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$l(luvio, config) {
      createResourceParams$x(config);
      return select$T();
    }
    function onFetchResponseSuccess$n(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$r(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$B(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$n(luvio, config, resourceParams, response) {
      const snapshot = ingestError$l(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$B(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$B(luvio, config, options) {
      const resourceParams = createResourceParams$x(config);
      const request = createResourceRequest$B(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$n(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$y(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$n(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$r(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$B, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$q(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$_(luvio, config),
        node: adapterFragment$l(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$B(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getNavItemsAdapterFactory = luvio => function UiApi__getNavItems(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$C(untrustedConfig, getNavItems_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$q, buildNetworkSnapshotCachePolicy$r);
    };
    function select$S(luvio, params) {
      return select$1G();
    }
    function keyBuilder$Z(luvio, params) {
      return keyPrefix + '::ObjectInfoDirectoryRepresentation:(' + ')';
    }
    function getResponseCacheKeys$x(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$K(storeKeyMap, luvio, response, () => keyBuilder$Z());
    }
    function ingestSuccess$q(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$Z();
      luvio.storeIngest(key, ingest$C, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$S(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$k(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$Z();
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$A(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/object-info',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$x = 'getObjectInfoDirectory';
    const getObjectInfoDirectory_ConfigPropertyMetadata = [];
    const getObjectInfoDirectory_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$x, getObjectInfoDirectory_ConfigPropertyMetadata);
    const createResourceParams$w = /*#__PURE__*/luvioEngine.createResourceParams(getObjectInfoDirectory_ConfigPropertyMetadata);
    function keyBuilder$Y(luvio, config) {
      createResourceParams$w(config);
      return keyBuilder$Z();
    }
    function typeCheckConfig$B(untrustedConfig) {
      const config = {};
      return config;
    }
    function validateAdapterConfig$B(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$B();
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$k(luvio, config) {
      createResourceParams$w(config);
      return select$S();
    }
    function onFetchResponseSuccess$m(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$q(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$A(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$m(luvio, config, resourceParams, response) {
      const snapshot = ingestError$k(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$A(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$A(luvio, config, options) {
      const resourceParams = createResourceParams$w(config);
      const request = createResourceRequest$A();
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$m(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$x(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$m(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$q(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$A, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$p(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$Y(luvio, config),
        node: adapterFragment$k(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$A(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getObjectInfoDirectoryAdapterFactory = luvio => function UiApi__getObjectInfoDirectory(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$B(untrustedConfig, getObjectInfoDirectory_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$p, buildNetworkSnapshotCachePolicy$q);
    };
    const nonCachedErrors$4 = ObjectCreate$1(null);
    function createChildResourceParams$5(resourceParams) {
      let childConfigs = [];
      for (let index = 0, len = resourceParams.urlParams.objectApiNames.length; index < len; index += 1) {
        const item = resourceParams.urlParams.objectApiNames[index];
        childConfigs.push({
          urlParams: {
            objectApiName: item
          }
        });
      }
      return childConfigs;
    }
    function selectChildResourceParams$4(luvio, childResources, resourceParams) {
      const envelopeBodyPath = 'result';
      const envelopeStatusCodePath = 'statusCode';
      const envelopePath = 'results';
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: reader => {
          // Top-level 404 lookup
          const result = reader.storeLookup(keyBuilder$X(luvio, resourceParams));
          if (result.state === reader.StoreResolveResultState.Error && result.value.status === 404) {
            return {
              state: 'Error',
              value: result.value
            };
          }
          const sink = {};
          reader.enterPath(envelopePath);
          const results = [];
          for (let i = 0, len = childResources.length; i < len; i += 1) {
            reader.enterPath(i);
            reader.enterPath(envelopeBodyPath);
            const childResource = childResources[i];
            const childKey = keyBuilder$1X(luvio, childResource);
            const childFragment = select$1K();
            const isMissingDataBeforeChildRead = reader.getIsDataMissing();
            const childSnapshot = reader.read({
              recordId: childKey,
              node: childFragment,
              variables: {}
            });
            reader.exitPath();
            const childSink = {};
            reader.markSeenId(childKey);
            switch (childSnapshot.state) {
              case 'Stale':
                reader.markStale();
              // Stale needs envelope bodies filled in so don't break
              case 'Fulfilled':
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                reader.exitPath();
                break;
              case 'Error':
                const childSnapshotError = childSnapshot.error;
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                reader.exitPath();
                break;
              case 'Unfulfilled':
                // if child snapshot doesn't have any data then
                // that means the child record key is missing
                if (childSnapshot.data === undefined) {
                  if (reader.isRebuilding() === false) {
                    // not a rebuild, mark as missing and move on
                    reader.markMissingLink(childKey);
                    break;
                  }
                  // On rebuilds we have to check if there is a non-cached
                  // error that we know about.  If we don't do this then
                  // rebuilds will go into endless refresh loop if a child
                  // has non-cached errors (since the top-level composite
                  // snapshot will look like an Unfulfilled snapshot
                  // instead of an error snapshot).
                  const nonCachedError = nonCachedErrors$4[childKey];
                  if (nonCachedError === undefined || nonCachedError.expiration < reader.getTimeStamp()) {
                    reader.markMissingLink(childKey);
                  } else {
                    // if this child error was the only reason the reader
                    // is marked as missing then we want to undo that
                    if (isMissingDataBeforeChildRead === false) {
                      reader.unMarkMissing();
                    }
                    // put status code and body into reader path
                    const {
                      response: nonCachedBody,
                      status: nonCachedStatus
                    } = nonCachedError;
                    reader.enterPath(envelopeStatusCodePath);
                    reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                    reader.exitPath();
                    reader.enterPath(envelopeBodyPath);
                    reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                    reader.exitPath();
                  }
                }
                break;
              case 'Pending':
                reader.markPending();
                break;
            }
            ArrayPrototypePush.call(results, childSink);
            reader.exitPath();
          }
          reader.assignNonScalar(sink, envelopePath, results);
          reader.exitPath();
          return sink;
        }
      };
    }
    function select$R(luvio, resourceParams) {
      const childResources = createChildResourceParams$5(resourceParams);
      return selectChildResourceParams$4(luvio, childResources, resourceParams);
    }
    function keyBuilder$X(luvio, params) {
      return keyPrefix + '::SimplifiedBatchRepresentation:(' + 'objectApiNames:' + params.urlParams.objectApiNames + ')';
    }
    function getResponseCacheKeys$w(keys, luvio, resourceParams, response) {
      const childEnvelopes = response.results;
      const childResourceParamsArray = createChildResourceParams$5(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      // get children keys
      for (let index = 0, len = childResourceParamsArray.length; index < len; index++) {
        const childResourceParams = childResourceParamsArray[index];
        const childResult = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = childResult;
        if (childStatusCode === 200) {
          getResponseCacheKeys$_(keys, luvio, childResourceParams, childBody);
        } else if (childStatusCode === 404) {
          const childKey = keyBuilder$1X(luvio, childResourceParams);
          keys.set(childKey, {
            namespace: keyPrefix,
            representationName: RepresentationType$O,
            mergeable: false
          });
        }
      }
    }
    function ingestSuccessChildResourceParams$5(luvio, childResourceParamsArray, childEnvelopes) {
      const childSnapshotDataResponses = [];
      let seenRecords = new luvioEngine.StoreKeySet();
      let snapshotState = 'Fulfilled';
      const now = Date.now();
      for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$1X(luvio, childResourceParams);
        const result = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = result;
        if (childStatusCode === 200) {
          const childResponse = {
            status: 200,
            body: childBody,
            ok: true,
            statusText: 'OK',
            headers: {}
          };
          const childSnapshot = ingestSuccess$P(luvio, childResourceParams, childResponse);
          if (childSnapshot.state === "Stale") {
            snapshotState = "Stale";
          }
          seenRecords.merge(childSnapshot.seenRecords);
          seenRecords.add(childSnapshot.recordId);
          const childValue = {
            statusCode: 200,
            result: childSnapshot.data
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        } else {
          const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
          const childResponse = {
            status: childStatusCode,
            body: childBody,
            ok: false,
            statusText: childStatusCodeText,
            headers: {},
            errorType: 'fetchResponse'
          };
          ingestError$I(luvio, childResourceParams, childResponse);
          seenRecords.add(childKey);
          const childValue = {
            statusCode: childStatusCode,
            result: childBody
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
          nonCachedErrors$4[childKey] = {
            expiration: now + TTL$x,
            response: childBody,
            status: childStatusCode
          };
        } else {
          delete nonCachedErrors$4[childKey];
        }
      }
      const childSnapshotData = {
        results: childSnapshotDataResponses
      };
      luvioEngine.deepFreeze(childSnapshotData);
      return {
        childSnapshotData: childSnapshotData,
        seenRecords,
        snapshotState
      };
    }
    function ingestSuccess$p(luvio, resourceParams, response, snapshotRefresh) {
      const childEnvelopes = response.body.results;
      const childResourceParamsArray = createChildResourceParams$5(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      const key = keyBuilder$X(luvio, resourceParams);
      const {
        childSnapshotData,
        seenRecords,
        snapshotState
      } = ingestSuccessChildResourceParams$5(luvio, childResourceParamsArray, childEnvelopes);
      const syntheticSnapshot = {
        recordId: key,
        data: childSnapshotData,
        state: snapshotState,
        seenRecords: seenRecords,
        select: {
          recordId: key,
          node: select$R(luvio, resourceParams),
          variables: {}
        },
        refresh: snapshotRefresh,
        variables: {}
      };
      // evict top level composite record from the store. This covers the case where a previous resource request returned a 404.
      luvio.storeEvict(key);
      return syntheticSnapshot;
    }
    function ingestError$j(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$X(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$z(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/object-info/batch/' + config.urlParams.objectApiNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$w = 'getObjectInfos';
    const getObjectInfos_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiNames', true, 0 /* UrlParameter */, 0 /* String */, true, getObjectApiNamesArray)];
    const getObjectInfos_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$w, getObjectInfos_ConfigPropertyMetadata);
    const createResourceParams$v = /*#__PURE__*/luvioEngine.createResourceParams(getObjectInfos_ConfigPropertyMetadata);
    function keyBuilder$W(luvio, config) {
      const resourceParams = createResourceParams$v(config);
      return keyBuilder$X(luvio, resourceParams);
    }
    function typeCheckConfig$A(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getObjectInfos_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$A(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getObjectInfos_ConfigPropertyMetadata);
      const config = typeCheckConfig$A(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$j(luvio, config) {
      const resourceParams = createResourceParams$v(config);
      return select$R(luvio, resourceParams);
    }
    function onFetchResponseSuccess$l(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$p(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$z(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$l(luvio, config, resourceParams, response) {
      const snapshot = ingestError$j(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$z(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$z(luvio, config, options) {
      const resourceParams = createResourceParams$v(config);
      const request = createResourceRequest$z(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$l(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$w(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$l(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$p(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$z, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$o(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$W(luvio, config),
        node: adapterFragment$j(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$z(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getObjectInfosAdapterFactory = luvio => function UiApi__getObjectInfos(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$A(untrustedConfig, getObjectInfos_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$o, buildNetworkSnapshotCachePolicy$p);
    };
    const VERSION$A = "8d2032474fb4fabdf5cf4042be9042d9";
    const select$Q = function WorkStepPicklistValueAttributeRepresentationSelect() {
      const {
        selections: AbstractPicklistValueAttributesRepresentationSelections
      } = select$M();
      return {
        kind: 'Fragment',
        version: VERSION$A,
        private: [],
        selections: [...AbstractPicklistValueAttributesRepresentationSelections, {
          name: 'sortOrder',
          kind: 'Scalar'
        }, {
          name: 'statusCode',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$z = "53893a219bc0888951863f2c44317cac";
    const select$P = function LeadStatusPicklistValueAttributesRepresentationSelect() {
      const {
        selections: AbstractPicklistValueAttributesRepresentationSelections
      } = select$M();
      return {
        kind: 'Fragment',
        version: VERSION$z,
        private: [],
        selections: [...AbstractPicklistValueAttributesRepresentationSelections, {
          name: 'converted',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$y = "4818ec07c499784571c1012ead048c88";
    const select$O = function CaseStatusPicklistValueAttributesRepresentationSelect() {
      const {
        selections: AbstractPicklistValueAttributesRepresentationSelections
      } = select$M();
      return {
        kind: 'Fragment',
        version: VERSION$y,
        private: [],
        selections: [...AbstractPicklistValueAttributesRepresentationSelections, {
          name: 'closed',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$x = "950a3a962acbd2b128f937d4c055a9d6";
    const select$N = function OpportunityStagePicklistValueAttributesRepresentationSelect() {
      const {
        selections: AbstractPicklistValueAttributesRepresentationSelections
      } = select$M();
      return {
        kind: 'Fragment',
        version: VERSION$x,
        private: [],
        selections: [...AbstractPicklistValueAttributesRepresentationSelections, {
          name: 'closed',
          kind: 'Scalar'
        }, {
          name: 'defaultProbability',
          kind: 'Scalar'
        }, {
          name: 'forecastCategoryName',
          kind: 'Scalar'
        }, {
          name: 'won',
          kind: 'Scalar'
        }]
      };
    };
    var DiscriminatorValues$4;
    (function (DiscriminatorValues) {
      DiscriminatorValues["WorkStepStatus"] = "WorkStepStatus";
      DiscriminatorValues["LeadStatus"] = "LeadStatus";
      DiscriminatorValues["CaseStatus"] = "CaseStatus";
      DiscriminatorValues["OpportunityStage"] = "OpportunityStage";
    })(DiscriminatorValues$4 || (DiscriminatorValues$4 = {}));
    const VERSION$w = "bd523b2343366edfc25a2dbee2c4e986";
    function validate$10(obj, path = 'AbstractPicklistValueAttributesRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_picklistAtrributesValueType = obj.picklistAtrributesValueType;
        const path_picklistAtrributesValueType = path + '.picklistAtrributesValueType';
        if (typeof obj_picklistAtrributesValueType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_picklistAtrributesValueType + '" (at "' + path_picklistAtrributesValueType + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const selectChildren$2 = function AbstractPicklistValueAttributesRepresentationSelectChildren() {
      const workStepPicklistValueAttributeRepresentationSelections = select$Q();
      const leadStatusPicklistValueAttributesRepresentationSelections = select$P();
      const caseStatusPicklistValueAttributesRepresentationSelections = select$O();
      const opportunityStagePicklistValueAttributesRepresentationSelections = select$N();
      return {
        kind: 'Fragment',
        union: true,
        discriminator: 'picklistAtrributesValueType',
        unionSelections: {
          [DiscriminatorValues$4.WorkStepStatus]: workStepPicklistValueAttributeRepresentationSelections,
          [DiscriminatorValues$4.LeadStatus]: leadStatusPicklistValueAttributesRepresentationSelections,
          [DiscriminatorValues$4.CaseStatus]: caseStatusPicklistValueAttributesRepresentationSelections,
          [DiscriminatorValues$4.OpportunityStage]: opportunityStagePicklistValueAttributesRepresentationSelections
        }
      };
    };
    const select$M = function AbstractPicklistValueAttributesRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$w,
        private: [],
        selections: [{
          name: 'picklistAtrributesValueType',
          kind: 'Scalar'
        }]
      };
    };
    const VERSION$v = "9e2a16a80378487f557124c771201cf9";
    function validate$$(obj, path = 'PicklistValueRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_attributes = obj.attributes;
        const path_attributes = path + '.attributes';
        let obj_attributes_union0 = null;
        const obj_attributes_union0_error = (() => {
          const referencepath_attributesValidationError = validate$10(obj_attributes, path_attributes);
          if (referencepath_attributesValidationError !== null) {
            let message = 'Object doesn\'t match AbstractPicklistValueAttributesRepresentation (at "' + path_attributes + '")\n';
            message += referencepath_attributesValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_attributes_union0_error != null) {
          obj_attributes_union0 = obj_attributes_union0_error.message;
        }
        let obj_attributes_union1 = null;
        const obj_attributes_union1_error = (() => {
          if (obj_attributes !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_attributes + '" (at "' + path_attributes + '")');
          }
        })();
        if (obj_attributes_union1_error != null) {
          obj_attributes_union1 = obj_attributes_union1_error.message;
        }
        if (obj_attributes_union0 && obj_attributes_union1) {
          let message = 'Object doesn\'t match union (at "' + path_attributes + '")';
          message += '\n' + obj_attributes_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_attributes_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_validFor = obj.validFor;
        const path_validFor = path + '.validFor';
        if (!ArrayIsArray(obj_validFor)) {
          return new TypeError('Expected "array" but received "' + typeof obj_validFor + '" (at "' + path_validFor + '")');
        }
        for (let i = 0; i < obj_validFor.length; i++) {
          const obj_validFor_item = obj_validFor[i];
          const path_validFor_item = path_validFor + '[' + i + ']';
          if (typeof obj_validFor_item !== 'number' || typeof obj_validFor_item === 'number' && Math.floor(obj_validFor_item) !== obj_validFor_item) {
            return new TypeError('Expected "integer" but received "' + typeof obj_validFor_item + '" (at "' + path_validFor_item + '")');
          }
        }
        const obj_value = obj.value;
        const path_value = path + '.value';
        if (typeof obj_value !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_value + '" (at "' + path_value + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$L = function PicklistValueRepresentationSelect() {
      const AbstractPicklistValueAttributesRepresentation__unionSelections = selectChildren$2();
      return {
        kind: 'Fragment',
        version: VERSION$v,
        private: [],
        selections: [{
          kind: 'Object',
          name: 'attributes',
          discriminator: AbstractPicklistValueAttributesRepresentation__unionSelections.discriminator,
          union: true,
          nullable: true,
          unionSelections: AbstractPicklistValueAttributesRepresentation__unionSelections.unionSelections
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'validFor',
          kind: 'Scalar',
          plural: true
        }, {
          name: 'value',
          kind: 'Scalar'
        }]
      };
    };
    const keyBuilderFromType$i =
    /**
     * custom key builder from PicklistValuesRepresentation.
     * PicklistValuesRepresentation.url is like /services/data/v62.0/ui-api/object-info/Account/picklist-values/012000000000000AAA/AccountSource
     * the '/services/data/v62.0' in the key make trouble for new js release.  so chop it off make the key unique cross releases.
     */
    function PicklistValuesRepresentationKeyBuilderFromType(luvio, object) {
      const id = object.url.substring(object.url.indexOf('/ui-api'));
      return keyBuilder$V(luvio, {
        id
      });
    };
    const TTL$h = 900000;
    const VERSION$u = "0a361a49370acb4c6a31721a2057649a";
    function validate$_(obj, path = 'PicklistValuesRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_controllerValues = obj.controllerValues;
        const path_controllerValues = path + '.controllerValues';
        if (typeof obj_controllerValues !== 'object' || ArrayIsArray(obj_controllerValues) || obj_controllerValues === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_controllerValues + '" (at "' + path_controllerValues + '")');
        }
        const obj_controllerValues_keys = ObjectKeys(obj_controllerValues);
        for (let i = 0; i < obj_controllerValues_keys.length; i++) {
          const key = obj_controllerValues_keys[i];
          const obj_controllerValues_prop = obj_controllerValues[key];
          const path_controllerValues_prop = path_controllerValues + '["' + key + '"]';
          if (typeof obj_controllerValues_prop !== 'number' || typeof obj_controllerValues_prop === 'number' && Math.floor(obj_controllerValues_prop) !== obj_controllerValues_prop) {
            return new TypeError('Expected "integer" but received "' + typeof obj_controllerValues_prop + '" (at "' + path_controllerValues_prop + '")');
          }
        }
        const obj_defaultValue = obj.defaultValue;
        const path_defaultValue = path + '.defaultValue';
        let obj_defaultValue_union0 = null;
        const obj_defaultValue_union0_error = (() => {
          const referencepath_defaultValueValidationError = validate$$(obj_defaultValue, path_defaultValue);
          if (referencepath_defaultValueValidationError !== null) {
            let message = 'Object doesn\'t match PicklistValueRepresentation (at "' + path_defaultValue + '")\n';
            message += referencepath_defaultValueValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_defaultValue_union0_error != null) {
          obj_defaultValue_union0 = obj_defaultValue_union0_error.message;
        }
        let obj_defaultValue_union1 = null;
        const obj_defaultValue_union1_error = (() => {
          if (obj_defaultValue !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_defaultValue + '" (at "' + path_defaultValue + '")');
          }
        })();
        if (obj_defaultValue_union1_error != null) {
          obj_defaultValue_union1 = obj_defaultValue_union1_error.message;
        }
        if (obj_defaultValue_union0 && obj_defaultValue_union1) {
          let message = 'Object doesn\'t match union (at "' + path_defaultValue + '")';
          message += '\n' + obj_defaultValue_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_defaultValue_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
        const obj_values = obj.values;
        const path_values = path + '.values';
        if (!ArrayIsArray(obj_values)) {
          return new TypeError('Expected "array" but received "' + typeof obj_values + '" (at "' + path_values + '")');
        }
        for (let i = 0; i < obj_values.length; i++) {
          const obj_values_item = obj_values[i];
          const path_values_item = path_values + '[' + i + ']';
          const referencepath_values_itemValidationError = validate$$(obj_values_item, path_values_item);
          if (referencepath_values_itemValidationError !== null) {
            let message = 'Object doesn\'t match PicklistValueRepresentation (at "' + path_values_item + '")\n';
            message += referencepath_values_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$r = 'PicklistValuesRepresentation';
    function keyBuilder$V(luvio, config) {
      return keyPrefix + '::' + RepresentationType$r + ':' + config.id;
    }
    function normalize$l(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$K = function PicklistValuesRepresentationSelect() {
      const {
        selections: PicklistValueRepresentation__selections,
        opaque: PicklistValueRepresentation__opaque
      } = select$L();
      return {
        kind: 'Fragment',
        version: VERSION$u,
        private: ['eTag'],
        selections: [{
          name: 'controllerValues',
          kind: 'Scalar',
          map: true
        }, {
          name: 'defaultValue',
          kind: 'Object',
          nullable: true,
          selections: PicklistValueRepresentation__selections
        }, {
          name: 'url',
          kind: 'Scalar'
        }, {
          name: 'values',
          kind: 'Object',
          plural: true,
          selections: PicklistValueRepresentation__selections
        }]
      };
    };
    function equals$u(existing, incoming) {
      if (existing.eTag !== incoming.eTag) {
        return false;
      }
      return true;
    }
    const ingest$l = function PicklistValuesRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$_(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$i(luvio, input);
      const ttlToUse = TTL$h;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$l, "UiApi", VERSION$u, RepresentationType$r, equals$u);
      return createLink(key);
    };
    function getTypeCacheKeys$s(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$i(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$r,
        mergeable: false
      });
    }
    const TTL$g = 300000;
    const VERSION$t = "ec03b0f6da287c949d1ccaa904ddbfd3";
    function validate$Z(obj, path = 'PicklistValuesCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_picklistFieldValues = obj.picklistFieldValues;
        const path_picklistFieldValues = path + '.picklistFieldValues';
        if (typeof obj_picklistFieldValues !== 'object' || ArrayIsArray(obj_picklistFieldValues) || obj_picklistFieldValues === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_picklistFieldValues + '" (at "' + path_picklistFieldValues + '")');
        }
        const obj_picklistFieldValues_keys = ObjectKeys(obj_picklistFieldValues);
        for (let i = 0; i < obj_picklistFieldValues_keys.length; i++) {
          const key = obj_picklistFieldValues_keys[i];
          const obj_picklistFieldValues_prop = obj_picklistFieldValues[key];
          const path_picklistFieldValues_prop = path_picklistFieldValues + '["' + key + '"]';
          if (typeof obj_picklistFieldValues_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_picklistFieldValues_prop + '" (at "' + path_picklistFieldValues_prop + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$q = 'PicklistValuesCollectionRepresentation';
    function normalize$k(input, existing, path, luvio, store, timestamp) {
      const input_picklistFieldValues = input.picklistFieldValues;
      const input_picklistFieldValues_id = path.fullPath + '__picklistFieldValues';
      const input_picklistFieldValues_keys = Object.keys(input_picklistFieldValues);
      const input_picklistFieldValues_length = input_picklistFieldValues_keys.length;
      for (let i = 0; i < input_picklistFieldValues_length; i++) {
        const key = input_picklistFieldValues_keys[i];
        const input_picklistFieldValues_prop = input_picklistFieldValues[key];
        const input_picklistFieldValues_prop_id = input_picklistFieldValues_id + '__' + key;
        input_picklistFieldValues[key] = ingest$l(input_picklistFieldValues_prop, {
          fullPath: input_picklistFieldValues_prop_id,
          propertyName: key,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$J = function PicklistValuesCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$t,
        private: ['eTag'],
        selections: [{
          name: 'picklistFieldValues',
          kind: 'Link',
          map: true,
          fragment: select$K()
        }]
      };
    };
    function equals$t(existing, incoming) {
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_picklistFieldValues = existing.picklistFieldValues;
      const incoming_picklistFieldValues = incoming.picklistFieldValues;
      const equals_picklistFieldValues_props = equalsObject(existing_picklistFieldValues, incoming_picklistFieldValues, (existing_picklistFieldValues_prop, incoming_picklistFieldValues_prop) => {
        if (!(existing_picklistFieldValues_prop.__ref === incoming_picklistFieldValues_prop.__ref)) {
          return false;
        }
      });
      if (equals_picklistFieldValues_props === false) {
        return false;
      }
      return true;
    }
    const ingest$k = function PicklistValuesCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$Z(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$g;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$k, "UiApi", VERSION$t, RepresentationType$q, equals$t);
      return createLink(key);
    };
    function getTypeCacheKeys$r(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$q,
        mergeable: false
      });
      const input_picklistFieldValues = input.picklistFieldValues;
      const input_picklistFieldValues_keys = ObjectKeys(input_picklistFieldValues);
      const input_picklistFieldValues_length = input_picklistFieldValues_keys.length;
      for (let i = 0; i < input_picklistFieldValues_length; i++) {
        const key = input_picklistFieldValues_keys[i];
        getTypeCacheKeys$s(rootKeySet, luvio, input_picklistFieldValues[key]);
      }
    }
    function select$I(luvio, params) {
      return select$J();
    }
    function keyBuilder$U(luvio, params) {
      return keyPrefix + '::PicklistValuesCollectionRepresentation:(' + 'objectApiName:' + params.urlParams.objectApiName + ',' + 'recordTypeId:' + params.urlParams.recordTypeId + ')';
    }
    function getResponseCacheKeys$v(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$r(storeKeyMap, luvio, response, () => keyBuilder$U(luvio, resourceParams));
    }
    function ingestSuccess$o(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$U(luvio, resourceParams);
      luvio.storeIngest(key, ingest$k, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$I(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$i(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$U(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$g,
        namespace: keyPrefix,
        version: VERSION$t,
        representationName: RepresentationType$q
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$y(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/object-info/' + config.urlParams.objectApiName + '/picklist-values/' + config.urlParams.recordTypeId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$v = 'getPicklistValuesByRecordType';
    const getPicklistValuesByRecordType_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('recordTypeId', true, 0 /* UrlParameter */, 0 /* String */, false, getRecordId18)];
    const getPicklistValuesByRecordType_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$v, getPicklistValuesByRecordType_ConfigPropertyMetadata);
    const createResourceParams$u = /*#__PURE__*/luvioEngine.createResourceParams(getPicklistValuesByRecordType_ConfigPropertyMetadata);
    function keyBuilder$T(luvio, config) {
      const resourceParams = createResourceParams$u(config);
      return keyBuilder$U(luvio, resourceParams);
    }
    function typeCheckConfig$z(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getPicklistValuesByRecordType_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$z(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getPicklistValuesByRecordType_ConfigPropertyMetadata);
      const config = typeCheckConfig$z(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$i(luvio, config) {
      createResourceParams$u(config);
      return select$I();
    }
    function onFetchResponseSuccess$k(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$o(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$y(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$k(luvio, config, resourceParams, response) {
      const snapshot = ingestError$i(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$y(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$y(luvio, config, options) {
      const resourceParams = createResourceParams$u(config);
      const request = createResourceRequest$y(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$k(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$v(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$k(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$o(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$y, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$n(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$T(luvio, config),
        node: adapterFragment$i(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$y(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getPicklistValuesByRecordTypeAdapterFactory = luvio => function UiApi__getPicklistValuesByRecordType(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$z(untrustedConfig, getPicklistValuesByRecordType_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$n, buildNetworkSnapshotCachePolicy$o);
    };
    function getResponseCacheKeys$u(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$s(storeKeyMap, luvio, response);
    }
    function createResourceRequest$x(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/object-info/' + config.urlParams.objectApiName + '/picklist-values/' + config.urlParams.recordTypeId + '/' + config.urlParams.fieldApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const path = select$K().selections;
    function buildSnapshotRefresh$2(luvio, config) {
      return {
        config,
        resolve: () => buildNetworkSnapshot$x(luvio, config)
      };
    }
    function buildRequestAndKey(luvio, config) {
      const {
        recordTypeId,
        fieldApiName
      } = config;
      const fieldNames = getFieldId(fieldApiName);
      const resourceParams = {
        urlParams: {
          objectApiName: fieldNames.objectApiName,
          fieldApiName: fieldNames.fieldApiName,
          recordTypeId
        }
      };
      const request = createResourceRequest$x(resourceParams);
      const key = keyBuilder$V(luvio, {
        id: request.basePath
      });
      return {
        resourceParams,
        request,
        key
      };
    }
    function onResponseSuccess$1(luvio, config, key, response) {
      const {
        body
      } = response;
      luvio.storeIngest(key, ingest$l, body);
      const snapshot = buildCachedSnapshot$4(luvio, config);
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onResponseError(luvio, config, key, err) {
      const errorSnapshot = luvio.errorSnapshot(err, buildSnapshotRefresh$2(luvio, config));
      luvio.storeIngestError(key, errorSnapshot);
      return luvio.storeBroadcast().then(() => errorSnapshot);
    }
    function buildNetworkSnapshot$x(luvio, config, options) {
      const {
        resourceParams,
        request,
        key
      } = buildRequestAndKey(luvio, config);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          return onResponseSuccess$1(luvio, config, key, response);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$u(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, err => {
        return luvio.handleErrorResponse(() => {
          return onResponseError(luvio, config, key, err);
        });
      });
    }
    function buildCachedSnapshot$4(luvio, config) {
      const fieldNames = getFieldId(config.fieldApiName);
      const request = createResourceRequest$x({
        urlParams: {
          objectApiName: fieldNames.objectApiName,
          fieldApiName: fieldNames.fieldApiName,
          recordTypeId: config.recordTypeId
        }
      });
      const key = keyBuilder$V(luvio, {
        id: request.basePath
      });
      return luvio.storeLookup({
        recordId: key,
        node: {
          kind: 'Fragment',
          private: ['eTag'],
          selections: path,
          version: VERSION$u
        },
        variables: {}
      }, buildSnapshotRefresh$2(luvio, config));
    }
    function buildNetworkSnapshotCachePolicy$n(context, coercedAdapterRequestContext) {
      const {
        config,
        luvio
      } = context;
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return buildNetworkSnapshot$x(luvio, config, dispatchOptions);
    }
    function buildCachedSnapshotCachePolicy$m(context, storeLookup) {
      const {
        config,
        luvio
      } = context;
      const fieldNames = getFieldId(config.fieldApiName);
      const {
        basePath
      } = createResourceRequest$x({
        urlParams: {
          objectApiName: fieldNames.objectApiName,
          fieldApiName: fieldNames.fieldApiName,
          recordTypeId: config.recordTypeId
        }
      });
      const key = keyBuilder$V(luvio, {
        id: basePath
      });
      return storeLookup({
        recordId: key,
        node: {
          kind: 'Fragment',
          private: ['eTag'],
          selections: path,
          version: VERSION$u
        },
        variables: {}
      }, buildSnapshotRefresh$2(luvio, config));
    }
    const picklistValuesConfigPropertyNames = {
      displayName: 'getPicklistValues',
      parameters: {
        required: ['recordTypeId', 'fieldApiName'],
        optional: []
      }
    };
    function validateAdapterConfig$y(untrusted, _config) {
      return validateAdapterConfig$x(untrusted, picklistValuesConfigPropertyNames);
    }
    const adapterName$u = 'getPicklistValues';
    const getPicklistValues_ConfigPropertyMetadata = [generateParamConfigMetadata('fieldApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getFieldApiName), generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('recordTypeId', true, 0 /* UrlParameter */, 0 /* String */, false, getRecordId18)];
    function typeCheckConfig$y(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getPicklistValues_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$x(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getPicklistValues_ConfigPropertyMetadata);
      const config = typeCheckConfig$y(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    const getPicklistValuesAdapterFactory = luvio => function UiApi__getPicklistValues(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$y(untrustedConfig);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$m, buildNetworkSnapshotCachePolicy$n);
    };
    function select$H(luvio, params) {
      return select$1J();
    }
    function keyBuilder$S(luvio, params) {
      return keyBuilder$1V(luvio, {
        layoutType: "PathAssistant",
        objectApiName: params.urlParams.objectApiName,
        layoutOverride: params.queryParams.layoutOverride,
        recordTypeId: params.queryParams.recordTypeId || "",
        mode: params.queryParams.mode || "",
        formFactor: params.queryParams.formFactor || ""
      });
    }
    function getResponseCacheKeys$t(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$N(storeKeyMap, luvio, response);
    }
    function ingestSuccess$n(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$S(luvio, resourceParams);
      luvio.storeIngest(key, ingest$G, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$H(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$h(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$S(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$w,
        namespace: keyPrefix,
        version: VERSION$15,
        representationName: RepresentationType$N
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$w(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/path/layout/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$t = 'getPathLayout';
    const getPathLayout_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('layoutOverride', true, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('mode', false, 1 /* QueryParameter */, 0 /* String */, false, coerceLayoutMode), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */, false, getRecordId18)];
    const getPathLayout_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$t, getPathLayout_ConfigPropertyMetadata);
    const createResourceParams$t = /*#__PURE__*/luvioEngine.createResourceParams(getPathLayout_ConfigPropertyMetadata);
    function keyBuilder$R(luvio, config) {
      const resourceParams = createResourceParams$t(config);
      return keyBuilder$S(luvio, resourceParams);
    }
    function typeCheckConfig$x(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getPathLayout_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$w(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getPathLayout_ConfigPropertyMetadata);
      const config = typeCheckConfig$x(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$h(luvio, config) {
      createResourceParams$t(config);
      return select$H();
    }
    function onFetchResponseSuccess$j(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$n(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$w(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$j(luvio, config, resourceParams, response) {
      const snapshot = ingestError$h(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$w(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$w(luvio, config, options) {
      const resourceParams = createResourceParams$t(config);
      const request = createResourceRequest$w(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$j(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$t(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$j(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$m(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$w, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$l(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$R(luvio, config),
        node: adapterFragment$h(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$w(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getPathLayoutAdapterFactory = luvio => function UiApi__getPathLayout(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$w(untrustedConfig, getPathLayout_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$l, buildNetworkSnapshotCachePolicy$m);
    };
    function validate$Y(obj, path = 'MatchResultInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_recordIds = obj.recordIds;
        const path_recordIds = path + '.recordIds';
        if (!ArrayIsArray(obj_recordIds)) {
          return new TypeError('Expected "array" but received "' + typeof obj_recordIds + '" (at "' + path_recordIds + '")');
        }
        for (let i = 0; i < obj_recordIds.length; i++) {
          const obj_recordIds_item = obj_recordIds[i];
          const path_recordIds_item = path_recordIds + '[' + i + ']';
          if (typeof obj_recordIds_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordIds_item + '" (at "' + path_recordIds_item + '")');
          }
        }
        const obj_rule = obj.rule;
        const path_rule = path + '.rule';
        if (typeof obj_rule !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_rule + '" (at "' + path_rule + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$X(obj, path = 'DuplicateResultInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_allowSave = obj.allowSave;
        const path_allowSave = path + '.allowSave';
        if (typeof obj_allowSave !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_allowSave + '" (at "' + path_allowSave + '")');
        }
        const obj_matchResultInfo = obj.matchResultInfo;
        const path_matchResultInfo = path + '.matchResultInfo';
        const referencepath_matchResultInfoValidationError = validate$Y(obj_matchResultInfo, path_matchResultInfo);
        if (referencepath_matchResultInfoValidationError !== null) {
          let message = 'Object doesn\'t match MatchResultInfoRepresentation (at "' + path_matchResultInfo + '")\n';
          message += referencepath_matchResultInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_rule = obj.rule;
        const path_rule = path + '.rule';
        if (typeof obj_rule !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_rule + '" (at "' + path_rule + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$W(obj, path = 'MatchRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_duplicateResultInfos = obj.duplicateResultInfos;
        const path_duplicateResultInfos = path + '.duplicateResultInfos';
        if (typeof obj_duplicateResultInfos !== 'object' || ArrayIsArray(obj_duplicateResultInfos) || obj_duplicateResultInfos === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_duplicateResultInfos + '" (at "' + path_duplicateResultInfos + '")');
        }
        const obj_duplicateResultInfos_keys = ObjectKeys(obj_duplicateResultInfos);
        for (let i = 0; i < obj_duplicateResultInfos_keys.length; i++) {
          const key = obj_duplicateResultInfos_keys[i];
          const obj_duplicateResultInfos_prop = obj_duplicateResultInfos[key];
          const path_duplicateResultInfos_prop = path_duplicateResultInfos + '["' + key + '"]';
          const referencepath_duplicateResultInfos_propValidationError = validate$X(obj_duplicateResultInfos_prop, path_duplicateResultInfos_prop);
          if (referencepath_duplicateResultInfos_propValidationError !== null) {
            let message = 'Object doesn\'t match DuplicateResultInfoRepresentation (at "' + path_duplicateResultInfos_prop + '")\n';
            message += referencepath_duplicateResultInfos_propValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_recordIds = obj.recordIds;
        const path_recordIds = path + '.recordIds';
        if (!ArrayIsArray(obj_recordIds)) {
          return new TypeError('Expected "array" but received "' + typeof obj_recordIds + '" (at "' + path_recordIds + '")');
        }
        for (let i = 0; i < obj_recordIds.length; i++) {
          const obj_recordIds_item = obj_recordIds[i];
          const path_recordIds_item = path_recordIds + '[' + i + ']';
          if (typeof obj_recordIds_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordIds_item + '" (at "' + path_recordIds_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$f = 30000;
    const VERSION$s = "583c38564fa15ce0fb3dd2807be1bdc6";
    function validate$V(obj, path = 'DuplicatesRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_allowSave = obj.allowSave;
        const path_allowSave = path + '.allowSave';
        if (typeof obj_allowSave !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_allowSave + '" (at "' + path_allowSave + '")');
        }
        const obj_duplicateError = obj.duplicateError;
        const path_duplicateError = path + '.duplicateError';
        if (typeof obj_duplicateError !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_duplicateError + '" (at "' + path_duplicateError + '")');
        }
        const obj_duplicateRules = obj.duplicateRules;
        const path_duplicateRules = path + '.duplicateRules';
        if (!ArrayIsArray(obj_duplicateRules)) {
          return new TypeError('Expected "array" but received "' + typeof obj_duplicateRules + '" (at "' + path_duplicateRules + '")');
        }
        for (let i = 0; i < obj_duplicateRules.length; i++) {
          const obj_duplicateRules_item = obj_duplicateRules[i];
          const path_duplicateRules_item = path_duplicateRules + '[' + i + ']';
          if (typeof obj_duplicateRules_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_duplicateRules_item + '" (at "' + path_duplicateRules_item + '")');
          }
        }
        const obj_matches = obj.matches;
        const path_matches = path + '.matches';
        if (!ArrayIsArray(obj_matches)) {
          return new TypeError('Expected "array" but received "' + typeof obj_matches + '" (at "' + path_matches + '")');
        }
        for (let i = 0; i < obj_matches.length; i++) {
          const obj_matches_item = obj_matches[i];
          const path_matches_item = path_matches + '[' + i + ']';
          const referencepath_matches_itemValidationError = validate$W(obj_matches_item, path_matches_item);
          if (referencepath_matches_itemValidationError !== null) {
            let message = 'Object doesn\'t match MatchRepresentation (at "' + path_matches_item + '")\n';
            message += referencepath_matches_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$p = 'DuplicatesRepresentation';
    function normalize$j(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$G = function DuplicatesRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$s,
        private: [],
        opaque: true
      };
    };
    function equals$s(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$j = function DuplicatesRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$V(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$f;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$j, "UiApi", VERSION$s, RepresentationType$p, equals$s);
      return createLink(key);
    };
    function getTypeCacheKeys$q(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$p,
        mergeable: false
      });
    }
    function select$F(luvio, params) {
      return select$G();
    }
    function keyBuilder$Q(luvio, params) {
      return keyPrefix + '::DuplicatesRepresentation:(' + (params.body.allowSaveOnDuplicate === undefined ? 'allowSaveOnDuplicate' : 'allowSaveOnDuplicate:' + params.body.allowSaveOnDuplicate) + '::' + (params.body.apiName === undefined ? 'apiName' : 'apiName:' + params.body.apiName) + '::' + stableJSONStringify(params.body.fields) + ')';
    }
    function getResponseCacheKeys$s(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$q(storeKeyMap, luvio, response, () => keyBuilder$Q(luvio, resourceParams));
    }
    function ingestSuccess$m(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$Q(luvio, resourceParams);
      luvio.storeIngest(key, ingest$j, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$F(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$g(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$Q(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$f,
        namespace: keyPrefix,
        version: VERSION$s,
        representationName: RepresentationType$p
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$v(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/predupe',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$s = 'getDuplicates';
    const getDuplicates_ConfigPropertyMetadata = [generateParamConfigMetadata('allowSaveOnDuplicate', false, 2 /* Body */, 1 /* Boolean */), generateParamConfigMetadata('apiName', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('fields', true, 2 /* Body */, 4 /* Unsupported */)];
    const getDuplicates_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$s, getDuplicates_ConfigPropertyMetadata);
    const createResourceParams$s = /*#__PURE__*/luvioEngine.createResourceParams(getDuplicates_ConfigPropertyMetadata);
    function keyBuilder$P(luvio, config) {
      const resourceParams = createResourceParams$s(config);
      return keyBuilder$Q(luvio, resourceParams);
    }
    function typeCheckConfig$w(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getDuplicates_ConfigPropertyMetadata);
      const untrustedConfig_fields = untrustedConfig.fields;
      if (untrustedIsObject(untrustedConfig_fields)) {
        const untrustedConfig_fields_object = {};
        const untrustedConfig_fields_keys = Object.keys(untrustedConfig_fields);
        for (let i = 0, arrayLength = untrustedConfig_fields_keys.length; i < arrayLength; i++) {
          const key = untrustedConfig_fields_keys[i];
          const untrustedConfig_fields_prop = untrustedConfig_fields[key];
          if (typeof untrustedConfig_fields_prop === 'string') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (typeof untrustedConfig_fields_prop === 'number') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (untrustedConfig_fields_prop === null) {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (typeof untrustedConfig_fields_prop === 'boolean') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
        }
        if (untrustedConfig_fields_object !== undefined && Object.keys(untrustedConfig_fields_object).length >= 0) {
          config.fields = untrustedConfig_fields_object;
        }
      }
      return config;
    }
    function validateAdapterConfig$v(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$w(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$g(luvio, config) {
      createResourceParams$s(config);
      return select$F();
    }
    function onFetchResponseSuccess$i(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$m(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$v(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$i(luvio, config, resourceParams, response) {
      const snapshot = ingestError$g(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$v(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$v(luvio, config, options) {
      const resourceParams = createResourceParams$s(config);
      const request = createResourceRequest$v(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$i(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$s(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$i(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$l(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$v, 'get', false);
    }
    function buildCachedSnapshotCachePolicy$k(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$P(luvio, config),
        node: adapterFragment$g(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$v(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getDuplicatesAdapterFactory = luvio => function UiApi__getDuplicates(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$v(untrustedConfig, getDuplicates_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$k, buildNetworkSnapshotCachePolicy$l);
    };
    const VERSION$r = "e84b9ffdeff97c411bd111f2a55cf6b6";
    function validate$U(obj, path = 'PhotoMetadataRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_companyBluemasterId = obj.companyBluemasterId;
        const path_companyBluemasterId = path + '.companyBluemasterId';
        let obj_companyBluemasterId_union0 = null;
        const obj_companyBluemasterId_union0_error = (() => {
          if (typeof obj_companyBluemasterId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_companyBluemasterId + '" (at "' + path_companyBluemasterId + '")');
          }
        })();
        if (obj_companyBluemasterId_union0_error != null) {
          obj_companyBluemasterId_union0 = obj_companyBluemasterId_union0_error.message;
        }
        let obj_companyBluemasterId_union1 = null;
        const obj_companyBluemasterId_union1_error = (() => {
          if (obj_companyBluemasterId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_companyBluemasterId + '" (at "' + path_companyBluemasterId + '")');
          }
        })();
        if (obj_companyBluemasterId_union1_error != null) {
          obj_companyBluemasterId_union1 = obj_companyBluemasterId_union1_error.message;
        }
        if (obj_companyBluemasterId_union0 && obj_companyBluemasterId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_companyBluemasterId + '")';
          message += '\n' + obj_companyBluemasterId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_companyBluemasterId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_responseId = obj.responseId;
        const path_responseId = path + '.responseId';
        let obj_responseId_union0 = null;
        const obj_responseId_union0_error = (() => {
          if (typeof obj_responseId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_responseId + '" (at "' + path_responseId + '")');
          }
        })();
        if (obj_responseId_union0_error != null) {
          obj_responseId_union0 = obj_responseId_union0_error.message;
        }
        let obj_responseId_union1 = null;
        const obj_responseId_union1_error = (() => {
          if (obj_responseId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_responseId + '" (at "' + path_responseId + '")');
          }
        })();
        if (obj_responseId_union1_error != null) {
          obj_responseId_union1 = obj_responseId_union1_error.message;
        }
        if (obj_responseId_union0 && obj_responseId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_responseId + '")';
          message += '\n' + obj_responseId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_responseId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$E = function PhotoMetadataRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$r,
        private: [],
        selections: [{
          name: 'companyBluemasterId',
          kind: 'Scalar'
        }, {
          name: 'responseId',
          kind: 'Scalar'
        }]
      };
    };
    function equals$r(existing, incoming) {
      const existing_companyBluemasterId = existing.companyBluemasterId;
      const incoming_companyBluemasterId = incoming.companyBluemasterId;
      if (!(existing_companyBluemasterId === incoming_companyBluemasterId)) {
        return false;
      }
      const existing_responseId = existing.responseId;
      const incoming_responseId = incoming.responseId;
      if (!(existing_responseId === incoming_responseId)) {
        return false;
      }
      return true;
    }
    const VERSION$q = "34ffbf4219dfebb707bff609c2d5bf89";
    function validate$T(obj, path = 'PhotoRecordAvatarRepresentation') {
      const validateAbstractRecordAvatarRepresentation_validateError = validate$R(obj, path);
      if (validateAbstractRecordAvatarRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarRepresentation_validateError;
      }
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_backgroundColor = obj.backgroundColor;
        const path_backgroundColor = path + '.backgroundColor';
        let obj_backgroundColor_union0 = null;
        const obj_backgroundColor_union0_error = (() => {
          if (typeof obj_backgroundColor !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
          }
        })();
        if (obj_backgroundColor_union0_error != null) {
          obj_backgroundColor_union0 = obj_backgroundColor_union0_error.message;
        }
        let obj_backgroundColor_union1 = null;
        const obj_backgroundColor_union1_error = (() => {
          if (obj_backgroundColor !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
          }
        })();
        if (obj_backgroundColor_union1_error != null) {
          obj_backgroundColor_union1 = obj_backgroundColor_union1_error.message;
        }
        if (obj_backgroundColor_union0 && obj_backgroundColor_union1) {
          let message = 'Object doesn\'t match union (at "' + path_backgroundColor + '")';
          message += '\n' + obj_backgroundColor_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_backgroundColor_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_height = obj.height;
        const path_height = path + '.height';
        let obj_height_union0 = null;
        const obj_height_union0_error = (() => {
          if (typeof obj_height !== 'number' || typeof obj_height === 'number' && Math.floor(obj_height) !== obj_height) {
            return new TypeError('Expected "integer" but received "' + typeof obj_height + '" (at "' + path_height + '")');
          }
        })();
        if (obj_height_union0_error != null) {
          obj_height_union0 = obj_height_union0_error.message;
        }
        let obj_height_union1 = null;
        const obj_height_union1_error = (() => {
          if (obj_height !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_height + '" (at "' + path_height + '")');
          }
        })();
        if (obj_height_union1_error != null) {
          obj_height_union1 = obj_height_union1_error.message;
        }
        if (obj_height_union0 && obj_height_union1) {
          let message = 'Object doesn\'t match union (at "' + path_height + '")';
          message += '\n' + obj_height_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_height_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_photoMetadata = obj.photoMetadata;
        const path_photoMetadata = path + '.photoMetadata';
        const referencepath_photoMetadataValidationError = validate$U(obj_photoMetadata, path_photoMetadata);
        if (referencepath_photoMetadataValidationError !== null) {
          let message = 'Object doesn\'t match PhotoMetadataRepresentation (at "' + path_photoMetadata + '")\n';
          message += referencepath_photoMetadataValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_photoUrl = obj.photoUrl;
        const path_photoUrl = path + '.photoUrl';
        if (typeof obj_photoUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_photoUrl + '" (at "' + path_photoUrl + '")');
        }
        const obj_provider = obj.provider;
        const path_provider = path + '.provider';
        let obj_provider_union0 = null;
        const obj_provider_union0_error = (() => {
          if (typeof obj_provider !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_provider + '" (at "' + path_provider + '")');
          }
        })();
        if (obj_provider_union0_error != null) {
          obj_provider_union0 = obj_provider_union0_error.message;
        }
        let obj_provider_union1 = null;
        const obj_provider_union1_error = (() => {
          if (obj_provider !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_provider + '" (at "' + path_provider + '")');
          }
        })();
        if (obj_provider_union1_error != null) {
          obj_provider_union1 = obj_provider_union1_error.message;
        }
        if (obj_provider_union0 && obj_provider_union1) {
          let message = 'Object doesn\'t match union (at "' + path_provider + '")';
          message += '\n' + obj_provider_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_provider_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_width = obj.width;
        const path_width = path + '.width';
        let obj_width_union0 = null;
        const obj_width_union0_error = (() => {
          if (typeof obj_width !== 'number' || typeof obj_width === 'number' && Math.floor(obj_width) !== obj_width) {
            return new TypeError('Expected "integer" but received "' + typeof obj_width + '" (at "' + path_width + '")');
          }
        })();
        if (obj_width_union0_error != null) {
          obj_width_union0 = obj_width_union0_error.message;
        }
        let obj_width_union1 = null;
        const obj_width_union1_error = (() => {
          if (obj_width !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_width + '" (at "' + path_width + '")');
          }
        })();
        if (obj_width_union1_error != null) {
          obj_width_union1 = obj_width_union1_error.message;
        }
        if (obj_width_union0 && obj_width_union1) {
          let message = 'Object doesn\'t match union (at "' + path_width + '")';
          message += '\n' + obj_width_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_width_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$o = 'PhotoRecordAvatarRepresentation';
    function keyBuilderFromType$h(luvio, object) {
      return keyBuilderFromType$f(luvio, object);
    }
    function normalize$i(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$D = function PhotoRecordAvatarRepresentationSelect() {
      const {
        selections: AbstractRecordAvatarRepresentationSelections
      } = select$B();
      const {
        selections: PhotoMetadataRepresentation__selections,
        opaque: PhotoMetadataRepresentation__opaque
      } = select$E();
      return {
        kind: 'Fragment',
        version: VERSION$q,
        private: ['eTag'],
        selections: [...AbstractRecordAvatarRepresentationSelections, {
          name: 'backgroundColor',
          kind: 'Scalar'
        }, {
          name: 'height',
          kind: 'Scalar'
        }, {
          name: 'photoMetadata',
          kind: 'Object',
          selections: PhotoMetadataRepresentation__selections
        }, {
          name: 'photoUrl',
          kind: 'Scalar'
        }, {
          name: 'provider',
          kind: 'Scalar'
        }, {
          name: 'width',
          kind: 'Scalar'
        }]
      };
    };
    function equals$q(existing, incoming) {
      if (equals$o(existing, incoming) === false) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_photoUrl = existing.photoUrl;
      const incoming_photoUrl = incoming.photoUrl;
      if (!(existing_photoUrl === incoming_photoUrl)) {
        return false;
      }
      const existing_backgroundColor = existing.backgroundColor;
      const incoming_backgroundColor = incoming.backgroundColor;
      if (!(existing_backgroundColor === incoming_backgroundColor)) {
        return false;
      }
      const existing_height = existing.height;
      const incoming_height = incoming.height;
      if (!(existing_height === incoming_height)) {
        return false;
      }
      const existing_photoMetadata = existing.photoMetadata;
      const incoming_photoMetadata = incoming.photoMetadata;
      if (!equals$r(existing_photoMetadata, incoming_photoMetadata)) {
        return false;
      }
      const existing_provider = existing.provider;
      const incoming_provider = incoming.provider;
      if (!(existing_provider === incoming_provider)) {
        return false;
      }
      const existing_width = existing.width;
      const incoming_width = incoming.width;
      if (!(existing_width === incoming_width)) {
        return false;
      }
      return true;
    }
    const ingest$i = function PhotoRecordAvatarRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$T(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$h(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$i, "UiApi", VERSION$q, RepresentationType$o, equals$q);
      return createLink(key);
    };
    function getTypeCacheKeys$p(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$h(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$m,
        mergeable: false
      });
    }
    const VERSION$p = "cbdcf69a6568d41ccf155b2b95ec70e7";
    function validate$S(obj, path = 'ThemeRecordAvatarRepresentation') {
      const validateAbstractRecordAvatarRepresentation_validateError = validate$R(obj, path);
      if (validateAbstractRecordAvatarRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarRepresentation_validateError;
      }
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_backgroundColor = obj.backgroundColor;
        const path_backgroundColor = path + '.backgroundColor';
        let obj_backgroundColor_union0 = null;
        const obj_backgroundColor_union0_error = (() => {
          if (typeof obj_backgroundColor !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
          }
        })();
        if (obj_backgroundColor_union0_error != null) {
          obj_backgroundColor_union0 = obj_backgroundColor_union0_error.message;
        }
        let obj_backgroundColor_union1 = null;
        const obj_backgroundColor_union1_error = (() => {
          if (obj_backgroundColor !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
          }
        })();
        if (obj_backgroundColor_union1_error != null) {
          obj_backgroundColor_union1 = obj_backgroundColor_union1_error.message;
        }
        if (obj_backgroundColor_union0 && obj_backgroundColor_union1) {
          let message = 'Object doesn\'t match union (at "' + path_backgroundColor + '")';
          message += '\n' + obj_backgroundColor_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_backgroundColor_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        let obj_iconUrl_union0 = null;
        const obj_iconUrl_union0_error = (() => {
          if (typeof obj_iconUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
          }
        })();
        if (obj_iconUrl_union0_error != null) {
          obj_iconUrl_union0 = obj_iconUrl_union0_error.message;
        }
        let obj_iconUrl_union1 = null;
        const obj_iconUrl_union1_error = (() => {
          if (obj_iconUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
          }
        })();
        if (obj_iconUrl_union1_error != null) {
          obj_iconUrl_union1 = obj_iconUrl_union1_error.message;
        }
        if (obj_iconUrl_union0 && obj_iconUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_iconUrl + '")';
          message += '\n' + obj_iconUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_iconUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$n = 'ThemeRecordAvatarRepresentation';
    function keyBuilderFromType$g(luvio, object) {
      return keyBuilderFromType$f(luvio, object);
    }
    function normalize$h(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$C = function ThemeRecordAvatarRepresentationSelect() {
      const {
        selections: AbstractRecordAvatarRepresentationSelections
      } = select$B();
      return {
        kind: 'Fragment',
        version: VERSION$p,
        private: ['eTag'],
        selections: [...AbstractRecordAvatarRepresentationSelections, {
          name: 'backgroundColor',
          kind: 'Scalar'
        }, {
          name: 'iconUrl',
          kind: 'Scalar'
        }]
      };
    };
    function equals$p(existing, incoming) {
      if (equals$o(existing, incoming) === false) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_backgroundColor = existing.backgroundColor;
      const incoming_backgroundColor = incoming.backgroundColor;
      if (!(existing_backgroundColor === incoming_backgroundColor)) {
        return false;
      }
      const existing_iconUrl = existing.iconUrl;
      const incoming_iconUrl = incoming.iconUrl;
      if (!(existing_iconUrl === incoming_iconUrl)) {
        return false;
      }
      return true;
    }
    const ingest$h = function ThemeRecordAvatarRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$S(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$g(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$h, "UiApi", VERSION$p, RepresentationType$n, equals$p);
      return createLink(key);
    };
    function getTypeCacheKeys$o(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$g(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$m,
        mergeable: false
      });
    }
    var DiscriminatorValues$3;
    (function (DiscriminatorValues) {
      DiscriminatorValues["Photo"] = "Photo";
      DiscriminatorValues["Theme"] = "Theme";
    })(DiscriminatorValues$3 || (DiscriminatorValues$3 = {}));
    const VERSION$o = "bc05f8d1c708b6c41c9bf2fe6001aff0";
    function validate$R(obj, path = 'AbstractRecordAvatarRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_recordId = obj.recordId;
        const path_recordId = path + '.recordId';
        if (typeof obj_recordId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_recordId + '" (at "' + path_recordId + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$m = 'AbstractRecordAvatarRepresentation';
    function keyBuilder$O(luvio, config) {
      return keyPrefix + '::' + RepresentationType$m + ':' + config.recordId;
    }
    function keyBuilderFromType$f(luvio, object) {
      const keyParams = {
        recordId: object.recordId
      };
      return keyBuilder$O(luvio, keyParams);
    }
    const selectChildren$1 = function AbstractRecordAvatarRepresentationSelectChildren() {
      const photoRecordAvatarRepresentationSelections = select$D();
      const themeRecordAvatarRepresentationSelections = select$C();
      return {
        kind: 'Fragment',
        union: true,
        discriminator: 'type',
        unionSelections: {
          [DiscriminatorValues$3.Photo]: photoRecordAvatarRepresentationSelections,
          [DiscriminatorValues$3.Theme]: themeRecordAvatarRepresentationSelections
        }
      };
    };
    const select$B = function AbstractRecordAvatarRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$o,
        private: [],
        selections: [{
          name: 'recordId',
          kind: 'Scalar'
        }, {
          name: 'type',
          kind: 'Scalar'
        }]
      };
    };
    function equals$o(existing, incoming) {
      const existing_recordId = existing.recordId;
      const incoming_recordId = incoming.recordId;
      if (!(existing_recordId === incoming_recordId)) {
        return false;
      }
      const existing_type = existing.type;
      const incoming_type = incoming.type;
      if (!(existing_type === incoming_type)) {
        return false;
      }
      return true;
    }
    const discriminatorIngest$1 = function AbstractRecordAvatarRepresentationDiscriminatorIngest(input, path, luvio, store, timestamp) {
      const discriminatorValue = input.type;
      if (discriminatorValue === 'Photo') {
        return ingest$i(input, path, luvio, store, timestamp);
      }
      if (discriminatorValue === 'Theme') {
        return ingest$h(input, path, luvio, store, timestamp);
      }
      throw new Error(`Invalid discriminatorValue "${discriminatorValue}". Expected one of "Photo","Theme"`);
    };
    function getTypeCacheKeys$n(rootKeySet, luvio, input, fullPathFactory) {
      const discriminatorValue = input.type;
      if (discriminatorValue === 'Photo') {
        return getTypeCacheKeys$p(rootKeySet, luvio, input);
      }
      if (discriminatorValue === 'Theme') {
        return getTypeCacheKeys$o(rootKeySet, luvio, input);
      }
      throw new Error(`Invalid discriminatorValue "${discriminatorValue}". Expected one of "Photo","Theme"`);
    }
    const VERSION$n = "f531b44760afecfce89990fe5a5c5c29";
    function validate$Q(obj, path = 'RecordAvatarBatchRepresentation') {
      const validateAbstractRecordAvatarBatchRepresentation_validateError = validate$M(obj, path);
      if (validateAbstractRecordAvatarBatchRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarBatchRepresentation_validateError;
      }
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_result = obj.result;
        const path_result = path + '.result';
        if (typeof obj_result !== 'object') {
          return new TypeError('Expected "object" but received "' + typeof obj_result + '" (at "' + path_result + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$l = 'RecordAvatarBatchRepresentation';
    function normalize$g(input, existing, path, luvio, store, timestamp) {
      const input_result = input.result;
      const input_result_id = path.fullPath + '__result';
      input.result = discriminatorIngest$1(input_result, {
        fullPath: input_result_id,
        propertyName: 'result',
        parent: {
          data: input,
          key: path.fullPath,
          existing: existing
        },
        ttl: path.ttl
      }, luvio, store, timestamp);
      return input;
    }
    const select$A = function RecordAvatarBatchRepresentationSelect() {
      const {
        selections: AbstractRecordAvatarBatchRepresentationSelections
      } = select$w();
      return {
        kind: 'Fragment',
        version: VERSION$n,
        private: [],
        selections: [...AbstractRecordAvatarBatchRepresentationSelections, {
          kind: 'Link',
          name: 'result',
          fragment: selectChildren$1()
        }]
      };
    };
    function equals$n(existing, incoming) {
      if (equals$j(existing, incoming) === false) {
        return false;
      }
      const existing_result = existing.result;
      const incoming_result = incoming.result;
      if (!(existing_result.__ref === incoming_result.__ref)) {
        return false;
      }
      return true;
    }
    const ingest$g = function RecordAvatarBatchRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$Q(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$e;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$g, "UiApi", VERSION$n, RepresentationType$l, equals$n);
      return createLink(key);
    };
    function getTypeCacheKeys$m(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$l,
        mergeable: false
      });
    }
    const VERSION$m = "17c20b01167dba9a81452e60bb28b2f2";
    function validate$P(obj, path = 'ErrorSingleRecordAvatarRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_errorCode = obj.errorCode;
        const path_errorCode = path + '.errorCode';
        if (typeof obj_errorCode !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_errorCode + '" (at "' + path_errorCode + '")');
        }
        const obj_message = obj.message;
        const path_message = path + '.message';
        if (typeof obj_message !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_message + '" (at "' + path_message + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$z = function ErrorSingleRecordAvatarRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$m,
        private: [],
        selections: [{
          name: 'errorCode',
          kind: 'Scalar'
        }, {
          name: 'message',
          kind: 'Scalar'
        }]
      };
    };
    function equals$m(existing, incoming) {
      const existing_errorCode = existing.errorCode;
      const incoming_errorCode = incoming.errorCode;
      if (!(existing_errorCode === incoming_errorCode)) {
        return false;
      }
      const existing_message = existing.message;
      const incoming_message = incoming.message;
      if (!(existing_message === incoming_message)) {
        return false;
      }
      return true;
    }
    const VERSION$l = "e7fac2bfb5cdacc5e0f15c350f9ab8fe";
    function validate$O(obj, path = 'ErrorBadRequestRecordAvatarBatchRepresentation') {
      const validateAbstractRecordAvatarBatchRepresentation_validateError = validate$M(obj, path);
      if (validateAbstractRecordAvatarBatchRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarBatchRepresentation_validateError;
      }
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_result = obj.result;
        const path_result = path + '.result';
        if (!ArrayIsArray(obj_result)) {
          return new TypeError('Expected "array" but received "' + typeof obj_result + '" (at "' + path_result + '")');
        }
        for (let i = 0; i < obj_result.length; i++) {
          const obj_result_item = obj_result[i];
          const path_result_item = path_result + '[' + i + ']';
          const referencepath_result_itemValidationError = validate$P(obj_result_item, path_result_item);
          if (referencepath_result_itemValidationError !== null) {
            let message = 'Object doesn\'t match ErrorSingleRecordAvatarRepresentation (at "' + path_result_item + '")\n';
            message += referencepath_result_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$k = 'ErrorBadRequestRecordAvatarBatchRepresentation';
    function normalize$f(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$y = function ErrorBadRequestRecordAvatarBatchRepresentationSelect() {
      const {
        selections: AbstractRecordAvatarBatchRepresentationSelections
      } = select$w();
      const {
        selections: ErrorSingleRecordAvatarRepresentation__selections,
        opaque: ErrorSingleRecordAvatarRepresentation__opaque
      } = select$z();
      return {
        kind: 'Fragment',
        version: VERSION$l,
        private: [],
        selections: [...AbstractRecordAvatarBatchRepresentationSelections, {
          name: 'result',
          kind: 'Object',
          plural: true,
          selections: ErrorSingleRecordAvatarRepresentation__selections
        }]
      };
    };
    function equals$l(existing, incoming) {
      if (equals$j(existing, incoming) === false) {
        return false;
      }
      const existing_result = existing.result;
      const incoming_result = incoming.result;
      const equals_result_items = equalsArray(existing_result, incoming_result, (existing_result_item, incoming_result_item) => {
        if (!equals$m(existing_result_item, incoming_result_item)) {
          return false;
        }
      });
      if (equals_result_items === false) {
        return false;
      }
      return true;
    }
    const ingest$f = function ErrorBadRequestRecordAvatarBatchRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$O(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$e;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$f, "UiApi", VERSION$l, RepresentationType$k, equals$l);
      return createLink(key);
    };
    function getTypeCacheKeys$l(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$k,
        mergeable: false
      });
    }
    const VERSION$k = "cbd48fd50d0db463fdff7b1834c22bed";
    function validate$N(obj, path = 'ErrorRecordAvatarBatchRepresentation') {
      const validateAbstractRecordAvatarBatchRepresentation_validateError = validate$M(obj, path);
      if (validateAbstractRecordAvatarBatchRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarBatchRepresentation_validateError;
      }
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_result = obj.result;
        const path_result = path + '.result';
        if (!ArrayIsArray(obj_result)) {
          return new TypeError('Expected "array" but received "' + typeof obj_result + '" (at "' + path_result + '")');
        }
        for (let i = 0; i < obj_result.length; i++) {
          const obj_result_item = obj_result[i];
          const path_result_item = path_result + '[' + i + ']';
          const referencepath_result_itemValidationError = validate$P(obj_result_item, path_result_item);
          if (referencepath_result_itemValidationError !== null) {
            let message = 'Object doesn\'t match ErrorSingleRecordAvatarRepresentation (at "' + path_result_item + '")\n';
            message += referencepath_result_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$j = 'ErrorRecordAvatarBatchRepresentation';
    function normalize$e(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$x = function ErrorRecordAvatarBatchRepresentationSelect() {
      const {
        selections: AbstractRecordAvatarBatchRepresentationSelections
      } = select$w();
      const {
        selections: ErrorSingleRecordAvatarRepresentation__selections,
        opaque: ErrorSingleRecordAvatarRepresentation__opaque
      } = select$z();
      return {
        kind: 'Fragment',
        version: VERSION$k,
        private: [],
        selections: [...AbstractRecordAvatarBatchRepresentationSelections, {
          name: 'result',
          kind: 'Object',
          plural: true,
          selections: ErrorSingleRecordAvatarRepresentation__selections
        }]
      };
    };
    function equals$k(existing, incoming) {
      if (equals$j(existing, incoming) === false) {
        return false;
      }
      const existing_result = existing.result;
      const incoming_result = incoming.result;
      const equals_result_items = equalsArray(existing_result, incoming_result, (existing_result_item, incoming_result_item) => {
        if (!equals$m(existing_result_item, incoming_result_item)) {
          return false;
        }
      });
      if (equals_result_items === false) {
        return false;
      }
      return true;
    }
    const ingest$e = function ErrorRecordAvatarBatchRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$N(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$e;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$e, "UiApi", VERSION$k, RepresentationType$j, equals$k);
      return createLink(key);
    };
    function getTypeCacheKeys$k(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$j,
        mergeable: false
      });
    }
    const DiscriminatorValues$2 = {
      '200': 200,
      '400': 400,
      '404': 404
    };
    const TTL$e = 300000;
    const VERSION$j = "8956293536e94d5ec63b274b61033d2c";
    function validate$M(obj, path = 'AbstractRecordAvatarBatchRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_statusCode = obj.statusCode;
        const path_statusCode = path + '.statusCode';
        if (typeof obj_statusCode !== 'number') {
          return new TypeError('Expected "number" but received "' + typeof obj_statusCode + '" (at "' + path_statusCode + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const selectChildren = function AbstractRecordAvatarBatchRepresentationSelectChildren() {
      const recordAvatarBatchRepresentationSelections = select$A();
      const errorBadRequestRecordAvatarBatchRepresentationSelections = select$y();
      const errorRecordAvatarBatchRepresentationSelections = select$x();
      return {
        kind: 'Fragment',
        union: true,
        discriminator: 'statusCode',
        unionSelections: {
          [DiscriminatorValues$2['200']]: recordAvatarBatchRepresentationSelections,
          [DiscriminatorValues$2['400']]: errorBadRequestRecordAvatarBatchRepresentationSelections,
          [DiscriminatorValues$2['404']]: errorRecordAvatarBatchRepresentationSelections
        }
      };
    };
    const select$w = function AbstractRecordAvatarBatchRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$j,
        private: [],
        selections: [{
          name: 'statusCode',
          kind: 'Scalar'
        }]
      };
    };
    function equals$j(existing, incoming) {
      const existing_statusCode = existing.statusCode;
      const incoming_statusCode = incoming.statusCode;
      if (!(existing_statusCode === incoming_statusCode)) {
        return false;
      }
      return true;
    }
    const discriminatorIngest = function AbstractRecordAvatarBatchRepresentationDiscriminatorIngest(input, path, luvio, store, timestamp) {
      const discriminatorValue = input.statusCode;
      if (discriminatorValue === 200) {
        return ingest$g(input, path, luvio, store, timestamp);
      }
      if (discriminatorValue === 400) {
        return ingest$f(input, path, luvio, store, timestamp);
      }
      if (discriminatorValue === 404) {
        return ingest$e(input, path, luvio, store, timestamp);
      }
      throw new Error(`Invalid discriminatorValue "${discriminatorValue}". Expected one of "200","400","404"`);
    };
    function getTypeCacheKeys$j(rootKeySet, luvio, input, fullPathFactory) {
      const discriminatorValue = input.statusCode;
      if (discriminatorValue === 200) {
        return getTypeCacheKeys$m(rootKeySet, luvio, input, fullPathFactory);
      }
      if (discriminatorValue === 400) {
        return getTypeCacheKeys$l(rootKeySet, luvio, input, fullPathFactory);
      }
      if (discriminatorValue === 404) {
        return getTypeCacheKeys$k(rootKeySet, luvio, input, fullPathFactory);
      }
      throw new Error(`Invalid discriminatorValue "${discriminatorValue}". Expected one of "200","400","404"`);
    }
    const TTL$d = 1800000;
    const VERSION$i = "c44c049fa6ad7cf7e932c0aab9107d86";
    function validate$L(obj, path = 'RecordAvatarBulkMapRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_keys = ObjectKeys(obj);
        for (let i = 0; i < obj_keys.length; i++) {
          const key = obj_keys[i];
          const obj_prop = obj[key];
          const path_prop = path + '["' + key + '"]';
          if (typeof obj_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_prop + '" (at "' + path_prop + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$i = 'RecordAvatarBulkMapRepresentation';
    function normalize$d(input, existing, path, luvio, store, timestamp) {
      const input_keys = Object.keys(input);
      const input_length = input_keys.length;
      for (let i = 0; i < input_length; i++) {
        const key = input_keys[i];
        const input_prop = input[key];
        const input_prop_id = path.fullPath + '__' + key;
        input[key] = discriminatorIngest(input_prop, {
          fullPath: input_prop_id,
          propertyName: key,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    function equals$i(existing, incoming) {
      const equals_props = equalsObject(existing, incoming, (existing_prop, incoming_prop) => {
        if (!(existing_prop.__ref === incoming_prop.__ref)) {
          return false;
        }
      });
      if (equals_props === false) {
        return false;
      }
      return true;
    }
    function getTypeCacheKeys$i(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$i,
        mergeable: false
      });
      const input__root = input;
      const input__root_keys = ObjectKeys(input__root);
      const input__root_length = input__root_keys.length;
      for (let i = 0; i < input__root_length; i++) {
        const key = input__root_keys[i];
        getTypeCacheKeys$j(rootKeySet, luvio, input__root[key], () => rootKey + "__" + key);
      }
    }
    function merge(existing, incoming, _luvio, _path) {
      if (existing === undefined) {
        return incoming;
      }
      // Merge RecordRepresentation field values together
      return {
        ...existing,
        ...incoming
      };
    }
    const ingest$d = function RecordAvatarBulkMapRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$L(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const existingRecord = store.readEntry(key);
      let incomingRecord = normalize$d(input, store.readEntry(key), {
        fullPath: key,
        propertyName: path.propertyName,
        parent: path.parent
      }, luvio, store, timestamp);
      incomingRecord = merge(existingRecord, incomingRecord);
      if (existingRecord === undefined || equals$i(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
      }
      return createLink(key);
    };
    function keyBuilder$N(luvio, params) {
      return keyPrefix + '::RecordAvatarBulkMapRepresentation:(' + 'formFactor:' + params.queryParams.formFactor + ',' + 'recordIds:' + params.urlParams.recordIds + ')';
    }
    function getResponseCacheKeys$r(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$i(storeKeyMap, luvio, response, () => keyBuilder$N(luvio, resourceParams));
    }
    function ingestError$f(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$N(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$d,
        namespace: keyPrefix,
        version: VERSION$i,
        representationName: RepresentationType$i
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$u(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/record-avatars/batch/' + config.urlParams.recordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }

    // All of the avatars are ingested into
    // the same top level object
    const KEY = `${keyPrefix}RecordAvatarsBulk`;
    function recordAvatarsFragment(recordIds) {
      return {
        kind: 'Fragment',
        private: [],
        version: VERSION$j,
        selections: recordIds.map(recordId => {
          return {
            kind: 'Link',
            name: recordId,
            fragment: selectChildren()
          };
        })
      };
    }
    function recordAvatarsSelector(recordIds) {
      return {
        recordId: KEY,
        node: recordAvatarsFragment(recordIds),
        variables: {}
      };
    }
    function buildCachedSnapshot$3(luvio, config) {
      const {
        recordIds
      } = config;
      return luvio.storeLookup(recordAvatarsSelector(recordIds), {
        config,
        resolve: () => buildNetworkSnapshot$u(luvio, config, snapshotRefreshOptions)
      });
    }

    // Track in-flight xrequests so we known when to send out our fake response
    const IN_FLIGHT_REQUESTS = new Set();
    function getRecordIdsFlightStatus(recordIds, in_flight_requests) {
      const recordIdsNotInFlight = [],
        recordIdsInFlight = [];
      // Split up the given record ids into in flight ids and not in flight ids
      recordIds.forEach(id => {
        if (in_flight_requests.has(id)) {
          recordIdsInFlight.push(id);
        } else {
          recordIdsNotInFlight.push(id);
        }
      });
      return {
        recordIdsInFlight: recordIdsInFlight,
        recordIdsNotInFlight: recordIdsNotInFlight
      };
    }
    /**
     * TODO [W-8318817]: For 230/232 this is a workaround to not having inflight
     * deduping for record avatars.
     * The way it works is we ingest a fake response while the real response is pending.
     * So for example a component wires record avatars for ABC, while that request is in flight
     * another component wires record avatars AB. The wire for ABC will send off a request for data
     * Then AB comes in and will resolve the fake response instead of sending off a request.
     * Then once the real response comes back it will be ingested and it will notify both AB and ABC.
     * We will resolve this in 234 using real inflight deduping
     */
    function ingestFakeResponse(luvio, recordIds) {
      const formatted = reduce.call(recordIds, (accum, recordId) => {
        accum[recordId] = {
          statusCode: 200,
          result: {
            backgroundColor: null,
            eTag: '',
            height: null,
            photoMetadata: {
              companyBluemasterId: null,
              responseId: null
            },
            photoUrl: '',
            provider: null,
            recordId: '',
            type: 'Photo',
            width: null
          }
        };
        return accum;
      }, {});
      luvio.storeIngest(KEY, ingest$d, formatted);
    }
    function isRecordAvatarBulkMapRepresentation(response) {
      return response.body.hasErrors === undefined;
    }
    function buildNetworkSnapshot$u(luvio, config, options) {
      const {
        uncachedRecordIds,
        recordIds
      } = config;
      const {
        recordIdsInFlight,
        recordIdsNotInFlight
      } = getRecordIdsFlightStatus(uncachedRecordIds || recordIds,
      // If uncached records were specified, only get those, otherwise, get all of them
      IN_FLIGHT_REQUESTS);
      // For any remaining record ids send off the real request and add it to the in flight request list
      let luvioResponse;
      if (recordIdsNotInFlight.length > 0) {
        recordIdsNotInFlight.forEach(id => IN_FLIGHT_REQUESTS.add(id));
        const resourceParams = createResourceParams$r({
          ...config,
          recordIds: recordIdsNotInFlight
        });
        const request = createResourceRequest$u(resourceParams);
        luvioResponse = luvio.dispatchResourceRequest(request, options).then(response => {
          recordIdsNotInFlight.forEach(id => IN_FLIGHT_REQUESTS.delete(id));
          // the selector passed to dispatchResourceRequest requests the data already formatted so the response
          // can either be a RecordAvatarBulkRepresentation or a RecordAvatarBulkMapRepresentation
          let formatted;
          if (isRecordAvatarBulkMapRepresentation(response)) {
            formatted = response.body;
          } else {
            formatted = response.body.results.reduce((seed, avatar, index) => {
              const recordId = recordIdsNotInFlight[index];
              seed[recordId] = avatar;
              return seed;
            }, {});
          }
          response.body = formatted;
          return luvio.handleSuccessResponse(() => onFetchResponseSuccess$h(luvio, config, resourceParams, response), () => {
            const cache = new luvioEngine.StoreKeyMap();
            getResponseCacheKeys$r(cache, luvio, resourceParams, formatted);
            return cache;
          });
        }, err => {
          recordIdsNotInFlight.forEach(id => IN_FLIGHT_REQUESTS.delete(id));
          return luvio.handleErrorResponse(() => {
            return onFetchResponseError$h(luvio, config, resourceParams, err);
          });
        });
      }
      // For any currently in flight record ids lets emit a fake response
      if (recordIdsInFlight.length > 0) {
        ingestFakeResponse(luvio, recordIdsInFlight);
      }
      return luvioResponse ? luvioResponse : Promise.resolve(buildCachedSnapshot$3(luvio, config));
    }
    function ingestSuccess$l(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      luvio.storeIngest(KEY, ingest$d, body);
      let recordIds = [];
      if (snapshotRefresh) {
        recordIds = snapshotRefresh.config.recordIds;
      }
      const snapshot = luvio.storeLookup(recordAvatarsSelector(recordIds), snapshotRefresh);
      if (snapshot.state === 'Pending') {
        luvio.resolvePendingSnapshot(snapshot).then(() => {
          ingestSuccess$l(luvio, resourceParams, response, snapshotRefresh);
        });
        return Promise.resolve(snapshot);
      }
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      return Promise.resolve(snapshot);
    }
    function buildCachedSnapshotCachePolicy$j(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const {
        recordIds
      } = config;
      const cachedSnapshot = storeLookup(recordAvatarsSelector(recordIds), {
        config,
        resolve: () => buildNetworkSnapshot$u(luvio, config, snapshotRefreshOptions)
      });
      // if the L1 lookup had some data but not all, then put the cache keys that were
      // missing onto the context, so buildNetworkSnapshotCachePolicy only requests
      // the missing records
      if (cachedSnapshot.data !== undefined && isUnfulfilledSnapshot(cachedSnapshot)) {
        context.uncachedRecordIds = cachedSnapshot.missingPaths.keysAsArray().sort();
      }
      return cachedSnapshot;
    }
    function buildNetworkSnapshotCachePolicy$k(context, coercedAdapterRequestContext) {
      const {
        luvio,
        config,
        uncachedRecordIds
      } = context;
      if (uncachedRecordIds !== undefined) {
        config.uncachedRecordIds = uncachedRecordIds;
      }
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return buildNetworkSnapshot$u(luvio, config, dispatchOptions);
    }
    const adapterName$r = 'getRecordAvatars';
    const getRecordAvatars_ConfigPropertyMetadata = [generateParamConfigMetadata('recordIds', true, 0 /* UrlParameter */, 0 /* String */, true, getRecordId18Array), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */, false, coerceFormFactor)];
    const getRecordAvatars_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$r, getRecordAvatars_ConfigPropertyMetadata);
    const createResourceParams$r = /*#__PURE__*/luvioEngine.createResourceParams(getRecordAvatars_ConfigPropertyMetadata);
    function typeCheckConfig$v(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRecordAvatars_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$u(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRecordAvatars_ConfigPropertyMetadata);
      const config = typeCheckConfig$v(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function onFetchResponseSuccess$h(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$l(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$u(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$h(luvio, config, resourceParams, response) {
      const snapshot = ingestError$f(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$u(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    const getRecordAvatarsAdapterFactory = luvio => function UiApi__getRecordAvatars(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$u(untrustedConfig, getRecordAvatars_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$j, buildNetworkSnapshotCachePolicy$k);
    };
    function coerceRecordId18Array(value) {
      const valueArray = ArrayIsArray$1(value) ? value : [value];
      const ret = [];
      for (let i = 0, len = valueArray.length; i < len; i += 1) {
        const item = valueArray[i];
        const coerced = getRecordId18(item);
        if (coerced === undefined) {
          return undefined;
        }
        ArrayPrototypePush.call(ret, coerced);
      }
      if (ret.length === 0) {
        return undefined;
      }
      return dedupe(ret);
    }
    function coerceConfig(config) {
      const coercedRecordsConfig = {
        records: []
      };
      const {
        records: recordsFromConfig = []
      } = config;
      for (let index = 0, len = recordsFromConfig.length; index < len; index += 1) {
        const coeredRecordConfig = {};
        const currentRecordBatch = recordsFromConfig[index];
        if (untrustedIsObject(currentRecordBatch)) {
          const recordIds = coerceRecordId18Array(currentRecordBatch.recordIds);
          if (recordIds !== undefined) {
            coeredRecordConfig.recordIds = recordIds;
          }
          const optionalFields = getFieldApiNamesArray(currentRecordBatch.optionalFields);
          if (optionalFields !== undefined) {
            coeredRecordConfig.optionalFields = optionalFields;
          }
          const fields = getFieldApiNamesArray(currentRecordBatch.fields);
          if (fields !== undefined) {
            coeredRecordConfig.fields = fields;
          }
          ArrayPrototypePush.call(coercedRecordsConfig.records, coeredRecordConfig);
        }
      }
      return coercedRecordsConfig;
    }
    function typeCheckConfig$u(untrustedConfig) {
      const coercedConfig = coerceConfig(untrustedConfig);
      const config = {};
      const untrustedConfigs_records = coercedConfig.records;
      if (ArrayIsArray$1(untrustedConfigs_records)) {
        const records = [];
        for (let index = 0, len = untrustedConfigs_records.length; index < len; index += 1) {
          const output_recordEntityConfig = {};
          const untrustedConfig_recordEntity = untrustedConfigs_records[index];
          if (untrustedIsObject(untrustedConfig_recordEntity)) {
            const {
              recordIds: untrustedConfig_recordIds,
              fields: untrustedConfig_fields,
              optionalFields: untrustedConfig_optionalFields
            } = untrustedConfig_recordEntity;
            if (ArrayIsArray$1(untrustedConfig_recordIds)) {
              const untrustedConfig_recordIds_array = [];
              for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
                const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
                if (typeof untrustedConfig_recordIds_item === 'string') {
                  ArrayPrototypePush.call(untrustedConfig_recordIds_array, untrustedConfig_recordIds_item);
                }
              }
              output_recordEntityConfig.recordIds = untrustedConfig_recordIds_array;
            }
            if (!output_recordEntityConfig.recordIds || output_recordEntityConfig.recordIds.length === 0) {
              continue;
            }
            if (ArrayIsArray$1(untrustedConfig_fields)) {
              const untrustedConfig_fields_array = [];
              for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
                const untrustedConfig_fields_item = untrustedConfig_fields[i];
                if (typeof untrustedConfig_fields_item === 'string') {
                  ArrayPrototypePush.call(untrustedConfig_fields_array, untrustedConfig_fields_item);
                }
              }
              output_recordEntityConfig.fields = untrustedConfig_fields_array;
            }
            if (ArrayIsArray$1(untrustedConfig_optionalFields)) {
              const untrustedConfig_optionalFields_array = [];
              for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
                const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
                if (typeof untrustedConfig_optionalFields_item === 'string') {
                  ArrayPrototypePush.call(untrustedConfig_optionalFields_array, untrustedConfig_optionalFields_item);
                }
              }
              output_recordEntityConfig.optionalFields = untrustedConfig_optionalFields_array;
            }
            if (output_recordEntityConfig.fields === undefined && output_recordEntityConfig.optionalFields === undefined) {
              continue;
            }
            ArrayPrototypePush.call(records, output_recordEntityConfig);
          }
        }
        if (records.length > 0) {
          assign(config, {
            records
          });
        }
      }
      return config;
    }
    function checkFieldsObjectApiName(fields, apiName) {
      return fields.every(field => splitQualifiedFieldApiName(field)[0] === apiName);
    }
    function getObjectApiName(fields, optionalFields) {
      if (fields === undefined || fields.length === 0) {
        return splitQualifiedFieldApiName(optionalFields[0])[0];
      }
      return splitQualifiedFieldApiName(fields[0])[0];
    }
    function validateFieldsObjectApiName(config) {
      const configRecords = config.records;
      for (let index = 0, len = configRecords.length; index < len; index++) {
        const {
          fields: configRecordEntityFields,
          optionalFields: configRecordEntityOptionalFields
        } = configRecords[index];
        const objectApiName = getObjectApiName(configRecordEntityFields, configRecordEntityOptionalFields);
        // check objectApiName of fields and optionalFields array
        if (configRecordEntityFields !== undefined && !checkFieldsObjectApiName(configRecordEntityFields, objectApiName) || configRecordEntityOptionalFields !== undefined && !checkFieldsObjectApiName(configRecordEntityOptionalFields, objectApiName)) {
          throw new TypeError(`all specified fields and optional fields must be of same ObjectApiName as ${objectApiName}`);
        }
      }
    }
    function validateAdapterConfig$t(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$u(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      // If we have made it this far, our config is validated and type checked
      {
        validateFieldsObjectApiName(config);
      }
      return config;
    }
    const getRecords_ConfigPropertyNames = {
      displayName: 'getRecords',
      parameters: {
        required: ['records'],
        optional: []
      }
    };
    const adapterName$q = 'getRecords';
    function keyBuilder$M(luvio, config) {
      const resourceParams = createResourceParams$11(config);
      return keyBuilder$27(luvio, resourceParams);
    }
    function onFetchResponseError$g(luvio, config, resourceParams, response) {
      const snapshot = ingestError$L(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$t(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$t(luvio, config, options) {
      const resourceParams = createResourceParams$11(config);
      const request = createResourceRequest$1a(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$N(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$11(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$g(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$j(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$t, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$i(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$M(luvio, config),
        node: adapterFragment$J(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$t(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRecordsAdapterFactory = luvio => function UiApi__getRecords(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$t(untrustedConfig, getRecords_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$i, buildNetworkSnapshotCachePolicy$j);
    };
    const VERSION$h = "4d4bdab5d0aa61e365e766409c9b3a31";
    function validate$K(obj, path = 'RelatedListReferenceRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
          if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union0_error != null) {
          obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
          if (obj_id !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union1_error != null) {
          obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
          let message = 'Object doesn\'t match union (at "' + path_id + '")';
          message += '\n' + obj_id_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_id_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_inContextOfRecordId = obj.inContextOfRecordId;
        const path_inContextOfRecordId = path + '.inContextOfRecordId';
        let obj_inContextOfRecordId_union0 = null;
        const obj_inContextOfRecordId_union0_error = (() => {
          if (typeof obj_inContextOfRecordId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_inContextOfRecordId + '" (at "' + path_inContextOfRecordId + '")');
          }
        })();
        if (obj_inContextOfRecordId_union0_error != null) {
          obj_inContextOfRecordId_union0 = obj_inContextOfRecordId_union0_error.message;
        }
        let obj_inContextOfRecordId_union1 = null;
        const obj_inContextOfRecordId_union1_error = (() => {
          if (obj_inContextOfRecordId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_inContextOfRecordId + '" (at "' + path_inContextOfRecordId + '")');
          }
        })();
        if (obj_inContextOfRecordId_union1_error != null) {
          obj_inContextOfRecordId_union1 = obj_inContextOfRecordId_union1_error.message;
        }
        if (obj_inContextOfRecordId_union0 && obj_inContextOfRecordId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_inContextOfRecordId + '")';
          message += '\n' + obj_inContextOfRecordId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_inContextOfRecordId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_listViewApiName = obj.listViewApiName;
        const path_listViewApiName = path + '.listViewApiName';
        let obj_listViewApiName_union0 = null;
        const obj_listViewApiName_union0_error = (() => {
          if (typeof obj_listViewApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
          }
        })();
        if (obj_listViewApiName_union0_error != null) {
          obj_listViewApiName_union0 = obj_listViewApiName_union0_error.message;
        }
        let obj_listViewApiName_union1 = null;
        const obj_listViewApiName_union1_error = (() => {
          if (obj_listViewApiName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
          }
        })();
        if (obj_listViewApiName_union1_error != null) {
          obj_listViewApiName_union1 = obj_listViewApiName_union1_error.message;
        }
        if (obj_listViewApiName_union0 && obj_listViewApiName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_listViewApiName + '")';
          message += '\n' + obj_listViewApiName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_listViewApiName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        let obj_objectApiName_union0 = null;
        const obj_objectApiName_union0_error = (() => {
          if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
          }
        })();
        if (obj_objectApiName_union0_error != null) {
          obj_objectApiName_union0 = obj_objectApiName_union0_error.message;
        }
        let obj_objectApiName_union1 = null;
        const obj_objectApiName_union1_error = (() => {
          if (obj_objectApiName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
          }
        })();
        if (obj_objectApiName_union1_error != null) {
          obj_objectApiName_union1 = obj_objectApiName_union1_error.message;
        }
        if (obj_objectApiName_union0 && obj_objectApiName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_objectApiName + '")';
          message += '\n' + obj_objectApiName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_objectApiName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_parentObjectApiName = obj.parentObjectApiName;
        const path_parentObjectApiName = path + '.parentObjectApiName';
        if (typeof obj_parentObjectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_parentObjectApiName + '" (at "' + path_parentObjectApiName + '")');
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
          if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union0_error != null) {
          obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
          if (obj_recordTypeId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union1_error != null) {
          obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
          message += '\n' + obj_recordTypeId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_recordTypeId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_relatedListId = obj.relatedListId;
        const path_relatedListId = path + '.relatedListId';
        if (typeof obj_relatedListId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_relatedListId + '" (at "' + path_relatedListId + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$v = function RelatedListReferenceRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$h,
        private: [],
        selections: [{
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'inContextOfRecordId',
          kind: 'Scalar'
        }, {
          name: 'listViewApiName',
          kind: 'Scalar'
        }, {
          name: 'objectApiName',
          kind: 'Scalar'
        }, {
          name: 'parentObjectApiName',
          kind: 'Scalar'
        }, {
          name: 'recordTypeId',
          kind: 'Scalar'
        }, {
          name: 'relatedListId',
          kind: 'Scalar'
        }, {
          name: 'type',
          kind: 'Scalar'
        }]
      };
    };
    function equals$h(existing, incoming) {
      const existing_parentObjectApiName = existing.parentObjectApiName;
      const incoming_parentObjectApiName = incoming.parentObjectApiName;
      if (!(existing_parentObjectApiName === incoming_parentObjectApiName)) {
        return false;
      }
      const existing_relatedListId = existing.relatedListId;
      const incoming_relatedListId = incoming.relatedListId;
      if (!(existing_relatedListId === incoming_relatedListId)) {
        return false;
      }
      const existing_type = existing.type;
      const incoming_type = incoming.type;
      if (!(existing_type === incoming_type)) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_inContextOfRecordId = existing.inContextOfRecordId;
      const incoming_inContextOfRecordId = incoming.inContextOfRecordId;
      if (!(existing_inContextOfRecordId === incoming_inContextOfRecordId)) {
        return false;
      }
      const existing_listViewApiName = existing.listViewApiName;
      const incoming_listViewApiName = incoming.listViewApiName;
      if (!(existing_listViewApiName === incoming_listViewApiName)) {
        return false;
      }
      const existing_objectApiName = existing.objectApiName;
      const incoming_objectApiName = incoming.objectApiName;
      if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
      }
      const existing_recordTypeId = existing.recordTypeId;
      const incoming_recordTypeId = incoming.recordTypeId;
      if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
      }
      return true;
    }
    const VERSION$g = "836b875b519813e7499efc62f0f1d04b";
    function validate$J(obj, path = 'RelatedListRecordCountRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        let obj_count_union0 = null;
        const obj_count_union0_error = (() => {
          if (typeof obj_count !== 'number' || typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count) {
            return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
          }
        })();
        if (obj_count_union0_error != null) {
          obj_count_union0 = obj_count_union0_error.message;
        }
        let obj_count_union1 = null;
        const obj_count_union1_error = (() => {
          if (obj_count !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_count + '" (at "' + path_count + '")');
          }
        })();
        if (obj_count_union1_error != null) {
          obj_count_union1 = obj_count_union1_error.message;
        }
        if (obj_count_union0 && obj_count_union1) {
          let message = 'Object doesn\'t match union (at "' + path_count + '")';
          message += '\n' + obj_count_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_count_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_hasMore = obj.hasMore;
        const path_hasMore = path + '.hasMore';
        if (typeof obj_hasMore !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_hasMore + '" (at "' + path_hasMore + '")');
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referencepath_listReferenceValidationError = validate$K(obj_listReference, path_listReference);
        if (referencepath_listReferenceValidationError !== null) {
          let message = 'Object doesn\'t match RelatedListReferenceRepresentation (at "' + path_listReference + '")\n';
          message += referencepath_listReferenceValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$h = 'RelatedListRecordCountRepresentation';
    function keyBuilder$L(luvio, config) {
      return keyPrefix + '::' + RepresentationType$h + ':' + (config.parentRecordId === null ? '' : config.parentRecordId) + ':' + config.relatedListId;
    }
    function keyBuilderFromType$e(luvio, object) {
      const keyParams = {
        parentRecordId: object.listReference.inContextOfRecordId,
        relatedListId: object.listReference.relatedListId
      };
      return keyBuilder$L(luvio, keyParams);
    }
    function normalize$c(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$u = function RelatedListRecordCountRepresentationSelect() {
      const {
        selections: RelatedListReferenceRepresentation__selections,
        opaque: RelatedListReferenceRepresentation__opaque
      } = select$v();
      return {
        kind: 'Fragment',
        version: VERSION$g,
        private: ['eTag'],
        selections: [{
          name: 'count',
          kind: 'Scalar'
        }, {
          name: 'hasMore',
          kind: 'Scalar'
        }, {
          name: 'listReference',
          kind: 'Object',
          selections: RelatedListReferenceRepresentation__selections
        }]
      };
    };
    function equals$g(existing, incoming) {
      const existing_hasMore = existing.hasMore;
      const incoming_hasMore = incoming.hasMore;
      if (!(existing_hasMore === incoming_hasMore)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_count = existing.count;
      const incoming_count = incoming.count;
      if (!(existing_count === incoming_count)) {
        return false;
      }
      const existing_listReference = existing.listReference;
      const incoming_listReference = incoming.listReference;
      if (!equals$h(existing_listReference, incoming_listReference)) {
        return false;
      }
      return true;
    }
    const ingest$c = function RelatedListRecordCountRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$J(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$e(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$c, "UiApi", VERSION$g, RepresentationType$h, equals$g);
      return createLink(key);
    };
    function getTypeCacheKeys$h(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$e(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$h,
        mergeable: false
      });
    }
    function select$t(luvio, params) {
      return select$u();
    }
    function keyBuilder$K(luvio, params) {
      return keyBuilder$L(luvio, {
        parentRecordId: params.urlParams.parentRecordId,
        relatedListId: params.urlParams.relatedListId
      });
    }
    function getResponseCacheKeys$q(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$h(storeKeyMap, luvio, response);
    }
    function ingestSuccess$k(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$K(luvio, resourceParams);
      luvio.storeIngest(key, ingest$c, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$t(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$e(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$K(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$t(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/related-list-count/' + config.urlParams.parentRecordId + '/' + config.urlParams.relatedListId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const nonCachedErrors$3 = ObjectCreate$1(null);
    function createChildResourceParams$4(resourceParams) {
      let childConfigs = [];
      for (let index = 0, len = resourceParams.urlParams.relatedListNames.length; index < len; index += 1) {
        const item = resourceParams.urlParams.relatedListNames[index];
        childConfigs.push({
          urlParams: {
            parentRecordId: resourceParams.urlParams.parentRecordId,
            relatedListId: item
          },
          queryParams: {
            maxCount: resourceParams.queryParams.maxCount
          }
        });
      }
      return childConfigs;
    }
    function selectChildResourceParams$3(luvio, childResources, resourceParams) {
      const envelopeBodyPath = 'result';
      const envelopeStatusCodePath = 'statusCode';
      const envelopePath = 'results';
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: reader => {
          // Top-level 404 lookup
          const result = reader.storeLookup(keyBuilder$J(luvio, resourceParams));
          if (result.state === reader.StoreResolveResultState.Error && result.value.status === 404) {
            return {
              state: 'Error',
              value: result.value
            };
          }
          const sink = {};
          reader.enterPath(envelopePath);
          const results = [];
          for (let i = 0, len = childResources.length; i < len; i += 1) {
            reader.enterPath(i);
            reader.enterPath(envelopeBodyPath);
            const childResource = childResources[i];
            const childKey = keyBuilder$K(luvio, childResource);
            const childFragment = select$t();
            const isMissingDataBeforeChildRead = reader.getIsDataMissing();
            const childSnapshot = reader.read({
              recordId: childKey,
              node: childFragment,
              variables: {}
            });
            reader.exitPath();
            const childSink = {};
            reader.markSeenId(childKey);
            switch (childSnapshot.state) {
              case 'Stale':
                reader.markStale();
              // Stale needs envelope bodies filled in so don't break
              case 'Fulfilled':
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                reader.exitPath();
                break;
              case 'Error':
                const childSnapshotError = childSnapshot.error;
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                reader.exitPath();
                break;
              case 'Unfulfilled':
                // if child snapshot doesn't have any data then
                // that means the child record key is missing
                if (childSnapshot.data === undefined) {
                  if (reader.isRebuilding() === false) {
                    // not a rebuild, mark as missing and move on
                    reader.markMissingLink(childKey);
                    break;
                  }
                  // On rebuilds we have to check if there is a non-cached
                  // error that we know about.  If we don't do this then
                  // rebuilds will go into endless refresh loop if a child
                  // has non-cached errors (since the top-level composite
                  // snapshot will look like an Unfulfilled snapshot
                  // instead of an error snapshot).
                  const nonCachedError = nonCachedErrors$3[childKey];
                  if (nonCachedError === undefined) {
                    reader.markMissingLink(childKey);
                  } else {
                    // if this child error was the only reason the reader
                    // is marked as missing then we want to undo that
                    if (isMissingDataBeforeChildRead === false) {
                      reader.unMarkMissing();
                    }
                    // put status code and body into reader path
                    const {
                      response: nonCachedBody,
                      status: nonCachedStatus
                    } = nonCachedError;
                    reader.enterPath(envelopeStatusCodePath);
                    reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                    reader.exitPath();
                    reader.enterPath(envelopeBodyPath);
                    reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                    reader.exitPath();
                  }
                }
                break;
              case 'Pending':
                reader.markPending();
                break;
            }
            ArrayPrototypePush.call(results, childSink);
            reader.exitPath();
          }
          reader.assignNonScalar(sink, envelopePath, results);
          reader.exitPath();
          return sink;
        }
      };
    }
    function select$s(luvio, resourceParams) {
      const childResources = createChildResourceParams$4(resourceParams);
      return selectChildResourceParams$3(luvio, childResources, resourceParams);
    }
    function keyBuilder$J(luvio, params) {
      return keyPrefix + '::BatchRelatedListCountRepresentation:(' + 'maxCount:' + params.queryParams.maxCount + ',' + 'parentRecordId:' + params.urlParams.parentRecordId + ',' + 'relatedListNames:' + params.urlParams.relatedListNames + ')';
    }
    function getResponseCacheKeys$p(keys, luvio, resourceParams, response) {
      const childEnvelopes = response.results;
      const childResourceParamsArray = createChildResourceParams$4(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      // get children keys
      for (let index = 0, len = childResourceParamsArray.length; index < len; index++) {
        const childResourceParams = childResourceParamsArray[index];
        const childResult = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = childResult;
        if (childStatusCode === 200) {
          getResponseCacheKeys$q(keys, luvio, childResourceParams, childBody);
        } else if (childStatusCode === 404) {
          const childKey = keyBuilder$K(luvio, childResourceParams);
          keys.set(childKey, {
            namespace: keyPrefix,
            representationName: RepresentationType$h,
            mergeable: false
          });
        }
      }
    }
    function ingestSuccessChildResourceParams$4(luvio, childResourceParamsArray, childEnvelopes) {
      const childSnapshotDataResponses = [];
      let seenRecords = new luvioEngine.StoreKeySet();
      let snapshotState = 'Fulfilled';
      for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$K(luvio, childResourceParams);
        const result = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = result;
        if (childStatusCode === 200) {
          const childResponse = {
            status: 200,
            body: childBody,
            ok: true,
            statusText: 'OK',
            headers: {}
          };
          const childSnapshot = ingestSuccess$k(luvio, childResourceParams, childResponse);
          if (childSnapshot.state === "Stale") {
            snapshotState = "Stale";
          }
          seenRecords.merge(childSnapshot.seenRecords);
          seenRecords.add(childSnapshot.recordId);
          const childValue = {
            statusCode: 200,
            result: childSnapshot.data
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        } else {
          const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
          const childResponse = {
            status: childStatusCode,
            body: childBody,
            ok: false,
            statusText: childStatusCodeText,
            headers: {},
            errorType: 'fetchResponse'
          };
          ingestError$e(luvio, childResourceParams, childResponse);
          seenRecords.add(childKey);
          const childValue = {
            statusCode: childStatusCode,
            result: childBody
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
          nonCachedErrors$3[childKey] = {
            response: childBody,
            status: childStatusCode
          };
        } else {
          delete nonCachedErrors$3[childKey];
        }
      }
      const childSnapshotData = {
        results: childSnapshotDataResponses
      };
      luvioEngine.deepFreeze(childSnapshotData);
      return {
        childSnapshotData: childSnapshotData,
        seenRecords,
        snapshotState
      };
    }
    function ingestSuccess$j(luvio, resourceParams, response, snapshotRefresh) {
      const childEnvelopes = response.body.results;
      const childResourceParamsArray = createChildResourceParams$4(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      const key = keyBuilder$J(luvio, resourceParams);
      const {
        childSnapshotData,
        seenRecords,
        snapshotState
      } = ingestSuccessChildResourceParams$4(luvio, childResourceParamsArray, childEnvelopes);
      const syntheticSnapshot = {
        recordId: key,
        data: childSnapshotData,
        state: snapshotState,
        seenRecords: seenRecords,
        select: {
          recordId: key,
          node: select$s(luvio, resourceParams),
          variables: {}
        },
        refresh: snapshotRefresh,
        variables: {}
      };
      // evict top level composite record from the store. This covers the case where a previous resource request returned a 404.
      luvio.storeEvict(key);
      return syntheticSnapshot;
    }
    function ingestError$d(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$J(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$s(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/related-list-count/batch/' + config.urlParams.parentRecordId + '/' + config.urlParams.relatedListNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$p = 'getRelatedListsCount';
    const getRelatedListsCount_ConfigPropertyMetadata = [generateParamConfigMetadata('parentRecordId', true, 0 /* UrlParameter */, 0 /* String */, false, getRecordId18), generateParamConfigMetadata('relatedListNames', true, 0 /* UrlParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('maxCount', false, 1 /* QueryParameter */, 3 /* Integer */)];
    const getRelatedListsCount_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$p, getRelatedListsCount_ConfigPropertyMetadata);
    const createResourceParams$q = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListsCount_ConfigPropertyMetadata);
    function keyBuilder$I(luvio, config) {
      const resourceParams = createResourceParams$q(config);
      return keyBuilder$J(luvio, resourceParams);
    }
    function typeCheckConfig$t(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListsCount_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$s(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRelatedListsCount_ConfigPropertyMetadata);
      const config = typeCheckConfig$t(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$f(luvio, config) {
      const resourceParams = createResourceParams$q(config);
      return select$s(luvio, resourceParams);
    }
    function onFetchResponseSuccess$g(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$j(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$s(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$f(luvio, config, resourceParams, response) {
      const snapshot = ingestError$d(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$s(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$s(luvio, config, options) {
      const resourceParams = createResourceParams$q(config);
      const request = createResourceRequest$s(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$g(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$p(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$f(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$i(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$s, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$h(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$I(luvio, config),
        node: adapterFragment$f(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$s(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRelatedListsCountAdapterFactory = luvio => function UiApi__getRelatedListsCount(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$s(untrustedConfig, getRelatedListsCount_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$h, buildNetworkSnapshotCachePolicy$i);
    };
    const adapterName$o = 'getRelatedListCount';
    const getRelatedListCount_ConfigPropertyMetadata = [generateParamConfigMetadata('parentRecordId', true, 0 /* UrlParameter */, 0 /* String */, false, getRecordId18), generateParamConfigMetadata('relatedListId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('maxCount', false, 1 /* QueryParameter */, 3 /* Integer */)];
    const getRelatedListCount_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$o, getRelatedListCount_ConfigPropertyMetadata);
    const createResourceParams$p = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListCount_ConfigPropertyMetadata);
    function keyBuilder$H(luvio, config) {
      const resourceParams = createResourceParams$p(config);
      return keyBuilder$K(luvio, resourceParams);
    }
    function typeCheckConfig$s(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListCount_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$r(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRelatedListCount_ConfigPropertyMetadata);
      const config = typeCheckConfig$s(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$e(luvio, config) {
      createResourceParams$p(config);
      return select$t();
    }
    function onFetchResponseSuccess$f(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$k(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$r(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$e(luvio, config, resourceParams, response) {
      const snapshot = ingestError$e(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$r(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$r(luvio, config, options) {
      const resourceParams = createResourceParams$p(config);
      const request = createResourceRequest$t(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$f(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$q(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$e(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$h(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$r, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$g(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$H(luvio, config),
        node: adapterFragment$e(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$r(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRelatedListCountAdapterFactory = luvio => function UiApi__getRelatedListCount(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$r(untrustedConfig, getRelatedListCount_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$g, buildNetworkSnapshotCachePolicy$h);
    };
    function validate$I(obj, path = 'RelatedListColumnRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_dataType = obj.dataType;
        const path_dataType = path + '.dataType';
        let obj_dataType_union0 = null;
        const obj_dataType_union0_error = (() => {
          if (typeof obj_dataType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_dataType + '" (at "' + path_dataType + '")');
          }
        })();
        if (obj_dataType_union0_error != null) {
          obj_dataType_union0 = obj_dataType_union0_error.message;
        }
        let obj_dataType_union1 = null;
        const obj_dataType_union1_error = (() => {
          if (obj_dataType !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_dataType + '" (at "' + path_dataType + '")');
          }
        })();
        if (obj_dataType_union1_error != null) {
          obj_dataType_union1 = obj_dataType_union1_error.message;
        }
        if (obj_dataType_union0 && obj_dataType_union1) {
          let message = 'Object doesn\'t match union (at "' + path_dataType + '")';
          message += '\n' + obj_dataType_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_dataType_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_filterable = obj.filterable;
        const path_filterable = path + '.filterable';
        let obj_filterable_union0 = null;
        const obj_filterable_union0_error = (() => {
          if (typeof obj_filterable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_filterable + '" (at "' + path_filterable + '")');
          }
        })();
        if (obj_filterable_union0_error != null) {
          obj_filterable_union0 = obj_filterable_union0_error.message;
        }
        let obj_filterable_union1 = null;
        const obj_filterable_union1_error = (() => {
          if (obj_filterable !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_filterable + '" (at "' + path_filterable + '")');
          }
        })();
        if (obj_filterable_union1_error != null) {
          obj_filterable_union1 = obj_filterable_union1_error.message;
        }
        if (obj_filterable_union0 && obj_filterable_union1) {
          let message = 'Object doesn\'t match union (at "' + path_filterable + '")';
          message += '\n' + obj_filterable_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_filterable_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_lookupId = obj.lookupId;
        const path_lookupId = path + '.lookupId';
        let obj_lookupId_union0 = null;
        const obj_lookupId_union0_error = (() => {
          if (typeof obj_lookupId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lookupId + '" (at "' + path_lookupId + '")');
          }
        })();
        if (obj_lookupId_union0_error != null) {
          obj_lookupId_union0 = obj_lookupId_union0_error.message;
        }
        let obj_lookupId_union1 = null;
        const obj_lookupId_union1_error = (() => {
          if (obj_lookupId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lookupId + '" (at "' + path_lookupId + '")');
          }
        })();
        if (obj_lookupId_union1_error != null) {
          obj_lookupId_union1 = obj_lookupId_union1_error.message;
        }
        if (obj_lookupId_union0 && obj_lookupId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lookupId + '")';
          message += '\n' + obj_lookupId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lookupId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_picklistValues = obj.picklistValues;
        const path_picklistValues = path + '.picklistValues';
        if (!ArrayIsArray(obj_picklistValues)) {
          return new TypeError('Expected "array" but received "' + typeof obj_picklistValues + '" (at "' + path_picklistValues + '")');
        }
        for (let i = 0; i < obj_picklistValues.length; i++) {
          const obj_picklistValues_item = obj_picklistValues[i];
          const path_picklistValues_item = path_picklistValues + '[' + i + ']';
          if (typeof obj_picklistValues_item !== 'object' || ArrayIsArray(obj_picklistValues_item) || obj_picklistValues_item === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_picklistValues_item + '" (at "' + path_picklistValues_item + '")');
          }
          const obj_picklistValues_item_keys = ObjectKeys(obj_picklistValues_item);
          for (let i = 0; i < obj_picklistValues_item_keys.length; i++) {
            const key = obj_picklistValues_item_keys[i];
            const obj_picklistValues_item_prop = obj_picklistValues_item[key];
            const path_picklistValues_item_prop = path_picklistValues_item + '["' + key + '"]';
            if (typeof obj_picklistValues_item_prop !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_picklistValues_item_prop + '" (at "' + path_picklistValues_item_prop + '")');
            }
          }
        }
        const obj_quickFilterOperator = obj.quickFilterOperator;
        const path_quickFilterOperator = path + '.quickFilterOperator';
        let obj_quickFilterOperator_union0 = null;
        const obj_quickFilterOperator_union0_error = (() => {
          if (typeof obj_quickFilterOperator !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_quickFilterOperator + '" (at "' + path_quickFilterOperator + '")');
          }
        })();
        if (obj_quickFilterOperator_union0_error != null) {
          obj_quickFilterOperator_union0 = obj_quickFilterOperator_union0_error.message;
        }
        let obj_quickFilterOperator_union1 = null;
        const obj_quickFilterOperator_union1_error = (() => {
          if (obj_quickFilterOperator !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_quickFilterOperator + '" (at "' + path_quickFilterOperator + '")');
          }
        })();
        if (obj_quickFilterOperator_union1_error != null) {
          obj_quickFilterOperator_union1 = obj_quickFilterOperator_union1_error.message;
        }
        if (obj_quickFilterOperator_union0 && obj_quickFilterOperator_union1) {
          let message = 'Object doesn\'t match union (at "' + path_quickFilterOperator + '")';
          message += '\n' + obj_quickFilterOperator_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_quickFilterOperator_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$c = 900000;
    const VERSION$f = "c977d65d153a2b4e888ddd45fb083248";
    function validate$H(obj, path = 'RelatedListInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_cloneable = obj.cloneable;
        const path_cloneable = path + '.cloneable';
        if (typeof obj_cloneable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_cloneable + '" (at "' + path_cloneable + '")');
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_deletable = obj.deletable;
        const path_deletable = path + '.deletable';
        if (typeof obj_deletable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_deletable + '" (at "' + path_deletable + '")');
        }
        const obj_displayColumns = obj.displayColumns;
        const path_displayColumns = path + '.displayColumns';
        if (!ArrayIsArray(obj_displayColumns)) {
          return new TypeError('Expected "array" but received "' + typeof obj_displayColumns + '" (at "' + path_displayColumns + '")');
        }
        for (let i = 0; i < obj_displayColumns.length; i++) {
          const obj_displayColumns_item = obj_displayColumns[i];
          const path_displayColumns_item = path_displayColumns + '[' + i + ']';
          const referencepath_displayColumns_itemValidationError = validate$I(obj_displayColumns_item, path_displayColumns_item);
          if (referencepath_displayColumns_itemValidationError !== null) {
            let message = 'Object doesn\'t match RelatedListColumnRepresentation (at "' + path_displayColumns_item + '")\n';
            message += referencepath_displayColumns_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (!ArrayIsArray(obj_fields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        for (let i = 0; i < obj_fields.length; i++) {
          const obj_fields_item = obj_fields[i];
          const path_fields_item = path_fields + '[' + i + ']';
          if (typeof obj_fields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fields_item + '" (at "' + path_fields_item + '")');
          }
        }
        const obj_filterLogicString = obj.filterLogicString;
        const path_filterLogicString = path + '.filterLogicString';
        if (typeof obj_filterLogicString !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_filterLogicString + '" (at "' + path_filterLogicString + '")');
        }
        const obj_filterable = obj.filterable;
        const path_filterable = path + '.filterable';
        if (typeof obj_filterable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_filterable + '" (at "' + path_filterable + '")');
        }
        const obj_filteredByInfo = obj.filteredByInfo;
        const path_filteredByInfo = path + '.filteredByInfo';
        if (!ArrayIsArray(obj_filteredByInfo)) {
          return new TypeError('Expected "array" but received "' + typeof obj_filteredByInfo + '" (at "' + path_filteredByInfo + '")');
        }
        for (let i = 0; i < obj_filteredByInfo.length; i++) {
          const obj_filteredByInfo_item = obj_filteredByInfo[i];
          const path_filteredByInfo_item = path_filteredByInfo + '[' + i + ']';
          const referencepath_filteredByInfo_itemValidationError = validate$2a(obj_filteredByInfo_item, path_filteredByInfo_item);
          if (referencepath_filteredByInfo_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListFilterByInfoRepresentation (at "' + path_filteredByInfo_item + '")\n';
            message += referencepath_filteredByInfo_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referencepath_listReferenceValidationError = validate$K(obj_listReference, path_listReference);
        if (referencepath_listReferenceValidationError !== null) {
          let message = 'Object doesn\'t match RelatedListReferenceRepresentation (at "' + path_listReference + '")\n';
          message += referencepath_listReferenceValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_objectApiNames = obj.objectApiNames;
        const path_objectApiNames = path + '.objectApiNames';
        if (!ArrayIsArray(obj_objectApiNames)) {
          return new TypeError('Expected "array" but received "' + typeof obj_objectApiNames + '" (at "' + path_objectApiNames + '")');
        }
        for (let i = 0; i < obj_objectApiNames.length; i++) {
          const obj_objectApiNames_item = obj_objectApiNames[i];
          const path_objectApiNames_item = path_objectApiNames + '[' + i + ']';
          if (typeof obj_objectApiNames_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiNames_item + '" (at "' + path_objectApiNames_item + '")');
          }
        }
        const obj_optionalFields = obj.optionalFields;
        const path_optionalFields = path + '.optionalFields';
        if (!ArrayIsArray(obj_optionalFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_optionalFields + '" (at "' + path_optionalFields + '")');
        }
        for (let i = 0; i < obj_optionalFields.length; i++) {
          const obj_optionalFields_item = obj_optionalFields[i];
          const path_optionalFields_item = path_optionalFields + '[' + i + ']';
          if (typeof obj_optionalFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_optionalFields_item + '" (at "' + path_optionalFields_item + '")');
          }
        }
        const obj_orderedByInfo = obj.orderedByInfo;
        const path_orderedByInfo = path + '.orderedByInfo';
        if (!ArrayIsArray(obj_orderedByInfo)) {
          return new TypeError('Expected "array" but received "' + typeof obj_orderedByInfo + '" (at "' + path_orderedByInfo + '")');
        }
        for (let i = 0; i < obj_orderedByInfo.length; i++) {
          const obj_orderedByInfo_item = obj_orderedByInfo[i];
          const path_orderedByInfo_item = path_orderedByInfo + '[' + i + ']';
          const referencepath_orderedByInfo_itemValidationError = validate$25(obj_orderedByInfo_item, path_orderedByInfo_item);
          if (referencepath_orderedByInfo_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListOrderByInfoRepresentation (at "' + path_orderedByInfo_item + '")\n';
            message += referencepath_orderedByInfo_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_restrictColumnsToLayout = obj.restrictColumnsToLayout;
        const path_restrictColumnsToLayout = path + '.restrictColumnsToLayout';
        if (typeof obj_restrictColumnsToLayout !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_restrictColumnsToLayout + '" (at "' + path_restrictColumnsToLayout + '")');
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
        const obj_userPreferences = obj.userPreferences;
        const path_userPreferences = path + '.userPreferences';
        const referencepath_userPreferencesValidationError = validate$21(obj_userPreferences, path_userPreferences);
        if (referencepath_userPreferencesValidationError !== null) {
          let message = 'Object doesn\'t match ListUserPreferenceRepresentation (at "' + path_userPreferences + '")\n';
          message += referencepath_userPreferencesValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_visibility = obj.visibility;
        const path_visibility = path + '.visibility';
        if (typeof obj_visibility !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_visibility + '" (at "' + path_visibility + '")');
        }
        const obj_visibilityEditable = obj.visibilityEditable;
        const path_visibilityEditable = path + '.visibilityEditable';
        if (typeof obj_visibilityEditable !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_visibilityEditable + '" (at "' + path_visibilityEditable + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$g = 'RelatedListInfoRepresentation';
    function keyBuilder$G(luvio, config) {
      return keyPrefix + '::' + RepresentationType$g + ':' + config.relatedListId + ':' + config.parentObjectApiName + ':' + config.restrictColumnsToLayout + ':' + (config.recordTypeId === null ? '' : config.recordTypeId) + ':' + '[' + config.optionalFields.join(',') + ']' + ':' + '[' + config.fields.join(',') + ']';
    }
    function keyBuilderFromType$d(luvio, object) {
      const keyParams = {
        relatedListId: object.listReference.relatedListId,
        parentObjectApiName: object.listReference.parentObjectApiName,
        restrictColumnsToLayout: object.restrictColumnsToLayout,
        recordTypeId: object.listReference.recordTypeId,
        optionalFields: object.optionalFields,
        fields: object.fields
      };
      return keyBuilder$G(luvio, keyParams);
    }
    function normalize$b(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$r = function RelatedListInfoRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$f,
        private: ['eTag'],
        selections: [{
          name: 'cloneable',
          kind: 'Scalar'
        }, {
          name: 'createable',
          kind: 'Scalar'
        }, {
          name: 'deletable',
          kind: 'Scalar'
        }, {
          name: 'displayColumns',
          kind: 'Object',
          opaque: true
        }, {
          name: 'fieldApiName',
          kind: 'Scalar'
        }, {
          name: 'fields',
          kind: 'Object',
          opaque: true
        }, {
          name: 'filterLogicString',
          kind: 'Scalar'
        }, {
          name: 'filterable',
          kind: 'Scalar'
        }, {
          name: 'filteredByInfo',
          kind: 'Object',
          opaque: true
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'listReference',
          kind: 'Object',
          opaque: true
        }, {
          name: 'objectApiNames',
          kind: 'Object',
          opaque: true
        }, {
          name: 'optionalFields',
          kind: 'Object',
          opaque: true
        }, {
          name: 'orderedByInfo',
          kind: 'Object',
          opaque: true
        }, {
          name: 'restrictColumnsToLayout',
          kind: 'Scalar'
        }, {
          name: 'updateable',
          kind: 'Scalar'
        }, {
          name: 'userPreferences',
          kind: 'Object',
          opaque: true
        }, {
          name: 'visibility',
          kind: 'Scalar'
        }, {
          name: 'visibilityEditable',
          kind: 'Scalar'
        }]
      };
    };
    function equals$f(existing, incoming) {
      if (existing.eTag !== incoming.eTag) {
        return false;
      }
      return true;
    }
    const ingest$b = function RelatedListInfoRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$H(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$d(luvio, input);
      const ttlToUse = TTL$c;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$b, "UiApi", VERSION$f, RepresentationType$g, equals$f);
      return createLink(key);
    };
    function getTypeCacheKeys$g(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$d(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$g,
        mergeable: false
      });
    }
    function select$q(luvio, params) {
      return select$r();
    }
    function keyBuilder$F(luvio, params) {
      return keyBuilder$G(luvio, {
        relatedListId: params.urlParams.relatedListId,
        parentObjectApiName: params.urlParams.parentObjectApiName,
        restrictColumnsToLayout: params.queryParams.restrictColumnsToLayout === false ? false : true,
        recordTypeId: params.queryParams.recordTypeId || null,
        optionalFields: params.queryParams.optionalFields || [],
        fields: params.queryParams.fields || []
      });
    }
    function getResponseCacheKeys$o(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$g(storeKeyMap, luvio, response);
    }
    function ingestSuccess$i(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$F(luvio, resourceParams);
      luvio.storeIngest(key, ingest$b, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$q(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$c(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$F(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$c,
        namespace: keyPrefix,
        version: VERSION$f,
        representationName: RepresentationType$g
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$r(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/related-list-info/' + config.urlParams.parentObjectApiName + '/' + config.urlParams.relatedListId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function createChildResourceParams$3(resourceParams) {
      const childConfigs = [];
      for (let index = 0, len = resourceParams.urlParams.relatedListNames.length; index < len; index += 1) {
        const item = resourceParams.urlParams.relatedListNames[index];
        childConfigs.push({
          urlParams: {
            parentObjectApiName: resourceParams.urlParams.parentObjectApiName,
            relatedListId: item
          },
          queryParams: {
            recordTypeId: resourceParams.queryParams.recordTypeId,
            fields: [],
            optionalFields: [],
            restrictColumnsToLayout: true
          }
        });
      }
      return childConfigs;
    }
    const nonCachedErrors$2 = ObjectCreate$1(null);
    function selectChildResourceParams$2(luvio, childResources, resourceParams) {
      const envelopeBodyPath = 'result';
      const envelopeStatusCodePath = 'statusCode';
      const envelopePath = 'results';
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: reader => {
          // Top-level 404 lookup
          const result = reader.storeLookup(keyBuilder$E(luvio, resourceParams));
          if (result.state === reader.StoreResolveResultState.Error && result.value.status === 404) {
            return {
              state: 'Error',
              value: result.value
            };
          }
          const sink = {};
          reader.enterPath(envelopePath);
          const results = [];
          for (let i = 0, len = childResources.length; i < len; i += 1) {
            reader.enterPath(i);
            reader.enterPath(envelopeBodyPath);
            const childResource = childResources[i];
            const childKey = keyBuilder$F(luvio, childResource);
            const childFragment = select$q();
            const isMissingDataBeforeChildRead = reader.getIsDataMissing();
            const childSnapshot = reader.read({
              recordId: childKey,
              node: childFragment,
              variables: {}
            });
            reader.exitPath();
            const childSink = {};
            reader.markSeenId(childKey);
            switch (childSnapshot.state) {
              case 'Stale':
                reader.markStale();
              // Stale needs envelope bodies filled in so don't break
              case 'Fulfilled':
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                reader.exitPath();
                break;
              case 'Error':
                const childSnapshotError = childSnapshot.error;
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                reader.exitPath();
                break;
              case 'Unfulfilled':
                // if child snapshot doesn't have any data then
                // that means the child record key is missing
                if (childSnapshot.data === undefined) {
                  if (reader.isRebuilding() === false) {
                    // not a rebuild, mark as missing and move on
                    reader.markMissingLink(childKey);
                    break;
                  }
                  // On rebuilds we have to check if there is a non-cached
                  // error that we know about.  If we don't do this then
                  // rebuilds will go into endless refresh loop if a child
                  // has non-cached errors (since the top-level composite
                  // snapshot will look like an Unfulfilled snapshot
                  // instead of an error snapshot).
                  const nonCachedError = nonCachedErrors$2[childKey];
                  if (nonCachedError === undefined || nonCachedError.expiration < reader.getTimeStamp()) {
                    reader.markMissingLink(childKey);
                  } else {
                    // if this child error was the only reason the reader
                    // is marked as missing then we want to undo that
                    if (isMissingDataBeforeChildRead === false) {
                      reader.unMarkMissing();
                    }
                    // put status code and body into reader path
                    const {
                      response: nonCachedBody,
                      status: nonCachedStatus
                    } = nonCachedError;
                    reader.enterPath(envelopeStatusCodePath);
                    reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                    reader.exitPath();
                    reader.enterPath(envelopeBodyPath);
                    reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                    reader.exitPath();
                  }
                }
                break;
              case 'Pending':
                reader.markPending();
                break;
            }
            ArrayPrototypePush.call(results, childSink);
            reader.exitPath();
          }
          reader.assignNonScalar(sink, envelopePath, results);
          reader.exitPath();
          return sink;
        }
      };
    }
    function select$p(luvio, resourceParams) {
      const childResources = createChildResourceParams$3(resourceParams);
      return selectChildResourceParams$2(luvio, childResources, resourceParams);
    }
    function keyBuilder$E(luvio, params) {
      return keyPrefix + '::RelatedListInfoBatchRepresentation:(' + 'recordTypeId:' + params.queryParams.recordTypeId + ',' + 'parentObjectApiName:' + params.urlParams.parentObjectApiName + ',' + 'relatedListNames:' + params.urlParams.relatedListNames + ')';
    }
    function getResponseCacheKeys$n(keys, luvio, resourceParams, response) {
      const childEnvelopes = response.results;
      const childResourceParamsArray = createChildResourceParams$3(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      // get children keys
      for (let index = 0, len = childResourceParamsArray.length; index < len; index++) {
        const childResourceParams = childResourceParamsArray[index];
        const childResult = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = childResult;
        if (childStatusCode === 200) {
          getResponseCacheKeys$o(keys, luvio, childResourceParams, childBody);
        } else if (childStatusCode === 404) {
          const childKey = keyBuilder$F(luvio, childResourceParams);
          keys.set(childKey, {
            namespace: keyPrefix,
            representationName: RepresentationType$g,
            mergeable: false
          });
        }
      }
    }
    function ingestSuccessChildResourceParams$3(luvio, childResourceParamsArray, childEnvelopes) {
      const childSnapshotDataResponses = [];
      let seenRecords = new luvioEngine.StoreKeySet();
      let snapshotState = 'Fulfilled';
      const now = Date.now();
      for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$F(luvio, childResourceParams);
        const result = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = result;
        if (childStatusCode === 200) {
          const childResponse = {
            status: 200,
            body: childBody,
            ok: true,
            statusText: 'OK',
            headers: {}
          };
          const childSnapshot = ingestSuccess$i(luvio, childResourceParams, childResponse);
          if (childSnapshot.state === "Stale") {
            snapshotState = "Stale";
          }
          seenRecords.merge(childSnapshot.seenRecords);
          seenRecords.add(childSnapshot.recordId);
          const childValue = {
            statusCode: 200,
            result: childSnapshot.data
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        } else {
          const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
          const childResponse = {
            status: childStatusCode,
            body: childBody,
            ok: false,
            statusText: childStatusCodeText,
            headers: {},
            errorType: 'fetchResponse'
          };
          ingestError$c(luvio, childResourceParams, childResponse);
          seenRecords.add(childKey);
          const childValue = {
            statusCode: childStatusCode,
            result: childBody
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
          nonCachedErrors$2[childKey] = {
            expiration: now + TTL$c,
            response: childBody,
            status: childStatusCode
          };
        } else {
          delete nonCachedErrors$2[childKey];
        }
      }
      const childSnapshotData = {
        results: childSnapshotDataResponses
      };
      luvioEngine.deepFreeze(childSnapshotData);
      return {
        childSnapshotData: childSnapshotData,
        seenRecords,
        snapshotState
      };
    }
    function ingestSuccess$h(luvio, resourceParams, response, snapshotRefresh) {
      const childEnvelopes = response.body.results;
      const childResourceParamsArray = createChildResourceParams$3(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      const key = keyBuilder$E(luvio, resourceParams);
      const {
        childSnapshotData,
        seenRecords,
        snapshotState
      } = ingestSuccessChildResourceParams$3(luvio, childResourceParamsArray, childEnvelopes);
      const syntheticSnapshot = {
        recordId: key,
        data: childSnapshotData,
        state: snapshotState,
        seenRecords: seenRecords,
        select: {
          recordId: key,
          node: select$p(luvio, resourceParams),
          variables: {}
        },
        refresh: snapshotRefresh,
        variables: {}
      };
      // evict top level composite record from the store. This covers the case where a previous resource request returned a 404.
      luvio.storeEvict(key);
      return syntheticSnapshot;
    }
    function ingestError$b(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$E(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$q(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/related-list-info/batch/' + config.urlParams.parentObjectApiName + '/' + config.urlParams.relatedListNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$n = 'getRelatedListInfoBatch';
    const getRelatedListInfoBatch_ConfigPropertyMetadata = [generateParamConfigMetadata('parentObjectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('relatedListNames', true, 0 /* UrlParameter */, 0 /* String */, true), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */)];
    const getRelatedListInfoBatch_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$n, getRelatedListInfoBatch_ConfigPropertyMetadata);
    const createResourceParams$o = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListInfoBatch_ConfigPropertyMetadata);
    function keyBuilder$D(luvio, config) {
      const resourceParams = createResourceParams$o(config);
      return keyBuilder$E(luvio, resourceParams);
    }
    function typeCheckConfig$r(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListInfoBatch_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$q(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRelatedListInfoBatch_ConfigPropertyMetadata);
      const config = typeCheckConfig$r(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$d(luvio, config) {
      const resourceParams = createResourceParams$o(config);
      return select$p(luvio, resourceParams);
    }
    function onFetchResponseSuccess$e(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$h(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$q(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$d(luvio, config, resourceParams, response) {
      const snapshot = ingestError$b(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$q(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$q(luvio, config, options) {
      const resourceParams = createResourceParams$o(config);
      const request = createResourceRequest$q(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$e(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$n(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$d(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$g(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$q, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$f(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$D(luvio, config),
        node: adapterFragment$d(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$q(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRelatedListInfoBatchAdapterFactory = luvio => function UiApi__getRelatedListInfoBatch(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$q(untrustedConfig, getRelatedListInfoBatch_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$f, buildNetworkSnapshotCachePolicy$g);
    };
    function validate$G(obj, path = 'RelatedListSummaryInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_entityLabel = obj.entityLabel;
        const path_entityLabel = path + '.entityLabel';
        if (typeof obj_entityLabel !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_entityLabel + '" (at "' + path_entityLabel + '")');
        }
        const obj_entityPluralLabel = obj.entityPluralLabel;
        const path_entityPluralLabel = path + '.entityPluralLabel';
        if (typeof obj_entityPluralLabel !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_entityPluralLabel + '" (at "' + path_entityPluralLabel + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_keyPrefix = obj.keyPrefix;
        const path_keyPrefix = path + '.keyPrefix';
        let obj_keyPrefix_union0 = null;
        const obj_keyPrefix_union0_error = (() => {
          if (typeof obj_keyPrefix !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
          }
        })();
        if (obj_keyPrefix_union0_error != null) {
          obj_keyPrefix_union0 = obj_keyPrefix_union0_error.message;
        }
        let obj_keyPrefix_union1 = null;
        const obj_keyPrefix_union1_error = (() => {
          if (obj_keyPrefix !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
          }
        })();
        if (obj_keyPrefix_union1_error != null) {
          obj_keyPrefix_union1 = obj_keyPrefix_union1_error.message;
        }
        if (obj_keyPrefix_union0 && obj_keyPrefix_union1) {
          let message = 'Object doesn\'t match union (at "' + path_keyPrefix + '")';
          message += '\n' + obj_keyPrefix_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_keyPrefix_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_parentFieldApiName = obj.parentFieldApiName;
        const path_parentFieldApiName = path + '.parentFieldApiName';
        if (typeof obj_parentFieldApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_parentFieldApiName + '" (at "' + path_parentFieldApiName + '")');
        }
        const obj_relatedListId = obj.relatedListId;
        const path_relatedListId = path + '.relatedListId';
        if (typeof obj_relatedListId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_relatedListId + '" (at "' + path_relatedListId + '")');
        }
        const obj_relatedListInfoUrl = obj.relatedListInfoUrl;
        const path_relatedListInfoUrl = path + '.relatedListInfoUrl';
        let obj_relatedListInfoUrl_union0 = null;
        const obj_relatedListInfoUrl_union0_error = (() => {
          if (typeof obj_relatedListInfoUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relatedListInfoUrl + '" (at "' + path_relatedListInfoUrl + '")');
          }
        })();
        if (obj_relatedListInfoUrl_union0_error != null) {
          obj_relatedListInfoUrl_union0 = obj_relatedListInfoUrl_union0_error.message;
        }
        let obj_relatedListInfoUrl_union1 = null;
        const obj_relatedListInfoUrl_union1_error = (() => {
          if (obj_relatedListInfoUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_relatedListInfoUrl + '" (at "' + path_relatedListInfoUrl + '")');
          }
        })();
        if (obj_relatedListInfoUrl_union1_error != null) {
          obj_relatedListInfoUrl_union1 = obj_relatedListInfoUrl_union1_error.message;
        }
        if (obj_relatedListInfoUrl_union0 && obj_relatedListInfoUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_relatedListInfoUrl + '")';
          message += '\n' + obj_relatedListInfoUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_relatedListInfoUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_themeInfo = obj.themeInfo;
        const path_themeInfo = path + '.themeInfo';
        let obj_themeInfo_union0 = null;
        const obj_themeInfo_union0_error = (() => {
          const referencepath_themeInfoValidationError = validate$1K(obj_themeInfo, path_themeInfo);
          if (referencepath_themeInfoValidationError !== null) {
            let message = 'Object doesn\'t match ThemeInfoRepresentation (at "' + path_themeInfo + '")\n';
            message += referencepath_themeInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_themeInfo_union0_error != null) {
          obj_themeInfo_union0 = obj_themeInfo_union0_error.message;
        }
        let obj_themeInfo_union1 = null;
        const obj_themeInfo_union1_error = (() => {
          if (obj_themeInfo !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_themeInfo + '" (at "' + path_themeInfo + '")');
          }
        })();
        if (obj_themeInfo_union1_error != null) {
          obj_themeInfo_union1 = obj_themeInfo_union1_error.message;
        }
        if (obj_themeInfo_union0 && obj_themeInfo_union1) {
          let message = 'Object doesn\'t match union (at "' + path_themeInfo + '")';
          message += '\n' + obj_themeInfo_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_themeInfo_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_uiApiEnabledLayout = obj.uiApiEnabledLayout;
        const path_uiApiEnabledLayout = path + '.uiApiEnabledLayout';
        if (typeof obj_uiApiEnabledLayout !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_uiApiEnabledLayout + '" (at "' + path_uiApiEnabledLayout + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const VERSION$e = "2a1722afba0e1ee52d6b7b0a25ccd9f4";
    function validate$F(obj, path = 'RelatedListSummaryInfoCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_parentObjectApiName = obj.parentObjectApiName;
        const path_parentObjectApiName = path + '.parentObjectApiName';
        if (typeof obj_parentObjectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_parentObjectApiName + '" (at "' + path_parentObjectApiName + '")');
        }
        const obj_parentRecordTypeId = obj.parentRecordTypeId;
        const path_parentRecordTypeId = path + '.parentRecordTypeId';
        let obj_parentRecordTypeId_union0 = null;
        const obj_parentRecordTypeId_union0_error = (() => {
          if (typeof obj_parentRecordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_parentRecordTypeId + '" (at "' + path_parentRecordTypeId + '")');
          }
        })();
        if (obj_parentRecordTypeId_union0_error != null) {
          obj_parentRecordTypeId_union0 = obj_parentRecordTypeId_union0_error.message;
        }
        let obj_parentRecordTypeId_union1 = null;
        const obj_parentRecordTypeId_union1_error = (() => {
          if (obj_parentRecordTypeId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_parentRecordTypeId + '" (at "' + path_parentRecordTypeId + '")');
          }
        })();
        if (obj_parentRecordTypeId_union1_error != null) {
          obj_parentRecordTypeId_union1 = obj_parentRecordTypeId_union1_error.message;
        }
        if (obj_parentRecordTypeId_union0 && obj_parentRecordTypeId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_parentRecordTypeId + '")';
          message += '\n' + obj_parentRecordTypeId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_parentRecordTypeId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_relatedLists = obj.relatedLists;
        const path_relatedLists = path + '.relatedLists';
        if (!ArrayIsArray(obj_relatedLists)) {
          return new TypeError('Expected "array" but received "' + typeof obj_relatedLists + '" (at "' + path_relatedLists + '")');
        }
        for (let i = 0; i < obj_relatedLists.length; i++) {
          const obj_relatedLists_item = obj_relatedLists[i];
          const path_relatedLists_item = path_relatedLists + '[' + i + ']';
          const referencepath_relatedLists_itemValidationError = validate$G(obj_relatedLists_item, path_relatedLists_item);
          if (referencepath_relatedLists_itemValidationError !== null) {
            let message = 'Object doesn\'t match RelatedListSummaryInfoRepresentation (at "' + path_relatedLists_item + '")\n';
            message += referencepath_relatedLists_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$f = 'RelatedListSummaryInfoCollectionRepresentation';
    function keyBuilder$C(luvio, config) {
      return keyPrefix + '::' + RepresentationType$f + ':' + config.parentObjectApiName + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
    }
    function keyBuilderFromType$c(luvio, object) {
      const keyParams = {
        parentObjectApiName: object.parentObjectApiName,
        recordTypeId: object.parentRecordTypeId
      };
      return keyBuilder$C(luvio, keyParams);
    }
    function normalize$a(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$o = function RelatedListSummaryInfoCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$e,
        private: ['eTag'],
        selections: [{
          name: 'parentObjectApiName',
          kind: 'Scalar'
        }, {
          name: 'parentRecordTypeId',
          kind: 'Scalar'
        }, {
          name: 'relatedLists',
          kind: 'Object',
          opaque: true
        }]
      };
    };
    function equals$e(existing, incoming) {
      if (existing.eTag !== incoming.eTag) {
        return false;
      }
      return true;
    }
    const ingest$a = function RelatedListSummaryInfoCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$F(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$c(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$a, "UiApi", VERSION$e, RepresentationType$f, equals$e);
      return createLink(key);
    };
    function getTypeCacheKeys$f(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$c(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$f,
        mergeable: false
      });
    }
    function select$n(luvio, params) {
      return select$o();
    }
    function keyBuilder$B(luvio, params) {
      return keyBuilder$C(luvio, {
        parentObjectApiName: params.urlParams.parentObjectApiName,
        recordTypeId: params.queryParams.recordTypeId || null
      });
    }
    function getResponseCacheKeys$m(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$f(storeKeyMap, luvio, response);
    }
    function ingestSuccess$g(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$B(luvio, resourceParams);
      luvio.storeIngest(key, ingest$a, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$n(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$a(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$B(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$p(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/related-list-info/' + config.urlParams.parentObjectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$m = 'getRelatedListsInfo';
    const getRelatedListsInfo_ConfigPropertyMetadata = [generateParamConfigMetadata('parentObjectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */)];
    const getRelatedListsInfo_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$m, getRelatedListsInfo_ConfigPropertyMetadata);
    const createResourceParams$n = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListsInfo_ConfigPropertyMetadata);
    function keyBuilder$A(luvio, config) {
      const resourceParams = createResourceParams$n(config);
      return keyBuilder$B(luvio, resourceParams);
    }
    function typeCheckConfig$q(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListsInfo_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$p(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRelatedListsInfo_ConfigPropertyMetadata);
      const config = typeCheckConfig$q(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$c(luvio, config) {
      createResourceParams$n(config);
      return select$n();
    }
    function onFetchResponseSuccess$d(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$g(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$p(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$c(luvio, config, resourceParams, response) {
      const snapshot = ingestError$a(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$p(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$p(luvio, config, options) {
      const resourceParams = createResourceParams$n(config);
      const request = createResourceRequest$p(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$d(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$m(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$c(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$f(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$p, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$e(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$A(luvio, config),
        node: adapterFragment$c(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$p(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRelatedListsInfoAdapterFactory = luvio => function UiApi__getRelatedListsInfo(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$p(untrustedConfig, getRelatedListsInfo_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$e, buildNetworkSnapshotCachePolicy$f);
    };
    const adapterName$l = 'getRelatedListInfo';
    const getRelatedListInfo_ConfigPropertyMetadata = [generateParamConfigMetadata('parentObjectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('relatedListId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('fields', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('optionalFields', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('restrictColumnsToLayout', false, 1 /* QueryParameter */, 1 /* Boolean */)];
    const getRelatedListInfo_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$l, getRelatedListInfo_ConfigPropertyMetadata);
    const createResourceParams$m = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListInfo_ConfigPropertyMetadata);
    function keyBuilder$z(luvio, config) {
      const resourceParams = createResourceParams$m(config);
      return keyBuilder$F(luvio, resourceParams);
    }
    function typeCheckConfig$p(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListInfo_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$o(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRelatedListInfo_ConfigPropertyMetadata);
      const config = typeCheckConfig$p(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$b(luvio, config) {
      createResourceParams$m(config);
      return select$q();
    }
    function onFetchResponseSuccess$c(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$i(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$o(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$b(luvio, config, resourceParams, response) {
      const snapshot = ingestError$c(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$o(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$o(luvio, config, options) {
      const resourceParams = createResourceParams$m(config);
      const request = createResourceRequest$r(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$c(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$o(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$b(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$e(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$o, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$d(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$z(luvio, config),
        node: adapterFragment$b(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$o(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRelatedListInfoAdapterFactory = luvio => function UiApi__getRelatedListInfo(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$o(untrustedConfig, getRelatedListInfo_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$d, buildNetworkSnapshotCachePolicy$e);
    };
    function validate$E(obj, path = 'ListUserPreferenceInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_columnWidths = obj.columnWidths;
        const path_columnWidths = path + '.columnWidths';
        if (typeof obj_columnWidths !== 'object' || ArrayIsArray(obj_columnWidths) || obj_columnWidths === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_columnWidths + '" (at "' + path_columnWidths + '")');
        }
        const obj_columnWidths_keys = ObjectKeys(obj_columnWidths);
        for (let i = 0; i < obj_columnWidths_keys.length; i++) {
          const key = obj_columnWidths_keys[i];
          const obj_columnWidths_prop = obj_columnWidths[key];
          const path_columnWidths_prop = path_columnWidths + '["' + key + '"]';
          if (typeof obj_columnWidths_prop !== 'number' || typeof obj_columnWidths_prop === 'number' && Math.floor(obj_columnWidths_prop) !== obj_columnWidths_prop) {
            return new TypeError('Expected "integer" but received "' + typeof obj_columnWidths_prop + '" (at "' + path_columnWidths_prop + '")');
          }
        }
        const obj_columnWrap = obj.columnWrap;
        const path_columnWrap = path + '.columnWrap';
        if (typeof obj_columnWrap !== 'object' || ArrayIsArray(obj_columnWrap) || obj_columnWrap === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_columnWrap + '" (at "' + path_columnWrap + '")');
        }
        const obj_columnWrap_keys = ObjectKeys(obj_columnWrap);
        for (let i = 0; i < obj_columnWrap_keys.length; i++) {
          const key = obj_columnWrap_keys[i];
          const obj_columnWrap_prop = obj_columnWrap[key];
          const path_columnWrap_prop = path_columnWrap + '["' + key + '"]';
          if (typeof obj_columnWrap_prop !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_columnWrap_prop + '" (at "' + path_columnWrap_prop + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function select$m(luvio, params) {
      return select$r();
    }
    function getResponseCacheKeys$l(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$g(storeKeyMap, luvio, response);
    }
    function ingestSuccess$f(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$d(luvio, body);
      luvio.storeIngest(key, ingest$b, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$m(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$o(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/related-list-info/' + config.urlParams.parentObjectApiName + '/' + config.urlParams.relatedListId + '',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function typeCheckConfig$o(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, updateRelatedListInfo_ConfigPropertyMetadata);
      const untrustedConfig_orderedByInfo = untrustedConfig.orderedByInfo;
      if (ArrayIsArray$1(untrustedConfig_orderedByInfo)) {
        const untrustedConfig_orderedByInfo_array = [];
        for (let i = 0, arrayLength = untrustedConfig_orderedByInfo.length; i < arrayLength; i++) {
          const untrustedConfig_orderedByInfo_item = untrustedConfig_orderedByInfo[i];
          const referenceListOrderedByInfoInputRepresentationValidationError = validate$12(untrustedConfig_orderedByInfo_item);
          if (referenceListOrderedByInfoInputRepresentationValidationError === null) {
            untrustedConfig_orderedByInfo_array.push(untrustedConfig_orderedByInfo_item);
          }
        }
        config.orderedByInfo = untrustedConfig_orderedByInfo_array;
      }
      const untrustedConfig_userPreferences = untrustedConfig.userPreferences;
      const referenceListUserPreferenceInputRepresentationValidationError = validate$E(untrustedConfig_userPreferences);
      if (referenceListUserPreferenceInputRepresentationValidationError === null) {
        config.userPreferences = untrustedConfig_userPreferences;
      } else {
        throw referenceListUserPreferenceInputRepresentationValidationError;
      }
      return config;
    }
    const adapterName$k = 'updateRelatedListInfo';
    const updateRelatedListInfo_ConfigPropertyMetadata = [generateParamConfigMetadata('parentObjectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('relatedListId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('orderedByInfo', true, 2 /* Body */, 4 /* Unsupported */, true), generateParamConfigMetadata('userPreferences', true, 2 /* Body */, 4 /* Unsupported */)];
    const updateRelatedListInfo_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$k, updateRelatedListInfo_ConfigPropertyMetadata);
    const createResourceParams$l = /*#__PURE__*/luvioEngine.createResourceParams(updateRelatedListInfo_ConfigPropertyMetadata);
    function validateAdapterConfig$n(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, updateRelatedListInfo_ConfigPropertyMetadata);
      const config = typeCheckConfig$o(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$n(luvio, config, options) {
      const resourceParams = createResourceParams$l(config);
      const request = createResourceRequest$o(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$f(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$l(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const updateRelatedListInfoAdapterFactory = luvio => {
      return function updateRelatedListInfo(untrustedConfig) {
        const config = validateAdapterConfig$n(untrustedConfig, updateRelatedListInfo_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "updateRelatedListInfo"');
        }
        return buildNetworkSnapshot$n(luvio, config);
      };
    };
    const TTL$b = 900000;
    const VERSION$d = "094cdf8e3e1f07fca02c4e51e14c528e";
    function validate$D(obj, path = 'RelatedListUserPreferencesRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_columnWidths = obj.columnWidths;
        const path_columnWidths = path + '.columnWidths';
        if (typeof obj_columnWidths !== 'object' || ArrayIsArray(obj_columnWidths) || obj_columnWidths === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_columnWidths + '" (at "' + path_columnWidths + '")');
        }
        const obj_columnWidths_keys = ObjectKeys(obj_columnWidths);
        for (let i = 0; i < obj_columnWidths_keys.length; i++) {
          const key = obj_columnWidths_keys[i];
          const obj_columnWidths_prop = obj_columnWidths[key];
          const path_columnWidths_prop = path_columnWidths + '["' + key + '"]';
          if (typeof obj_columnWidths_prop !== 'number' || typeof obj_columnWidths_prop === 'number' && Math.floor(obj_columnWidths_prop) !== obj_columnWidths_prop) {
            return new TypeError('Expected "integer" but received "' + typeof obj_columnWidths_prop + '" (at "' + path_columnWidths_prop + '")');
          }
        }
        const obj_columnWrap = obj.columnWrap;
        const path_columnWrap = path + '.columnWrap';
        if (typeof obj_columnWrap !== 'object' || ArrayIsArray(obj_columnWrap) || obj_columnWrap === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_columnWrap + '" (at "' + path_columnWrap + '")');
        }
        const obj_columnWrap_keys = ObjectKeys(obj_columnWrap);
        for (let i = 0; i < obj_columnWrap_keys.length; i++) {
          const key = obj_columnWrap_keys[i];
          const obj_columnWrap_prop = obj_columnWrap[key];
          const path_columnWrap_prop = path_columnWrap + '["' + key + '"]';
          if (typeof obj_columnWrap_prop !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_columnWrap_prop + '" (at "' + path_columnWrap_prop + '")');
          }
        }
        const obj_orderedBy = obj.orderedBy;
        const path_orderedBy = path + '.orderedBy';
        if (!ArrayIsArray(obj_orderedBy)) {
          return new TypeError('Expected "array" but received "' + typeof obj_orderedBy + '" (at "' + path_orderedBy + '")');
        }
        for (let i = 0; i < obj_orderedBy.length; i++) {
          const obj_orderedBy_item = obj_orderedBy[i];
          const path_orderedBy_item = path_orderedBy + '[' + i + ']';
          const referencepath_orderedBy_itemValidationError = validate$25(obj_orderedBy_item, path_orderedBy_item);
          if (referencepath_orderedBy_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListOrderByInfoRepresentation (at "' + path_orderedBy_item + '")\n';
            message += referencepath_orderedBy_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_preferencesId = obj.preferencesId;
        const path_preferencesId = path + '.preferencesId';
        if (typeof obj_preferencesId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_preferencesId + '" (at "' + path_preferencesId + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$e = 'RelatedListUserPreferencesRepresentation';
    function keyBuilder$y(luvio, config) {
      return keyPrefix + '::' + RepresentationType$e + ':' + config.preferencesId;
    }
    function keyBuilderFromType$b(luvio, object) {
      const keyParams = {
        preferencesId: object.preferencesId
      };
      return keyBuilder$y(luvio, keyParams);
    }
    function normalize$9(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$l = function RelatedListUserPreferencesRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$d,
        private: [],
        opaque: true
      };
    };
    function equals$d(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$9 = function RelatedListUserPreferencesRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$D(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$b(luvio, input);
      const ttlToUse = TTL$b;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$9, "UiApi", VERSION$d, RepresentationType$e, equals$d);
      return createLink(key);
    };
    function getTypeCacheKeys$e(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$b(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$e,
        mergeable: false
      });
    }
    function select$k(luvio, params) {
      return select$l();
    }
    function keyBuilder$x(luvio, params) {
      return keyBuilder$y(luvio, {
        preferencesId: params.urlParams.preferencesId
      });
    }
    function getResponseCacheKeys$k(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$e(storeKeyMap, luvio, response);
    }
    function ingestSuccess$e(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$x(luvio, resourceParams);
      luvio.storeIngest(key, ingest$9, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$k(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$9(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$x(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$b,
        namespace: keyPrefix,
        version: VERSION$d,
        representationName: RepresentationType$e
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$n(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/related-list-preferences/' + config.urlParams.preferencesId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const nonCachedErrors$1 = ObjectCreate$1(null);
    function createChildResourceParams$2(resourceParams) {
      let childConfigs = [];
      for (let index = 0, len = resourceParams.urlParams.preferencesIds.length; index < len; index += 1) {
        const item = resourceParams.urlParams.preferencesIds[index];
        childConfigs.push({
          urlParams: {
            preferencesId: item
          }
        });
      }
      return childConfigs;
    }
    function selectChildResourceParams$1(luvio, childResources, resourceParams) {
      const envelopeBodyPath = 'result';
      const envelopeStatusCodePath = 'statusCode';
      const envelopePath = 'results';
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: reader => {
          // Top-level 404 lookup
          const result = reader.storeLookup(keyBuilder$w(luvio, resourceParams));
          if (result.state === reader.StoreResolveResultState.Error && result.value.status === 404) {
            return {
              state: 'Error',
              value: result.value
            };
          }
          const sink = {};
          reader.enterPath(envelopePath);
          const results = [];
          for (let i = 0, len = childResources.length; i < len; i += 1) {
            reader.enterPath(i);
            reader.enterPath(envelopeBodyPath);
            const childResource = childResources[i];
            const childKey = keyBuilder$x(luvio, childResource);
            const childFragment = select$k();
            const isMissingDataBeforeChildRead = reader.getIsDataMissing();
            const childSnapshot = reader.read({
              recordId: childKey,
              node: childFragment,
              variables: {}
            });
            reader.exitPath();
            const childSink = {};
            reader.markSeenId(childKey);
            switch (childSnapshot.state) {
              case 'Stale':
                reader.markStale();
              // Stale needs envelope bodies filled in so don't break
              case 'Fulfilled':
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                reader.exitPath();
                break;
              case 'Error':
                const childSnapshotError = childSnapshot.error;
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                reader.exitPath();
                break;
              case 'Unfulfilled':
                // if child snapshot doesn't have any data then
                // that means the child record key is missing
                if (childSnapshot.data === undefined) {
                  if (reader.isRebuilding() === false) {
                    // not a rebuild, mark as missing and move on
                    reader.markMissingLink(childKey);
                    break;
                  }
                  // On rebuilds we have to check if there is a non-cached
                  // error that we know about.  If we don't do this then
                  // rebuilds will go into endless refresh loop if a child
                  // has non-cached errors (since the top-level composite
                  // snapshot will look like an Unfulfilled snapshot
                  // instead of an error snapshot).
                  const nonCachedError = nonCachedErrors$1[childKey];
                  if (nonCachedError === undefined || nonCachedError.expiration < reader.getTimeStamp()) {
                    reader.markMissingLink(childKey);
                  } else {
                    // if this child error was the only reason the reader
                    // is marked as missing then we want to undo that
                    if (isMissingDataBeforeChildRead === false) {
                      reader.unMarkMissing();
                    }
                    // put status code and body into reader path
                    const {
                      response: nonCachedBody,
                      status: nonCachedStatus
                    } = nonCachedError;
                    reader.enterPath(envelopeStatusCodePath);
                    reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                    reader.exitPath();
                    reader.enterPath(envelopeBodyPath);
                    reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                    reader.exitPath();
                  }
                }
                break;
              case 'Pending':
                reader.markPending();
                break;
            }
            ArrayPrototypePush.call(results, childSink);
            reader.exitPath();
          }
          reader.assignNonScalar(sink, envelopePath, results);
          reader.exitPath();
          return sink;
        }
      };
    }
    function select$j(luvio, resourceParams) {
      const childResources = createChildResourceParams$2(resourceParams);
      return selectChildResourceParams$1(luvio, childResources, resourceParams);
    }
    function keyBuilder$w(luvio, params) {
      return keyPrefix + '::RelatedListPreferencesBatchRepresentation:(' + 'preferencesIds:' + params.urlParams.preferencesIds + ')';
    }
    function getResponseCacheKeys$j(keys, luvio, resourceParams, response) {
      const childEnvelopes = response.results;
      const childResourceParamsArray = createChildResourceParams$2(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      // get children keys
      for (let index = 0, len = childResourceParamsArray.length; index < len; index++) {
        const childResourceParams = childResourceParamsArray[index];
        const childResult = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = childResult;
        if (childStatusCode === 200) {
          getResponseCacheKeys$k(keys, luvio, childResourceParams, childBody);
        } else if (childStatusCode === 404) {
          const childKey = keyBuilder$x(luvio, childResourceParams);
          keys.set(childKey, {
            namespace: keyPrefix,
            representationName: RepresentationType$e,
            mergeable: false
          });
        }
      }
    }
    function ingestSuccessChildResourceParams$2(luvio, childResourceParamsArray, childEnvelopes) {
      const childSnapshotDataResponses = [];
      let seenRecords = new luvioEngine.StoreKeySet();
      let snapshotState = 'Fulfilled';
      const now = Date.now();
      for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$x(luvio, childResourceParams);
        const result = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = result;
        if (childStatusCode === 200) {
          const childResponse = {
            status: 200,
            body: childBody,
            ok: true,
            statusText: 'OK',
            headers: {}
          };
          const childSnapshot = ingestSuccess$e(luvio, childResourceParams, childResponse);
          if (childSnapshot.state === "Stale") {
            snapshotState = "Stale";
          }
          seenRecords.merge(childSnapshot.seenRecords);
          seenRecords.add(childSnapshot.recordId);
          const childValue = {
            statusCode: 200,
            result: childSnapshot.data
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        } else {
          const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
          const childResponse = {
            status: childStatusCode,
            body: childBody,
            ok: false,
            statusText: childStatusCodeText,
            headers: {},
            errorType: 'fetchResponse'
          };
          ingestError$9(luvio, childResourceParams, childResponse);
          seenRecords.add(childKey);
          const childValue = {
            statusCode: childStatusCode,
            result: childBody
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
          nonCachedErrors$1[childKey] = {
            expiration: now + TTL$b,
            response: childBody,
            status: childStatusCode
          };
        } else {
          delete nonCachedErrors$1[childKey];
        }
      }
      const childSnapshotData = {
        results: childSnapshotDataResponses
      };
      luvioEngine.deepFreeze(childSnapshotData);
      return {
        childSnapshotData: childSnapshotData,
        seenRecords,
        snapshotState
      };
    }
    function ingestSuccess$d(luvio, resourceParams, response, snapshotRefresh) {
      const childEnvelopes = response.body.results;
      const childResourceParamsArray = createChildResourceParams$2(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      const key = keyBuilder$w(luvio, resourceParams);
      const {
        childSnapshotData,
        seenRecords,
        snapshotState
      } = ingestSuccessChildResourceParams$2(luvio, childResourceParamsArray, childEnvelopes);
      const syntheticSnapshot = {
        recordId: key,
        data: childSnapshotData,
        state: snapshotState,
        seenRecords: seenRecords,
        select: {
          recordId: key,
          node: select$j(luvio, resourceParams),
          variables: {}
        },
        refresh: snapshotRefresh,
        variables: {}
      };
      // evict top level composite record from the store. This covers the case where a previous resource request returned a 404.
      luvio.storeEvict(key);
      return syntheticSnapshot;
    }
    function ingestError$8(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$w(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$m(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/related-list-preferences/batch/' + config.urlParams.preferencesIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$j = 'getRelatedListPreferencesBatch';
    const getRelatedListPreferencesBatch_ConfigPropertyMetadata = [generateParamConfigMetadata('preferencesIds', true, 0 /* UrlParameter */, 0 /* String */, true)];
    const getRelatedListPreferencesBatch_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$j, getRelatedListPreferencesBatch_ConfigPropertyMetadata);
    const createResourceParams$k = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListPreferencesBatch_ConfigPropertyMetadata);
    function keyBuilder$v(luvio, config) {
      const resourceParams = createResourceParams$k(config);
      return keyBuilder$w(luvio, resourceParams);
    }
    function typeCheckConfig$n(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListPreferencesBatch_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$m(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$n(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$a(luvio, config) {
      const resourceParams = createResourceParams$k(config);
      return select$j(luvio, resourceParams);
    }
    function onFetchResponseSuccess$b(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$d(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$m(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$a(luvio, config, resourceParams, response) {
      const snapshot = ingestError$8(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$m(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$m(luvio, config, options) {
      const resourceParams = createResourceParams$k(config);
      const request = createResourceRequest$m(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$b(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$j(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$a(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$d(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$m, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$c(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$v(luvio, config),
        node: adapterFragment$a(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$m(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRelatedListPreferencesBatchAdapterFactory = luvio => function UiApi__getRelatedListPreferencesBatch(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$m(untrustedConfig, getRelatedListPreferencesBatch_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$c, buildNetworkSnapshotCachePolicy$d);
    };
    const adapterName$i = 'getRelatedListPreferences';
    const getRelatedListPreferences_ConfigPropertyMetadata = [generateParamConfigMetadata('preferencesId', true, 0 /* UrlParameter */, 0 /* String */)];
    const getRelatedListPreferences_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$i, getRelatedListPreferences_ConfigPropertyMetadata);
    const createResourceParams$j = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListPreferences_ConfigPropertyMetadata);
    function keyBuilder$u(luvio, config) {
      const resourceParams = createResourceParams$j(config);
      return keyBuilder$x(luvio, resourceParams);
    }
    function typeCheckConfig$m(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListPreferences_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$l(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$m(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$9(luvio, config) {
      createResourceParams$j(config);
      return select$k();
    }
    function onFetchResponseSuccess$a(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$e(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$l(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$9(luvio, config, resourceParams, response) {
      const snapshot = ingestError$9(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$l(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$l(luvio, config, options) {
      const resourceParams = createResourceParams$j(config);
      const request = createResourceRequest$n(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$a(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$k(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$9(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$c(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$l, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$b(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$u(luvio, config),
        node: adapterFragment$9(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$l(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRelatedListPreferencesAdapterFactory = luvio => function UiApi__getRelatedListPreferences(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$l(untrustedConfig, getRelatedListPreferences_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$b, buildNetworkSnapshotCachePolicy$c);
    };
    function select$i(luvio, params) {
      return select$l();
    }
    function getResponseCacheKeys$i(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$e(storeKeyMap, luvio, response);
    }
    function ingestSuccess$c(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$b(luvio, body);
      luvio.storeIngest(key, ingest$9, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$i(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$l(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/related-list-preferences/' + config.urlParams.preferencesId + '',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$h = 'updateRelatedListPreferences';
    const updateRelatedListPreferences_ConfigPropertyMetadata = [generateParamConfigMetadata('preferencesId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('columnWidths', false, 2 /* Body */, 4 /* Unsupported */), generateParamConfigMetadata('columnWrap', false, 2 /* Body */, 4 /* Unsupported */), generateParamConfigMetadata('orderedBy', false, 2 /* Body */, 4 /* Unsupported */, true)];
    const updateRelatedListPreferences_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$h, updateRelatedListPreferences_ConfigPropertyMetadata);
    const createResourceParams$i = /*#__PURE__*/luvioEngine.createResourceParams(updateRelatedListPreferences_ConfigPropertyMetadata);
    function typeCheckConfig$l(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, updateRelatedListPreferences_ConfigPropertyMetadata);
      const untrustedConfig_columnWidths = untrustedConfig.columnWidths;
      if (untrustedIsObject(untrustedConfig_columnWidths)) {
        const untrustedConfig_columnWidths_object = {};
        const untrustedConfig_columnWidths_keys = Object.keys(untrustedConfig_columnWidths);
        for (let i = 0, arrayLength = untrustedConfig_columnWidths_keys.length; i < arrayLength; i++) {
          const key = untrustedConfig_columnWidths_keys[i];
          const untrustedConfig_columnWidths_prop = untrustedConfig_columnWidths[key];
          if (typeof untrustedConfig_columnWidths_prop === 'number' && Math.floor(untrustedConfig_columnWidths_prop) === untrustedConfig_columnWidths_prop) {
            if (untrustedConfig_columnWidths_object !== undefined) {
              untrustedConfig_columnWidths_object[key] = untrustedConfig_columnWidths_prop;
            }
          }
        }
        if (untrustedConfig_columnWidths_object !== undefined && Object.keys(untrustedConfig_columnWidths_object).length >= 0) {
          config.columnWidths = untrustedConfig_columnWidths_object;
        }
      }
      const untrustedConfig_columnWrap = untrustedConfig.columnWrap;
      if (untrustedIsObject(untrustedConfig_columnWrap)) {
        const untrustedConfig_columnWrap_object = {};
        const untrustedConfig_columnWrap_keys = Object.keys(untrustedConfig_columnWrap);
        for (let i = 0, arrayLength = untrustedConfig_columnWrap_keys.length; i < arrayLength; i++) {
          const key = untrustedConfig_columnWrap_keys[i];
          const untrustedConfig_columnWrap_prop = untrustedConfig_columnWrap[key];
          if (typeof untrustedConfig_columnWrap_prop === 'boolean') {
            if (untrustedConfig_columnWrap_object !== undefined) {
              untrustedConfig_columnWrap_object[key] = untrustedConfig_columnWrap_prop;
            }
          }
        }
        if (untrustedConfig_columnWrap_object !== undefined && Object.keys(untrustedConfig_columnWrap_object).length >= 0) {
          config.columnWrap = untrustedConfig_columnWrap_object;
        }
      }
      const untrustedConfig_orderedBy = untrustedConfig.orderedBy;
      if (ArrayIsArray$1(untrustedConfig_orderedBy)) {
        const untrustedConfig_orderedBy_array = [];
        for (let i = 0, arrayLength = untrustedConfig_orderedBy.length; i < arrayLength; i++) {
          const untrustedConfig_orderedBy_item = untrustedConfig_orderedBy[i];
          const referenceListOrderedByInfoInputRepresentationValidationError = validate$12(untrustedConfig_orderedBy_item);
          if (referenceListOrderedByInfoInputRepresentationValidationError === null) {
            untrustedConfig_orderedBy_array.push(untrustedConfig_orderedBy_item);
          }
        }
        config.orderedBy = untrustedConfig_orderedBy_array;
      }
      return config;
    }
    function validateAdapterConfig$k(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$l(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$k(luvio, config, options) {
      const resourceParams = createResourceParams$i(config);
      const request = createResourceRequest$l(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$c(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$i(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const updateRelatedListPreferencesAdapterFactory = luvio => {
      return function updateRelatedListPreferences(untrustedConfig) {
        const config = validateAdapterConfig$k(untrustedConfig, updateRelatedListPreferences_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "updateRelatedListPreferences"');
        }
        return buildNetworkSnapshot$k(luvio, config);
      };
    };
    function validate$C(obj, path = 'RelatedListRecordsSingleBatchInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.fields !== undefined) {
          const obj_fields = obj.fields;
          const path_fields = path + '.fields';
          if (!ArrayIsArray(obj_fields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
          }
          for (let i = 0; i < obj_fields.length; i++) {
            const obj_fields_item = obj_fields[i];
            const path_fields_item = path_fields + '[' + i + ']';
            if (typeof obj_fields_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_fields_item + '" (at "' + path_fields_item + '")');
            }
          }
        }
        if (obj.optionalFields !== undefined) {
          const obj_optionalFields = obj.optionalFields;
          const path_optionalFields = path + '.optionalFields';
          if (!ArrayIsArray(obj_optionalFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_optionalFields + '" (at "' + path_optionalFields + '")');
          }
          for (let i = 0; i < obj_optionalFields.length; i++) {
            const obj_optionalFields_item = obj_optionalFields[i];
            const path_optionalFields_item = path_optionalFields + '[' + i + ']';
            if (typeof obj_optionalFields_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_optionalFields_item + '" (at "' + path_optionalFields_item + '")');
            }
          }
        }
        if (obj.pageSize !== undefined) {
          const obj_pageSize = obj.pageSize;
          const path_pageSize = path + '.pageSize';
          if (typeof obj_pageSize !== 'number' || typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize) {
            return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
          }
        }
        const obj_relatedListId = obj.relatedListId;
        const path_relatedListId = path + '.relatedListId';
        if (typeof obj_relatedListId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_relatedListId + '" (at "' + path_relatedListId + '")');
        }
        if (obj.sortBy !== undefined) {
          const obj_sortBy = obj.sortBy;
          const path_sortBy = path + '.sortBy';
          if (!ArrayIsArray(obj_sortBy)) {
            return new TypeError('Expected "array" but received "' + typeof obj_sortBy + '" (at "' + path_sortBy + '")');
          }
          for (let i = 0; i < obj_sortBy.length; i++) {
            const obj_sortBy_item = obj_sortBy[i];
            const path_sortBy_item = path_sortBy + '[' + i + ']';
            if (typeof obj_sortBy_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_sortBy_item + '" (at "' + path_sortBy_item + '")');
            }
          }
        }
        if (obj.where !== undefined) {
          const obj_where = obj.where;
          const path_where = path + '.where';
          if (typeof obj_where !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_where + '" (at "' + path_where + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const PAGINATION_VERSION = "0.111.0";
    const paginationStoreMetadata = {
      ttl: Number.MAX_SAFE_INTEGER,
      namespace: '',
      representationName: '',
      version: PAGINATION_VERSION
    };
    function clientTokenFromOffset(paginationMetadata, offset) {
      const {
        clientTokens
      } = paginationMetadata;
      const tokens = Object.keys(clientTokens);
      for (let i = 0, len = tokens.length; i < len; i++) {
        const token = tokens[i];
        if (clientTokens[token] === offset) {
          return token;
        }
      }
    }
    function offsetFromClientToken(paginationMetadata, token) {
      if (token === undefined) {
        return 0;
      }
      const offset = paginationMetadata.clientTokens[token];
      return offset === undefined ? -1 : offset;
    }
    function offsetFromServerToken(paginationMetadata, token) {
      return paginationMetadata.serverTokens.indexOf(token);
    }
    function getNextPageTokens(paginationMetadata, pageEndOffset) {
      const listEndOffset = paginationMetadata.__END__;
      if (listEndOffset === undefined || pageEndOffset < listEndOffset) {
        const clientToken = clientTokenFromOffset(paginationMetadata, pageEndOffset);
        if (clientToken === undefined) {
          return {
            clientToken: undefined,
            serverToken: undefined
          };
        }
        return {
          clientToken,
          serverToken: paginationMetadata.serverTokens[pageEndOffset] || undefined
        };
      }
      return {
        clientToken: null,
        serverToken: null
      };
    }
    function getPreviousClientToken(paginationMetadata, startOffset, pageSize) {
      const previousPageOffset = startOffset - pageSize;
      if (previousPageOffset < 0) {
        return null;
      }
      const listEndOffset = paginationMetadata.__END__;
      if (listEndOffset !== undefined && previousPageOffset >= listEndOffset) {
        return;
      }
      return clientTokenFromOffset(paginationMetadata, previousPageOffset);
    }
    function pageEndOffset(paginationMetadata, startOffset, pageSize) {
      const listEndOffset = paginationMetadata.__END__;
      const nextPageOffset = startOffset + pageSize;
      if (listEndOffset === undefined) {
        return nextPageOffset;
      }
      return Math.min(nextPageOffset, listEndOffset);
    }
    function getPageTokenAndOffset(paginationMetadata, token) {
      if (token === undefined) {
        const startToken = clientTokenFromOffset(paginationMetadata, 0);
        if (startToken === undefined) {
          return;
        }
        return [startToken, 0];
      }
      const startOffset = offsetFromClientToken(paginationMetadata, token);
      if (startOffset < 0) {
        return;
      }
      return [token, startOffset];
    }
    function serverTokenForAtMost(paginationMetadata, maxOffset) {
      const {
        serverTokens
      } = paginationMetadata;
      for (let i = maxOffset; i >= 0; i--) {
        const token = serverTokens[i];
        if (token !== undefined) {
          return [token, i];
        }
      }
      return [undefined, -1];
    }
    function generateClientToken(offset) {
      return base64Encode('client:' + offset);
    }
    // Code lifted from https://github.com/MaxArt2501/base64-js/blob/master/base64.js
    // base64 character set, plus padding character (=)
    const b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function base64Encode(input) {
      let bitmap, a, b, c;
      let result = "",
        i = 0;
      const rest = input.length % 3; // To determine the final padding
      for (; i < input.length;) {
        if ((a = input.charCodeAt(i++)) > 255 || (b = input.charCodeAt(i++)) > 255 || (c = input.charCodeAt(i++)) > 255) {
          throw new TypeError("Failed base64ToAscii encoding: The string to be encoded contains characters outside of the Latin1 range. " + input);
        }
        bitmap = a << 16 | b << 8 | c;
        result += b64.charAt(bitmap >> 18 & 63) + b64.charAt(bitmap >> 12 & 63) + b64.charAt(bitmap >> 6 & 63) + b64.charAt(bitmap & 63);
      }
      // If there's need of padding, replace the last 'A's with equal signs
      return rest ? result.slice(0, rest - 3) + "===".substring(rest) : result;
    }
    function addTokens(paginationMetadata, offset, clientToken, serverToken) {
      paginationMetadata.clientTokens[clientToken] = offset;
      if (serverToken !== undefined) {
        paginationMetadata.serverTokens[offset] = serverToken;
      }
    }
    function mergeMetadata(existingMetadata, incomingMetadata) {
      if (existingMetadata === undefined) {
        return incomingMetadata;
      }
      const clientTokens = {
        ...existingMetadata.clientTokens,
        ...incomingMetadata.clientTokens
      };
      const serverTokens = mergeArrays(existingMetadata.serverTokens, incomingMetadata.serverTokens);
      const __END__ = incomingMetadata.hasOwnProperty('__END__') ? incomingMetadata.__END__ : existingMetadata.__END__;
      return {
        clientTokens,
        serverTokens,
        __END__
      };
    }
    function mergeArrays(existing, incoming) {
      const merged = [];
      const len = Math.max(existing.length, incoming.length);
      for (let i = 0; i < len; i++) {
        const value = incoming[i] || existing[i];
        merged.push(value);
      }
      return merged;
    }
    function equalsMetadata(existingMetadata, incomingMetadata) {
      const {
        clientTokens: existingClientTokens,
        serverTokens: existingServerTokens,
        __END__: existingListEnd
      } = existingMetadata;
      const {
        clientTokens: incomingClientTokens,
        serverTokens: incomingServerTokens,
        __END__: incomingListEnd
      } = incomingMetadata;
      const existingKeys = Object.keys(existingClientTokens);
      const incomingKeys = Object.keys(incomingClientTokens);
      const clientTokensLength = existingKeys.length;
      if (clientTokensLength !== incomingKeys.length) {
        return false;
      }
      for (let i = 0; i < clientTokensLength; i++) {
        const key = existingKeys[i];
        if (existingClientTokens[key] !== incomingClientTokens[key]) {
          return false;
        }
      }
      const serverTokensLength = existingServerTokens.length;
      if (serverTokensLength !== incomingServerTokens.length) {
        return false;
      }
      for (let i = 0; i < serverTokensLength; i++) {
        if (existingServerTokens[i] !== incomingServerTokens[i]) {
          return false;
        }
      }
      return existingListEnd === incomingListEnd;
    }
    const TTL$a = 30000;
    const VERSION$c = "62467c27c19349b70c9db2a8d9d591d9";
    function validate$B(obj, path = 'RelatedListRecordCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count) {
          return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        if (typeof obj_currentPageToken !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        let obj_currentPageUrl_union0 = null;
        const obj_currentPageUrl_union0_error = (() => {
          if (typeof obj_currentPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
          }
        })();
        if (obj_currentPageUrl_union0_error != null) {
          obj_currentPageUrl_union0 = obj_currentPageUrl_union0_error.message;
        }
        let obj_currentPageUrl_union1 = null;
        const obj_currentPageUrl_union1_error = (() => {
          if (obj_currentPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
          }
        })();
        if (obj_currentPageUrl_union1_error != null) {
          obj_currentPageUrl_union1 = obj_currentPageUrl_union1_error.message;
        }
        if (obj_currentPageUrl_union0 && obj_currentPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_currentPageUrl + '")';
          message += '\n' + obj_currentPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_currentPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (!ArrayIsArray(obj_fields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        for (let i = 0; i < obj_fields.length; i++) {
          const obj_fields_item = obj_fields[i];
          const path_fields_item = path_fields + '[' + i + ']';
          if (typeof obj_fields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fields_item + '" (at "' + path_fields_item + '")');
          }
        }
        const obj_listInfoETag = obj.listInfoETag;
        const path_listInfoETag = path + '.listInfoETag';
        let obj_listInfoETag_union0 = null;
        const obj_listInfoETag_union0_error = (() => {
          if (typeof obj_listInfoETag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_listInfoETag + '" (at "' + path_listInfoETag + '")');
          }
        })();
        if (obj_listInfoETag_union0_error != null) {
          obj_listInfoETag_union0 = obj_listInfoETag_union0_error.message;
        }
        let obj_listInfoETag_union1 = null;
        const obj_listInfoETag_union1_error = (() => {
          if (obj_listInfoETag !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_listInfoETag + '" (at "' + path_listInfoETag + '")');
          }
        })();
        if (obj_listInfoETag_union1_error != null) {
          obj_listInfoETag_union1 = obj_listInfoETag_union1_error.message;
        }
        if (obj_listInfoETag_union0 && obj_listInfoETag_union1) {
          let message = 'Object doesn\'t match union (at "' + path_listInfoETag + '")';
          message += '\n' + obj_listInfoETag_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_listInfoETag_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referencepath_listReferenceValidationError = validate$K(obj_listReference, path_listReference);
        if (referencepath_listReferenceValidationError !== null) {
          let message = 'Object doesn\'t match RelatedListReferenceRepresentation (at "' + path_listReference + '")\n';
          message += referencepath_listReferenceValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
          if (typeof obj_nextPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union0_error != null) {
          obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
          if (obj_nextPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union1_error != null) {
          obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
          message += '\n' + obj_nextPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
          if (typeof obj_nextPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union0_error != null) {
          obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
          if (obj_nextPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union1_error != null) {
          obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
          message += '\n' + obj_nextPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_optionalFields = obj.optionalFields;
        const path_optionalFields = path + '.optionalFields';
        if (!ArrayIsArray(obj_optionalFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_optionalFields + '" (at "' + path_optionalFields + '")');
        }
        for (let i = 0; i < obj_optionalFields.length; i++) {
          const obj_optionalFields_item = obj_optionalFields[i];
          const path_optionalFields_item = path_optionalFields + '[' + i + ']';
          if (typeof obj_optionalFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_optionalFields_item + '" (at "' + path_optionalFields_item + '")');
          }
        }
        const obj_pageSize = obj.pageSize;
        const path_pageSize = path + '.pageSize';
        if (typeof obj_pageSize !== 'number' || typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize) {
          return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
          if (typeof obj_previousPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union0_error != null) {
          obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
          if (obj_previousPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union1_error != null) {
          obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
          message += '\n' + obj_previousPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
          if (typeof obj_previousPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union0_error != null) {
          obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
          if (obj_previousPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union1_error != null) {
          obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
          message += '\n' + obj_previousPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (!ArrayIsArray(obj_records)) {
          return new TypeError('Expected "array" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        for (let i = 0; i < obj_records.length; i++) {
          const obj_records_item = obj_records[i];
          const path_records_item = path_records + '[' + i + ']';
          if (typeof obj_records_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_records_item + '" (at "' + path_records_item + '")');
          }
        }
        const obj_sortBy = obj.sortBy;
        const path_sortBy = path + '.sortBy';
        if (!ArrayIsArray(obj_sortBy)) {
          return new TypeError('Expected "array" but received "' + typeof obj_sortBy + '" (at "' + path_sortBy + '")');
        }
        for (let i = 0; i < obj_sortBy.length; i++) {
          const obj_sortBy_item = obj_sortBy[i];
          const path_sortBy_item = path_sortBy + '[' + i + ']';
          if (typeof obj_sortBy_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_sortBy_item + '" (at "' + path_sortBy_item + '")');
          }
        }
        const obj_where = obj.where;
        const path_where = path + '.where';
        let obj_where_union0 = null;
        const obj_where_union0_error = (() => {
          if (typeof obj_where !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_where + '" (at "' + path_where + '")');
          }
        })();
        if (obj_where_union0_error != null) {
          obj_where_union0 = obj_where_union0_error.message;
        }
        let obj_where_union1 = null;
        const obj_where_union1_error = (() => {
          if (obj_where !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_where + '" (at "' + path_where + '")');
          }
        })();
        if (obj_where_union1_error != null) {
          obj_where_union1 = obj_where_union1_error.message;
        }
        if (obj_where_union0 && obj_where_union1) {
          let message = 'Object doesn\'t match union (at "' + path_where + '")';
          message += '\n' + obj_where_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_where_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$d = 'RelatedListRecordCollectionRepresentation';
    function keyBuilder$t(luvio, config) {
      return keyPrefix + '::' + RepresentationType$d + ':' + '[' + config.sortBy.join(',') + ']' + ':' + (config.parentRecordId === null ? '' : config.parentRecordId) + ':' + config.relatedListId + ':' + (config.where === null ? '' : config.where);
    }
    function keyBuilderFromType$a(luvio, object) {
      const keyParams = {
        sortBy: object.sortBy,
        parentRecordId: object.listReference.inContextOfRecordId,
        relatedListId: object.listReference.relatedListId,
        where: object.where
      };
      return keyBuilder$t(luvio, keyParams);
    }
    function normalize$8(input, existing, path, luvio, store, timestamp) {
      const input_records = input.records;
      const input_records_id = path.fullPath + '__records';
      for (let i = 0; i < input_records.length; i++) {
        const input_records_item = input_records[i];
        let input_records_item_id = input_records_id + '__' + i;
        input_records[i] = ingest$O(input_records_item, {
          fullPath: input_records_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    function getPageMetadata(paginationMetadata, paginationParams) {
      const metadataProperties = {};
      const sink = {
        metadataProperties
      };
      if (paginationMetadata === undefined) {
        return sink;
      }
      const {
        token,
        pageSize
      } = paginationParams;
      const pageTokenAndOffset = getPageTokenAndOffset(paginationMetadata, token);
      if (pageTokenAndOffset === undefined) {
        return sink;
      }
      const [pageToken, startOffset] = pageTokenAndOffset;
      const endOffset = pageEndOffset(paginationMetadata, startOffset, pageSize);
      sink.startOffset = startOffset;
      sink.endOffset = endOffset;
      metadataProperties.currentPageToken = pageToken;
      const {
        clientToken: nextClientToken,
        serverToken: nextServerToken
      } = getNextPageTokens(paginationMetadata, endOffset);
      if (nextClientToken !== undefined) {
        metadataProperties.nextPageToken = nextClientToken;
        sink.nextServerToken = nextServerToken;
      }
      const previousClientToken = getPreviousClientToken(paginationMetadata, startOffset, pageSize);
      if (previousClientToken !== undefined) {
        metadataProperties.previousPageToken = previousClientToken;
      }
      metadataProperties.pageSize = pageSize;
      metadataProperties.count = endOffset - startOffset;
      return sink;
    }
    const dynamicSelect$4 = function dynamicRelatedListRecordCollectionRepresentationSelect(params, paginationParams) {
      const recordsPathSelection = params.records === undefined ? {
        name: 'records',
        kind: 'Link',
        fragment: select$1T()
      } : params.records;
      const {
        selections: RelatedListReferenceRepresentation__selections,
        opaque: RelatedListReferenceRepresentation__opaque
      } = select$v();
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: false,
        version: VERSION$c,
        read: (source, reader) => {
          const sink = {};
          if (paginationParams === undefined) {
            return sink;
          }
          const metadata = reader.resolveMetadata(source, PAGINATION_VERSION);
          const currentPageMetadata = getPageMetadata(metadata, paginationParams);
          const {
            startOffset,
            endOffset,
            metadataProperties
          } = currentPageMetadata;
          if (metadata !== undefined && startOffset !== undefined && endOffset !== undefined) {
            const itemsProperty = 'records';
            reader.enterPath(itemsProperty);
            const itemsSource = source[itemsProperty];
            const itemsSink = [];
            const allSink = [];
            for (let i = startOffset; i < endOffset; i++) {
              reader.enterPath(i);
              reader.readSingleLink(i, recordsPathSelection, itemsSource, allSink, i - startOffset);
              if (reader.getIsDataMissing() === false) {
                itemsSink[i - startOffset] = allSink[i - startOffset];
              }
              reader.exitPath();
            }
            reader.exitPath();
            reader.assignNonScalar(sink, itemsProperty, itemsSink);
          }
          reader.enterPath('currentPageToken');
          reader.readScalar('currentPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('nextPageToken');
          reader.readScalar('nextPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('previousPageToken');
          reader.readScalar('previousPageToken', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('pageSize');
          reader.readScalar('pageSize', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('count');
          reader.readScalar('count', metadataProperties, sink);
          reader.exitPath();
          reader.enterPath('fields');
          reader.readScalarPlural('fields', source, sink, true);
          reader.exitPath();
          reader.enterPath('listInfoETag');
          reader.readScalar('listInfoETag', source, sink);
          reader.exitPath();
          reader.enterPath('listReference');
          reader.readObject('listReference', {
            name: 'listReference',
            kind: 'Object',
            selections: RelatedListReferenceRepresentation__selections
          }, source, sink);
          reader.exitPath();
          reader.enterPath('optionalFields');
          reader.readScalarPlural('optionalFields', source, sink, true);
          reader.exitPath();
          reader.enterPath('sortBy');
          reader.readScalarPlural('sortBy', source, sink, true);
          reader.exitPath();
          reader.enterPath('where');
          reader.readScalar('where', source, sink);
          reader.exitPath();
          return sink;
        }
      };
    };
    function equals$c(existing, incoming) {
      const existing_count = existing.count;
      const incoming_count = incoming.count;
      if (!(existing_count === incoming_count)) {
        return false;
      }
      const existing_pageSize = existing.pageSize;
      const incoming_pageSize = incoming.pageSize;
      if (!(existing_pageSize === incoming_pageSize)) {
        return false;
      }
      const existing_currentPageToken = existing.currentPageToken;
      const incoming_currentPageToken = incoming.currentPageToken;
      if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
      }
      const existing_currentPageUrl = existing.currentPageUrl;
      const incoming_currentPageUrl = incoming.currentPageUrl;
      if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
      }
      const existing_fields = existing.fields;
      const incoming_fields = incoming.fields;
      const equals_fields_items = equalsArray(existing_fields, incoming_fields, (existing_fields_item, incoming_fields_item) => {
        if (!(existing_fields_item === incoming_fields_item)) {
          return false;
        }
      });
      if (equals_fields_items === false) {
        return false;
      }
      const existing_listInfoETag = existing.listInfoETag;
      const incoming_listInfoETag = incoming.listInfoETag;
      if (!(existing_listInfoETag === incoming_listInfoETag)) {
        return false;
      }
      const existing_listReference = existing.listReference;
      const incoming_listReference = incoming.listReference;
      if (!equals$h(existing_listReference, incoming_listReference)) {
        return false;
      }
      const existing_nextPageToken = existing.nextPageToken;
      const incoming_nextPageToken = incoming.nextPageToken;
      if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
      }
      const existing_nextPageUrl = existing.nextPageUrl;
      const incoming_nextPageUrl = incoming.nextPageUrl;
      if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
      }
      const existing_optionalFields = existing.optionalFields;
      const incoming_optionalFields = incoming.optionalFields;
      const equals_optionalFields_items = equalsArray(existing_optionalFields, incoming_optionalFields, (existing_optionalFields_item, incoming_optionalFields_item) => {
        if (!(existing_optionalFields_item === incoming_optionalFields_item)) {
          return false;
        }
      });
      if (equals_optionalFields_items === false) {
        return false;
      }
      const existing_previousPageToken = existing.previousPageToken;
      const incoming_previousPageToken = incoming.previousPageToken;
      if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
      }
      const existing_previousPageUrl = existing.previousPageUrl;
      const incoming_previousPageUrl = incoming.previousPageUrl;
      if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
      }
      const existing_records = existing.records;
      const incoming_records = incoming.records;
      const equals_records_items = equalsArray(existing_records, incoming_records, (existing_records_item, incoming_records_item) => {
        if (!(existing_records_item.__ref === incoming_records_item.__ref)) {
          return false;
        }
      });
      if (equals_records_items === false) {
        return false;
      }
      const existing_sortBy = existing.sortBy;
      const incoming_sortBy = incoming.sortBy;
      const equals_sortBy_items = equalsArray(existing_sortBy, incoming_sortBy, (existing_sortBy_item, incoming_sortBy_item) => {
        if (!(existing_sortBy_item === incoming_sortBy_item)) {
          return false;
        }
      });
      if (equals_sortBy_items === false) {
        return false;
      }
      const existing_where = existing.where;
      const incoming_where = incoming.where;
      if (!(existing_where === incoming_where)) {
        return false;
      }
      return true;
    }
    const ingest$8 = function RelatedListRecordCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$B(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$a(luvio, input);
      const existingRecord = store.readEntry(key);
      const ttlToUse = TTL$a;
      let incomingRecord = normalize$8(input, store.readEntry(key), {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
        ttl: ttlToUse
      }, luvio, store, timestamp);
      const paginationKey = key + '__pagination';
      const existingPaginationMetadata = store.readEntry(paginationKey);
      const {
        count: count,
        currentPageToken: token,
        nextPageToken: nextToken,
        pageSize: pageSize,
        previousPageToken: previousToken,
        records: items
      } = input;
      const startOffset = existingPaginationMetadata === undefined ? 0 : offsetFromServerToken(existingPaginationMetadata, token);
      {
        if (startOffset < 0 || existingRecord && existingRecord.records && existingRecord.records.length < startOffset) {
          throw new RangeError('currentPageToken value ' + token + ' is not recognized');
        }
      }
      const incomingPaginationMetadata = {
        clientTokens: {},
        serverTokens: []
      };
      const pageClientToken = generateClientToken(startOffset);
      addTokens(incomingPaginationMetadata, startOffset, pageClientToken, token);
      const nextOffset = startOffset + items.length;
      if (nextToken === null) {
        incomingPaginationMetadata.__END__ = nextOffset;
      } else {
        const nextClientToken = generateClientToken(nextOffset);
        addTokens(incomingPaginationMetadata, nextOffset, nextClientToken, nextToken);
        if (existingPaginationMetadata !== undefined) {
          const listEndOffset = existingPaginationMetadata.__END__;
          if (listEndOffset !== undefined && nextOffset >= listEndOffset) {
            incomingPaginationMetadata.__END__ = undefined;
          }
        }
      }
      if (previousToken !== null) {
        const previousOffset = Math.max(startOffset - pageSize, 0);
        const previousClientToken = generateClientToken(previousOffset);
        addTokens(incomingPaginationMetadata, previousOffset, previousClientToken, previousToken);
      }
      for (let i = startOffset + 1; i < nextOffset; i++) {
        const itemClientToken = generateClientToken(i);
        addTokens(incomingPaginationMetadata, i, itemClientToken);
      }
      const mergedPaginationMetadata = mergeMetadata(existingPaginationMetadata, incomingPaginationMetadata);
      if (existingPaginationMetadata === undefined || equalsMetadata(existingPaginationMetadata, mergedPaginationMetadata) === false) {
        luvio.storePublish(paginationKey, mergedPaginationMetadata);
        luvio.publishStoreMetadata(paginationKey, paginationStoreMetadata);
      }
      assignMetadataLink(incomingRecord, paginationKey);
      if (existingRecord !== undefined && existingRecord.records !== undefined) {
        incomingRecord.records = [...existingRecord.records.slice(0, startOffset), ...incomingRecord.records, ...existingRecord.records.slice(nextOffset)];
      }
      if (existingRecord === undefined || equals$c(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
      }
      {
        const storeMetadataParams = {
          ttl: ttlToUse,
          namespace: "UiApi",
          version: VERSION$c,
          representationName: RepresentationType$d,
          ingestionTimestamp: timestamp
        };
        luvio.publishStoreMetadata(key, storeMetadataParams);
      }
      return createLink(key);
    };
    function getTypeCacheKeys$d(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$a(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$d,
        mergeable: true
      });
      rootKeySet.set(rootKey + '__pagination', {
        namespace: keyPrefix,
        representationName: RepresentationType$d,
        mergeable: true
      });
      const input_records_length = input.records.length;
      for (let i = 0; i < input_records_length; i++) {
        getTypeCacheKeys$X(rootKeySet, luvio, input.records[i]);
      }
    }
    function select$h(luvio, params) {
      const {
        fields = [],
        optionalFields = []
      } = params.body;
      return dynamicSelect$4({
        records: {
          name: 'records',
          kind: 'Link',
          fragment: {
            kind: 'Fragment',
            private: ['eTag', 'weakEtag'],
            selections: buildSelectionFromFields(fields, optionalFields),
            version: VERSION$1e
          }
        }
      }, createPaginationParams(params));
    }
    function ingestSuccess$b(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$s(luvio, resourceParams);
      luvio.storeIngest(key, ingest$8, body);
      const optionalFields = resourceParams.body.optionalFields;
      if (optionalFields && optionalFields.length > 0) {
        const normalized = body;
        markMissingOptionalFieldsOnRecords(luvio, normalized, optionalFields);
      }
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$h(luvio, resourceParams),
        variables: {}
      }, snapshotRefresh);
      return snapshot;
    }
    function markMissingOptionalFieldsOnRecords(luvio, nomalized, optionalFields) {
      const records = nomalized.records;
      for (let i = 0; i < records.length; i++) {
        const record = records[i];
        const recordKey = record.__ref;
        if (recordKey !== undefined) {
          const node = luvio.getNode(recordKey);
          markMissingOptionalFields(node, optionalFields);
        }
      }
    }
    function createPaginationParams(params) {
      const {
        body
      } = params;
      return {
        token: body.pageToken,
        pageSize: body.pageSize === undefined ? 50 : body.pageSize
      };
    }
    function keyBuilder$s(luvio, params) {
      return keyBuilder$t(luvio, {
        sortBy: params.body.sortBy || [],
        where: params.body.where || null,
        parentRecordId: params.urlParams.parentRecordId,
        relatedListId: params.urlParams.relatedListId
      });
    }
    function getResponseCacheKeys$h(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$d(storeKeyMap, luvio, response);
    }
    function ingestError$7(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$s(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$a,
        namespace: keyPrefix,
        version: VERSION$c,
        representationName: RepresentationType$d
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$k(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/related-list-records/' + config.urlParams.parentRecordId + '/' + config.urlParams.relatedListId + '',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function createChildResourceParams$1(resourceParams) {
      const childConfigs = [];
      for (let index = 0, len = resourceParams.body.relatedListParameters.length; index < len; index += 1) {
        let childConfig = {
          urlParams: {
            parentRecordId: resourceParams.urlParams.parentRecordId,
            relatedListId: resourceParams.body.relatedListParameters[index].relatedListId
          },
          body: {}
        };
        let relatedListConfig = resourceParams.body.relatedListParameters[index];
        // manually populate childConfig body
        if ('fields' in relatedListConfig) {
          childConfig.body.fields = relatedListConfig.fields;
        }
        if ('optionalFields' in relatedListConfig) {
          childConfig.body.optionalFields = relatedListConfig.optionalFields;
        }
        if ('pageSize' in relatedListConfig) {
          childConfig.body.pageSize = relatedListConfig.pageSize;
        }
        if ('sortBy' in relatedListConfig) {
          childConfig.body.sortBy = relatedListConfig.sortBy;
        }
        if ('where' in relatedListConfig) {
          childConfig.body.where = relatedListConfig.where;
        }
        childConfigs.push(childConfig);
      }
      return childConfigs;
    }
    const nonCachedErrors = ObjectCreate$1(null);
    function createChildResourceParams(resourceParams) {
      return createChildResourceParams$1(resourceParams);
    }
    function selectChildResourceParams(luvio, childResources, resourceParams) {
      const envelopeBodyPath = 'result';
      const envelopeStatusCodePath = 'statusCode';
      const envelopePath = 'results';
      return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: reader => {
          // Top-level 404 lookup
          const result = reader.storeLookup(keyBuilder$r(luvio, resourceParams));
          if (result.state === reader.StoreResolveResultState.Error && result.value.status === 404) {
            return {
              state: 'Error',
              value: result.value
            };
          }
          const sink = {};
          reader.enterPath(envelopePath);
          const results = [];
          for (let i = 0, len = childResources.length; i < len; i += 1) {
            reader.enterPath(i);
            reader.enterPath(envelopeBodyPath);
            const childResource = childResources[i];
            const childKey = keyBuilder$s(luvio, childResource);
            const childFragment = select$h(luvio, childResource);
            const isMissingDataBeforeChildRead = reader.getIsDataMissing();
            const childSnapshot = reader.read({
              recordId: childKey,
              node: childFragment,
              variables: {}
            });
            reader.exitPath();
            const childSink = {};
            reader.markSeenId(childKey);
            switch (childSnapshot.state) {
              case 'Stale':
                reader.markStale();
              // Stale needs envelope bodies filled in so don't break
              case 'Fulfilled':
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                reader.exitPath();
                break;
              case 'Error':
                const childSnapshotError = childSnapshot.error;
                reader.enterPath(envelopeStatusCodePath);
                reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                reader.exitPath();
                reader.enterPath(envelopeBodyPath);
                reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                reader.exitPath();
                break;
              case 'Unfulfilled':
                // if child snapshot doesn't have any data then
                // that means the child record key is missing
                if (childSnapshot.data === undefined) {
                  if (reader.isRebuilding() === false) {
                    // not a rebuild, mark as missing and move on
                    reader.markMissingLink(childKey);
                    break;
                  }
                  // On rebuilds we have to check if there is a non-cached
                  // error that we know about.  If we don't do this then
                  // rebuilds will go into endless refresh loop if a child
                  // has non-cached errors (since the top-level composite
                  // snapshot will look like an Unfulfilled snapshot
                  // instead of an error snapshot).
                  const nonCachedError = nonCachedErrors[childKey];
                  if (nonCachedError === undefined || nonCachedError.expiration < reader.getTimeStamp()) {
                    reader.markMissingLink(childKey);
                  } else {
                    // if this child error was the only reason the reader
                    // is marked as missing then we want to undo that
                    if (isMissingDataBeforeChildRead === false) {
                      reader.unMarkMissing();
                    }
                    // put status code and body into reader path
                    const {
                      response: nonCachedBody,
                      status: nonCachedStatus
                    } = nonCachedError;
                    reader.enterPath(envelopeStatusCodePath);
                    reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                    reader.exitPath();
                    reader.enterPath(envelopeBodyPath);
                    reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                    reader.exitPath();
                  }
                }
                break;
              case 'Pending':
                reader.markPending();
                break;
            }
            ArrayPrototypePush.call(results, childSink);
            reader.exitPath();
          }
          reader.assignNonScalar(sink, envelopePath, results);
          reader.exitPath();
          return sink;
        }
      };
    }
    function select$g(luvio, resourceParams) {
      const childResources = createChildResourceParams(resourceParams);
      return selectChildResourceParams(luvio, childResources, resourceParams);
    }
    function keyBuilder$r(luvio, params) {
      return keyPrefix + '::RelatedListRecordCollectionBatchRepresentation:(' + 'parentRecordId:' + params.urlParams.parentRecordId + ',' + '[' + params.body.relatedListParameters.map(element => (element.fields === undefined ? 'relatedListParameters.fields' : 'relatedListParameters.fields:' + element.fields) + '::' + (element.optionalFields === undefined ? 'relatedListParameters.optionalFields' : 'relatedListParameters.optionalFields:' + element.optionalFields) + '::' + (element.pageSize === undefined ? 'relatedListParameters.pageSize' : 'relatedListParameters.pageSize:' + element.pageSize) + '::' + 'relatedListParameters.relatedListId:' + element.relatedListId + '::' + (element.sortBy === undefined ? 'relatedListParameters.sortBy' : 'relatedListParameters.sortBy:' + element.sortBy) + '::' + (element.where === undefined ? 'relatedListParameters.where' : 'relatedListParameters.where:' + element.where)).join(',') + ']' + ')';
    }
    function getResponseCacheKeys$g(keys, luvio, resourceParams, response) {
      const childEnvelopes = response.results;
      const childResourceParamsArray = createChildResourceParams(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      // get children keys
      for (let index = 0, len = childResourceParamsArray.length; index < len; index++) {
        const childResourceParams = childResourceParamsArray[index];
        const childResult = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = childResult;
        if (childStatusCode === 200) {
          getResponseCacheKeys$h(keys, luvio, childResourceParams, childBody);
        } else if (childStatusCode === 404) {
          const childKey = keyBuilder$s(luvio, childResourceParams);
          keys.set(childKey, {
            namespace: keyPrefix,
            representationName: RepresentationType$d,
            mergeable: false
          });
        }
      }
    }
    function ingestSuccessChildResourceParams$1(luvio, childResourceParamsArray, childEnvelopes) {
      const childSnapshotDataResponses = [];
      let seenRecords = new luvioEngine.StoreKeySet();
      let snapshotState = 'Fulfilled';
      const now = Date.now();
      for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$s(luvio, childResourceParams);
        const result = childEnvelopes[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = result;
        if (childStatusCode === 200) {
          const childResponse = {
            status: 200,
            body: childBody,
            ok: true,
            statusText: 'OK',
            headers: {}
          };
          const childSnapshot = ingestSuccess$b(luvio, childResourceParams, childResponse);
          if (childSnapshot.state === "Stale") {
            snapshotState = "Stale";
          }
          seenRecords.merge(childSnapshot.seenRecords);
          seenRecords.add(childSnapshot.recordId);
          const childValue = {
            statusCode: 200,
            result: childSnapshot.data
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        } else {
          const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
          const childResponse = {
            status: childStatusCode,
            body: childBody,
            ok: false,
            statusText: childStatusCodeText,
            headers: {},
            errorType: 'fetchResponse'
          };
          ingestError$7(luvio, childResourceParams, childResponse);
          seenRecords.add(childKey);
          const childValue = {
            statusCode: childStatusCode,
            result: childBody
          };
          luvioEngine.deepFreeze(childValue);
          ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
          nonCachedErrors[childKey] = {
            expiration: now + TTL$a,
            response: childBody,
            status: childStatusCode
          };
        } else {
          delete nonCachedErrors[childKey];
        }
      }
      const childSnapshotData = {
        results: childSnapshotDataResponses
      };
      luvioEngine.deepFreeze(childSnapshotData);
      return {
        childSnapshotData: childSnapshotData,
        seenRecords,
        snapshotState
      };
    }
    function ingestSuccess$a(luvio, resourceParams, response, snapshotRefresh) {
      const childEnvelopes = response.body.results;
      const childResourceParamsArray = createChildResourceParams(resourceParams);
      {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
          throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
      }
      const key = keyBuilder$r(luvio, resourceParams);
      const {
        childSnapshotData,
        seenRecords,
        snapshotState
      } = ingestSuccessChildResourceParams$1(luvio, childResourceParamsArray, childEnvelopes);
      const syntheticSnapshot = {
        recordId: key,
        data: childSnapshotData,
        state: snapshotState,
        seenRecords: seenRecords,
        select: {
          recordId: key,
          node: select$g(luvio, resourceParams),
          variables: {}
        },
        refresh: snapshotRefresh,
        variables: {}
      };
      // evict top level composite record from the store. This covers the case where a previous resource request returned a 404.
      luvio.storeEvict(key);
      return syntheticSnapshot;
    }
    function ingestError$6(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$r(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      luvio.storeIngestError(key, errorSnapshot);
      return errorSnapshot;
    }
    function createResourceRequest$j(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/related-list-records/batch/' + config.urlParams.parentRecordId + '',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$g = 'getRelatedListRecordsBatch';
    const getRelatedListRecordsBatch_ConfigPropertyMetadata = [generateParamConfigMetadata('parentRecordId', true, 0 /* UrlParameter */, 0 /* String */, false, getRecordId18), generateParamConfigMetadata('relatedListParameters', true, 2 /* Body */, 4 /* Unsupported */, true)];
    const getRelatedListRecordsBatch_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$g, getRelatedListRecordsBatch_ConfigPropertyMetadata);
    const createResourceParams$h = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListRecordsBatch_ConfigPropertyMetadata);
    function keyBuilder$q(luvio, config) {
      const resourceParams = createResourceParams$h(config);
      return keyBuilder$r(luvio, resourceParams);
    }
    function typeCheckConfig$k(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListRecordsBatch_ConfigPropertyMetadata);
      const untrustedConfig_relatedListParameters = untrustedConfig.relatedListParameters;
      if (ArrayIsArray$1(untrustedConfig_relatedListParameters)) {
        const untrustedConfig_relatedListParameters_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedListParameters.length; i < arrayLength; i++) {
          const untrustedConfig_relatedListParameters_item = untrustedConfig_relatedListParameters[i];
          const referenceRelatedListRecordsSingleBatchInputRepresentationValidationError = validate$C(untrustedConfig_relatedListParameters_item);
          if (referenceRelatedListRecordsSingleBatchInputRepresentationValidationError === null) {
            untrustedConfig_relatedListParameters_array.push(untrustedConfig_relatedListParameters_item);
          }
        }
        config.relatedListParameters = untrustedConfig_relatedListParameters_array;
      }
      return config;
    }
    function validateAdapterConfig$j(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRelatedListRecordsBatch_ConfigPropertyMetadata);
      const config = typeCheckConfig$k(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$8(luvio, config) {
      const resourceParams = createResourceParams$h(config);
      return select$g(luvio, resourceParams);
    }
    function onFetchResponseSuccess$9(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$a(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$j(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$8(luvio, config, resourceParams, response) {
      const snapshot = ingestError$6(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$j(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$j(luvio, config, options) {
      const resourceParams = createResourceParams$h(config);
      const request = createResourceRequest$j(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$9(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$g(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$8(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$b(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$j, 'get', false);
    }
    function buildCachedSnapshotCachePolicy$a(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$q(luvio, config),
        node: adapterFragment$8(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$j(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getRelatedListRecordsBatchAdapterFactory = luvio => function UiApi__getRelatedListRecordsBatch(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$j(untrustedConfig, getRelatedListRecordsBatch_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$a, buildNetworkSnapshotCachePolicy$b);
    };
    const adapterName$f = 'getRelatedListRecords';
    const getRelatedListRecords_ConfigPropertyMetadata = [generateParamConfigMetadata('parentRecordId', true, 0 /* UrlParameter */, 0 /* String */, false, getRecordId18), generateParamConfigMetadata('relatedListId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('fields', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('optionalFields', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('pageSize', false, 2 /* Body */, 3 /* Integer */), generateParamConfigMetadata('pageToken', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('sortBy', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('where', false, 2 /* Body */, 0 /* String */)];
    const getRelatedListRecords_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$f, getRelatedListRecords_ConfigPropertyMetadata);
    const createResourceParams$g = /*#__PURE__*/luvioEngine.createResourceParams(getRelatedListRecords_ConfigPropertyMetadata);
    function keyBuilder$p(luvio, config) {
      const resourceParams = createResourceParams$g(config);
      return keyBuilder$s(luvio, resourceParams);
    }
    function typeCheckConfig$j(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRelatedListRecords_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$i(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRelatedListRecords_ConfigPropertyMetadata);
      const config = typeCheckConfig$j(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$7(luvio, config) {
      const resourceParams = createResourceParams$g(config);
      return select$h(luvio, resourceParams);
    }
    function onFetchResponseSuccess$8(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$b(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$i(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$7(luvio, config, resourceParams, response) {
      const snapshot = ingestError$7(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$i(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function prepareRequest$2(luvio, config, resourceParams, cacheSnapshot) {
      const paginationMetadata = getPaginationMetadata$1(luvio, resourceParams);
      if (paginationMetadata === undefined) {
        return createResourceRequest$k(resourceParams);
      }
      const {
        token: configToken,
        pageSize: configPageSize
      } = createPaginationParams(resourceParams);
      const configTokenOffset = offsetFromClientToken(paginationMetadata, configToken);
      const maxOffset = getRequestMaxOffset(configTokenOffset, cacheSnapshot);
      const [serverToken, serverTokenOffset] = serverTokenForAtMost(paginationMetadata, maxOffset);
      return createResourceRequest$k(createResourceParams$g({
        ...config,
        pageSize: configPageSize - (serverTokenOffset - configTokenOffset),
        pageToken: serverToken
      }));
    }
    function getRequestMaxOffset(configTokenOffset, cacheSnapshot) {
      if (cacheSnapshot === undefined) {
        return configTokenOffset;
      }
      const num = getCachedItemsNumber$1(cacheSnapshot);
      if (num <= 0) {
        return configTokenOffset;
      }
      return Math.max(configTokenOffset + num, configTokenOffset);
    }
    function getCachedItemsNumber$1(cacheSnapshot) {
      const {
        data
      } = cacheSnapshot;
      if (data === undefined || !data.records) {
        return 0;
      }
      const items = data.records;
      for (let i = 0; i < items.length; i++) {
        if (items[i] === undefined) {
          return i;
        }
      }
      return items.length;
    }
    function getPaginationMetadata$1(luvio, resourceParams) {
      const key = keyBuilder$s(luvio, resourceParams);
      const selector = {
        recordId: key,
        node: {
          kind: 'Fragment',
          version: VERSION$c,
          private: [],
          selections: [{
            kind: 'Link',
            name: '__metadata',
            fragment: {
              kind: 'Fragment',
              version: PAGINATION_VERSION,
              opaque: true,
              private: []
            }
          }]
        },
        variables: {}
      };
      const node = luvio.storeLookup(selector);
      if (node.state !== 'Fulfilled') {
        return;
      }
      return node.data.__metadata;
    }
    function buildNetworkSnapshot$i(luvio, config, options, cacheSnapshot) {
      const resourceParams = createResourceParams$g(config);
      const request = prepareRequest$2(luvio, config, resourceParams, cacheSnapshot);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$8(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$h(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$7(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$a(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$i, 'get', true);
    }
    function buildCachedSnapshotCachePolicy$9(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$p(luvio, config),
        node: adapterFragment$7(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$i(luvio, config, snapshotRefreshOptions)
      });
      if (isUnfulfilledSnapshot$1(cacheSnapshot) && cacheSnapshot.data !== undefined) {
        context.cacheSnapshot = cacheSnapshot;
      }
      return cacheSnapshot;
    }
    const getRelatedListRecordsAdapterFactory = luvio => function UiApi__getRelatedListRecords(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$i(untrustedConfig, getRelatedListRecords_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$9, buildNetworkSnapshotCachePolicy$a);
    };
    function validate$A(obj, path = 'SearchFilterOptionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_value = obj.value;
        const path_value = path + '.value';
        if (typeof obj_value !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_value + '" (at "' + path_value + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    var DiscriminatorValues$1;
    (function (DiscriminatorValues) {
      DiscriminatorValues["Text"] = "Text";
      DiscriminatorValues["Select"] = "Select";
    })(DiscriminatorValues$1 || (DiscriminatorValues$1 = {}));
    var DiscriminatorValues;
    (function (DiscriminatorValues) {
      DiscriminatorValues["Field"] = "Field";
      DiscriminatorValues["DataCategory"] = "DataCategory";
    })(DiscriminatorValues || (DiscriminatorValues = {}));
    function validate$z(obj, path = 'SearchFilterDefinitionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_defaultValues = obj.defaultValues;
        const path_defaultValues = path + '.defaultValues';
        if (!ArrayIsArray(obj_defaultValues)) {
          return new TypeError('Expected "array" but received "' + typeof obj_defaultValues + '" (at "' + path_defaultValues + '")');
        }
        for (let i = 0; i < obj_defaultValues.length; i++) {
          const obj_defaultValues_item = obj_defaultValues[i];
          const path_defaultValues_item = path_defaultValues + '[' + i + ']';
          if (typeof obj_defaultValues_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_defaultValues_item + '" (at "' + path_defaultValues_item + '")');
          }
        }
        if (obj.helpMessage !== undefined) {
          const obj_helpMessage = obj.helpMessage;
          const path_helpMessage = path + '.helpMessage';
          let obj_helpMessage_union0 = null;
          const obj_helpMessage_union0_error = (() => {
            if (typeof obj_helpMessage !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_helpMessage + '" (at "' + path_helpMessage + '")');
            }
          })();
          if (obj_helpMessage_union0_error != null) {
            obj_helpMessage_union0 = obj_helpMessage_union0_error.message;
          }
          let obj_helpMessage_union1 = null;
          const obj_helpMessage_union1_error = (() => {
            if (obj_helpMessage !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_helpMessage + '" (at "' + path_helpMessage + '")');
            }
          })();
          if (obj_helpMessage_union1_error != null) {
            obj_helpMessage_union1 = obj_helpMessage_union1_error.message;
          }
          if (obj_helpMessage_union0 && obj_helpMessage_union1) {
            let message = 'Object doesn\'t match union (at "' + path_helpMessage + '")';
            message += '\n' + obj_helpMessage_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_helpMessage_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$9 = 30000;
    const VERSION$b = "7d241c2ee7cc9b09d6bd434b33b0b5e4";
    function validate$y(obj, path = 'SearchFilterMetadataCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_channel = obj.channel;
        const path_channel = path + '.channel';
        let obj_channel_union0 = null;
        const obj_channel_union0_error = (() => {
          if (typeof obj_channel !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_channel + '" (at "' + path_channel + '")');
          }
        })();
        if (obj_channel_union0_error != null) {
          obj_channel_union0 = obj_channel_union0_error.message;
        }
        let obj_channel_union1 = null;
        const obj_channel_union1_error = (() => {
          if (obj_channel !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_channel + '" (at "' + path_channel + '")');
          }
        })();
        if (obj_channel_union1_error != null) {
          obj_channel_union1 = obj_channel_union1_error.message;
        }
        if (obj_channel_union0 && obj_channel_union1) {
          let message = 'Object doesn\'t match union (at "' + path_channel + '")';
          message += '\n' + obj_channel_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_channel_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_filters = obj.filters;
        const path_filters = path + '.filters';
        if (!ArrayIsArray(obj_filters)) {
          return new TypeError('Expected "array" but received "' + typeof obj_filters + '" (at "' + path_filters + '")');
        }
        for (let i = 0; i < obj_filters.length; i++) {
          const obj_filters_item = obj_filters[i];
          const path_filters_item = path_filters + '[' + i + ']';
          const referencepath_filters_itemValidationError = validate$z(obj_filters_item, path_filters_item);
          if (referencepath_filters_itemValidationError !== null) {
            let message = 'Object doesn\'t match SearchFilterDefinitionRepresentation (at "' + path_filters_item + '")\n';
            message += referencepath_filters_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$c = 'SearchFilterMetadataCollectionRepresentation';
    function keyBuilder$o(luvio, config) {
      return keyPrefix + '::' + RepresentationType$c + ':' + config.objectApiName + ':' + (config.channel === null ? '' : config.channel);
    }
    function keyBuilderFromType$9(luvio, object) {
      const keyParams = {
        objectApiName: object.objectApiName,
        channel: object.channel
      };
      return keyBuilder$o(luvio, keyParams);
    }
    function normalize$7(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$f = function SearchFilterMetadataCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$b,
        private: [],
        opaque: true
      };
    };
    function equals$b(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$7 = function SearchFilterMetadataCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$y(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$9(luvio, input);
      const ttlToUse = TTL$9;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$7, "UiApi", VERSION$b, RepresentationType$c, equals$b);
      return createLink(key);
    };
    function getTypeCacheKeys$c(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$9(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$c,
        mergeable: false
      });
    }
    function select$e(luvio, params) {
      return select$f();
    }
    function keyBuilder$n(luvio, params) {
      return keyBuilder$o(luvio, {
        objectApiName: params.urlParams.objectApiName,
        channel: params.queryParams.channel || null
      });
    }
    function getResponseCacheKeys$f(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$c(storeKeyMap, luvio, response);
    }
    function ingestSuccess$9(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$n(luvio, resourceParams);
      luvio.storeIngest(key, ingest$7, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$e(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$5(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$n(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$9,
        namespace: keyPrefix,
        version: VERSION$b,
        representationName: RepresentationType$c
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$i(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/search-info/' + config.urlParams.objectApiName + '/filters',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$e = 'getSearchFilterMetadata';
    const getSearchFilterMetadata_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('channel', false, 1 /* QueryParameter */, 0 /* String */)];
    const getSearchFilterMetadata_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$e, getSearchFilterMetadata_ConfigPropertyMetadata);
    const createResourceParams$f = /*#__PURE__*/luvioEngine.createResourceParams(getSearchFilterMetadata_ConfigPropertyMetadata);
    function keyBuilder$m(luvio, config) {
      const resourceParams = createResourceParams$f(config);
      return keyBuilder$n(luvio, resourceParams);
    }
    function typeCheckConfig$i(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getSearchFilterMetadata_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$h(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$i(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$6(luvio, config) {
      createResourceParams$f(config);
      return select$e();
    }
    function onFetchResponseSuccess$7(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$9(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$h(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$6(luvio, config, resourceParams, response) {
      const snapshot = ingestError$5(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$h(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$h(luvio, config, options) {
      const resourceParams = createResourceParams$f(config);
      const request = createResourceRequest$i(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$7(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$f(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$6(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$9(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$h, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$8(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$m(luvio, config),
        node: adapterFragment$6(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$h(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getSearchFilterMetadataAdapterFactory = luvio => function UiApi__getSearchFilterMetadata(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$h(untrustedConfig, getSearchFilterMetadata_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$8, buildNetworkSnapshotCachePolicy$9);
    };
    const TTL$8 = 30000;
    const VERSION$a = "8d851a8d9abf0a061a8ad81d4cbb83bc";
    function validate$x(obj, path = 'SearchFilterOptionCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_filterApiName = obj.filterApiName;
        const path_filterApiName = path + '.filterApiName';
        if (typeof obj_filterApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_filterApiName + '" (at "' + path_filterApiName + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_options = obj.options;
        const path_options = path + '.options';
        if (!ArrayIsArray(obj_options)) {
          return new TypeError('Expected "array" but received "' + typeof obj_options + '" (at "' + path_options + '")');
        }
        for (let i = 0; i < obj_options.length; i++) {
          const obj_options_item = obj_options[i];
          const path_options_item = path_options + '[' + i + ']';
          const referencepath_options_itemValidationError = validate$A(obj_options_item, path_options_item);
          if (referencepath_options_itemValidationError !== null) {
            let message = 'Object doesn\'t match SearchFilterOptionRepresentation (at "' + path_options_item + '")\n';
            message += referencepath_options_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_query = obj.query;
        const path_query = path + '.query';
        let obj_query_union0 = null;
        const obj_query_union0_error = (() => {
          if (typeof obj_query !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_query + '" (at "' + path_query + '")');
          }
        })();
        if (obj_query_union0_error != null) {
          obj_query_union0 = obj_query_union0_error.message;
        }
        let obj_query_union1 = null;
        const obj_query_union1_error = (() => {
          if (obj_query !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_query + '" (at "' + path_query + '")');
          }
        })();
        if (obj_query_union1_error != null) {
          obj_query_union1 = obj_query_union1_error.message;
        }
        if (obj_query_union0 && obj_query_union1) {
          let message = 'Object doesn\'t match union (at "' + path_query + '")';
          message += '\n' + obj_query_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_query_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$b = 'SearchFilterOptionCollectionRepresentation';
    function keyBuilder$l(luvio, config) {
      return keyPrefix + '::' + RepresentationType$b + ':' + (config.query === null ? '' : config.query) + ':' + config.objectApiName + ':' + config.filterApiName;
    }
    function keyBuilderFromType$8(luvio, object) {
      const keyParams = {
        query: object.query,
        objectApiName: object.objectApiName,
        filterApiName: object.filterApiName
      };
      return keyBuilder$l(luvio, keyParams);
    }
    function normalize$6(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$d = function SearchFilterOptionCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$a,
        private: [],
        opaque: true
      };
    };
    function equals$a(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$6 = function SearchFilterOptionCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$x(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$8(luvio, input);
      const ttlToUse = TTL$8;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$6, "UiApi", VERSION$a, RepresentationType$b, equals$a);
      return createLink(key);
    };
    function getTypeCacheKeys$b(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$8(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$b,
        mergeable: false
      });
    }
    function select$c(luvio, params) {
      return select$d();
    }
    function keyBuilder$k(luvio, params) {
      return keyBuilder$l(luvio, {
        query: params.queryParams.q || null,
        objectApiName: params.urlParams.objectApiName,
        filterApiName: params.urlParams.filterApiName
      });
    }
    function getResponseCacheKeys$e(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$b(storeKeyMap, luvio, response);
    }
    function ingestSuccess$8(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$k(luvio, resourceParams);
      luvio.storeIngest(key, ingest$6, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$c(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$4(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$k(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$8,
        namespace: keyPrefix,
        version: VERSION$a,
        representationName: RepresentationType$b
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$h(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/search-info/' + config.urlParams.objectApiName + '/filters/' + config.urlParams.filterApiName + '/options',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$d = 'getSearchFilterOptions';
    const getSearchFilterOptions_ConfigPropertyMetadata = [generateParamConfigMetadata('filterApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('q', false, 1 /* QueryParameter */, 0 /* String */)];
    const getSearchFilterOptions_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$d, getSearchFilterOptions_ConfigPropertyMetadata);
    const createResourceParams$e = /*#__PURE__*/luvioEngine.createResourceParams(getSearchFilterOptions_ConfigPropertyMetadata);
    function keyBuilder$j(luvio, config) {
      const resourceParams = createResourceParams$e(config);
      return keyBuilder$k(luvio, resourceParams);
    }
    function typeCheckConfig$h(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getSearchFilterOptions_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$g(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$h(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$5(luvio, config) {
      createResourceParams$e(config);
      return select$c();
    }
    function onFetchResponseSuccess$6(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$8(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$g(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$5(luvio, config, resourceParams, response) {
      const snapshot = ingestError$4(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$g(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$g(luvio, config, options) {
      const resourceParams = createResourceParams$e(config);
      const request = createResourceRequest$h(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$6(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$e(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$5(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$8(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$g, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$7(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$j(luvio, config),
        node: adapterFragment$5(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$g(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getSearchFilterOptionsAdapterFactory = luvio => function UiApi__getSearchFilterOptions(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$g(untrustedConfig, getSearchFilterOptions_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$7, buildNetworkSnapshotCachePolicy$8);
    };
    function validate$w(obj, path = 'AdvancedLookupDisplayInfoFieldRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldPath = obj.fieldPath;
        const path_fieldPath = path + '.fieldPath';
        if (typeof obj_fieldPath !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldPath + '" (at "' + path_fieldPath + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$v(obj, path = 'AdvancedLookupDisplayInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (!ArrayIsArray(obj_fields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        for (let i = 0; i < obj_fields.length; i++) {
          const obj_fields_item = obj_fields[i];
          const path_fields_item = path_fields + '[' + i + ']';
          const referencepath_fields_itemValidationError = validate$w(obj_fields_item, path_fields_item);
          if (referencepath_fields_itemValidationError !== null) {
            let message = 'Object doesn\'t match AdvancedLookupDisplayInfoFieldRepresentation (at "' + path_fields_item + '")\n';
            message += referencepath_fields_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$u(obj, path = 'AdvancedLookupInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_displayInfo = obj.displayInfo;
        const path_displayInfo = path + '.displayInfo';
        const referencepath_displayInfoValidationError = validate$v(obj_displayInfo, path_displayInfo);
        if (referencepath_displayInfoValidationError !== null) {
          let message = 'Object doesn\'t match AdvancedLookupDisplayInfoRepresentation (at "' + path_displayInfo + '")\n';
          message += referencepath_displayInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$t(obj, path = 'DisplayLayoutRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_displayFields = obj.displayFields;
        const path_displayFields = path + '.displayFields';
        if (!ArrayIsArray(obj_displayFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_displayFields + '" (at "' + path_displayFields + '")');
        }
        for (let i = 0; i < obj_displayFields.length; i++) {
          const obj_displayFields_item = obj_displayFields[i];
          const path_displayFields_item = path_displayFields + '[' + i + ']';
          if (typeof obj_displayFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_displayFields_item + '" (at "' + path_displayFields_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$s(obj, path = 'MatchingInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_matchingFields = obj.matchingFields;
        const path_matchingFields = path + '.matchingFields';
        if (!ArrayIsArray(obj_matchingFields)) {
          return new TypeError('Expected "array" but received "' + typeof obj_matchingFields + '" (at "' + path_matchingFields + '")');
        }
        for (let i = 0; i < obj_matchingFields.length; i++) {
          const obj_matchingFields_item = obj_matchingFields[i];
          const path_matchingFields_item = path_matchingFields + '[' + i + ']';
          if (typeof obj_matchingFields_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_matchingFields_item + '" (at "' + path_matchingFields_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$r(obj, path = 'DisplayLayoutAndMatchingInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_displayLayout = obj.displayLayout;
        const path_displayLayout = path + '.displayLayout';
        const referencepath_displayLayoutValidationError = validate$t(obj_displayLayout, path_displayLayout);
        if (referencepath_displayLayoutValidationError !== null) {
          let message = 'Object doesn\'t match DisplayLayoutRepresentation (at "' + path_displayLayout + '")\n';
          message += referencepath_displayLayoutValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_matchingInfo = obj.matchingInfo;
        const path_matchingInfo = path + '.matchingInfo';
        const referencepath_matchingInfoValidationError = validate$s(obj_matchingInfo, path_matchingInfo);
        if (referencepath_matchingInfoValidationError !== null) {
          let message = 'Object doesn\'t match MatchingInfoRepresentation (at "' + path_matchingInfo + '")\n';
          message += referencepath_matchingInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$q(obj, path = 'LookupMetadataTargetInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_advancedLookupInfo = obj.advancedLookupInfo;
        const path_advancedLookupInfo = path + '.advancedLookupInfo';
        const referencepath_advancedLookupInfoValidationError = validate$u(obj_advancedLookupInfo, path_advancedLookupInfo);
        if (referencepath_advancedLookupInfoValidationError !== null) {
          let message = 'Object doesn\'t match AdvancedLookupInfoRepresentation (at "' + path_advancedLookupInfo + '")\n';
          message += referencepath_advancedLookupInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_suggestionsInfo = obj.suggestionsInfo;
        const path_suggestionsInfo = path + '.suggestionsInfo';
        const referencepath_suggestionsInfoValidationError = validate$r(obj_suggestionsInfo, path_suggestionsInfo);
        if (referencepath_suggestionsInfoValidationError !== null) {
          let message = 'Object doesn\'t match DisplayLayoutAndMatchingInfoRepresentation (at "' + path_suggestionsInfo + '")\n';
          message += referencepath_suggestionsInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$7 = 30000;
    const VERSION$9 = "ab99b79a5e8a78e051ec92b39d76a6bd";
    function validate$p(obj, path = 'LookupMetadataRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_secondaryField = obj.secondaryField;
        const path_secondaryField = path + '.secondaryField';
        let obj_secondaryField_union0 = null;
        const obj_secondaryField_union0_error = (() => {
          if (typeof obj_secondaryField !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_secondaryField + '" (at "' + path_secondaryField + '")');
          }
        })();
        if (obj_secondaryField_union0_error != null) {
          obj_secondaryField_union0 = obj_secondaryField_union0_error.message;
        }
        let obj_secondaryField_union1 = null;
        const obj_secondaryField_union1_error = (() => {
          if (obj_secondaryField !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_secondaryField + '" (at "' + path_secondaryField + '")');
          }
        })();
        if (obj_secondaryField_union1_error != null) {
          obj_secondaryField_union1 = obj_secondaryField_union1_error.message;
        }
        if (obj_secondaryField_union0 && obj_secondaryField_union1) {
          let message = 'Object doesn\'t match union (at "' + path_secondaryField + '")';
          message += '\n' + obj_secondaryField_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_secondaryField_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_targetInfo = obj.targetInfo;
        const path_targetInfo = path + '.targetInfo';
        if (typeof obj_targetInfo !== 'object' || ArrayIsArray(obj_targetInfo) || obj_targetInfo === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_targetInfo + '" (at "' + path_targetInfo + '")');
        }
        const obj_targetInfo_keys = ObjectKeys(obj_targetInfo);
        for (let i = 0; i < obj_targetInfo_keys.length; i++) {
          const key = obj_targetInfo_keys[i];
          const obj_targetInfo_prop = obj_targetInfo[key];
          const path_targetInfo_prop = path_targetInfo + '["' + key + '"]';
          const referencepath_targetInfo_propValidationError = validate$q(obj_targetInfo_prop, path_targetInfo_prop);
          if (referencepath_targetInfo_propValidationError !== null) {
            let message = 'Object doesn\'t match LookupMetadataTargetInfoRepresentation (at "' + path_targetInfo_prop + '")\n';
            message += referencepath_targetInfo_propValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$a = 'LookupMetadataRepresentation';
    function keyBuilder$i(luvio, config) {
      return keyPrefix + '::' + RepresentationType$a + ':' + config.objectApiName + ':' + config.fieldApiName;
    }
    function keyBuilderFromType$7(luvio, object) {
      const keyParams = {
        objectApiName: object.objectApiName,
        fieldApiName: object.fieldApiName
      };
      return keyBuilder$i(luvio, keyParams);
    }
    function normalize$5(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$b = function LookupMetadataRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$9,
        private: [],
        opaque: true
      };
    };
    function equals$9(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$5 = function LookupMetadataRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$p(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$7(luvio, input);
      const ttlToUse = TTL$7;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$5, "UiApi", VERSION$9, RepresentationType$a, equals$9);
      return createLink(key);
    };
    function getTypeCacheKeys$a(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$7(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$a,
        mergeable: false
      });
    }
    function select$a(luvio, params) {
      return select$b();
    }
    function keyBuilder$h(luvio, params) {
      return keyBuilder$i(luvio, {
        objectApiName: params.urlParams.objectApiName,
        fieldApiName: params.urlParams.fieldApiName
      });
    }
    function getResponseCacheKeys$d(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$a(storeKeyMap, luvio, response);
    }
    function ingestSuccess$7(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$h(luvio, resourceParams);
      luvio.storeIngest(key, ingest$5, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$a(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$3(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$h(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$7,
        namespace: keyPrefix,
        version: VERSION$9,
        representationName: RepresentationType$a
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$g(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/search-info/' + config.urlParams.objectApiName + '/lookup/' + config.urlParams.fieldApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$c = 'getLookupMetadata';
    const getLookupMetadata_ConfigPropertyMetadata = [generateParamConfigMetadata('fieldApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */)];
    const getLookupMetadata_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$c, getLookupMetadata_ConfigPropertyMetadata);
    const createResourceParams$d = /*#__PURE__*/luvioEngine.createResourceParams(getLookupMetadata_ConfigPropertyMetadata);
    function keyBuilder$g(luvio, config) {
      const resourceParams = createResourceParams$d(config);
      return keyBuilder$h(luvio, resourceParams);
    }
    function typeCheckConfig$g(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getLookupMetadata_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$f(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$g(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$4(luvio, config) {
      createResourceParams$d(config);
      return select$a();
    }
    function onFetchResponseSuccess$5(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$7(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$f(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$4(luvio, config, resourceParams, response) {
      const snapshot = ingestError$3(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$f(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$f(luvio, config, options) {
      const resourceParams = createResourceParams$d(config);
      const request = createResourceRequest$g(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$5(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$d(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$4(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$7(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$f, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$6(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$g(luvio, config),
        node: adapterFragment$4(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$f(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getLookupMetadataAdapterFactory = luvio => function UiApi__getLookupMetadata(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$f(untrustedConfig, getLookupMetadata_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$6, buildNetworkSnapshotCachePolicy$7);
    };
    function validate$o(obj, path = 'SearchDataCategoryInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_groupName = obj.groupName;
        const path_groupName = path + '.groupName';
        if (typeof obj_groupName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_groupName + '" (at "' + path_groupName + '")');
        }
        const obj_operator = obj.operator;
        const path_operator = path + '.operator';
        if (typeof obj_operator !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_operator + '" (at "' + path_operator + '")');
        }
        const obj_values = obj.values;
        const path_values = path + '.values';
        if (!ArrayIsArray(obj_values)) {
          return new TypeError('Expected "array" but received "' + typeof obj_values + '" (at "' + path_values + '")');
        }
        for (let i = 0; i < obj_values.length; i++) {
          const obj_values_item = obj_values[i];
          const path_values_item = path_values + '[' + i + ']';
          if (typeof obj_values_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_values_item + '" (at "' + path_values_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$n(obj, path = 'SearchFilterInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldPath = obj.fieldPath;
        const path_fieldPath = path + '.fieldPath';
        if (typeof obj_fieldPath !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldPath + '" (at "' + path_fieldPath + '")');
        }
        if (obj.objectApiName !== undefined) {
          const obj_objectApiName = obj.objectApiName;
          const path_objectApiName = path + '.objectApiName';
          if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
          }
        }
        const obj_operator = obj.operator;
        const path_operator = path + '.operator';
        if (typeof obj_operator !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_operator + '" (at "' + path_operator + '")');
        }
        const obj_values = obj.values;
        const path_values = path + '.values';
        if (!ArrayIsArray(obj_values)) {
          return new TypeError('Expected "array" but received "' + typeof obj_values + '" (at "' + path_values + '")');
        }
        for (let i = 0; i < obj_values.length; i++) {
          const obj_values_item = obj_values[i];
          const path_values_item = path_values + '[' + i + ']';
          let obj_values_item_union0 = null;
          const obj_values_item_union0_error = (() => {
            if (typeof obj_values_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_values_item + '" (at "' + path_values_item + '")');
            }
          })();
          if (obj_values_item_union0_error != null) {
            obj_values_item_union0 = obj_values_item_union0_error.message;
          }
          let obj_values_item_union1 = null;
          const obj_values_item_union1_error = (() => {
            if (typeof obj_values_item !== 'number') {
              return new TypeError('Expected "number" but received "' + typeof obj_values_item + '" (at "' + path_values_item + '")');
            }
          })();
          if (obj_values_item_union1_error != null) {
            obj_values_item_union1 = obj_values_item_union1_error.message;
          }
          let obj_values_item_union2 = null;
          const obj_values_item_union2_error = (() => {
            if (typeof obj_values_item !== 'boolean') {
              return new TypeError('Expected "boolean" but received "' + typeof obj_values_item + '" (at "' + path_values_item + '")');
            }
          })();
          if (obj_values_item_union2_error != null) {
            obj_values_item_union2 = obj_values_item_union2_error.message;
          }
          if (obj_values_item_union0 && obj_values_item_union1 && obj_values_item_union2) {
            let message = 'Object doesn\'t match union (at "' + path_values_item + '")';
            message += '\n' + obj_values_item_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_values_item_union1.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_values_item_union2.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$m(obj, path = 'SearchObjectOptionsRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_dataCategories = obj.dataCategories;
        const path_dataCategories = path + '.dataCategories';
        if (!ArrayIsArray(obj_dataCategories)) {
          return new TypeError('Expected "array" but received "' + typeof obj_dataCategories + '" (at "' + path_dataCategories + '")');
        }
        for (let i = 0; i < obj_dataCategories.length; i++) {
          const obj_dataCategories_item = obj_dataCategories[i];
          const path_dataCategories_item = path_dataCategories + '[' + i + ']';
          const referencepath_dataCategories_itemValidationError = validate$o(obj_dataCategories_item, path_dataCategories_item);
          if (referencepath_dataCategories_itemValidationError !== null) {
            let message = 'Object doesn\'t match SearchDataCategoryInputRepresentation (at "' + path_dataCategories_item + '")\n';
            message += referencepath_dataCategories_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_filters = obj.filters;
        const path_filters = path + '.filters';
        if (!ArrayIsArray(obj_filters)) {
          return new TypeError('Expected "array" but received "' + typeof obj_filters + '" (at "' + path_filters + '")');
        }
        for (let i = 0; i < obj_filters.length; i++) {
          const obj_filters_item = obj_filters[i];
          const path_filters_item = path_filters + '[' + i + ']';
          const referencepath_filters_itemValidationError = validate$n(obj_filters_item, path_filters_item);
          if (referencepath_filters_itemValidationError !== null) {
            let message = 'Object doesn\'t match SearchFilterInputRepresentation (at "' + path_filters_item + '")\n';
            message += referencepath_filters_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$l(obj, path = 'DirectAnswerResultRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_explanation = obj.explanation;
        const path_explanation = path + '.explanation';
        let obj_explanation_union0 = null;
        const obj_explanation_union0_error = (() => {
          if (typeof obj_explanation !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_explanation + '" (at "' + path_explanation + '")');
          }
        })();
        if (obj_explanation_union0_error != null) {
          obj_explanation_union0 = obj_explanation_union0_error.message;
        }
        let obj_explanation_union1 = null;
        const obj_explanation_union1_error = (() => {
          if (obj_explanation !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_explanation + '" (at "' + path_explanation + '")');
          }
        })();
        if (obj_explanation_union1_error != null) {
          obj_explanation_union1 = obj_explanation_union1_error.message;
        }
        if (obj_explanation_union0 && obj_explanation_union1) {
          let message = 'Object doesn\'t match union (at "' + path_explanation + '")';
          message += '\n' + obj_explanation_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_explanation_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_hasNoResult = obj.hasNoResult;
        const path_hasNoResult = path + '.hasNoResult';
        let obj_hasNoResult_union0 = null;
        const obj_hasNoResult_union0_error = (() => {
          if (typeof obj_hasNoResult !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_hasNoResult + '" (at "' + path_hasNoResult + '")');
          }
        })();
        if (obj_hasNoResult_union0_error != null) {
          obj_hasNoResult_union0 = obj_hasNoResult_union0_error.message;
        }
        let obj_hasNoResult_union1 = null;
        const obj_hasNoResult_union1_error = (() => {
          if (obj_hasNoResult !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_hasNoResult + '" (at "' + path_hasNoResult + '")');
          }
        })();
        if (obj_hasNoResult_union1_error != null) {
          obj_hasNoResult_union1 = obj_hasNoResult_union1_error.message;
        }
        if (obj_hasNoResult_union0 && obj_hasNoResult_union1) {
          let message = 'Object doesn\'t match union (at "' + path_hasNoResult + '")';
          message += '\n' + obj_hasNoResult_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_hasNoResult_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_result = obj.result;
        const path_result = path + '.result';
        let obj_result_union0 = null;
        const obj_result_union0_error = (() => {
          if (typeof obj_result !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_result + '" (at "' + path_result + '")');
          }
        })();
        if (obj_result_union0_error != null) {
          obj_result_union0 = obj_result_union0_error.message;
        }
        let obj_result_union1 = null;
        const obj_result_union1_error = (() => {
          if (obj_result !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_result + '" (at "' + path_result + '")');
          }
        })();
        if (obj_result_union1_error != null) {
          obj_result_union1 = obj_result_union1_error.message;
        }
        if (obj_result_union0 && obj_result_union1) {
          let message = 'Object doesn\'t match union (at "' + path_result + '")';
          message += '\n' + obj_result_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_result_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_turnId = obj.turnId;
        const path_turnId = path + '.turnId';
        let obj_turnId_union0 = null;
        const obj_turnId_union0_error = (() => {
          if (typeof obj_turnId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_turnId + '" (at "' + path_turnId + '")');
          }
        })();
        if (obj_turnId_union0_error != null) {
          obj_turnId_union0 = obj_turnId_union0_error.message;
        }
        let obj_turnId_union1 = null;
        const obj_turnId_union1_error = (() => {
          if (obj_turnId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_turnId + '" (at "' + path_turnId + '")');
          }
        })();
        if (obj_turnId_union1_error != null) {
          obj_turnId_union1 = obj_turnId_union1_error.message;
        }
        if (obj_turnId_union0 && obj_turnId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_turnId + '")';
          message += '\n' + obj_turnId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_turnId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$k(obj, path = 'ErrorMessageRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_errorCode = obj.errorCode;
        const path_errorCode = path + '.errorCode';
        if (typeof obj_errorCode !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_errorCode + '" (at "' + path_errorCode + '")');
        }
        const obj_message = obj.message;
        const path_message = path + '.message';
        let obj_message_union0 = null;
        const obj_message_union0_error = (() => {
          if (typeof obj_message !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_message + '" (at "' + path_message + '")');
          }
        })();
        if (obj_message_union0_error != null) {
          obj_message_union0 = obj_message_union0_error.message;
        }
        let obj_message_union1 = null;
        const obj_message_union1_error = (() => {
          if (obj_message !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_message + '" (at "' + path_message + '")');
          }
        })();
        if (obj_message_union1_error != null) {
          obj_message_union1 = obj_message_union1_error.message;
        }
        if (obj_message_union0 && obj_message_union1) {
          let message = 'Object doesn\'t match union (at "' + path_message + '")';
          message += '\n' + obj_message_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_message_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$j(obj, path = 'SearchResultCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        if (typeof obj_currentPageToken !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
        }
        const obj_error = obj.error;
        const path_error = path + '.error';
        let obj_error_union0 = null;
        const obj_error_union0_error = (() => {
          const referencepath_errorValidationError = validate$k(obj_error, path_error);
          if (referencepath_errorValidationError !== null) {
            let message = 'Object doesn\'t match ErrorMessageRepresentation (at "' + path_error + '")\n';
            message += referencepath_errorValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_error_union0_error != null) {
          obj_error_union0 = obj_error_union0_error.message;
        }
        let obj_error_union1 = null;
        const obj_error_union1_error = (() => {
          if (obj_error !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_error + '" (at "' + path_error + '")');
          }
        })();
        if (obj_error_union1_error != null) {
          obj_error_union1 = obj_error_union1_error.message;
        }
        if (obj_error_union0 && obj_error_union1) {
          let message = 'Object doesn\'t match union (at "' + path_error + '")';
          message += '\n' + obj_error_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_error_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
          if (typeof obj_nextPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union0_error != null) {
          obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
          if (obj_nextPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
          }
        })();
        if (obj_nextPageToken_union1_error != null) {
          obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
          message += '\n' + obj_nextPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_orderBy = obj.orderBy;
        const path_orderBy = path + '.orderBy';
        if (!ArrayIsArray(obj_orderBy)) {
          return new TypeError('Expected "array" but received "' + typeof obj_orderBy + '" (at "' + path_orderBy + '")');
        }
        for (let i = 0; i < obj_orderBy.length; i++) {
          const obj_orderBy_item = obj_orderBy[i];
          const path_orderBy_item = path_orderBy + '[' + i + ']';
          const referencepath_orderBy_itemValidationError = validate$25(obj_orderBy_item, path_orderBy_item);
          if (referencepath_orderBy_itemValidationError !== null) {
            let message = 'Object doesn\'t match ListOrderByInfoRepresentation (at "' + path_orderBy_item + '")\n';
            message += referencepath_orderBy_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_pageSize = obj.pageSize;
        const path_pageSize = path + '.pageSize';
        if (typeof obj_pageSize !== 'number' || typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize) {
          return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
          if (typeof obj_previousPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union0_error != null) {
          obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
          if (obj_previousPageToken !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
          }
        })();
        if (obj_previousPageToken_union1_error != null) {
          obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
          message += '\n' + obj_previousPageToken_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageToken_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (!ArrayIsArray(obj_records)) {
          return new TypeError('Expected "array" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        for (let i = 0; i < obj_records.length; i++) {
          const obj_records_item = obj_records[i];
          const path_records_item = path_records + '[' + i + ']';
          if (typeof obj_records_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_records_item + '" (at "' + path_records_item + '")');
          }
        }
        const obj_relatedObjectApiNames = obj.relatedObjectApiNames;
        const path_relatedObjectApiNames = path + '.relatedObjectApiNames';
        if (!ArrayIsArray(obj_relatedObjectApiNames)) {
          return new TypeError('Expected "array" but received "' + typeof obj_relatedObjectApiNames + '" (at "' + path_relatedObjectApiNames + '")');
        }
        for (let i = 0; i < obj_relatedObjectApiNames.length; i++) {
          const obj_relatedObjectApiNames_item = obj_relatedObjectApiNames[i];
          const path_relatedObjectApiNames_item = path_relatedObjectApiNames + '[' + i + ']';
          if (typeof obj_relatedObjectApiNames_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relatedObjectApiNames_item + '" (at "' + path_relatedObjectApiNames_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$i(obj, path = 'KeywordSearchResultsRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_hasNoResult = obj.hasNoResult;
        const path_hasNoResult = path + '.hasNoResult';
        let obj_hasNoResult_union0 = null;
        const obj_hasNoResult_union0_error = (() => {
          if (typeof obj_hasNoResult !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_hasNoResult + '" (at "' + path_hasNoResult + '")');
          }
        })();
        if (obj_hasNoResult_union0_error != null) {
          obj_hasNoResult_union0 = obj_hasNoResult_union0_error.message;
        }
        let obj_hasNoResult_union1 = null;
        const obj_hasNoResult_union1_error = (() => {
          if (obj_hasNoResult !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_hasNoResult + '" (at "' + path_hasNoResult + '")');
          }
        })();
        if (obj_hasNoResult_union1_error != null) {
          obj_hasNoResult_union1 = obj_hasNoResult_union1_error.message;
        }
        if (obj_hasNoResult_union0 && obj_hasNoResult_union1) {
          let message = 'Object doesn\'t match union (at "' + path_hasNoResult + '")';
          message += '\n' + obj_hasNoResult_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_hasNoResult_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_results = obj.results;
        const path_results = path + '.results';
        if (!ArrayIsArray(obj_results)) {
          return new TypeError('Expected "array" but received "' + typeof obj_results + '" (at "' + path_results + '")');
        }
        for (let i = 0; i < obj_results.length; i++) {
          const obj_results_item = obj_results[i];
          const path_results_item = path_results + '[' + i + ']';
          if (typeof obj_results_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_results_item + '" (at "' + path_results_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$h(obj, path = 'NLSResultsRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_hasNoResult = obj.hasNoResult;
        const path_hasNoResult = path + '.hasNoResult';
        let obj_hasNoResult_union0 = null;
        const obj_hasNoResult_union0_error = (() => {
          if (typeof obj_hasNoResult !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_hasNoResult + '" (at "' + path_hasNoResult + '")');
          }
        })();
        if (obj_hasNoResult_union0_error != null) {
          obj_hasNoResult_union0 = obj_hasNoResult_union0_error.message;
        }
        let obj_hasNoResult_union1 = null;
        const obj_hasNoResult_union1_error = (() => {
          if (obj_hasNoResult !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_hasNoResult + '" (at "' + path_hasNoResult + '")');
          }
        })();
        if (obj_hasNoResult_union1_error != null) {
          obj_hasNoResult_union1 = obj_hasNoResult_union1_error.message;
        }
        if (obj_hasNoResult_union0 && obj_hasNoResult_union1) {
          let message = 'Object doesn\'t match union (at "' + path_hasNoResult + '")';
          message += '\n' + obj_hasNoResult_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_hasNoResult_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_results = obj.results;
        const path_results = path + '.results';
        if (typeof obj_results !== 'object') {
          return new TypeError('Expected "object" but received "' + typeof obj_results + '" (at "' + path_results + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$g(obj, path = 'AppliedSearchFilterOutputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldPath = obj.fieldPath;
        const path_fieldPath = path + '.fieldPath';
        if (typeof obj_fieldPath !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldPath + '" (at "' + path_fieldPath + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_operator = obj.operator;
        const path_operator = path + '.operator';
        if (typeof obj_operator !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_operator + '" (at "' + path_operator + '")');
        }
        const obj_values = obj.values;
        const path_values = path + '.values';
        if (!ArrayIsArray(obj_values)) {
          return new TypeError('Expected "array" but received "' + typeof obj_values + '" (at "' + path_values + '")');
        }
        for (let i = 0; i < obj_values.length; i++) {
          const obj_values_item = obj_values[i];
          const path_values_item = path_values + '[' + i + ']';
          if (typeof obj_values_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_values_item + '" (at "' + path_values_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$f(obj, path = 'SearchAnswersRecordRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_objectApiLabel = obj.objectApiLabel;
        const path_objectApiLabel = path + '.objectApiLabel';
        if (typeof obj_objectApiLabel !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiLabel + '" (at "' + path_objectApiLabel + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_recordId = obj.recordId;
        const path_recordId = path + '.recordId';
        if (typeof obj_recordId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_recordId + '" (at "' + path_recordId + '")');
        }
        const obj_title = obj.title;
        const path_title = path + '.title';
        if (typeof obj_title !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$e(obj, path = 'SearchAnswersResultRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_answerType = obj.answerType;
        const path_answerType = path + '.answerType';
        let obj_answerType_union0 = null;
        const obj_answerType_union0_error = (() => {
          if (typeof obj_answerType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_answerType + '" (at "' + path_answerType + '")');
          }
        })();
        if (obj_answerType_union0_error != null) {
          obj_answerType_union0 = obj_answerType_union0_error.message;
        }
        let obj_answerType_union1 = null;
        const obj_answerType_union1_error = (() => {
          if (obj_answerType !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_answerType + '" (at "' + path_answerType + '")');
          }
        })();
        if (obj_answerType_union1_error != null) {
          obj_answerType_union1 = obj_answerType_union1_error.message;
        }
        if (obj_answerType_union0 && obj_answerType_union1) {
          let message = 'Object doesn\'t match union (at "' + path_answerType + '")';
          message += '\n' + obj_answerType_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_answerType_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_appliedFilters = obj.appliedFilters;
        const path_appliedFilters = path + '.appliedFilters';
        if (!ArrayIsArray(obj_appliedFilters)) {
          return new TypeError('Expected "array" but received "' + typeof obj_appliedFilters + '" (at "' + path_appliedFilters + '")');
        }
        for (let i = 0; i < obj_appliedFilters.length; i++) {
          const obj_appliedFilters_item = obj_appliedFilters[i];
          const path_appliedFilters_item = path_appliedFilters + '[' + i + ']';
          const referencepath_appliedFilters_itemValidationError = validate$g(obj_appliedFilters_item, path_appliedFilters_item);
          if (referencepath_appliedFilters_itemValidationError !== null) {
            let message = 'Object doesn\'t match AppliedSearchFilterOutputRepresentation (at "' + path_appliedFilters_item + '")\n';
            message += referencepath_appliedFilters_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_hasNoResult = obj.hasNoResult;
        const path_hasNoResult = path + '.hasNoResult';
        let obj_hasNoResult_union0 = null;
        const obj_hasNoResult_union0_error = (() => {
          if (typeof obj_hasNoResult !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_hasNoResult + '" (at "' + path_hasNoResult + '")');
          }
        })();
        if (obj_hasNoResult_union0_error != null) {
          obj_hasNoResult_union0 = obj_hasNoResult_union0_error.message;
        }
        let obj_hasNoResult_union1 = null;
        const obj_hasNoResult_union1_error = (() => {
          if (obj_hasNoResult !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_hasNoResult + '" (at "' + path_hasNoResult + '")');
          }
        })();
        if (obj_hasNoResult_union1_error != null) {
          obj_hasNoResult_union1 = obj_hasNoResult_union1_error.message;
        }
        if (obj_hasNoResult_union0 && obj_hasNoResult_union1) {
          let message = 'Object doesn\'t match union (at "' + path_hasNoResult + '")';
          message += '\n' + obj_hasNoResult_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_hasNoResult_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_passage = obj.passage;
        const path_passage = path + '.passage';
        let obj_passage_union0 = null;
        const obj_passage_union0_error = (() => {
          if (typeof obj_passage !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_passage + '" (at "' + path_passage + '")');
          }
        })();
        if (obj_passage_union0_error != null) {
          obj_passage_union0 = obj_passage_union0_error.message;
        }
        let obj_passage_union1 = null;
        const obj_passage_union1_error = (() => {
          if (obj_passage !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_passage + '" (at "' + path_passage + '")');
          }
        })();
        if (obj_passage_union1_error != null) {
          obj_passage_union1 = obj_passage_union1_error.message;
        }
        if (obj_passage_union0 && obj_passage_union1) {
          let message = 'Object doesn\'t match union (at "' + path_passage + '")';
          message += '\n' + obj_passage_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_passage_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (!ArrayIsArray(obj_records)) {
          return new TypeError('Expected "array" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        for (let i = 0; i < obj_records.length; i++) {
          const obj_records_item = obj_records[i];
          const path_records_item = path_records + '[' + i + ']';
          const referencepath_records_itemValidationError = validate$f(obj_records_item, path_records_item);
          if (referencepath_records_itemValidationError !== null) {
            let message = 'Object doesn\'t match SearchAnswersRecordRepresentation (at "' + path_records_item + '")\n';
            message += referencepath_records_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$d(obj, path = 'SearchDataCategoryOutputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_groupName = obj.groupName;
        const path_groupName = path + '.groupName';
        if (typeof obj_groupName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_groupName + '" (at "' + path_groupName + '")');
        }
        const obj_operator = obj.operator;
        const path_operator = path + '.operator';
        if (typeof obj_operator !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_operator + '" (at "' + path_operator + '")');
        }
        const obj_values = obj.values;
        const path_values = path + '.values';
        if (!ArrayIsArray(obj_values)) {
          return new TypeError('Expected "array" but received "' + typeof obj_values + '" (at "' + path_values + '")');
        }
        for (let i = 0; i < obj_values.length; i++) {
          const obj_values_item = obj_values[i];
          const path_values_item = path_values + '[' + i + ']';
          if (typeof obj_values_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_values_item + '" (at "' + path_values_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$c(obj, path = 'SearchFilterOutputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldPath = obj.fieldPath;
        const path_fieldPath = path + '.fieldPath';
        if (typeof obj_fieldPath !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fieldPath + '" (at "' + path_fieldPath + '")');
        }
        const obj_operator = obj.operator;
        const path_operator = path + '.operator';
        if (typeof obj_operator !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_operator + '" (at "' + path_operator + '")');
        }
        const obj_values = obj.values;
        const path_values = path + '.values';
        if (!ArrayIsArray(obj_values)) {
          return new TypeError('Expected "array" but received "' + typeof obj_values + '" (at "' + path_values + '")');
        }
        for (let i = 0; i < obj_values.length; i++) {
          const obj_values_item = obj_values[i];
          const path_values_item = path_values + '[' + i + ']';
          if (typeof obj_values_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_values_item + '" (at "' + path_values_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$b(obj, path = 'SearchObjectOptionsOutputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_dataCategories = obj.dataCategories;
        const path_dataCategories = path + '.dataCategories';
        if (!ArrayIsArray(obj_dataCategories)) {
          return new TypeError('Expected "array" but received "' + typeof obj_dataCategories + '" (at "' + path_dataCategories + '")');
        }
        for (let i = 0; i < obj_dataCategories.length; i++) {
          const obj_dataCategories_item = obj_dataCategories[i];
          const path_dataCategories_item = path_dataCategories + '[' + i + ']';
          const referencepath_dataCategories_itemValidationError = validate$d(obj_dataCategories_item, path_dataCategories_item);
          if (referencepath_dataCategories_itemValidationError !== null) {
            let message = 'Object doesn\'t match SearchDataCategoryOutputRepresentation (at "' + path_dataCategories_item + '")\n';
            message += referencepath_dataCategories_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_filters = obj.filters;
        const path_filters = path + '.filters';
        if (!ArrayIsArray(obj_filters)) {
          return new TypeError('Expected "array" but received "' + typeof obj_filters + '" (at "' + path_filters + '")');
        }
        for (let i = 0; i < obj_filters.length; i++) {
          const obj_filters_item = obj_filters[i];
          const path_filters_item = path_filters + '[' + i + ']';
          const referencepath_filters_itemValidationError = validate$c(obj_filters_item, path_filters_item);
          if (referencepath_filters_itemValidationError !== null) {
            let message = 'Object doesn\'t match SearchFilterOutputRepresentation (at "' + path_filters_item + '")\n';
            message += referencepath_filters_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$6 = 200;
    const VERSION$8 = "5e805b26bc243a05358227e1d5e31fe2";
    function validate$a(obj, path = 'SearchResultsSummaryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_configurationName = obj.configurationName;
        const path_configurationName = path + '.configurationName';
        let obj_configurationName_union0 = null;
        const obj_configurationName_union0_error = (() => {
          if (typeof obj_configurationName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_configurationName + '" (at "' + path_configurationName + '")');
          }
        })();
        if (obj_configurationName_union0_error != null) {
          obj_configurationName_union0 = obj_configurationName_union0_error.message;
        }
        let obj_configurationName_union1 = null;
        const obj_configurationName_union1_error = (() => {
          if (obj_configurationName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_configurationName + '" (at "' + path_configurationName + '")');
          }
        })();
        if (obj_configurationName_union1_error != null) {
          obj_configurationName_union1 = obj_configurationName_union1_error.message;
        }
        if (obj_configurationName_union0 && obj_configurationName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_configurationName + '")';
          message += '\n' + obj_configurationName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_configurationName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_directAnswerResult = obj.directAnswerResult;
        const path_directAnswerResult = path + '.directAnswerResult';
        let obj_directAnswerResult_union0 = null;
        const obj_directAnswerResult_union0_error = (() => {
          const referencepath_directAnswerResultValidationError = validate$l(obj_directAnswerResult, path_directAnswerResult);
          if (referencepath_directAnswerResultValidationError !== null) {
            let message = 'Object doesn\'t match DirectAnswerResultRepresentation (at "' + path_directAnswerResult + '")\n';
            message += referencepath_directAnswerResultValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_directAnswerResult_union0_error != null) {
          obj_directAnswerResult_union0 = obj_directAnswerResult_union0_error.message;
        }
        let obj_directAnswerResult_union1 = null;
        const obj_directAnswerResult_union1_error = (() => {
          if (obj_directAnswerResult !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_directAnswerResult + '" (at "' + path_directAnswerResult + '")');
          }
        })();
        if (obj_directAnswerResult_union1_error != null) {
          obj_directAnswerResult_union1 = obj_directAnswerResult_union1_error.message;
        }
        if (obj_directAnswerResult_union0 && obj_directAnswerResult_union1) {
          let message = 'Object doesn\'t match union (at "' + path_directAnswerResult + '")';
          message += '\n' + obj_directAnswerResult_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_directAnswerResult_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_keywordSearchResults = obj.keywordSearchResults;
        const path_keywordSearchResults = path + '.keywordSearchResults';
        let obj_keywordSearchResults_union0 = null;
        const obj_keywordSearchResults_union0_error = (() => {
          const referencepath_keywordSearchResultsValidationError = validate$i(obj_keywordSearchResults, path_keywordSearchResults);
          if (referencepath_keywordSearchResultsValidationError !== null) {
            let message = 'Object doesn\'t match KeywordSearchResultsRepresentation (at "' + path_keywordSearchResults + '")\n';
            message += referencepath_keywordSearchResultsValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_keywordSearchResults_union0_error != null) {
          obj_keywordSearchResults_union0 = obj_keywordSearchResults_union0_error.message;
        }
        let obj_keywordSearchResults_union1 = null;
        const obj_keywordSearchResults_union1_error = (() => {
          if (obj_keywordSearchResults !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_keywordSearchResults + '" (at "' + path_keywordSearchResults + '")');
          }
        })();
        if (obj_keywordSearchResults_union1_error != null) {
          obj_keywordSearchResults_union1 = obj_keywordSearchResults_union1_error.message;
        }
        if (obj_keywordSearchResults_union0 && obj_keywordSearchResults_union1) {
          let message = 'Object doesn\'t match union (at "' + path_keywordSearchResults + '")';
          message += '\n' + obj_keywordSearchResults_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_keywordSearchResults_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_nlsResults = obj.nlsResults;
        const path_nlsResults = path + '.nlsResults';
        let obj_nlsResults_union0 = null;
        const obj_nlsResults_union0_error = (() => {
          const referencepath_nlsResultsValidationError = validate$h(obj_nlsResults, path_nlsResults);
          if (referencepath_nlsResultsValidationError !== null) {
            let message = 'Object doesn\'t match NLSResultsRepresentation (at "' + path_nlsResults + '")\n';
            message += referencepath_nlsResultsValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_nlsResults_union0_error != null) {
          obj_nlsResults_union0 = obj_nlsResults_union0_error.message;
        }
        let obj_nlsResults_union1 = null;
        const obj_nlsResults_union1_error = (() => {
          if (obj_nlsResults !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nlsResults + '" (at "' + path_nlsResults + '")');
          }
        })();
        if (obj_nlsResults_union1_error != null) {
          obj_nlsResults_union1 = obj_nlsResults_union1_error.message;
        }
        if (obj_nlsResults_union0 && obj_nlsResults_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nlsResults + '")';
          message += '\n' + obj_nlsResults_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nlsResults_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_qnaResult = obj.qnaResult;
        const path_qnaResult = path + '.qnaResult';
        let obj_qnaResult_union0 = null;
        const obj_qnaResult_union0_error = (() => {
          const referencepath_qnaResultValidationError = validate$e(obj_qnaResult, path_qnaResult);
          if (referencepath_qnaResultValidationError !== null) {
            let message = 'Object doesn\'t match SearchAnswersResultRepresentation (at "' + path_qnaResult + '")\n';
            message += referencepath_qnaResultValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_qnaResult_union0_error != null) {
          obj_qnaResult_union0 = obj_qnaResult_union0_error.message;
        }
        let obj_qnaResult_union1 = null;
        const obj_qnaResult_union1_error = (() => {
          if (obj_qnaResult !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_qnaResult + '" (at "' + path_qnaResult + '")');
          }
        })();
        if (obj_qnaResult_union1_error != null) {
          obj_qnaResult_union1 = obj_qnaResult_union1_error.message;
        }
        if (obj_qnaResult_union0 && obj_qnaResult_union1) {
          let message = 'Object doesn\'t match union (at "' + path_qnaResult + '")';
          message += '\n' + obj_qnaResult_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_qnaResult_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_query = obj.query;
        const path_query = path + '.query';
        if (typeof obj_query !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_query + '" (at "' + path_query + '")');
        }
        const obj_queryId = obj.queryId;
        const path_queryId = path + '.queryId';
        if (typeof obj_queryId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_queryId + '" (at "' + path_queryId + '")');
        }
        const obj_searchObjectOptions = obj.searchObjectOptions;
        const path_searchObjectOptions = path + '.searchObjectOptions';
        if (typeof obj_searchObjectOptions !== 'object' || ArrayIsArray(obj_searchObjectOptions) || obj_searchObjectOptions === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_searchObjectOptions + '" (at "' + path_searchObjectOptions + '")');
        }
        const obj_searchObjectOptions_keys = ObjectKeys(obj_searchObjectOptions);
        for (let i = 0; i < obj_searchObjectOptions_keys.length; i++) {
          const key = obj_searchObjectOptions_keys[i];
          const obj_searchObjectOptions_prop = obj_searchObjectOptions[key];
          const path_searchObjectOptions_prop = path_searchObjectOptions + '["' + key + '"]';
          const referencepath_searchObjectOptions_propValidationError = validate$b(obj_searchObjectOptions_prop, path_searchObjectOptions_prop);
          if (referencepath_searchObjectOptions_propValidationError !== null) {
            let message = 'Object doesn\'t match SearchObjectOptionsOutputRepresentation (at "' + path_searchObjectOptions_prop + '")\n';
            message += referencepath_searchObjectOptions_propValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$9 = 'SearchResultsSummaryRepresentation';
    function keyBuilder$f(luvio, config) {
      return keyPrefix + '::' + RepresentationType$9 + ':' + config.query + ':' + (config.configurationName === null ? '' : config.configurationName);
    }
    function keyBuilderFromType$6(luvio, object) {
      const keyParams = {
        query: object.query,
        configurationName: object.configurationName
      };
      return keyBuilder$f(luvio, keyParams);
    }
    function normalize$4(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$9 = function SearchResultsSummaryRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$8,
        private: [],
        opaque: true
      };
    };
    function equals$8(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$4 = function SearchResultsSummaryRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$a(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$6(luvio, input);
      const ttlToUse = TTL$6;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$4, "UiApi", VERSION$8, RepresentationType$9, equals$8);
      return createLink(key);
    };
    function getTypeCacheKeys$9(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$6(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$9,
        mergeable: false
      });
    }
    function select$8(luvio, params) {
      return select$9();
    }
    function keyBuilder$e(luvio, params) {
      return keyBuilder$f(luvio, {
        query: params.queryParams.q,
        configurationName: params.body.configurationName || null
      });
    }
    function getResponseCacheKeys$c(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$9(storeKeyMap, luvio, response);
    }
    function ingestSuccess$6(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$e(luvio, resourceParams);
      luvio.storeIngest(key, ingest$4, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$8(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$2(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$e(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$6,
        namespace: keyPrefix,
        version: VERSION$8,
        representationName: RepresentationType$9
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$f(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/search/results',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$b = 'getSearchResults';
    const getSearchResults_ConfigPropertyMetadata = [generateParamConfigMetadata('q', true, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('answerTypes', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('configurationName', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('objectApiNames', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('searchObjectOptions', false, 2 /* Body */, 4 /* Unsupported */)];
    const getSearchResults_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$b, getSearchResults_ConfigPropertyMetadata);
    const createResourceParams$c = /*#__PURE__*/luvioEngine.createResourceParams(getSearchResults_ConfigPropertyMetadata);
    function keyBuilder$d(luvio, config) {
      const resourceParams = createResourceParams$c(config);
      return keyBuilder$e(luvio, resourceParams);
    }
    function typeCheckConfig$f(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getSearchResults_ConfigPropertyMetadata);
      const untrustedConfig_searchObjectOptions = untrustedConfig.searchObjectOptions;
      if (untrustedIsObject(untrustedConfig_searchObjectOptions)) {
        const untrustedConfig_searchObjectOptions_object = {};
        const untrustedConfig_searchObjectOptions_keys = Object.keys(untrustedConfig_searchObjectOptions);
        for (let i = 0, arrayLength = untrustedConfig_searchObjectOptions_keys.length; i < arrayLength; i++) {
          const key = untrustedConfig_searchObjectOptions_keys[i];
          const untrustedConfig_searchObjectOptions_prop = untrustedConfig_searchObjectOptions[key];
          const referenceSearchObjectOptionsRepresentationValidationError = validate$m(untrustedConfig_searchObjectOptions_prop);
          if (referenceSearchObjectOptionsRepresentationValidationError === null) {
            if (untrustedConfig_searchObjectOptions_object !== undefined) {
              untrustedConfig_searchObjectOptions_object[key] = untrustedConfig_searchObjectOptions_prop;
            }
          }
        }
        if (untrustedConfig_searchObjectOptions_object !== undefined && Object.keys(untrustedConfig_searchObjectOptions_object).length >= 0) {
          config.searchObjectOptions = untrustedConfig_searchObjectOptions_object;
        }
      }
      return config;
    }
    function validateAdapterConfig$e(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$f(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$3(luvio, config) {
      createResourceParams$c(config);
      return select$8();
    }
    function onFetchResponseSuccess$4(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$6(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$e(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$3(luvio, config, resourceParams, response) {
      const snapshot = ingestError$2(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$e(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$e(luvio, config, options) {
      const resourceParams = createResourceParams$c(config);
      const request = createResourceRequest$f(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$4(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$c(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$3(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$6(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$e, 'get', false);
    }
    function buildCachedSnapshotCachePolicy$5(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$d(luvio, config),
        node: adapterFragment$3(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$e(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getSearchResultsAdapterFactory = luvio => function UiApi__getSearchResults(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$e(untrustedConfig, getSearchResults_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$5, buildNetworkSnapshotCachePolicy$6);
    };
    const TTL$5 = 200;
    const VERSION$7 = "3102453bf10ea449d9665914d5f5febf";
    function validate$9(obj, path = 'KeywordSearchResultsSummaryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_configurationName = obj.configurationName;
        const path_configurationName = path + '.configurationName';
        let obj_configurationName_union0 = null;
        const obj_configurationName_union0_error = (() => {
          if (typeof obj_configurationName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_configurationName + '" (at "' + path_configurationName + '")');
          }
        })();
        if (obj_configurationName_union0_error != null) {
          obj_configurationName_union0 = obj_configurationName_union0_error.message;
        }
        let obj_configurationName_union1 = null;
        const obj_configurationName_union1_error = (() => {
          if (obj_configurationName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_configurationName + '" (at "' + path_configurationName + '")');
          }
        })();
        if (obj_configurationName_union1_error != null) {
          obj_configurationName_union1 = obj_configurationName_union1_error.message;
        }
        if (obj_configurationName_union0 && obj_configurationName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_configurationName + '")';
          message += '\n' + obj_configurationName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_configurationName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_keywordSearchResult = obj.keywordSearchResult;
        const path_keywordSearchResult = path + '.keywordSearchResult';
        const referencepath_keywordSearchResultValidationError = validate$j(obj_keywordSearchResult, path_keywordSearchResult);
        if (referencepath_keywordSearchResultValidationError !== null) {
          let message = 'Object doesn\'t match SearchResultCollectionRepresentation (at "' + path_keywordSearchResult + '")\n';
          message += referencepath_keywordSearchResultValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_query = obj.query;
        const path_query = path + '.query';
        if (typeof obj_query !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_query + '" (at "' + path_query + '")');
        }
        const obj_queryId = obj.queryId;
        const path_queryId = path + '.queryId';
        if (typeof obj_queryId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_queryId + '" (at "' + path_queryId + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$8 = 'KeywordSearchResultsSummaryRepresentation';
    function keyBuilder$c(luvio, config) {
      return keyPrefix + '::' + RepresentationType$8 + ':' + config.query + ':' + config.objectApiName + ':' + (config.configurationName === null ? '' : config.configurationName);
    }
    function keyBuilderFromType$5(luvio, object) {
      const keyParams = {
        query: object.query,
        objectApiName: object.objectApiName,
        configurationName: object.configurationName
      };
      return keyBuilder$c(luvio, keyParams);
    }
    function normalize$3(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$7 = function KeywordSearchResultsSummaryRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$7,
        private: [],
        opaque: true
      };
    };
    function equals$7(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$3 = function KeywordSearchResultsSummaryRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$9(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$5(luvio, input);
      const ttlToUse = TTL$5;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$3, "UiApi", VERSION$7, RepresentationType$8, equals$7);
      return createLink(key);
    };
    function getTypeCacheKeys$8(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$5(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$8,
        mergeable: false
      });
    }
    function select$6(luvio, params) {
      return select$7();
    }
    function keyBuilder$b(luvio, params) {
      return keyBuilder$c(luvio, {
        query: params.queryParams.q,
        objectApiName: params.queryParams.objectApiName,
        configurationName: params.body.configurationName || null
      });
    }
    function getResponseCacheKeys$b(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$8(storeKeyMap, luvio, response);
    }
    function ingestSuccess$5(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$b(luvio, resourceParams);
      luvio.storeIngest(key, ingest$3, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$6(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$1(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$b(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$5,
        namespace: keyPrefix,
        version: VERSION$7,
        representationName: RepresentationType$8
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$e(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/search/results/keyword',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$a = 'getKeywordSearchResults';
    const getKeywordSearchResults_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('q', true, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('configurationName', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('filters', false, 2 /* Body */, 4 /* Unsupported */, true), generateParamConfigMetadata('pageSize', false, 2 /* Body */, 3 /* Integer */), generateParamConfigMetadata('pageToken', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('sortBy', false, 2 /* Body */, 0 /* String */)];
    const getKeywordSearchResults_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$a, getKeywordSearchResults_ConfigPropertyMetadata);
    const createResourceParams$b = /*#__PURE__*/luvioEngine.createResourceParams(getKeywordSearchResults_ConfigPropertyMetadata);
    function keyBuilder$a(luvio, config) {
      const resourceParams = createResourceParams$b(config);
      return keyBuilder$b(luvio, resourceParams);
    }
    function typeCheckConfig$e(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getKeywordSearchResults_ConfigPropertyMetadata);
      const untrustedConfig_filters = untrustedConfig.filters;
      if (ArrayIsArray$1(untrustedConfig_filters)) {
        const untrustedConfig_filters_array = [];
        for (let i = 0, arrayLength = untrustedConfig_filters.length; i < arrayLength; i++) {
          const untrustedConfig_filters_item = untrustedConfig_filters[i];
          const referenceSearchFilterInputRepresentationValidationError = validate$n(untrustedConfig_filters_item);
          if (referenceSearchFilterInputRepresentationValidationError === null) {
            untrustedConfig_filters_array.push(untrustedConfig_filters_item);
          }
        }
        config.filters = untrustedConfig_filters_array;
      }
      return config;
    }
    function validateAdapterConfig$d(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$e(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$2(luvio, config) {
      createResourceParams$b(config);
      return select$6();
    }
    function onFetchResponseSuccess$3(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$5(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$d(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$2(luvio, config, resourceParams, response) {
      const snapshot = ingestError$1(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$d(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$d(luvio, config, options) {
      const resourceParams = createResourceParams$b(config);
      const request = createResourceRequest$e(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$3(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$b(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$2(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$5(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$d, 'get', false);
    }
    function buildCachedSnapshotCachePolicy$4(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$a(luvio, config),
        node: adapterFragment$2(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$d(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getKeywordSearchResultsAdapterFactory = luvio => function UiApi__getKeywordSearchResults(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$d(untrustedConfig, getKeywordSearchResults_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$4, buildNetworkSnapshotCachePolicy$5);
    };
    const API_NAMESPACE = 'UiApi';
    const RECORD_REPRESENTATION_NAME = 'RecordRepresentation';
    const RECORD_VIEW_ENTITY_REPRESENTATION_NAME = 'RecordViewEntityRepresentation';
    const RECORD_ID_PREFIX = `${API_NAMESPACE}::${RECORD_REPRESENTATION_NAME}:`;
    const RECORD_VIEW_ENTITY_ID_PREFIX = `${API_NAMESPACE}::${RECORD_VIEW_ENTITY_REPRESENTATION_NAME}:Name:`;
    const RECORD_FIELDS_KEY_JUNCTION = '__fields__';
    function extractRecordIdFromStoreKey(key) {
      if (key === undefined || key.indexOf(RECORD_ID_PREFIX) === -1 && key.indexOf(RECORD_VIEW_ENTITY_ID_PREFIX) === -1) {
        return undefined;
      }
      const parts = key.split(':');
      return parts[parts.length - 1].split('_')[0];
    }
    function isStoreKeyRecordViewEntity(key) {
      return key.indexOf(RECORD_VIEW_ENTITY_ID_PREFIX) > -1 && key.indexOf(RECORD_FIELDS_KEY_JUNCTION) === -1;
    }
    function buildRecordRepKeyFromId(recordId) {
      return `${API_NAMESPACE}::${RECORD_REPRESENTATION_NAME}:${recordId}`;
    }

    // The rest of this is copy-pasted. Sorry.
    ObjectCreate$1(null);
    function getResponseCacheKeys$a(cacheKeyMap, luvio, _resourceParams,
    // For consistency of interface with other adapters
    response) {
      const results = response.results;
      for (let index = 0, len = results.length; index < len; index += 1) {
        const {
          statusCode: childStatusCode,
          result: childBody
        } = results[index];
        if (childStatusCode === 200 || childStatusCode === 201) {
          if (isDeleteResponse(childBody)) {
            const recordKey = keyBuilder$29(luvio, {
              recordId: childBody.id
            });
            cacheKeyMap.set(recordKey, {
              namespace: keyPrefix,
              representationName: RepresentationType$V,
              mergeable: false
            });
          } else {
            getTypeCacheKeys$X(cacheKeyMap, luvio, childBody);
          }
        }
      }
    }
    function ingestSuccessChildResourceParams(luvio, response) {
      const childSnapshotDataResponses = [];
      let seenRecords = new luvioEngine.StoreKeySet();
      let batchSnapshotState = 'Fulfilled';
      const results = response.results;
      for (let index = 0, len = results.length; index < len; index += 1) {
        const individualResponse = results[index];
        const {
          statusCode: childStatusCode,
          result: childBody
        } = individualResponse;
        if (childStatusCode === 200 || childStatusCode === 201) {
          if (isDeleteResponse(childBody)) {
            const recordKey = keyBuilder$29(luvio, {
              recordId: childBody.id
            });
            luvio.storeEvict(recordKey);
            ArrayPrototypePush.call(childSnapshotDataResponses, {
              ...individualResponse
            });
          } else {
            const childSnapshot = ingestRecord(childBody, luvio);
            if (childSnapshot.state !== 'Error') {
              // Not sure why it's possible to get Error here but it is
              seenRecords.merge(childSnapshot.seenRecords);
              seenRecords.add(childSnapshot.recordId);
              if (childSnapshot.state === 'Stale') {
                batchSnapshotState = 'Stale';
              }
            }
            const childDataValue = {
              ...individualResponse,
              result: childSnapshot.data // verify, is this safe w/ pending snapshots and stuff? Do we even need to return the snapshot really?
            };
            ArrayPrototypePush.call(childSnapshotDataResponses, childDataValue);
          }
        } else {
          // Got an error back
          const childErrorValue = {
            statusCode: childStatusCode,
            result: childBody
          };
          ArrayPrototypePush.call(childSnapshotDataResponses, childErrorValue);
        }
      }
      const childSnapshotData = {
        hasErrors: response.hasErrors,
        results: childSnapshotDataResponses
      };
      luvioEngine.deepFreeze(childSnapshotData);
      return {
        result: childSnapshotData,
        seenRecords,
        snapshotState: batchSnapshotState
      };
    }
    function ingestRecord(childBody, luvio) {
      const childResponse = {
        status: 200,
        body: childBody,
        ok: true,
        statusText: 'OK',
        headers: {}
      };
      const fieldTrie = BLANK_RECORD_FIELDS_TRIE;
      const optionalFieldTrie = BLANK_RECORD_FIELDS_TRIE;
      const conflictMap = {
        conflicts: {},
        serverRequestCount: 0
      };
      const recordIngest = createRecordIngest(fieldTrie, optionalFieldTrie, conflictMap);
      const childSnapshot = ingestRecordResponse(luvio, childResponse, childBody.id, recordIngest, conflictMap);
      return childSnapshot;
    }
    function isDeleteResponse(childBody) {
      return childBody.fields === undefined && childBody.id !== undefined;
    }
    function ingestSuccess$4(luvio, response) {
      const {
        result,
        snapshotState,
        seenRecords
      } = ingestSuccessChildResourceParams(luvio, response.body);
      const syntheticSnapshot = {
        state: snapshotState,
        seenRecords,
        data: result
      };
      return syntheticSnapshot;
    }
    function createResourceRequest$d(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/records/batch',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$9 = 'executeBatchRecordOperations';
    const executeBatchRecordOperations_ConfigPropertyMetadata = [generateParamConfigMetadata('allOrNone', true, 2, 1, false), generateParamConfigMetadata('operations', true, 2, 4, true) // Required, BodyParam, Unsupported(Object type), array
    ];
    const executeBatchRecordOperations_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$9, executeBatchRecordOperations_ConfigPropertyMetadata);
    const acceptedOperations = ['CREATE', 'UPDATE', 'DELETE'];
    const batchUpdateRecordsCreateResourceParams = /*#__PURE__*/luvioEngine.createResourceParams(executeBatchRecordOperations_ConfigPropertyMetadata);
    function batchUpdateRecordsTypeCheckConfig(untrustedConfig) {
      const config = {};
      const untrustedConfigOperations = untrustedConfig.operations;
      if (untrustedConfigOperations !== undefined && ArrayIsArray$1(untrustedConfigOperations)) {
        const trustedOperations = [];
        let hasInvalidOperation = false;
        for (let i = 0, arrayLength = untrustedConfigOperations.length; i < arrayLength; i++) {
          const untrustedSingleOperation = untrustedConfigOperations[i];
          // Not much deep validation here - if it's got a CREATE/UPDATE/DELETE type and a 'records' property, we add it
          if (untrustedIsObject(untrustedSingleOperation)) {
            if (untrustedSingleOperation !== undefined && untrustedSingleOperation.type !== undefined && typeof untrustedSingleOperation.type === 'string' && acceptedOperations.includes(untrustedSingleOperation.type.toUpperCase()) && ObjectPrototypeHasOwnProperty.call(untrustedSingleOperation, 'records')) {
              trustedOperations.push(untrustedSingleOperation);
            } else {
              hasInvalidOperation = true;
            }
          }
        }
        if (!hasInvalidOperation && trustedOperations.length > 0) {
          config.operations = trustedOperations;
        }
      }
      const untrustedConfigAllOrNone = untrustedConfig.allOrNone;
      if (untrustedConfigAllOrNone !== undefined && typeof untrustedConfigAllOrNone === 'boolean') {
        config.allOrNone = untrustedConfigAllOrNone;
      }
      return config;
    }
    function validateAdapterConfig$c(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      // Do we need to coerce all the incoming recordIds to 18 character? We don't use the config for any ingestion so might be okay.
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, executeBatchRecordOperations_ConfigPropertyMetadata);
      const config = batchUpdateRecordsTypeCheckConfig(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$c(luvio, config, options) {
      const resourceParams = batchUpdateRecordsCreateResourceParams(config);
      const request = createResourceRequest$d(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$4(luvio, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$a(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const factory$e = luvio => {
      return function executeBatchRecordOperations(untrustedConfig) {
        const config = validateAdapterConfig$c(untrustedConfig, executeBatchRecordOperations_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          // eslint-disable-next-line @salesforce/lds/no-error-in-production
          throw new Error('Invalid config for "executeBatchRecordOperations"');
        }
        return buildNetworkSnapshot$c(luvio, config);
      };
    };
    function select$5(luvio, params) {
      return select$1F();
    }
    function getResponseCacheKeys$9(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$J(storeKeyMap, luvio, response);
    }
    function ingestSuccess$3(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$s(luvio, body);
      luvio.storeIngest(key, ingest$B, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$5(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$c(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/perform-quick-action/' + config.urlParams.actionApiName + '',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$8 = 'performUpdateRecordQuickAction';
    const performUpdateRecordQuickAction_ConfigPropertyMetadata = [generateParamConfigMetadata('actionApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('allowSaveOnDuplicate', false, 2 /* Body */, 1 /* Boolean */), generateParamConfigMetadata('apiName', true, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('contextId', false, 2 /* Body */, 0 /* String */, false, getRecordId18), generateParamConfigMetadata('fields', true, 2 /* Body */, 4 /* Unsupported */)];
    const performUpdateRecordQuickAction_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$8, performUpdateRecordQuickAction_ConfigPropertyMetadata);
    const createResourceParams$a = /*#__PURE__*/luvioEngine.createResourceParams(performUpdateRecordQuickAction_ConfigPropertyMetadata);
    function typeCheckConfig$d(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, performUpdateRecordQuickAction_ConfigPropertyMetadata);
      const untrustedConfig_fields = untrustedConfig.fields;
      if (untrustedIsObject(untrustedConfig_fields)) {
        const untrustedConfig_fields_object = {};
        const untrustedConfig_fields_keys = Object.keys(untrustedConfig_fields);
        for (let i = 0, arrayLength = untrustedConfig_fields_keys.length; i < arrayLength; i++) {
          const key = untrustedConfig_fields_keys[i];
          const untrustedConfig_fields_prop = untrustedConfig_fields[key];
          if (typeof untrustedConfig_fields_prop === 'string') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (typeof untrustedConfig_fields_prop === 'number') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (untrustedConfig_fields_prop === null) {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (typeof untrustedConfig_fields_prop === 'boolean') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
        }
        if (untrustedConfig_fields_object !== undefined && Object.keys(untrustedConfig_fields_object).length >= 0) {
          config.fields = untrustedConfig_fields_object;
        }
      }
      return config;
    }
    function validateAdapterConfig$b(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, performUpdateRecordQuickAction_ConfigPropertyMetadata);
      const config = typeCheckConfig$d(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$b(luvio, config, options) {
      const resourceParams = createResourceParams$a(config);
      const request = createResourceRequest$c(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$3(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$9(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const performUpdateRecordQuickActionAdapterFactory = luvio => {
      return function performUpdateRecordQuickAction(untrustedConfig) {
        const config = validateAdapterConfig$b(untrustedConfig, performUpdateRecordQuickAction_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "performUpdateRecordQuickAction"');
        }
        return buildNetworkSnapshot$b(luvio, config);
      };
    };
    const factory$d = performUpdateRecordQuickActionAdapterFactory;
    function select$4(luvio, params) {
      return select$1F();
    }
    function getResponseCacheKeys$8(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$J(storeKeyMap, luvio, response);
    }
    function ingestSuccess$2(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$s(luvio, body);
      luvio.storeIngest(key, ingest$B, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$4(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$b(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/actions/perform-quick-action/' + config.urlParams.actionApiName + '',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$7 = 'performQuickAction';
    const performQuickAction_ConfigPropertyMetadata = [generateParamConfigMetadata('actionApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('allowSaveOnDuplicate', false, 2 /* Body */, 1 /* Boolean */), generateParamConfigMetadata('apiName', true, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('contextId', false, 2 /* Body */, 0 /* String */, false, getRecordId18), generateParamConfigMetadata('fields', true, 2 /* Body */, 4 /* Unsupported */)];
    const performQuickAction_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$7, performQuickAction_ConfigPropertyMetadata);
    const createResourceParams$9 = /*#__PURE__*/luvioEngine.createResourceParams(performQuickAction_ConfigPropertyMetadata);
    function typeCheckConfig$c(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, performQuickAction_ConfigPropertyMetadata);
      const untrustedConfig_fields = untrustedConfig.fields;
      if (untrustedIsObject(untrustedConfig_fields)) {
        const untrustedConfig_fields_object = {};
        const untrustedConfig_fields_keys = Object.keys(untrustedConfig_fields);
        for (let i = 0, arrayLength = untrustedConfig_fields_keys.length; i < arrayLength; i++) {
          const key = untrustedConfig_fields_keys[i];
          const untrustedConfig_fields_prop = untrustedConfig_fields[key];
          if (typeof untrustedConfig_fields_prop === 'string') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (typeof untrustedConfig_fields_prop === 'number') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (untrustedConfig_fields_prop === null) {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (typeof untrustedConfig_fields_prop === 'boolean') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
        }
        if (untrustedConfig_fields_object !== undefined && Object.keys(untrustedConfig_fields_object).length >= 0) {
          config.fields = untrustedConfig_fields_object;
        }
      }
      return config;
    }
    function validateAdapterConfig$a(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, performQuickAction_ConfigPropertyMetadata);
      const config = typeCheckConfig$c(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$a(luvio, config, options) {
      const resourceParams = createResourceParams$9(config);
      const request = createResourceRequest$b(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$2(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$8(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const performQuickActionAdapterFactory = luvio => {
      return function performQuickAction(untrustedConfig) {
        const config = validateAdapterConfig$a(untrustedConfig, performQuickAction_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "performQuickAction"');
        }
        return buildNetworkSnapshot$a(luvio, config);
      };
    };
    const factory$c = performQuickActionAdapterFactory;
    function createResourceRequest$a(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/layout/' + config.urlParams.objectApiName + '/user-state',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function validate$8(obj, path = 'RecordLayoutUserStateInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_sectionUserStates = obj.sectionUserStates;
        const path_sectionUserStates = path + '.sectionUserStates';
        if (typeof obj_sectionUserStates !== 'object' || ArrayIsArray(obj_sectionUserStates) || obj_sectionUserStates === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_sectionUserStates + '" (at "' + path_sectionUserStates + '")');
        }
        const obj_sectionUserStates_keys = ObjectKeys(obj_sectionUserStates);
        for (let i = 0; i < obj_sectionUserStates_keys.length; i++) {
          const key = obj_sectionUserStates_keys[i];
          const obj_sectionUserStates_prop = obj_sectionUserStates[key];
          const path_sectionUserStates_prop = path_sectionUserStates + '["' + key + '"]';
          if (typeof obj_sectionUserStates_prop !== 'object' || ArrayIsArray(obj_sectionUserStates_prop) || obj_sectionUserStates_prop === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_sectionUserStates_prop + '" (at "' + path_sectionUserStates_prop + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }

    // Hack method- this should be removed eventually when layoutUserState raml is fixed.
    function addAdditionalFieldsForNorming(layoutUserState, apiName, recordTypeId, layoutType, mode) {
      // Hack- adding in this params so record-ui will be able to use normed values.
      layoutUserState.apiName = apiName;
      layoutUserState.recordTypeId = recordTypeId;
      layoutUserState.layoutType = layoutType;
      layoutUserState.mode = mode;
    }
    function updateLayoutUserState$1(luvio, config, key, updateRequest) {
      return luvio.dispatchResourceRequest(updateRequest).then(response => {
        const {
          body
        } = response;
        return luvio.handleSuccessResponse(() => ingestAndBroadcast(luvio, key, config, body), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getTypeCacheKeys$M(cache, luvio, body);
          return cache;
        });
      }, err => {
        luvioEngine.deepFreeze(err);
        throw err;
      });
    }
    function ingestAndBroadcast(luvio, key, config, body) {
      addAdditionalFieldsForNorming(body, config.objectApiName, config.recordTypeId, config.layoutType, config.mode);
      luvio.storeIngest(key, ingest$F, body);
      return luvio.storeBroadcast().then(() => {
        return buildCachedSnapshot$5(luvio, config);
      });
    }
    function clone(userLayoutState) {
      return parse(stringify(userLayoutState));
    }
    // Applies optimisticUpdate to layoutUserState
    // If the optimistic update can be applied, returns RecordLayoutUserStateRepresentation
    // If the optimistic update cannot be applied, returns null
    // The optimistic update can be applied only IF the cached layoutUserState has all the sections
    // enumerated on the layout user state input
    function optimisticUpdate(cachedLayoutUserState, layoutUserStateInput) {
      let clonedLayoutUserState;
      let clonedLayoutUserStateSections;
      const {
        sectionUserStates
      } = layoutUserStateInput;
      const {
        sectionUserStates: cachedSectionUserStates
      } = cachedLayoutUserState;
      const sectionUserStateKeys = keys(sectionUserStates);
      for (let i = 0, len = sectionUserStateKeys.length; i < len; i += 1) {
        const sectionId = sectionUserStateKeys[i];
        if (cachedSectionUserStates[sectionId] === undefined) {
          // Cannot update a section that isn't in the cache. Cancel the optimistic update.
          return null;
        }
        if (clonedLayoutUserState === undefined) {
          // We have to clone cachedLayoutUserState because this object is coming from
          // a snapshot, where it is frozen
          clonedLayoutUserState = clone(cachedLayoutUserState);
          // hold onto sectionUserStates from clonedLayoutUserState
          clonedLayoutUserStateSections = clonedLayoutUserState.sectionUserStates;
        }
        // DEV MODE sanity check
        {
          if (clonedLayoutUserStateSections === undefined) {
            throw new Error('clonedLayoutUserStateSections is undefined in updateLayoutUserState optimisticUpdate');
          }
        }
        const userState = sectionUserStates[sectionId];
        clonedLayoutUserStateSections[sectionId].collapsed = userState.collapsed;
      }
      // DEV MODE sanity check
      {
        if (clonedLayoutUserState === undefined) {
          throw new Error('clonedLayoutUserState is undefined in updateLayoutUserState optimisticUpdate');
        }
      }
      return clonedLayoutUserState;
    }
    function coerceConfigWithDefaults$2(untrusted, layoutUserStateInput) {
      const config = validateAdapterConfig$N(untrusted, getLayoutUserState_ConfigPropertyNames);
      if (config === null) {
        // eslint-disable-next-line @salesforce/lds/no-error-in-production
        throw new Error(`@wire(updateLayoutUserState) invalid configuration ${stringify(untrusted)}`);
      }
      // This will throw if layoutUserStateInput is not a valid input
      validate$8(layoutUserStateInput, 'layoutUserStateInput');
      return {
        ...config,
        layoutUserStateInput: layoutUserStateInput
      };
    }
    const factory$b = luvio => {
      return (untrustedObjectApiName, untrustedRecordTypeId, untrustedLayoutType, untrustedMode, untrustedLayoutUserStateInput) => {
        const untrusted = {
          objectApiName: untrustedObjectApiName,
          recordTypeId: untrustedRecordTypeId,
          layoutType: untrustedLayoutType,
          mode: untrustedMode
        };
        const config = coerceConfigWithDefaults$2(untrusted, untrustedLayoutUserStateInput);
        if (config === null) {
          {
            throw new Error(`@wire(updateLayoutUserState) invalid configuration ${stringify(untrusted)}`);
          }
        }
        const {
          objectApiName,
          layoutType,
          mode,
          recordTypeId,
          layoutUserStateInput
        } = config;
        const updateRequest = createResourceRequest$a({
          urlParams: {
            objectApiName
          },
          body: layoutUserStateInput,
          queryParams: {
            layoutType,
            mode,
            recordTypeId
          }
        });
        const key = keyBuilder$1U(luvio, {
          apiName: objectApiName,
          recordTypeId,
          layoutType,
          mode
        });
        const cacheSnapshot = buildCachedSnapshot$5(luvio, config);
        if (isFulfilledSnapshot(cacheSnapshot)) {
          // Create an optimistic update if we can
          const updatedLayoutUserState = optimisticUpdate(cacheSnapshot.data, layoutUserStateInput);
          if (updatedLayoutUserState !== null) {
            // Ingest optimistic update done client side
            ingestAndBroadcast(luvio, key, config, updatedLayoutUserState);
          }
        }
        return updateLayoutUserState$1(luvio, config, key, updateRequest);
      };
    };
    function buildNetworkSnapshot$9(luvio, config, options, cacheSnapshot) {
      const resourceParams = createResourceParams$8(config);
      const request = prepareRequest$1(luvio, config, resourceParams, cacheSnapshot);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        const {
          body
        } = response;
        // Hand-rolling: The server returns sortBy as a comma-delimited String, but LDS expects an array.
        // getListUi does the same in its index.ts.
        const sortBy = body.sortBy;
        if (sortBy && typeof sortBy === 'string') {
          response.body.sortBy = sortBy.split(',');
        }
        // Hand-rolling: The server returns sortBy as null for MRU when we don't pass it as a parameter.
        // Changing server response to avoid key mismatch
        const listViewApiName = body.listReference && body.listReference.listViewApiName ? body.listReference.listViewApiName : null;
        if (listViewApiName === '__Recent' && !sortBy) {
          response.body.sortBy = [];
        }
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$1(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$10(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$1(luvio, config, resourceParams, response));
      });
    }
    const adapterName$6 = 'getListRecordsByName';
    const getListRecordsByName_ConfigPropertyMetadata = [generateParamConfigMetadata('listViewApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('fields', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('optionalFields', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('pageSize', false, 2 /* Body */, 3 /* Integer */), generateParamConfigMetadata('pageToken', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('searchTerm', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('sortBy', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('where', false, 2 /* Body */, 0 /* String */)];
    const getListRecordsByName_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$6, getListRecordsByName_ConfigPropertyMetadata);
    const createResourceParams$8 = /*#__PURE__*/luvioEngine.createResourceParams(getListRecordsByName_ConfigPropertyMetadata);
    function keyBuilder$9(luvio, config) {
      const resourceParams = createResourceParams$8(config);
      return keyBuilder$22(luvio, resourceParams);
    }
    function typeCheckConfig$b(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getListRecordsByName_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$9(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$b(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$1(luvio, config) {
      const resourceParams = createResourceParams$8(config);
      return select$1P(luvio, resourceParams);
    }
    function onFetchResponseSuccess$2(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$R(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$9(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$1(luvio, config, resourceParams, response) {
      const snapshot = ingestError$K(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$9(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function prepareRequest$1(luvio, config, resourceParams, cacheSnapshot) {
      if (cacheSnapshot === undefined) {
        return createResourceRequest$16(resourceParams);
      }
      const [newToken, newPageSize] = minimizePaginationParams(luvio, resourceParams, cacheSnapshot);
      if (newToken === undefined) {
        return createResourceRequest$16(resourceParams);
      }
      return createResourceRequest$16(createResourceParams$8({
        ...config,
        pageSize: newPageSize,
        pageToken: newToken
      }));
    }
    function minimizePaginationParams(luvio, resourceParams, cacheSnapshot) {
      const num = getCachedItemsNumber(cacheSnapshot);
      if (num > 0) {
        const paginationMetadata = getPaginationMetadata(luvio, resourceParams);
        if (paginationMetadata !== undefined) {
          const {
            token: configToken,
            pageSize: configPageSize
          } = createPaginationParams$4(resourceParams);
          const configTokenOffset = offsetFromToken(paginationMetadata, configToken);
          if (configTokenOffset < 0) {
            return [undefined, -1];
          }
          const maxOffset = configTokenOffset + num;
          const [token, offset] = tokenForAtMost(paginationMetadata, maxOffset);
          if (token !== undefined) {
            return [token, configPageSize - (offset - configTokenOffset)];
          }
        }
      }
      return [undefined, -1];
    }
    function getCachedItemsNumber(cacheSnapshot) {
      const {
        data
      } = cacheSnapshot;
      if (data === undefined || !data.records) {
        return 0;
      }
      const items = data.records;
      for (let i = 0; i < items.length; i++) {
        if (items[i] === undefined) {
          return i;
        }
      }
      return items.length;
    }
    function getPaginationMetadata(luvio, resourceParams) {
      const key = keyBuilder$22(luvio, resourceParams);
      const selector = {
        recordId: key,
        node: {
          kind: 'Fragment',
          version: VERSION$1c,
          private: [],
          selections: [{
            kind: 'Link',
            name: '__metadata',
            fragment: {
              kind: 'Fragment',
              version: PAGINATION_VERSION$1,
              opaque: true,
              private: []
            }
          }]
        },
        variables: {}
      };
      const node = luvio.storeLookup(selector);
      if (node.state !== 'Fulfilled') {
        return;
      }
      return node.data.__metadata;
    }
    function buildNetworkSnapshotCachePolicy$4(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$9, 'get', true);
    }
    function buildCachedSnapshotCachePolicy$3(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$9(luvio, config),
        node: adapterFragment$1(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$9(luvio, config, snapshotRefreshOptions)
      });
      if (isUnfulfilledSnapshot$1(cacheSnapshot) && cacheSnapshot.data !== undefined) {
        context.cacheSnapshot = cacheSnapshot;
      }
      return cacheSnapshot;
    }
    let context;
    function setContext(adapterContext) {
      context = adapterContext;
    }
    function onFetchResponseSuccess$1(luvio, config, resourceParams, response) {
      const {
          body
        } = response,
        originalListRef = body.listReference;
      // If the response contains a listReference, then we need to add it/update it in the internal store
      if (originalListRef !== undefined) {
        const mutatedListRef = {
          ...originalListRef
        };
        // Setting the id to the eTag in the stored AdapterContext entry only, because
        // keyBuilder needs the eTag to generate the correct key for a cache hit.
        // Ideally, this can be removed once we deprecate getListUi and remove the hardcoded eTag reference in ListRecordCollectionRepresentation
        // Note: The original listReference will remain unchanged in the response.
        mutatedListRef.id = body.listInfoETag;
        addListReferenceWithId(mutatedListRef, context, body.listReference.id);
        // storing sortBy ensuring a cache hit when requesting records with no sortBy provided
        addServerDefaults(config, body, originalListRef, context);
      }
      return onFetchResponseSuccess$2(luvio, config, resourceParams, response);
    }
    const contextId$3 = `${keyPrefix}__${adapterName$6}`;
    const factory$a = luvio => {
      return luvio.withContext(function UiApi__getListRecordsByName(untrustedConfig, adapterContext, requestContext) {
        const config = validateAdapterConfig$9(untrustedConfig, getListRecordsByName_ConfigPropertyNames);
        if (config === null) {
          return null;
        }
        setContext$1(adapterContext);
        setContext(adapterContext);
        return luvio.applyCachePolicy(requestContext || {}, {
          adapterContext,
          config,
          luvio
        }, buildCachedSnapshotCachePolicy$3, buildNetworkSnapshotCachePolicy$4);
      }, {
        contextId: contextId$3
      });
    };
    function validate$7(obj, path = 'RecordInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.allowSaveOnDuplicate !== undefined) {
          const obj_allowSaveOnDuplicate = obj.allowSaveOnDuplicate;
          const path_allowSaveOnDuplicate = path + '.allowSaveOnDuplicate';
          if (typeof obj_allowSaveOnDuplicate !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_allowSaveOnDuplicate + '" (at "' + path_allowSaveOnDuplicate + '")');
          }
        }
        if (obj.apiName !== undefined) {
          const obj_apiName = obj.apiName;
          const path_apiName = path + '.apiName';
          if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
          }
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray(obj_fields) || obj_fields === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
          const key = obj_fields_keys[i];
          const obj_fields_prop = obj_fields[key];
          const path_fields_prop = path_fields + '["' + key + '"]';
          let obj_fields_prop_union0 = null;
          const obj_fields_prop_union0_error = (() => {
            if (typeof obj_fields_prop !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
          })();
          if (obj_fields_prop_union0_error != null) {
            obj_fields_prop_union0 = obj_fields_prop_union0_error.message;
          }
          let obj_fields_prop_union1 = null;
          const obj_fields_prop_union1_error = (() => {
            if (typeof obj_fields_prop !== 'number') {
              return new TypeError('Expected "number" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
          })();
          if (obj_fields_prop_union1_error != null) {
            obj_fields_prop_union1 = obj_fields_prop_union1_error.message;
          }
          let obj_fields_prop_union2 = null;
          const obj_fields_prop_union2_error = (() => {
            if (obj_fields_prop !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
          })();
          if (obj_fields_prop_union2_error != null) {
            obj_fields_prop_union2 = obj_fields_prop_union2_error.message;
          }
          let obj_fields_prop_union3 = null;
          const obj_fields_prop_union3_error = (() => {
            if (typeof obj_fields_prop !== 'boolean') {
              return new TypeError('Expected "boolean" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
          })();
          if (obj_fields_prop_union3_error != null) {
            obj_fields_prop_union3 = obj_fields_prop_union3_error.message;
          }
          if (obj_fields_prop_union0 && obj_fields_prop_union1 && obj_fields_prop_union2 && obj_fields_prop_union3) {
            let message = 'Object doesn\'t match union (at "' + path_fields_prop + '")';
            message += '\n' + obj_fields_prop_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_fields_prop_union1.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_fields_prop_union2.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_fields_prop_union3.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$7 = 'LookupValuesRepresentation';
    function getTypeCacheKeys$7(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$7,
        mergeable: false
      });
      const input_lookupResults = input.lookupResults;
      const input_lookupResults_keys = ObjectKeys(input_lookupResults);
      const input_lookupResults_length = input_lookupResults_keys.length;
      for (let i = 0; i < input_lookupResults_length; i++) {
        const key = input_lookupResults_keys[i];
        getTypeCacheKeys$W(rootKeySet, luvio, input_lookupResults[key], () => rootKey + "__lookupResults" + "__" + key);
      }
    }
    function keyBuilder$8(luvio, params) {
      return keyPrefix + '::LookupValuesRepresentation:(' + 'dependentFieldBindings:' + params.queryParams.dependentFieldBindings + ',' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'q:' + params.queryParams.q + ',' + 'searchType:' + params.queryParams.searchType + ',' + 'sourceRecordId:' + params.queryParams.sourceRecordId + ',' + 'targetApiName:' + params.queryParams.targetApiName + ',' + 'fieldApiName:' + params.urlParams.fieldApiName + ',' + 'objectApiName:' + params.urlParams.objectApiName + ',' + (params.body.sourceRecord === undefined ? 'sourceRecord' : 'sourceRecord:' + params.body.sourceRecord) + ')';
    }
    function getResponseCacheKeys$7(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$7(storeKeyMap, luvio, response, () => keyBuilder$8(luvio, resourceParams));
    }
    function createResourceRequest$9(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/lookups/' + config.urlParams.objectApiName + '/' + config.urlParams.fieldApiName + '',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const getLookupRecords_ConfigPropertyMetadata = [generateParamConfigMetadata('fieldApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getFieldApiName), generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('dependentFieldBindings', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('page', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('q', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('searchType', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('sourceRecordId', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('targetApiName', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('sourceRecord', false, 2 /* Body */, 4 /* Unsupported */)];
    function typeCheckConfig$a(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getLookupRecords_ConfigPropertyMetadata);
      const untrustedConfig_sourceRecord = untrustedConfig.sourceRecord;
      const referenceRecordInputRepresentationValidationError = validate$7(untrustedConfig_sourceRecord);
      if (referenceRecordInputRepresentationValidationError === null) {
        config.sourceRecord = untrustedConfig_sourceRecord;
      }
      if (untrustedConfig_sourceRecord === null) {
        config.sourceRecord = untrustedConfig_sourceRecord;
      }
      return config;
    }
    function validateAdapterConfig$8(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getLookupRecords_ConfigPropertyMetadata);
      const config = typeCheckConfig$a(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    const paramNames = {
      displayName: 'getLookupRecords',
      parameters: {
        required: ['fieldApiName'],
        optional: ['requestParams']
      }
    };
    function coerceRequestParams(untrusted) {
      if (!untrustedIsObject(untrusted)) {
        return {};
      }
      const coercedConfig = {};
      const requestParams = untrusted.requestParams || {};
      const dependentFieldBindings = requestParams.dependentFieldBindings;
      if (dependentFieldBindings !== undefined) {
        coercedConfig.dependentFieldBindings = dependentFieldBindings;
      }
      const page = requestParams.page;
      if (page !== undefined) {
        coercedConfig.page = page;
      }
      const pageSize = requestParams.pageSize;
      if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
      }
      const q = requestParams.q;
      if (q !== undefined) {
        coercedConfig.q = q;
      }
      const searchType = requestParams.searchType;
      if (searchType !== undefined) {
        coercedConfig.searchType = searchType;
      }
      const sourceRecordId = requestParams.sourceRecordId;
      if (sourceRecordId !== undefined) {
        coercedConfig.sourceRecordId = sourceRecordId;
      }
      const targetApiName = requestParams.targetApiName;
      if (targetApiName !== undefined) {
        coercedConfig.targetApiName = targetApiName;
      }
      const sourceRecord = requestParams.sourceRecord;
      if (sourceRecord !== undefined) {
        coercedConfig.sourceRecord = sourceRecord;
      }
      return coercedConfig;
    }
    function coerceConfigWithDefaults$1(untrusted) {
      const config = validateAdapterConfig$8(untrusted, paramNames);
      if (config === null) {
        return config;
      }
      const coercedRequestParams = coerceRequestParams(untrusted);
      const {
        objectApiName,
        fieldApiName
      } = getFieldId(config.fieldApiName);
      return {
        ...config,
        objectApiName,
        fieldApiName,
        ...coercedRequestParams
      };
    }
    function removeEtags(recordRep) {
      const {
        fields
      } = recordRep;
      delete recordRep.eTag;
      delete recordRep.weakEtag;
      Object.keys(fields).forEach(fieldName => {
        const {
          value: nestedValue
        } = fields[fieldName];
        if (isSpanningRecord(nestedValue)) {
          removeEtags(nestedValue);
        }
      });
    }
    function buildNetworkSnapshot$8(luvio, config, options) {
      const {
        objectApiName,
        fieldApiName
      } = config;
      const resourceParams = {
        /*
            targetApiName is not set in the config in order to call /lookups/{objectApiName}/{fieldApiName} resource only.
            This is a temporary measure while aligning the representation of lookup resources (W-10320080)
        */
        urlParams: {
          objectApiName,
          fieldApiName
        },
        queryParams: {
          page: config.page,
          pageSize: config.pageSize,
          q: config.q,
          searchType: config.searchType,
          dependentFieldBindings: config.dependentFieldBindings,
          sourceRecordId: config.sourceRecordId,
          targetApiName: config.targetApiName
        },
        body: {
          sourceRecord: config.sourceRecord
        }
      };
      const request = createResourceRequest$9(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          // TODO [W-7235112]: remove this hack to never ingest lookup responses that
          // avoids issues caused by them not being real RecordRepresentations
          const key = keyBuilder$8(luvio, resourceParams);
          const {
            body
          } = response;
          Object.keys(body.lookupResults).map(targetApiName => body.lookupResults[targetApiName].records).reduce((allRecords, records) => allRecords.concat(records), []).forEach(record => removeEtags(record));
          luvioEngine.deepFreeze(body);
          return Promise.resolve({
            state: 'Fulfilled',
            recordId: key,
            variables: {},
            seenRecords: new luvioEngine.StoreKeySet(),
            select: {
              recordId: key,
              node: {
                kind: 'Fragment'
              },
              variables: {}
            },
            data: body
          });
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$7(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, err => {
        return luvio.handleErrorResponse(() => {
          return Promise.resolve(luvio.errorSnapshot(err));
        });
      });
    }
    function buildCachedSnapshot$2(_context, _storeLookup) {
      return;
    }
    function buildNetworkSnapshotCachePolicy$3(context, coercedAdapterRequestContext) {
      const {
        networkPriority,
        requestCorrelator,
        eventObservers
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return buildNetworkSnapshot$8(context.luvio, context.config, dispatchOptions);
    }
    const factory$9 = luvio => {
      return (untrustedConfig, requestContext) => {
        const config = coerceConfigWithDefaults$1(untrustedConfig);
        if (config === null) {
          return null;
        }
        const refresh = {
          config,
          resolve: () => buildNetworkSnapshot$8(luvio, config)
        };
        const promiseOrSnapshot = luvio.applyCachePolicy(requestContext || {}, {
          config,
          luvio
        }, buildCachedSnapshot$2, buildNetworkSnapshotCachePolicy$3);
        if (isPromise(promiseOrSnapshot)) {
          return promiseOrSnapshot.then(snapshot => {
            snapshot.refresh = refresh;
            return snapshot;
          });
        }
        promiseOrSnapshot.refresh = refresh;
        return promiseOrSnapshot;
      };
    };
    function createResourceRequest$8(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/record-avatars/' + config.urlParams.recordId + '/association',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$5 = 'updateRecordAvatar';
    const updateRecordAvatar_ConfigPropertyMetadata = [generateParamConfigMetadata('recordId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('actionType', true, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('blueMasterId', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('externalId', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('photoUrl', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('profileName', false, 2 /* Body */, 0 /* String */)];
    const updateRecordAvatar_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$5, updateRecordAvatar_ConfigPropertyMetadata);
    function typeCheckConfig$9(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, updateRecordAvatar_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$7(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$9(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    const factory$8 = luvio => {
      return untrustedConfig => {
        const config = validateAdapterConfig$7(untrustedConfig, updateRecordAvatar_ConfigPropertyNames);
        if (config === null) {
          // eslint-disable-next-line @salesforce/lds/no-error-in-production
          throw new Error('updateRecordAvatar invalid configuration');
        }
        const resourceParams = {
          urlParams: {
            recordId: config.recordId
          },
          body: {
            externalId: config.externalId,
            blueMasterId: config.blueMasterId,
            profileName: config.profileName,
            photoUrl: config.photoUrl,
            actionType: config.actionType
          }
        };
        const request = createResourceRequest$8(resourceParams);
        return luvio.dispatchResourceRequest(request).then(response => {
          const {
            body
          } = response;
          const key = keyBuilderFromType$f(luvio, body);
          return luvio.handleSuccessResponse(() => {
            let selectors;
            if (body.type === 'Theme') {
              selectors = select$C;
              luvio.storeIngest(key, ingest$h, body);
            } else if (body.type === 'Photo') {
              selectors = select$D;
              luvio.storeIngest(key, ingest$i, body);
            } else {
              // eslint-disable-next-line @salesforce/lds/no-error-in-production
              throw new Error('Unsupported avatar type');
            }
            // TODO [W-6804405]: support unions on fragments (only supported on links today)
            const snapshot = luvio.storeLookup({
              recordId: key,
              node: selectors(),
              variables: {}
            });
            return luvio.storeBroadcast().then(() => snapshot);
          }, () => {
            const cache = new luvioEngine.StoreKeyMap();
            getTypeCacheKeys$n(cache, luvio, body);
            return cache;
          });
        }, err => {
          luvioEngine.deepFreeze(err);
          throw err;
        });
      };
    };
    const VERSION$6 = "809ada3563b00c364360826037620d7e";
    function validate$6(obj, path = 'RecordCreateDefaultRecordRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_childRelationships = obj.childRelationships;
        const path_childRelationships = path + '.childRelationships';
        if (typeof obj_childRelationships !== 'object' || ArrayIsArray(obj_childRelationships) || obj_childRelationships === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_childRelationships + '" (at "' + path_childRelationships + '")');
        }
        const obj_childRelationships_keys = ObjectKeys(obj_childRelationships);
        for (let i = 0; i < obj_childRelationships_keys.length; i++) {
          const key = obj_childRelationships_keys[i];
          const obj_childRelationships_prop = obj_childRelationships[key];
          const path_childRelationships_prop = path_childRelationships + '["' + key + '"]';
          if (typeof obj_childRelationships_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_childRelationships_prop + '" (at "' + path_childRelationships_prop + '")');
          }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray(obj_fields) || obj_fields === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
          const key = obj_fields_keys[i];
          const obj_fields_prop = obj_fields[key];
          const path_fields_prop = path_fields + '["' + key + '"]';
          if (typeof obj_fields_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
          }
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (obj_id !== null) {
          return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_lastModifiedById = obj.lastModifiedById;
        const path_lastModifiedById = path + '.lastModifiedById';
        let obj_lastModifiedById_union0 = null;
        const obj_lastModifiedById_union0_error = (() => {
          if (typeof obj_lastModifiedById !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
          }
        })();
        if (obj_lastModifiedById_union0_error != null) {
          obj_lastModifiedById_union0 = obj_lastModifiedById_union0_error.message;
        }
        let obj_lastModifiedById_union1 = null;
        const obj_lastModifiedById_union1_error = (() => {
          if (obj_lastModifiedById !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
          }
        })();
        if (obj_lastModifiedById_union1_error != null) {
          obj_lastModifiedById_union1 = obj_lastModifiedById_union1_error.message;
        }
        if (obj_lastModifiedById_union0 && obj_lastModifiedById_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lastModifiedById + '")';
          message += '\n' + obj_lastModifiedById_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lastModifiedById_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        let obj_lastModifiedDate_union0 = null;
        const obj_lastModifiedDate_union0_error = (() => {
          if (typeof obj_lastModifiedDate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
          }
        })();
        if (obj_lastModifiedDate_union0_error != null) {
          obj_lastModifiedDate_union0 = obj_lastModifiedDate_union0_error.message;
        }
        let obj_lastModifiedDate_union1 = null;
        const obj_lastModifiedDate_union1_error = (() => {
          if (obj_lastModifiedDate !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
          }
        })();
        if (obj_lastModifiedDate_union1_error != null) {
          obj_lastModifiedDate_union1 = obj_lastModifiedDate_union1_error.message;
        }
        if (obj_lastModifiedDate_union0 && obj_lastModifiedDate_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lastModifiedDate + '")';
          message += '\n' + obj_lastModifiedDate_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lastModifiedDate_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
          if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union0_error != null) {
          obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
          if (obj_recordTypeId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union1_error != null) {
          obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
          message += '\n' + obj_recordTypeId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_recordTypeId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_recordTypeInfo = obj.recordTypeInfo;
        const path_recordTypeInfo = path + '.recordTypeInfo';
        let obj_recordTypeInfo_union0 = null;
        const obj_recordTypeInfo_union0_error = (() => {
          const referencepath_recordTypeInfoValidationError = validate$1Y(obj_recordTypeInfo, path_recordTypeInfo);
          if (referencepath_recordTypeInfoValidationError !== null) {
            let message = 'Object doesn\'t match RecordTypeInfoRepresentation (at "' + path_recordTypeInfo + '")\n';
            message += referencepath_recordTypeInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_recordTypeInfo_union0_error != null) {
          obj_recordTypeInfo_union0 = obj_recordTypeInfo_union0_error.message;
        }
        let obj_recordTypeInfo_union1 = null;
        const obj_recordTypeInfo_union1_error = (() => {
          if (obj_recordTypeInfo !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_recordTypeInfo + '" (at "' + path_recordTypeInfo + '")');
          }
        })();
        if (obj_recordTypeInfo_union1_error != null) {
          obj_recordTypeInfo_union1 = obj_recordTypeInfo_union1_error.message;
        }
        if (obj_recordTypeInfo_union0 && obj_recordTypeInfo_union1) {
          let message = 'Object doesn\'t match union (at "' + path_recordTypeInfo + '")';
          message += '\n' + obj_recordTypeInfo_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_recordTypeInfo_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_systemModstamp = obj.systemModstamp;
        const path_systemModstamp = path + '.systemModstamp';
        let obj_systemModstamp_union0 = null;
        const obj_systemModstamp_union0_error = (() => {
          if (typeof obj_systemModstamp !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
          }
        })();
        if (obj_systemModstamp_union0_error != null) {
          obj_systemModstamp_union0 = obj_systemModstamp_union0_error.message;
        }
        let obj_systemModstamp_union1 = null;
        const obj_systemModstamp_union1_error = (() => {
          if (obj_systemModstamp !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
          }
        })();
        if (obj_systemModstamp_union1_error != null) {
          obj_systemModstamp_union1 = obj_systemModstamp_union1_error.message;
        }
        if (obj_systemModstamp_union0 && obj_systemModstamp_union1) {
          let message = 'Object doesn\'t match union (at "' + path_systemModstamp + '")';
          message += '\n' + obj_systemModstamp_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_systemModstamp_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_weakEtag = obj.weakEtag;
        const path_weakEtag = path + '.weakEtag';
        if (typeof obj_weakEtag !== 'number' || typeof obj_weakEtag === 'number' && Math.floor(obj_weakEtag) !== obj_weakEtag) {
          return new TypeError('Expected "integer" but received "' + typeof obj_weakEtag + '" (at "' + path_weakEtag + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$6 = 'RecordCreateDefaultRecordRepresentation';
    function normalize$2(input, existing, path, luvio, store, timestamp) {
      const input_childRelationships = input.childRelationships;
      const input_childRelationships_id = path.fullPath + '__childRelationships';
      const input_childRelationships_keys = Object.keys(input_childRelationships);
      const input_childRelationships_length = input_childRelationships_keys.length;
      for (let i = 0; i < input_childRelationships_length; i++) {
        const key = input_childRelationships_keys[i];
        const input_childRelationships_prop = input_childRelationships[key];
        const input_childRelationships_prop_id = input_childRelationships_id + '__' + key;
        input_childRelationships[key] = ingest$P(input_childRelationships_prop, {
          fullPath: input_childRelationships_prop_id,
          propertyName: key,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      const input_fields = input.fields;
      const input_fields_id = path.fullPath + '__fields';
      const input_fields_keys = Object.keys(input_fields);
      const input_fields_length = input_fields_keys.length;
      for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        const input_fields_prop = input_fields[key];
        const input_fields_prop_id = input_fields_id + '__' + key;
        input_fields[key] = ingest$Q(input_fields_prop, {
          fullPath: input_fields_prop_id,
          propertyName: key,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    function equals$6(existing, incoming) {
      const existing_weakEtag = existing.weakEtag;
      const incoming_weakEtag = incoming.weakEtag;
      if (!(existing_weakEtag === incoming_weakEtag)) {
        return false;
      }
      const existing_apiName = existing.apiName;
      const incoming_apiName = incoming.apiName;
      if (!(existing_apiName === incoming_apiName)) {
        return false;
      }
      const existing_eTag = existing.eTag;
      const incoming_eTag = incoming.eTag;
      if (!(existing_eTag === incoming_eTag)) {
        return false;
      }
      const existing_childRelationships = existing.childRelationships;
      const incoming_childRelationships = incoming.childRelationships;
      const equals_childRelationships_props = equalsObject(existing_childRelationships, incoming_childRelationships, (existing_childRelationships_prop, incoming_childRelationships_prop) => {
        if (!(existing_childRelationships_prop.__ref === incoming_childRelationships_prop.__ref)) {
          return false;
        }
      });
      if (equals_childRelationships_props === false) {
        return false;
      }
      const existing_fields = existing.fields;
      const incoming_fields = incoming.fields;
      const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
          return false;
        }
      });
      if (equals_fields_props === false) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_lastModifiedById = existing.lastModifiedById;
      const incoming_lastModifiedById = incoming.lastModifiedById;
      if (!(existing_lastModifiedById === incoming_lastModifiedById)) {
        return false;
      }
      const existing_lastModifiedDate = existing.lastModifiedDate;
      const incoming_lastModifiedDate = incoming.lastModifiedDate;
      if (!(existing_lastModifiedDate === incoming_lastModifiedDate)) {
        return false;
      }
      const existing_recordTypeId = existing.recordTypeId;
      const incoming_recordTypeId = incoming.recordTypeId;
      if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
      }
      const existing_recordTypeInfo = existing.recordTypeInfo;
      const incoming_recordTypeInfo = incoming.recordTypeInfo;
      if (!(existing_recordTypeInfo === incoming_recordTypeInfo || existing_recordTypeInfo != null && incoming_recordTypeInfo != null && equals$16(existing_recordTypeInfo, incoming_recordTypeInfo))) {
        return false;
      }
      const existing_systemModstamp = existing.systemModstamp;
      const incoming_systemModstamp = incoming.systemModstamp;
      if (!(existing_systemModstamp === incoming_systemModstamp)) {
        return false;
      }
      return true;
    }
    const ingest$2 = function RecordCreateDefaultRecordRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$6(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$2, "UiApi", VERSION$6, RepresentationType$6, equals$6);
      return createLink(key);
    };
    function getTypeCacheKeys$6(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$6,
        mergeable: false
      });
      const input_childRelationships = input.childRelationships;
      const input_childRelationships_keys = ObjectKeys(input_childRelationships);
      const input_childRelationships_length = input_childRelationships_keys.length;
      for (let i = 0; i < input_childRelationships_length; i++) {
        const key = input_childRelationships_keys[i];
        getTypeCacheKeys$W(rootKeySet, luvio, input_childRelationships[key], () => rootKey + "__childRelationships" + "__" + key);
      }
      const input_fields = input.fields;
      const input_fields_keys = ObjectKeys(input_fields);
      const input_fields_length = input_fields_keys.length;
      for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        getTypeCacheKeys$Y(rootKeySet, luvio, input_fields[key], () => rootKey + "__fields" + "__" + key);
      }
    }
    const TTL$4 = 900000;
    const VERSION$5 = "894a62b8f5de5535f2483fb2c3abca8e";
    function validate$5(obj, path = 'RecordDefaultsRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_layout = obj.layout;
        const path_layout = path + '.layout';
        let obj_layout_union0 = null;
        const obj_layout_union0_error = (() => {
          if (typeof obj_layout !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_layout + '" (at "' + path_layout + '")');
          }
        })();
        if (obj_layout_union0_error != null) {
          obj_layout_union0 = obj_layout_union0_error.message;
        }
        let obj_layout_union1 = null;
        const obj_layout_union1_error = (() => {
          if (obj_layout !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_layout + '" (at "' + path_layout + '")');
          }
        })();
        if (obj_layout_union1_error != null) {
          obj_layout_union1 = obj_layout_union1_error.message;
        }
        if (obj_layout_union0 && obj_layout_union1) {
          let message = 'Object doesn\'t match union (at "' + path_layout + '")';
          message += '\n' + obj_layout_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_layout_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray(obj_objectInfos) || obj_objectInfos === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
          const key = obj_objectInfos_keys[i];
          const obj_objectInfos_prop = obj_objectInfos[key];
          const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
          if (typeof obj_objectInfos_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
          }
        }
        const obj_record = obj.record;
        const path_record = path + '.record';
        if (typeof obj_record !== 'object') {
          return new TypeError('Expected "object" but received "' + typeof obj_record + '" (at "' + path_record + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$5 = 'RecordDefaultsRepresentation';
    function normalize$1(input, existing, path, luvio, store, timestamp) {
      const input_layout = input.layout;
      const input_layout_id = path.fullPath + '__layout';
      if (input_layout !== null && typeof input_layout === 'object') {
        input.layout = ingest$G(input_layout, {
          fullPath: input_layout_id,
          propertyName: 'layout',
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      const input_objectInfos = input.objectInfos;
      const input_objectInfos_id = path.fullPath + '__objectInfos';
      const input_objectInfos_keys = Object.keys(input_objectInfos);
      const input_objectInfos_length = input_objectInfos_keys.length;
      for (let i = 0; i < input_objectInfos_length; i++) {
        const key = input_objectInfos_keys[i];
        const input_objectInfos_prop = input_objectInfos[key];
        const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
        input_objectInfos[key] = ingest$H(input_objectInfos_prop, {
          fullPath: input_objectInfos_prop_id,
          propertyName: key,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      const input_record = input.record;
      const input_record_id = path.fullPath + '__record';
      input.record = ingest$2(input_record, {
        fullPath: input_record_id,
        propertyName: 'record',
        parent: {
          data: input,
          key: path.fullPath,
          existing: existing
        },
        ttl: path.ttl
      }, luvio, store, timestamp);
      return input;
    }
    function equals$5(existing, incoming) {
      const existing_layout = existing.layout;
      const incoming_layout = incoming.layout;
      if (!(existing_layout === incoming_layout || existing_layout != null && incoming_layout != null && existing_layout.__ref != null && incoming_layout.__ref != null && existing_layout.__ref === incoming_layout.__ref)) {
        return false;
      }
      const existing_objectInfos = existing.objectInfos;
      const incoming_objectInfos = incoming.objectInfos;
      const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
          return false;
        }
      });
      if (equals_objectInfos_props === false) {
        return false;
      }
      const existing_record = existing.record;
      const incoming_record = incoming.record;
      if (!(existing_record.__ref === incoming_record.__ref)) {
        return false;
      }
      return true;
    }
    const ingest$1 = function RecordDefaultsRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$5(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$4;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$1, "UiApi", VERSION$5, RepresentationType$5, equals$5);
      return createLink(key);
    };
    function getTypeCacheKeys$5(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$5,
        mergeable: false
      });
      if (input.layout !== null && typeof input.layout === 'object') {
        getTypeCacheKeys$N(rootKeySet, luvio, input.layout);
      }
      const input_objectInfos = input.objectInfos;
      const input_objectInfos_keys = ObjectKeys(input_objectInfos);
      const input_objectInfos_length = input_objectInfos_keys.length;
      for (let i = 0; i < input_objectInfos_length; i++) {
        const key = input_objectInfos_keys[i];
        getTypeCacheKeys$O(rootKeySet, luvio, input_objectInfos[key]);
      }
      getTypeCacheKeys$6(rootKeySet, luvio, input.record, () => rootKey + "__" + "record");
    }
    function keyBuilder$7(luvio, params) {
      return keyPrefix + '::RecordDefaultsRepresentation:(' + 'formFactor:' + params.queryParams.formFactor + ',' + 'optionalFields:' + params.queryParams.optionalFields + ',' + 'recordTypeId:' + params.queryParams.recordTypeId + ',' + 'objectApiName:' + params.urlParams.objectApiName + ')';
    }
    function getResponseCacheKeys$6(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$5(storeKeyMap, luvio, response, () => keyBuilder$7(luvio, resourceParams));
    }
    function createResourceRequest$7(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/record-defaults/create/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$4 = 'getRecordCreateDefaults';
    const getRecordCreateDefaults_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('formFactor', false, 1 /* QueryParameter */, 0 /* String */, false, coerceFormFactor), generateParamConfigMetadata('optionalFields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */, false, getRecordId18)];
    const getRecordCreateDefaults_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$4, getRecordCreateDefaults_ConfigPropertyMetadata);
    const createResourceParams$7 = /*#__PURE__*/luvioEngine.createResourceParams(getRecordCreateDefaults_ConfigPropertyMetadata);
    function typeCheckConfig$8(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRecordCreateDefaults_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$6(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRecordCreateDefaults_ConfigPropertyMetadata);
      const config = typeCheckConfig$8(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    const contextId$2 = `${keyPrefix}__${adapterName$4}`;
    const layoutSelections = select$1J();
    const objectInfoSelections = select$1L();
    function buildSelector(resp) {
      const recordSelections = buildSelectionFromRecord(resp.record);
      return [{
        kind: 'Link',
        name: 'layout',
        nullable: true,
        fragment: layoutSelections
      }, {
        kind: 'Link',
        name: 'objectInfos',
        map: true,
        fragment: objectInfoSelections
      }, {
        kind: 'Link',
        name: 'record',
        fragment: {
          kind: 'Fragment',
          private: [],
          selections: recordSelections,
          version: VERSION$6
        }
      }];
    }
    function buildSnapshotRefresh$1(luvio, context, config) {
      return {
        config,
        resolve: () => buildNetworkSnapshot$7(luvio, context, config)
      };
    }
    function buildNetworkSnapshot$7(luvio, context, config, options) {
      const params = createResourceParams$7(config);
      const request = createResourceRequest$7(params);
      const key = keyBuilder$7(luvio, params);
      const selectorKey = buildSelectorKey(luvio, config);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const {
            body
          } = response;
          const cacheSelector = {
            recordId: key,
            node: {
              kind: 'Fragment',
              private: [],
              version: VERSION$5,
              selections: buildSelector(body)
            },
            variables: {}
          };
          context.set(selectorKey, cacheSelector);
          luvio.storeIngest(key, ingest$1, body);
          const snapshot = luvio.storeLookup(cacheSelector, buildSnapshotRefresh$1(luvio, context, config));
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$6(cache, luvio, params, response.body);
          return cache;
        });
      }, err => {
        return luvio.handleErrorResponse(() => {
          const errorSnapshot = luvio.errorSnapshot(err, buildSnapshotRefresh$1(luvio, context, config));
          luvio.storeIngestError(key, errorSnapshot);
          return luvio.storeBroadcast().then(() => errorSnapshot);
        });
      });
    }
    function coerceConfigWithDefaults(untrusted) {
      const config = validateAdapterConfig$6(untrusted, getRecordCreateDefaults_ConfigPropertyNames);
      if (config === null) {
        return null;
      }
      let formFactor = config.formFactor;
      if (formFactor === undefined) {
        if (untrusted.formFactor === undefined) {
          formFactor = FormFactor.Large;
        } else {
          return null;
        }
      }
      const recordTypeId = config.recordTypeId === undefined ? MAIN_RECORD_TYPE_ID : config.recordTypeId;
      const optionalFields = config.optionalFields === undefined ? [] : config.optionalFields;
      return {
        ...config,
        formFactor,
        recordTypeId,
        optionalFields
      };
    }
    function buildSelectorKey(luvio, config) {
      const params = createResourceParams$7(config);
      const key = keyBuilder$7(luvio, params);
      return `${key}__selector`;
    }
    function buildCachedSnapshotCachePolicy$2(context, storeLookup) {
      const {
        luvio,
        config,
        cachedSelector,
        adapterContext
      } = context;
      return cachedSelector === undefined ? undefined : storeLookup(cachedSelector, buildSnapshotRefresh$1(luvio, adapterContext, config));
    }
    function buildNetworkSnapshotCachePolicy$2(context, coercedAdapterRequestContext) {
      const {
        config,
        adapterContext,
        luvio
      } = context;
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return buildNetworkSnapshot$7(luvio, adapterContext, config, dispatchOptions);
    }
    const factory$7 = luvio => {
      return luvio.withContext(function UiApi__getRecordCreateDefaults(untrusted, adapterContext, requestContext) {
        const config = coerceConfigWithDefaults(untrusted);
        if (config === null) {
          return null;
        }
        const selectorKey = buildSelectorKey(luvio, config);
        /**
         * getRecordCreateDefaults returns a value that includes a map of ObjectInfos,
         * a layout and a record. The returned record includes fields that are not
         * known to the client. Because we don't know what the return shape will be,
         * we have to store a selector from a previous response and see if we can
         * extract those values back out.
         *
         * store cached selector in the adapter context and if it does not exist
         * we need to fetch it from the network and set it.
         */
        const cachedSelector = adapterContext.get(selectorKey);
        return luvio.applyCachePolicy(requestContext || {}, {
          luvio,
          config,
          adapterContext,
          cachedSelector
        }, buildCachedSnapshotCachePolicy$2, buildNetworkSnapshotCachePolicy$2);
      }, {
        contextId: contextId$2
      });
    };
    const TTL$3 = 1000;
    const VERSION$4 = "6a63c9ca6dda2e125d94e004f83240d8";
    function validate$4(obj, path = 'RecordTemplateCloneRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_cloneSourceId = obj.cloneSourceId;
        const path_cloneSourceId = path + '.cloneSourceId';
        if (typeof obj_cloneSourceId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_cloneSourceId + '" (at "' + path_cloneSourceId + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray(obj_fields) || obj_fields === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
          const key = obj_fields_keys[i];
          const obj_fields_prop = obj_fields[key];
          const path_fields_prop = path_fields + '["' + key + '"]';
          if (typeof obj_fields_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
          }
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
          if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union0_error != null) {
          obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
          if (obj_recordTypeId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union1_error != null) {
          obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
          message += '\n' + obj_recordTypeId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_recordTypeId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$4 = 'RecordTemplateCloneRepresentation';
    function keyBuilder$6(luvio, config) {
      return keyPrefix + '::' + RepresentationType$4 + ':' + config.cloneSourceId + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
    }
    function keyBuilderFromType$4(luvio, object) {
      const keyParams = {
        cloneSourceId: object.cloneSourceId,
        recordTypeId: object.recordTypeId
      };
      return keyBuilder$6(luvio, keyParams);
    }
    function dynamicNormalize$3(ingestParams) {
      return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_fields = input.fields;
        const input_fields_id = path.fullPath + '__fields';
        const input_fields_keys = Object.keys(input_fields);
        const input_fields_length = input_fields_keys.length;
        for (let i = 0; i < input_fields_length; i++) {
          const key = input_fields_keys[i];
          const input_fields_prop = input_fields[key];
          const input_fields_prop_id = input_fields_id + '__' + key;
          input_fields[key] = ingestParams.fields(input_fields_prop, {
            fullPath: input_fields_prop_id,
            propertyName: key,
            parent: {
              data: input,
              key: path.fullPath,
              existing: existing
            },
            ttl: path.ttl
          }, luvio, store, timestamp);
        }
        return input;
      };
    }
    const select$3 = function RecordTemplateCloneRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$4,
        private: [],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'cloneSourceId',
          kind: 'Scalar'
        }, {
          name: 'fields',
          kind: 'Link',
          map: true,
          fragment: select$1V()
        }, {
          name: 'recordTypeId',
          kind: 'Scalar'
        }]
      };
    };
    const dynamicSelect$3 = function dynamicRecordTemplateCloneRepresentationSelect(params) {
      const fieldsPathSelection = params.fields === undefined ? {
        name: 'fields',
        kind: 'Link',
        map: true,
        fragment: select$1V()
      } : params.fields;
      return {
        kind: 'Fragment',
        version: VERSION$4,
        private: [],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'cloneSourceId',
          kind: 'Scalar'
        }, fieldsPathSelection, {
          name: 'recordTypeId',
          kind: 'Scalar'
        }]
      };
    };
    function equals$4(existing, incoming) {
      const existing_apiName = existing.apiName;
      const incoming_apiName = incoming.apiName;
      if (!(existing_apiName === incoming_apiName)) {
        return false;
      }
      const existing_cloneSourceId = existing.cloneSourceId;
      const incoming_cloneSourceId = incoming.cloneSourceId;
      if (!(existing_cloneSourceId === incoming_cloneSourceId)) {
        return false;
      }
      const existing_fields = existing.fields;
      const incoming_fields = incoming.fields;
      const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
          return false;
        }
      });
      if (equals_fields_props === false) {
        return false;
      }
      const existing_recordTypeId = existing.recordTypeId;
      const incoming_recordTypeId = incoming.recordTypeId;
      if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
      }
      return true;
    }
    function getTypeCacheKeys$4(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$4(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$4,
        mergeable: false
      });
      const input_fields = input.fields;
      const input_fields_keys = ObjectKeys(input_fields);
      const input_fields_length = input_fields_keys.length;
      for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        getTypeCacheKeys$Y(rootKeySet, luvio, input_fields[key], () => rootKey + "__fields" + "__" + key);
      }
    }
    function dynamicIngest$3(ingestParams) {
      return function RecordTemplateCloneRepresentationIngest(input, path, luvio, store, timestamp) {
        {
          const validateError = validate$4(input);
          if (validateError !== null) {
            throw validateError;
          }
        }
        const key = keyBuilderFromType$4(luvio, input);
        const ttlToUse = TTL$3;
        luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, dynamicNormalize$3(ingestParams), "UiApi", VERSION$4, RepresentationType$4, equals$4);
        return createLink(key);
      };
    }
    const TTL$2 = 1000;
    const VERSION$3 = "b352a734f919895e97682703b486b649";
    function validate$3(obj, path = 'RecordDefaultsTemplateCloneRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray(obj_objectInfos) || obj_objectInfos === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
          const key = obj_objectInfos_keys[i];
          const obj_objectInfos_prop = obj_objectInfos[key];
          const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
          if (typeof obj_objectInfos_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
          }
        }
        const obj_record = obj.record;
        const path_record = path + '.record';
        if (typeof obj_record !== 'object') {
          return new TypeError('Expected "object" but received "' + typeof obj_record + '" (at "' + path_record + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$3 = 'RecordDefaultsTemplateCloneRepresentation';
    function keyBuilder$5(luvio, config) {
      return keyPrefix + '::' + RepresentationType$3 + ':' + config.cloneSourceId + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
    }
    function keyBuilderFromType$3(luvio, object) {
      const keyParams = {
        cloneSourceId: object.record.cloneSourceId,
        recordTypeId: object.record.recordTypeId
      };
      return keyBuilder$5(luvio, keyParams);
    }
    function dynamicNormalize$2(ingestParams) {
      return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_objectInfos = input.objectInfos;
        const input_objectInfos_id = path.fullPath + '__objectInfos';
        const input_objectInfos_keys = Object.keys(input_objectInfos);
        const input_objectInfos_length = input_objectInfos_keys.length;
        for (let i = 0; i < input_objectInfos_length; i++) {
          const key = input_objectInfos_keys[i];
          const input_objectInfos_prop = input_objectInfos[key];
          const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
          input_objectInfos[key] = ingestParams.objectInfos(input_objectInfos_prop, {
            fullPath: input_objectInfos_prop_id,
            propertyName: key,
            parent: {
              data: input,
              key: path.fullPath,
              existing: existing
            },
            ttl: path.ttl
          }, luvio, store, timestamp);
        }
        const input_record = input.record;
        const input_record_id = path.fullPath + '__record';
        input.record = ingestParams.record(input_record, {
          fullPath: input_record_id,
          propertyName: 'record',
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
        return input;
      };
    }
    const dynamicSelect$2 = function dynamicRecordDefaultsTemplateCloneRepresentationSelect(params) {
      const objectInfosPathSelection = params.objectInfos === undefined ? {
        name: 'objectInfos',
        kind: 'Link',
        map: true,
        fragment: select$1L()
      } : params.objectInfos;
      const recordPathSelection = params.record === undefined ? {
        name: 'record',
        kind: 'Link',
        fragment: select$3()
      } : params.record;
      return {
        kind: 'Fragment',
        version: VERSION$3,
        private: [],
        selections: [objectInfosPathSelection, recordPathSelection]
      };
    };
    function equals$3(existing, incoming) {
      const existing_objectInfos = existing.objectInfos;
      const incoming_objectInfos = incoming.objectInfos;
      const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
          return false;
        }
      });
      if (equals_objectInfos_props === false) {
        return false;
      }
      const existing_record = existing.record;
      const incoming_record = incoming.record;
      if (!(existing_record.__ref === incoming_record.__ref)) {
        return false;
      }
      return true;
    }
    function getTypeCacheKeys$3(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$3(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$3,
        mergeable: false
      });
      const input_objectInfos = input.objectInfos;
      const input_objectInfos_keys = ObjectKeys(input_objectInfos);
      const input_objectInfos_length = input_objectInfos_keys.length;
      for (let i = 0; i < input_objectInfos_length; i++) {
        const key = input_objectInfos_keys[i];
        getTypeCacheKeys$O(rootKeySet, luvio, input_objectInfos[key]);
      }
      getTypeCacheKeys$4(rootKeySet, luvio, input.record);
    }
    function dynamicIngest$2(ingestParams) {
      return function RecordDefaultsTemplateCloneRepresentationIngest(input, path, luvio, store, timestamp) {
        {
          const validateError = validate$3(input);
          if (validateError !== null) {
            throw validateError;
          }
        }
        const key = keyBuilderFromType$3(luvio, input);
        const ttlToUse = TTL$2;
        luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, dynamicNormalize$2(ingestParams), "UiApi", VERSION$3, RepresentationType$3, equals$3);
        return createLink(key);
      };
    }
    function createFieldsIngest$3(params) {
      const {
        fields,
        optionalFields,
        trackedFields,
        recordConflictMap
      } = params;
      const ingest = dynamicIngest$3({
        fields: createFieldsIngestion(fields, optionalFields, recordConflictMap)
      });
      return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
      };
    }
    function selectFields$5(fields) {
      return dynamicSelect$3({
        fields: createPathSelection('fields', fields)
      });
    }
    function createFieldsIngest$2(params) {
      const {
        fields,
        optionalFields,
        trackedFields,
        recordConflictMap
      } = params;
      const ingest = dynamicIngest$2({
        objectInfos: ingest$H,
        record: createFieldsIngest$3(params)
      });
      return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
      };
    }
    function selectFields$4(fields) {
      return dynamicSelect$2({
        record: {
          kind: 'Link',
          name: 'record',
          fragment: selectFields$5(fields)
        }
      });
    }
    function createFieldsIngestSuccess$1(params) {
      const {
        trackedFields
      } = params;
      const recordConflictMap = {
        conflicts: {},
        serverRequestCount: 1
      };
      const ingest = createFieldsIngest$2({
        ...params,
        recordConflictMap
      });
      return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        resolveConflict(luvio, recordConflictMap);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
      };
    }
    function selectFields$3(luvio, params) {
      const optionalFields = params.queryParams.optionalFields || [];
      const fields = [];
      const trie = convertRecordFieldsArrayToTrie(fields, optionalFields);
      return selectFields$4(trie);
    }
    const select$2 = (luvio, params) => {
      let {
        optionalFields
      } = params.queryParams;
      optionalFields = optionalFields === undefined ? ['.CloneSourceId'] : [...optionalFields, '.CloneSourceId'];
      return selectFields$3(luvio, {
        ...params,
        queryParams: {
          ...params.queryParams,
          optionalFields
        }
      });
    };
    function getResponseCacheKeys$5(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$3(storeKeyMap, luvio, response);
    }
    function createResourceRequest$6(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/record-defaults/template/clone/' + config.urlParams.recordId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$3 = 'getRecordTemplateClone';
    const getRecordTemplateClone_ConfigPropertyMetadata = [generateParamConfigMetadata('recordId', true, 0 /* UrlParameter */, 0 /* String */, false, getRecordId18), generateParamConfigMetadata('optionalFields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */)];
    const getRecordTemplateClone_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$3, getRecordTemplateClone_ConfigPropertyMetadata);
    const createResourceParams$6 = /*#__PURE__*/luvioEngine.createResourceParams(getRecordTemplateClone_ConfigPropertyMetadata);
    function typeCheckConfig$7(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRecordTemplateClone_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$5(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRecordTemplateClone_ConfigPropertyMetadata);
      const config = typeCheckConfig$7(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    const contextId$1 = `${keyPrefix}__${adapterName$3}`;
    const DEFAULT_RECORD_TYPE_ID_KEY = 'defaultRecordTypeId';
    const RECORD_TEMPLATE_CLONE_ERROR_VERSION = 'RECORD_TEMPLATE_CLONE_ERROR_VERSION_1';
    const RECORD_TEMPLATE_CLONE_ERROR_STORE_METADATA_PARAMS = {
      ttl: TTL$2,
      representationName: '',
      namespace: keyPrefix,
      version: RECORD_TEMPLATE_CLONE_ERROR_VERSION
    };
    function saveDefaultRecordTypeId(context, objectInfo) {
      context.set(DEFAULT_RECORD_TYPE_ID_KEY, objectInfo.defaultRecordTypeId);
    }
    function getRecordTypeId$1(adapterConfig, context) {
      const {
        recordTypeId
      } = adapterConfig;
      if (recordTypeId !== undefined && recordTypeId !== null) {
        return recordTypeId;
      }
      const contextValue = context.get(DEFAULT_RECORD_TYPE_ID_KEY);
      if (contextValue === null || contextValue === undefined) {
        return undefined;
      }
      return contextValue;
    }
    const buildNetworkSnapshot$6 = (luvio, context, config, options) => {
      const resourceParams = createResourceParams$6(config);
      const recordTypeId = getRecordTypeId$1(config, context);
      const {
        recordId
      } = config;
      const resourceRequest = createResourceRequest$6(resourceParams);
      const coercedRecordTypeId = recordTypeId === undefined ? null : recordTypeId;
      const templateRecordKey = keyBuilder$6(luvio, {
        cloneSourceId: recordId,
        recordTypeId: coercedRecordTypeId
      });
      const request = recordTypeId === undefined ? resourceRequest : createResourceRequest$6({
        ...resourceParams,
        queryParams: {
          ...resourceRequest.queryParams,
          optionalFields: getTrackedFields(templateRecordKey, luvio.getNode(templateRecordKey), {
            maxDepth: configurationForRestAdapters.getTrackedFieldDepthOnCacheMiss(),
            onlyFetchLeafNodeIdAndName: configurationForRestAdapters.getTrackedFieldLeafNodeIdAndNameOnly()
          }, config.optionalFields)
        }
      });
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const {
            body
          } = response;
          const key = keyBuilderFromType$3(luvio, body);
          const responseRecordTypeId = body.record.recordTypeId;
          const objectApiName = body.record.apiName;
          // publish metadata for recordTypeId
          saveDefaultRecordTypeId(context, body.objectInfos[objectApiName]);
          const optionalFieldsTrie = convertFieldsToTrie(resourceParams.queryParams.optionalFields);
          luvio.storeIngest(key, createFieldsIngestSuccess$1({
            fields: BLANK_RECORD_FIELDS_TRIE,
            optionalFields: optionalFieldsTrie,
            trackedFields: optionalFieldsTrie,
            serverRequestCount: 1
          }), body);
          const snapshot = buildCachedSnapshot$1(luvio, context, {
            ...config,
            recordTypeId: responseRecordTypeId
          });
          {
            if (snapshot.state !== 'Fulfilled') {
              throw new Error('Invalid network response. Expected network response to result in Fulfilled snapshot');
            }
          }
          return luvio.storeBroadcast().then(() => {
            return snapshot;
          });
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$5(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => {
          const key = keyBuilder$5(luvio, {
            cloneSourceId: config.recordId,
            recordTypeId: config.recordTypeId || null
          });
          const errorSnapshot = luvio.errorSnapshot(response, {
            config,
            resolve: () => buildNetworkSnapshot$6(luvio, context, config, snapshotRefreshOptions)
          });
          luvio.storeIngestError(key, errorSnapshot, RECORD_TEMPLATE_CLONE_ERROR_STORE_METADATA_PARAMS);
          return Promise.resolve(errorSnapshot);
        });
      });
    };
    const buildCachedSnapshot$1 = (luvio, context, config) => {
      const resourceParams = createResourceParams$6(config);
      const key = keyBuilder$5(luvio, {
        cloneSourceId: config.recordId,
        recordTypeId: config.recordTypeId || null
      });
      const selector = {
        recordId: key,
        node: select$2(luvio, resourceParams),
        variables: {}
      };
      return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$6(luvio, context, config, snapshotRefreshOptions)
      });
    };
    function buildNetworkSnapshotCachePolicy$1(context, coercedAdapterRequestContext) {
      const {
        config,
        adapterContext,
        luvio
      } = context;
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return buildNetworkSnapshot$6(luvio, adapterContext, config, dispatchOptions);
    }
    function buildCachedSnapshotCachePolicy$1(context, storeLookup) {
      const {
        adapterContext,
        config,
        luvio,
        recordTypeId
      } = context;
      const updatedConfig = {
        ...config,
        recordTypeId
      };
      const resourceParams = createResourceParams$6(updatedConfig);
      const key = keyBuilder$5(luvio, {
        cloneSourceId: updatedConfig.recordId,
        recordTypeId: updatedConfig.recordTypeId || null
      });
      const selector = {
        recordId: key,
        node: select$2(luvio, resourceParams),
        variables: {}
      };
      return storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$6(luvio, adapterContext, updatedConfig, snapshotRefreshOptions)
      });
    }
    const factory$6 = luvio => luvio.withContext(function getRecordTemplateClone_ContextWrapper(untrustedConfig, adapterContext, requestContext) {
      const config = validateAdapterConfig$5(untrustedConfig, getRecordTemplateClone_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      const recordTypeId = getRecordTypeId$1(config, adapterContext);
      return luvio.applyCachePolicy(requestContext || {}, {
        luvio,
        config,
        recordTypeId,
        adapterContext
      }, buildCachedSnapshotCachePolicy$1, buildNetworkSnapshotCachePolicy$1);
    }, {
      contextId: contextId$1
    });
    const TTL$1 = 30000;
    const VERSION$2 = "665de0fdde39efd6f1098e374117ef58";
    function validate$2(obj, path = 'RecordTemplateCreateRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray(obj_fields) || obj_fields === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
          const key = obj_fields_keys[i];
          const obj_fields_prop = obj_fields[key];
          const path_fields_prop = path_fields + '["' + key + '"]';
          if (typeof obj_fields_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
          }
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
          if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union0_error != null) {
          obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
          if (obj_recordTypeId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
          }
        })();
        if (obj_recordTypeId_union1_error != null) {
          obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
          message += '\n' + obj_recordTypeId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_recordTypeId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$2 = 'RecordTemplateCreateRepresentation';
    function keyBuilder$4(luvio, config) {
      return keyPrefix + '::' + RepresentationType$2 + ':' + config.apiName + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
    }
    function keyBuilderFromType$2(luvio, object) {
      const keyParams = {
        apiName: object.apiName,
        recordTypeId: object.recordTypeId
      };
      return keyBuilder$4(luvio, keyParams);
    }
    function dynamicNormalize$1(ingestParams) {
      return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_fields = input.fields;
        const input_fields_id = path.fullPath + '__fields';
        const input_fields_keys = Object.keys(input_fields);
        const input_fields_length = input_fields_keys.length;
        for (let i = 0; i < input_fields_length; i++) {
          const key = input_fields_keys[i];
          const input_fields_prop = input_fields[key];
          const input_fields_prop_id = input_fields_id + '__' + key;
          input_fields[key] = ingestParams.fields(input_fields_prop, {
            fullPath: input_fields_prop_id,
            propertyName: key,
            parent: {
              data: input,
              key: path.fullPath,
              existing: existing
            },
            ttl: path.ttl
          }, luvio, store, timestamp);
        }
        return input;
      };
    }
    const select$1 = function RecordTemplateCreateRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$2,
        private: [],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, {
          name: 'fields',
          kind: 'Link',
          map: true,
          fragment: select$1V()
        }, {
          name: 'recordTypeId',
          kind: 'Scalar'
        }]
      };
    };
    const dynamicSelect$1 = function dynamicRecordTemplateCreateRepresentationSelect(params) {
      const fieldsPathSelection = params.fields === undefined ? {
        name: 'fields',
        kind: 'Link',
        map: true,
        fragment: select$1V()
      } : params.fields;
      return {
        kind: 'Fragment',
        version: VERSION$2,
        private: [],
        selections: [{
          name: 'apiName',
          kind: 'Scalar'
        }, fieldsPathSelection, {
          name: 'recordTypeId',
          kind: 'Scalar'
        }]
      };
    };
    function equals$2(existing, incoming) {
      const existing_apiName = existing.apiName;
      const incoming_apiName = incoming.apiName;
      if (!(existing_apiName === incoming_apiName)) {
        return false;
      }
      const existing_fields = existing.fields;
      const incoming_fields = incoming.fields;
      const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
          return false;
        }
      });
      if (equals_fields_props === false) {
        return false;
      }
      const existing_recordTypeId = existing.recordTypeId;
      const incoming_recordTypeId = incoming.recordTypeId;
      if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
      }
      return true;
    }
    function getTypeCacheKeys$2(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$2(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$2,
        mergeable: false
      });
      const input_fields = input.fields;
      const input_fields_keys = ObjectKeys(input_fields);
      const input_fields_length = input_fields_keys.length;
      for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        getTypeCacheKeys$Y(rootKeySet, luvio, input_fields[key], () => rootKey + "__fields" + "__" + key);
      }
    }
    function dynamicIngest$1(ingestParams) {
      return function RecordTemplateCreateRepresentationIngest(input, path, luvio, store, timestamp) {
        {
          const validateError = validate$2(input);
          if (validateError !== null) {
            throw validateError;
          }
        }
        const key = keyBuilderFromType$2(luvio, input);
        const ttlToUse = TTL$1;
        luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, dynamicNormalize$1(ingestParams), "UiApi", VERSION$2, RepresentationType$2, equals$2);
        return createLink(key);
      };
    }
    const TTL = 900000;
    const VERSION$1 = "30493e7ac0677e35242026bb959c079e";
    function validate$1(obj, path = 'RecordDefaultsTemplateCreateRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray(obj_objectInfos) || obj_objectInfos === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
          const key = obj_objectInfos_keys[i];
          const obj_objectInfos_prop = obj_objectInfos[key];
          const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
          if (typeof obj_objectInfos_prop !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
          }
        }
        const obj_record = obj.record;
        const path_record = path + '.record';
        if (typeof obj_record !== 'object') {
          return new TypeError('Expected "object" but received "' + typeof obj_record + '" (at "' + path_record + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$1 = 'RecordDefaultsTemplateCreateRepresentation';
    function keyBuilder$3(luvio, config) {
      return keyPrefix + '::' + RepresentationType$1 + ':' + config.objectApiName + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
    }
    function keyBuilderFromType$1(luvio, object) {
      const keyParams = {
        objectApiName: object.record.apiName,
        recordTypeId: object.record.recordTypeId
      };
      return keyBuilder$3(luvio, keyParams);
    }
    function dynamicNormalize(ingestParams) {
      return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_objectInfos = input.objectInfos;
        const input_objectInfos_id = path.fullPath + '__objectInfos';
        const input_objectInfos_keys = Object.keys(input_objectInfos);
        const input_objectInfos_length = input_objectInfos_keys.length;
        for (let i = 0; i < input_objectInfos_length; i++) {
          const key = input_objectInfos_keys[i];
          const input_objectInfos_prop = input_objectInfos[key];
          const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
          input_objectInfos[key] = ingestParams.objectInfos(input_objectInfos_prop, {
            fullPath: input_objectInfos_prop_id,
            propertyName: key,
            parent: {
              data: input,
              key: path.fullPath,
              existing: existing
            },
            ttl: path.ttl
          }, luvio, store, timestamp);
        }
        const input_record = input.record;
        const input_record_id = path.fullPath + '__record';
        input.record = ingestParams.record(input_record, {
          fullPath: input_record_id,
          propertyName: 'record',
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
        return input;
      };
    }
    const dynamicSelect = function dynamicRecordDefaultsTemplateCreateRepresentationSelect(params) {
      const objectInfosPathSelection = params.objectInfos === undefined ? {
        name: 'objectInfos',
        kind: 'Link',
        map: true,
        fragment: select$1L()
      } : params.objectInfos;
      const recordPathSelection = params.record === undefined ? {
        name: 'record',
        kind: 'Link',
        fragment: select$1()
      } : params.record;
      return {
        kind: 'Fragment',
        version: VERSION$1,
        private: [],
        selections: [objectInfosPathSelection, recordPathSelection]
      };
    };
    function equals$1(existing, incoming) {
      const existing_objectInfos = existing.objectInfos;
      const incoming_objectInfos = incoming.objectInfos;
      const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
          return false;
        }
      });
      if (equals_objectInfos_props === false) {
        return false;
      }
      const existing_record = existing.record;
      const incoming_record = incoming.record;
      if (!(existing_record.__ref === incoming_record.__ref)) {
        return false;
      }
      return true;
    }
    function getTypeCacheKeys$1(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$1(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$1,
        mergeable: false
      });
      const input_objectInfos = input.objectInfos;
      const input_objectInfos_keys = ObjectKeys(input_objectInfos);
      const input_objectInfos_length = input_objectInfos_keys.length;
      for (let i = 0; i < input_objectInfos_length; i++) {
        const key = input_objectInfos_keys[i];
        getTypeCacheKeys$O(rootKeySet, luvio, input_objectInfos[key]);
      }
      getTypeCacheKeys$2(rootKeySet, luvio, input.record);
    }
    function dynamicIngest(ingestParams) {
      return function RecordDefaultsTemplateCreateRepresentationIngest(input, path, luvio, store, timestamp) {
        {
          const validateError = validate$1(input);
          if (validateError !== null) {
            throw validateError;
          }
        }
        const key = keyBuilderFromType$1(luvio, input);
        const ttlToUse = TTL;
        luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, dynamicNormalize(ingestParams), "UiApi", VERSION$1, RepresentationType$1, equals$1);
        return createLink(key);
      };
    }
    function createFieldsIngest$1(params) {
      const {
        fields,
        optionalFields,
        trackedFields,
        recordConflictMap
      } = params;
      const ingest = dynamicIngest$1({
        fields: createFieldsIngestion(fields, optionalFields, recordConflictMap)
      });
      return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
      };
    }
    function selectFields$2(fields) {
      return dynamicSelect$1({
        fields: createPathSelection('fields', fields)
      });
    }
    function createFieldsIngest(params) {
      const {
        fields,
        optionalFields,
        trackedFields,
        recordConflictMap
      } = params;
      const ingest = dynamicIngest({
        objectInfos: ingest$H,
        record: createFieldsIngest$1(params)
      });
      return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
      };
    }
    function selectFields$1(fields) {
      return dynamicSelect({
        record: {
          kind: 'Link',
          name: 'record',
          fragment: selectFields$2(fields)
        }
      });
    }
    function createFieldsIngestSuccess(params) {
      const {
        trackedFields
      } = params;
      const recordConflictMap = {
        conflicts: {},
        serverRequestCount: 1
      };
      const ingest = createFieldsIngest({
        ...params,
        recordConflictMap
      });
      return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        resolveConflict(luvio, recordConflictMap);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
      };
    }
    function selectFields(luvio, params) {
      const optionalFields = params.queryParams.optionalFields || [];
      const fields = [];
      const trie = convertRecordFieldsArrayToTrie(fields, optionalFields);
      return selectFields$1(trie);
    }
    function keyBuilder$2(luvio, params) {
      return keyBuilder$3(luvio, {
        objectApiName: params.urlParams.objectApiName,
        recordTypeId: params.queryParams.recordTypeId || null
      });
    }
    function getResponseCacheKeys$4(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$1(storeKeyMap, luvio, response);
    }
    function ingestError(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$2(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL,
        namespace: keyPrefix,
        version: VERSION$1,
        representationName: RepresentationType$1
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$5(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/record-defaults/template/create/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function adapterFragment(luvio, config) {
      const resourceParams = createResourceParams$5(config);
      return selectFields(luvio, resourceParams);
    }
    const adapterName$2 = 'getRecordTemplateCreate';
    const getRecordTemplateCreate_ConfigPropertyMetadata = [generateParamConfigMetadata('objectApiName', true, 0 /* UrlParameter */, 0 /* String */, false, getObjectApiName$1), generateParamConfigMetadata('optionalFields', false, 1 /* QueryParameter */, 0 /* String */, true, getFieldApiNamesArray), generateParamConfigMetadata('recordTypeId', false, 1 /* QueryParameter */, 0 /* String */)];
    const getRecordTemplateCreate_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$2, getRecordTemplateCreate_ConfigPropertyMetadata);
    const createResourceParams$5 = /*#__PURE__*/luvioEngine.createResourceParams(getRecordTemplateCreate_ConfigPropertyMetadata);
    function typeCheckConfig$6(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getRecordTemplateCreate_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$4(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, getRecordTemplateCreate_ConfigPropertyMetadata);
      const config = typeCheckConfig$6(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    const contextId = `${keyPrefix}__${adapterName$2}`;
    function buildSnapshotRefresh(luvio, context, config) {
      return {
        config,
        resolve: () => buildNetworkSnapshot$5(luvio, context, config, snapshotRefreshOptions)
      };
    }
    function buildRecordTypeIdContextKey(objectApiName) {
      return `DEFAULTS::recordTypeId:${objectApiName}`;
    }
    function getRecordTypeId(context, adapterConfig) {
      const config = createResourceParams$5(adapterConfig);
      const {
        recordTypeId
      } = config.queryParams;
      if (recordTypeId !== undefined && recordTypeId !== null) {
        return recordTypeId;
      }
      const saved = context.get(buildRecordTypeIdContextKey(config.urlParams.objectApiName));
      if (saved === null || saved === undefined) {
        return undefined;
      }
      return saved;
    }
    function prepareRequest(luvio, context, config) {
      const resourceParams = createResourceParams$5(config);
      const recordTypeId = getRecordTypeId(context, config);
      const {
        objectApiName
      } = config;
      const resourceRequest = createResourceRequest$5(resourceParams);
      if (recordTypeId === undefined) {
        return resourceRequest;
      }
      const recordTemplateKey = keyBuilder$4(luvio, {
        apiName: objectApiName,
        recordTypeId: recordTypeId
      });
      return createResourceRequest$5({
        ...resourceParams,
        queryParams: {
          ...resourceRequest.queryParams,
          optionalFields: getTrackedFields(recordTemplateKey, luvio.getNode(recordTemplateKey), {
            maxDepth: configurationForRestAdapters.getTrackedFieldDepthOnCacheMiss(),
            onlyFetchLeafNodeIdAndName: configurationForRestAdapters.getTrackedFieldLeafNodeIdAndNameOnly()
          }, config.optionalFields)
        }
      });
    }
    function onFetchResponseSuccess(luvio, context, config, request, response, resourceParams) {
      const {
        urlParams: {
          objectApiName
        },
        queryParams: {
          optionalFields
        }
      } = resourceParams;
      const {
        body
      } = response;
      const key = keyBuilderFromType$1(luvio, body);
      const responseRecordTypeId = body.record.recordTypeId;
      // publish metadata for recordTypeId
      const recordTypeId = body.objectInfos[objectApiName].defaultRecordTypeId;
      context.set(buildRecordTypeIdContextKey(objectApiName), recordTypeId);
      // mark missing optionalFields
      const templateRecordKey = keyBuilder$4(luvio, {
        apiName: objectApiName,
        recordTypeId: responseRecordTypeId
      });
      const allTrackedFields = getTrackedFields(templateRecordKey, luvio.getNode(templateRecordKey), {
        maxDepth: configurationForRestAdapters.getTrackedFieldDepthOnCacheMiss(),
        onlyFetchLeafNodeIdAndName: configurationForRestAdapters.getTrackedFieldLeafNodeIdAndNameOnly()
      }, optionalFields);
      const allTrackedFieldsTrie = convertFieldsToTrie(allTrackedFields, true);
      const ingest = createFieldsIngestSuccess({
        fields: BLANK_RECORD_FIELDS_TRIE,
        optionalFields: allTrackedFieldsTrie,
        trackedFields: allTrackedFieldsTrie,
        serverRequestCount: 1
      });
      luvio.storeIngest(key, ingest, body);
      const snapshot = buildCachedSnapshot(luvio, context, {
        ...config,
        recordTypeId: responseRecordTypeId
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected network response to result in Fulfilled snapshot');
        }
      }
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError(luvio, context, config, resourceParams, error) {
      const snapshot = ingestError(luvio, resourceParams, error, buildSnapshotRefresh(luvio, context, config));
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$5(luvio, context, config, options) {
      const resourceParams = createResourceParams$5(config);
      const request = prepareRequest(luvio, context, config);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          return onFetchResponseSuccess(luvio, context, config, request, response, resourceParams);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$4(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => {
          return onFetchResponseError(luvio, context, config, resourceParams, response);
        });
      });
    }
    function buildCachedSnapshot(luvio, context, config) {
      const resourceParams = createResourceParams$5(config);
      const selector = {
        recordId: keyBuilder$2(luvio, resourceParams),
        node: adapterFragment(luvio, config),
        variables: {}
      };
      return luvio.storeLookup(selector, buildSnapshotRefresh(luvio, context, config));
    }
    const buildNetworkSnapshotCachePolicy = (context, coercedAdapterRequestContext) => {
      const {
        config,
        adapterContext,
        luvio
      } = context;
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return buildNetworkSnapshot$5(luvio, adapterContext, config, dispatchOptions);
    };
    const buildCachedSnapshotCachePolicy = (context, storeLookup) => {
      const {
        adapterContext,
        config,
        luvio,
        recordTypeId
      } = context;
      const updatedConfig = {
        ...config,
        recordTypeId
      };
      const resourceParams = createResourceParams$5(updatedConfig);
      const selector = {
        recordId: keyBuilder$2(luvio, resourceParams),
        node: adapterFragment(luvio, config),
        variables: {}
      };
      return storeLookup(selector, buildSnapshotRefresh(luvio, adapterContext, config));
    };
    const factory$5 = luvio => {
      return luvio.withContext(function UiApi__getRecordDefaultsTemplateForCreate(untrustedConfig, adapterContext, requestContext) {
        const config = validateAdapterConfig$4(untrustedConfig, getRecordTemplateCreate_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          return null;
        }
        const recordTypeId = getRecordTypeId(adapterContext, config);
        return luvio.applyCachePolicy(requestContext || {}, {
          luvio,
          config,
          recordTypeId,
          adapterContext
        }, buildCachedSnapshotCachePolicy, buildNetworkSnapshotCachePolicy);
      }, {
        contextId
      });
    };
    function getResponseCacheKeys$3(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$X(storeKeyMap, luvio, response);
    }
    function createResourceRequest$4(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/records',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const createRecord_ConfigPropertyMetadata = [generateParamConfigMetadata('handleOwnerChange', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('includeFieldsInBody', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('triggerOtherEmail', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('triggerUserEmail', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('useDefaultRule', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('allowSaveOnDuplicate', false, 2 /* Body */, 1 /* Boolean */), generateParamConfigMetadata('apiName', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('fields', true, 2 /* Body */, 4 /* Unsupported */)];
    const createResourceParams$4 = /*#__PURE__*/luvioEngine.createResourceParams(createRecord_ConfigPropertyMetadata);
    function onResponseSuccess(luvio, response, recordIngest, conflictMap) {
      const {
        body,
        status
      } = response;
      if (status === luvioEngine.HttpStatusCode.NoContent) {
        const syntheticSnapshot = {
          state: 'Fulfilled',
          data: {}
        };
        return luvio.storeBroadcast().then(() => syntheticSnapshot);
      }
      const selections = buildSelectionFromRecord(body);
      const key = keyBuilder$29(luvio, {
        recordId: body.id
      });
      luvio.storeIngest(key, recordIngest, body);
      resolveConflict(luvio, conflictMap);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: {
          kind: 'Fragment',
          private: [],
          selections,
          version: VERSION$1e
        },
        variables: {}
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$4(luvio, config) {
      const resourceParams = createResourceParams$4(config);
      const request = createResourceRequest$4(resourceParams);
      const fieldTrie = BLANK_RECORD_FIELDS_TRIE;
      const optionalFieldTrie = BLANK_RECORD_FIELDS_TRIE;
      const conflictMap = {
        conflicts: {},
        serverRequestCount: 1
      };
      const recordIngest = createRecordIngest(fieldTrie, optionalFieldTrie, conflictMap);
      return luvio.dispatchResourceRequest(request).then(response => {
        return luvio.handleSuccessResponse(() => onResponseSuccess(luvio, response, recordIngest, conflictMap), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$3(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, err => {
        luvioEngine.deepFreeze(err);
        throw err;
      });
    }
    const factory$4 = luvio => {
      return function (untrustedConfig) {
        const config = untrustedConfig;
        const draftAdapter = configurationForRestAdapters.getDraftAwareCreateRecordAdapter();
        if (draftAdapter !== undefined) {
          return draftAdapter(config, buildNetworkSnapshot$4);
        }
        return buildNetworkSnapshot$4(luvio, config);
      };
    };
    function keyBuilder$1(luvio, params) {
      return keyBuilder$29(luvio, {
        recordId: params.urlParams.recordId
      });
    }
    function getResponseCacheKeys$2(cacheKeyMap, luvio, resourceParams) {
      const key = keyBuilder$1(luvio, resourceParams);
      cacheKeyMap.set(key, {
        namespace: keyPrefix,
        representationName: RepresentationType$V,
        mergeable: false
      });
    }
    function evictSuccess(luvio, resourceParams) {
      const key = keyBuilder$1(luvio, resourceParams);
      luvio.storeEvict(key);
    }
    function createResourceRequest$3(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/records/' + config.urlParams.recordId + '',
        method: 'delete',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$1 = 'deleteRecord';
    const deleteRecord_ConfigPropertyMetadata = [generateParamConfigMetadata('recordId', true, 0 /* UrlParameter */, 0 /* String */, false, getRecordId18)];
    const deleteRecord_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$1, deleteRecord_ConfigPropertyMetadata);
    const createResourceParams$3 = /*#__PURE__*/luvioEngine.createResourceParams(deleteRecord_ConfigPropertyMetadata);
    function typeCheckConfig$5(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, deleteRecord_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$3(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, deleteRecord_ConfigPropertyMetadata);
      const config = typeCheckConfig$5(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$3(luvio, config, options) {
      const resourceParams = createResourceParams$3(config);
      const request = createResourceRequest$3(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(() => {
        return luvio.handleSuccessResponse(() => {
          evictSuccess(luvio, resourceParams);
          return luvio.storeBroadcast();
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$2(cache, luvio, resourceParams);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const deleteRecordAdapterFactory = luvio => {
      return function UiApideleteRecord(untrustedConfig) {
        const config = validateAdapterConfig$3(untrustedConfig, deleteRecord_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error(`Invalid config for "${adapterName$1}"`);
        }
        return buildNetworkSnapshot$3(luvio, config);
      };
    };
    const factory$3 = luvio => {
      const deleteRecordAdapterInstance = deleteRecordAdapterFactory(luvio);
      return recordId => {
        const config = {
          recordId
        };
        const draftAdapter = configurationForRestAdapters.getDraftAwareDeleteRecordAdapter();
        if (draftAdapter !== undefined) {
          return draftAdapter(config, buildNetworkSnapshot$3);
        }
        return deleteRecordAdapterInstance(config);
      };
    };
    function getResponseCacheKeys$1(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$X(storeKeyMap, luvio, response);
    }
    function createResourceRequest$2(config) {
      const headers = {};
      const header_ifUnmodifiedSince = config.headers.ifUnmodifiedSince;
      if (header_ifUnmodifiedSince !== undefined) {
        headers['If-Unmodified-Since'] = header_ifUnmodifiedSince;
      }
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/records/' + config.urlParams.recordId + '',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName = 'updateRecord';
    const updateRecord_ConfigPropertyMetadata = [generateParamConfigMetadata('recordId', true, 0 /* UrlParameter */, 0 /* String */, false, getRecordId18), generateParamConfigMetadata('handleOwnerChange', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('triggerOtherEmail', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('triggerUserEmail', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('useDefaultRule', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('allowSaveOnDuplicate', false, 2 /* Body */, 1 /* Boolean */), generateParamConfigMetadata('apiName', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('fields', true, 2 /* Body */, 4 /* Unsupported */), generateParamConfigMetadata('ifUnmodifiedSince', false, 3 /* Header */, 0 /* String */)];
    const updateRecord_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName, updateRecord_ConfigPropertyMetadata);
    const createResourceParams$2 = /*#__PURE__*/luvioEngine.createResourceParams(updateRecord_ConfigPropertyMetadata);
    function typeCheckConfig$4(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, updateRecord_ConfigPropertyMetadata);
      const untrustedConfig_fields = untrustedConfig.fields;
      if (untrustedIsObject(untrustedConfig_fields)) {
        const untrustedConfig_fields_object = {};
        const untrustedConfig_fields_keys = Object.keys(untrustedConfig_fields);
        for (let i = 0, arrayLength = untrustedConfig_fields_keys.length; i < arrayLength; i++) {
          const key = untrustedConfig_fields_keys[i];
          const untrustedConfig_fields_prop = untrustedConfig_fields[key];
          if (typeof untrustedConfig_fields_prop === 'string') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (typeof untrustedConfig_fields_prop === 'number') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (untrustedConfig_fields_prop === null) {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
          if (typeof untrustedConfig_fields_prop === 'boolean') {
            if (untrustedConfig_fields_object !== undefined) {
              untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
          }
        }
        if (untrustedConfig_fields_object !== undefined && Object.keys(untrustedConfig_fields_object).length >= 0) {
          config.fields = untrustedConfig_fields_object;
        }
      }
      return config;
    }
    function validateAdapterConfig$2(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const coercedConfig = luvioEngine.coerceConfig(untrustedConfig, updateRecord_ConfigPropertyMetadata);
      const config = typeCheckConfig$4(coercedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    const ISO8601_DATE_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+Z$/;
    function getHeaders(clientOptions) {
      const headers = {};
      if (untrustedIsObject(clientOptions)) {
        if (typeof clientOptions.ifUnmodifiedSince === 'string') {
          headers.ifUnmodifiedSince = clientOptions.ifUnmodifiedSince;
          // HTTP standard format date is expected by UI-API
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Unmodified-Since
          // A component built for Connect API must use If-Unmodified-Since
          // dates formatted as ISO 8601, which does not match the HTTP spec.
          // For compatibility, convert the date to match the standard.
          if (headers.ifUnmodifiedSince.match(ISO8601_DATE_REGEX)) {
            const utcString = new Date(headers.ifUnmodifiedSince).toUTCString();
            if (utcString !== 'Invalid Date') {
              headers.ifUnmodifiedSince = utcString;
            }
          }
        }
      }
      return headers;
    }
    function buildNetworkSnapshot$2(luvio, config, clientOptions) {
      const {
        recordId
      } = config;
      const headers = getHeaders(clientOptions);
      const resourceParams = createResourceParams$2({
        ...config,
        ...headers
      });
      const request = createResourceRequest$2(resourceParams);
      const fieldTrie = BLANK_RECORD_FIELDS_TRIE;
      const optionalFieldTrie = BLANK_RECORD_FIELDS_TRIE;
      const conflictMap = {
        conflicts: {},
        serverRequestCount: 0 // do not count the update request we're about to make
      };
      const recordIngest = createRecordIngest(fieldTrie, optionalFieldTrie, conflictMap);
      return luvio.dispatchResourceRequest(request).then(response => {
        return luvio.handleSuccessResponse(() => {
          if (response.status === luvioEngine.HttpStatusCode.NoContent) {
            const syntheticSnapshot = {
              state: 'Fulfilled',
              data: {}
            };
            luvio.storeEvict(keyBuilder$29(luvio, {
              recordId
            }));
            return luvio.storeBroadcast().then(() => syntheticSnapshot);
          }
          const snapshot = ingestRecordResponse(luvio, response, recordId, recordIngest, conflictMap);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$1(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, err => {
        luvioEngine.deepFreeze(err);
        throw err;
      });
    }
    const factory$2 = luvio => {
      return (untrusted, clientOptions) => {
        let config = null;
        if (untrustedIsObject(untrusted) && untrustedIsObject(untrusted.fields)) {
          config = validateAdapterConfig$2({
            recordId: untrusted.fields.Id,
            ...untrusted
          }, updateRecord_ConfigPropertyNames);
        }
        // Invalid or incomplete config
        if (config === null) {
          // eslint-disable-next-line @salesforce/lds/no-error-in-production
          throw new Error('Invalid recordInput');
        }
        const draftAdapter = configurationForRestAdapters.getDraftAwareUpdateRecordAdapter();
        if (draftAdapter !== undefined) {
          return draftAdapter(config, buildNetworkSnapshot$2);
        }
        return buildNetworkSnapshot$2(luvio, config, clientOptions);
      };
    };
    const VERSION = "5f97eb4f2c3f805ef9d98ba7f0530b3e";
    function validate(obj, path = 'ContentDocumentCompositeRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentDocument = obj.contentDocument;
        const path_contentDocument = path + '.contentDocument';
        if (typeof obj_contentDocument !== 'object') {
          return new TypeError('Expected "object" but received "' + typeof obj_contentDocument + '" (at "' + path_contentDocument + '")');
        }
        const obj_contentDocumentLinks = obj.contentDocumentLinks;
        const path_contentDocumentLinks = path + '.contentDocumentLinks';
        if (!ArrayIsArray(obj_contentDocumentLinks)) {
          return new TypeError('Expected "array" but received "' + typeof obj_contentDocumentLinks + '" (at "' + path_contentDocumentLinks + '")');
        }
        for (let i = 0; i < obj_contentDocumentLinks.length; i++) {
          const obj_contentDocumentLinks_item = obj_contentDocumentLinks[i];
          const path_contentDocumentLinks_item = path_contentDocumentLinks + '[' + i + ']';
          if (typeof obj_contentDocumentLinks_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_contentDocumentLinks_item + '" (at "' + path_contentDocumentLinks_item + '")');
          }
        }
        const obj_contentVersion = obj.contentVersion;
        const path_contentVersion = path + '.contentVersion';
        if (typeof obj_contentVersion !== 'object') {
          return new TypeError('Expected "object" but received "' + typeof obj_contentVersion + '" (at "' + path_contentVersion + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType = 'ContentDocumentCompositeRepresentation';
    function keyBuilder(luvio, config) {
      return keyPrefix + '::' + RepresentationType + ':' + config.contentDocumentId;
    }
    function keyBuilderFromType(luvio, object) {
      const keyParams = {
        contentDocumentId: object.contentDocument.id
      };
      return keyBuilder(luvio, keyParams);
    }
    function normalize(input, existing, path, luvio, store, timestamp) {
      const input_contentDocument = input.contentDocument;
      const input_contentDocument_id = path.fullPath + '__contentDocument';
      input.contentDocument = ingest$O(input_contentDocument, {
        fullPath: input_contentDocument_id,
        propertyName: 'contentDocument',
        parent: {
          data: input,
          key: path.fullPath,
          existing: existing
        },
        ttl: path.ttl
      }, luvio, store, timestamp);
      const input_contentDocumentLinks = input.contentDocumentLinks;
      const input_contentDocumentLinks_id = path.fullPath + '__contentDocumentLinks';
      for (let i = 0; i < input_contentDocumentLinks.length; i++) {
        const input_contentDocumentLinks_item = input_contentDocumentLinks[i];
        let input_contentDocumentLinks_item_id = input_contentDocumentLinks_id + '__' + i;
        input_contentDocumentLinks[i] = ingest$O(input_contentDocumentLinks_item, {
          fullPath: input_contentDocumentLinks_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      const input_contentVersion = input.contentVersion;
      const input_contentVersion_id = path.fullPath + '__contentVersion';
      input.contentVersion = ingest$O(input_contentVersion, {
        fullPath: input_contentVersion_id,
        propertyName: 'contentVersion',
        parent: {
          data: input,
          key: path.fullPath,
          existing: existing
        },
        ttl: path.ttl
      }, luvio, store, timestamp);
      return input;
    }
    function equals(existing, incoming) {
      const existing_contentDocument = existing.contentDocument;
      const incoming_contentDocument = incoming.contentDocument;
      if (!(existing_contentDocument.__ref === incoming_contentDocument.__ref)) {
        return false;
      }
      const existing_contentDocumentLinks = existing.contentDocumentLinks;
      const incoming_contentDocumentLinks = incoming.contentDocumentLinks;
      const equals_contentDocumentLinks_items = equalsArray(existing_contentDocumentLinks, incoming_contentDocumentLinks, (existing_contentDocumentLinks_item, incoming_contentDocumentLinks_item) => {
        if (!(existing_contentDocumentLinks_item.__ref === incoming_contentDocumentLinks_item.__ref)) {
          return false;
        }
      });
      if (equals_contentDocumentLinks_items === false) {
        return false;
      }
      const existing_contentVersion = existing.contentVersion;
      const incoming_contentVersion = incoming.contentVersion;
      if (!(existing_contentVersion.__ref === incoming_contentVersion.__ref)) {
        return false;
      }
      return true;
    }
    const ingest = function ContentDocumentCompositeRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType(luvio, input);
      const ttlToUse = path.ttl !== undefined ? path.ttl : 2592000000;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize, "UiApi", VERSION, RepresentationType, equals);
      return createLink(key);
    };
    function getTypeCacheKeys(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType,
        mergeable: false
      });
      getTypeCacheKeys$X(rootKeySet, luvio, input.contentDocument);
      const input_contentDocumentLinks_length = input.contentDocumentLinks.length;
      for (let i = 0; i < input_contentDocumentLinks_length; i++) {
        getTypeCacheKeys$X(rootKeySet, luvio, input.contentDocumentLinks[i]);
      }
      getTypeCacheKeys$X(rootKeySet, luvio, input.contentVersion);
    }
    function getResponseCacheKeys(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys(storeKeyMap, luvio, response);
    }
    function createResourceParams$1(config) {
      const {
        fileData,
        title,
        description,
        contentDocumentId
      } = config;
      const body = {
        namedEntries: [{
          name: 'fileData',
          value: fileData
        }]
      };
      if (title !== undefined) {
        body.namedEntries.push({
          name: 'title',
          value: title
        });
      }
      if (description !== undefined) {
        body.namedEntries.push({
          name: 'description',
          value: description
        });
      }
      return {
        urlParams: {
          contentDocumentId
        },
        body
      };
    }
    function createResourceRequest$1(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/records/content-documents/' + config.urlParams.contentDocumentId + '/content-versions',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const select = function ContentDocumentCompositeRepresentationSelect(body) {
      return {
        kind: 'Fragment',
        private: [],
        version: VERSION,
        selections: [{
          name: 'contentDocument',
          kind: 'Link',
          fragment: {
            kind: 'Fragment',
            private: [],
            version: VERSION$1e,
            selections: buildSelectionFromRecord(body.contentDocument)
          }
        }, {
          name: 'contentDocumentLinks',
          kind: 'Link',
          plural: true,
          fragment: {
            kind: 'Fragment',
            private: [],
            version: VERSION$1e,
            selections: buildSelectionFromRecord(body.contentDocumentLinks[0] || {
              fields: {}
            })
          }
        }, {
          name: 'contentVersion',
          kind: 'Link',
          fragment: {
            kind: 'Fragment',
            private: [],
            version: VERSION$1e,
            selections: buildSelectionFromRecord(body.contentVersion)
          }
        }]
      };
    };
    function ingestSuccess$1(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType(luvio, body);
      const node = select(body);
      luvio.storeIngest(key, ingest, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node,
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      return snapshot;
    }
    function buildNetworkSnapshot$1(luvio, config, options) {
      const resourceParams = createResourceParams$1(config);
      const request = createResourceRequest$1(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$1(luvio, {}, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys(cache, luvio, {}, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    function createResourceParams(config) {
      const {
        fileData,
        title,
        description
      } = config;
      const body = {
        namedEntries: [{
          name: 'fileData',
          value: fileData
        }]
      };
      if (title !== undefined) {
        body.namedEntries.push({
          name: 'title',
          value: title
        });
      }
      if (description !== undefined) {
        body.namedEntries.push({
          name: 'description',
          value: description
        });
      }
      return {
        body
      };
    }
    function createResourceRequest(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/ui-api/records/content-documents/content-versions',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function ingestSuccess(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType(luvio, body);
      const node = select(body);
      luvio.storeIngest(key, ingest, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node,
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      return snapshot;
    }
    function buildNetworkSnapshot(luvio, config, options) {
      const resourceParams = createResourceParams(config);
      const request = createResourceRequest(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess(luvio, {}, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const createContentDocumentAndVersion_ConfigPropertyMetadata = [generateParamConfigMetadata('description', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('title', false, 2 /* Body */, 0 /* String */)];
    function typeCheckConfig$3(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, createContentDocumentAndVersion_ConfigPropertyMetadata);
      return config;
    }

    // This override is due to the addition of Blob formatted file data. There is not a convenient way to express this in RAML, so this validation
    // must be handrolled
    const createContentDocumentAndVersion_ConfigPropertyNames = {
      displayName: 'createContentDocumentAndVersion',
      parameters: {
        required: ['fileData'],
        optional: ['description', 'title']
      }
    };
    function typeCheckConfig$2(untrustedConfig) {
      const config = typeCheckConfig$3(untrustedConfig);
      const untrustedConfig_fileData = untrustedConfig.fileData;
      if (untrustedConfig_fileData !== undefined && untrustedConfig_fileData instanceof Object) {
        config.fileData = untrustedConfig_fileData;
      }
      return config;
    }
    function validateAdapterConfig$1(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$2(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    const factory$1 = luvio => {
      return function createContentDocumentAndVersion(untrustedConfig, requestContext) {
        let config = validateAdapterConfig$1(untrustedConfig, createContentDocumentAndVersion_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          // eslint-disable-next-line @salesforce/lds/no-error-in-production
          throw new Error('Invalid config for "createContentDocumentAndVersion"');
        }
        const draftAdapter = configurationForRestAdapters.getDraftAwareCreateContentDocumentAndVersionAdapter();
        if (draftAdapter !== undefined) {
          return draftAdapter(config, buildNetworkSnapshot, requestContext);
        }
        return buildNetworkSnapshot(luvio, config, createDispatchResourceRequestContext$1(requestContext));
      };
    };
    function createDispatchResourceRequestContext$1(requestContext) {
      let dispatchOptions = undefined;
      if (requestContext !== undefined) {
        const coercedAdapterRequestContext = luvioEngine.coerceAdapterRequestContext(requestContext);
        const {
          networkPriority,
          requestCorrelator,
          eventObservers,
          sourceContext
        } = coercedAdapterRequestContext;
        dispatchOptions = {
          resourceRequestContext: {
            requestCorrelator,
            sourceContext,
            luvioRequestMethod: undefined
          },
          eventObservers
        };
        if (networkPriority !== 'normal') {
          dispatchOptions.overrides = {
            priority: networkPriority
          };
        }
      }
      return dispatchOptions;
    }
    const createContentVersion_ConfigPropertyMetadata = [generateParamConfigMetadata('contentDocumentId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('description', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('title', false, 2 /* Body */, 0 /* String */)];
    function typeCheckConfig$1(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, createContentVersion_ConfigPropertyMetadata);
      return config;
    }

    // This override is due to the addition of Blob formatted file data. There is not a convenient way to express this in RAML, so this validation
    // must be handrolled
    const createContentVersion_ConfigPropertyNames = {
      displayName: 'createContentVersion',
      parameters: {
        required: ['contentDocumentId', 'fileData'],
        optional: ['description', 'title']
      }
    };
    function typeCheckConfig(untrustedConfig) {
      const config = typeCheckConfig$1(untrustedConfig);
      const untrustedConfig_fileData = untrustedConfig.fileData;
      if (untrustedConfig_fileData !== undefined && untrustedConfig_fileData instanceof Object) {
        config.fileData = untrustedConfig_fileData;
      }
      return config;
    }
    function validateAdapterConfig(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    const factory = luvio => {
      return function createContentVersion(untrustedConfig, requestContext) {
        const config = validateAdapterConfig(untrustedConfig, createContentVersion_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          // eslint-disable-next-line @salesforce/lds/no-error-in-production
          throw new Error('Invalid config for "createContentVersion"');
        }
        const draftAdapter = configurationForRestAdapters.getDraftAwareCreateContentVersionAdapter();
        if (draftAdapter !== undefined) {
          return draftAdapter(config, buildNetworkSnapshot$1, requestContext);
        }
        return buildNetworkSnapshot$1(luvio, config, createDispatchResourceRequestContext(requestContext));
      };
    };
    function createDispatchResourceRequestContext(requestContext) {
      let dispatchOptions = undefined;
      if (requestContext !== undefined) {
        const coercedAdapterRequestContext = luvioEngine.coerceAdapterRequestContext(requestContext);
        const {
          networkPriority,
          requestCorrelator,
          eventObservers,
          sourceContext
        } = coercedAdapterRequestContext;
        dispatchOptions = {
          resourceRequestContext: {
            requestCorrelator,
            sourceContext,
            luvioRequestMethod: undefined
          },
          eventObservers
        };
        if (networkPriority !== 'normal') {
          dispatchOptions.overrides = {
            priority: networkPriority
          };
        }
      }
      return dispatchOptions;
    }

    // TODO [W-11498005]: This should be imported from generated code once key generation is complete
    const recordRepresentationKeySchema = ['namespace', 'representationName', 'id'];
    class InMemoryRecordRepresentationQueryEvaluator {
      constructor(baseQueryEvaluator) {
        this.baseQueryEvaluator = baseQueryEvaluator;
      }
      queryByKey(keyQuery) {
        return this.baseQueryEvaluator.queryByKey(this.buildKeyQuery(keyQuery), recordRepresentationKeySchema);
      }
      queryWhere(valueQuery, keyQuery) {
        const defaultKeyQuery = {
          namespace: keyPrefix,
          representationName: RepresentationType$V,
          id: luvioEngine.Wildcard
        };
        const actualKeyQuery = keyQuery ? this.buildKeyQuery(keyQuery) : defaultKeyQuery;
        return this.baseQueryEvaluator.queryWhere(actualKeyQuery, recordRepresentationKeySchema, valueQuery);
      }
      buildKeyQuery(keyQuery) {
        // Ensure that all key queries on this class are for record representations
        return {
          id: luvioEngine.Wildcard,
          ...keyQuery,
          namespace: keyPrefix,
          representationName: RepresentationType$V
        };
      }
    }
    ({
      ...configurationForRestAdapters,
      ...configurationForGraphQLAdapters,
      ...configurationForOneStoreEnabledAdapters
    });
    ensureRegisteredOnce({
      id: '@salesforce/lds-adapters-uiapi',
      configuration: {
        ...configurationForRestAdapters,
        ...configurationForGraphQLAdapters,
        ...configurationForOneStoreEnabledAdapters
      },
      instrument
    });
    exports.createContentDocumentAndVersion = void 0;
    exports.createContentVersion = void 0;
    exports.createListInfo = void 0;
    exports.createRecord = void 0;
    exports.deleteListInfo = void 0;
    exports.deleteRecord = void 0;
    exports.executeBatchRecordOperations = void 0;
    exports.getActionOverrides = void 0;
    exports.getAllApps = void 0;
    exports.getAppDetails = void 0;
    exports.getDuplicateConfiguration = void 0;
    exports.getDuplicates = void 0;
    exports.getFlexipageFormulaOverrides = void 0;
    exports.getGlobalActions = void 0;
    exports.getKeywordSearchResults = void 0;
    exports.getLayout = void 0;
    exports.getLayoutUserState = void 0;
    exports.getListInfoByName = void 0;
    exports.getListInfosByName = void 0;
    exports.getListInfosByObjectName = void 0;
    exports.getListObjectInfo = void 0;
    exports.getListPreferences = void 0;
    exports.getListRecordsByName = void 0;
    exports.getListUi = void 0;
    exports.getLookupActions = void 0;
    exports.getLookupMetadata = void 0;
    exports.getLookupRecords = void 0;
    exports.getNavItems = void 0;
    exports.getObjectCreateActions = void 0;
    exports.getObjectInfo = void 0;
    exports.getObjectInfos = void 0;
    exports.getPathLayout = void 0;
    exports.getPicklistValues = void 0;
    exports.getPicklistValuesByRecordType = void 0;
    exports.getQuickActionDefaults = void 0;
    exports.getQuickActionInfo = void 0;
    exports.getQuickActionLayout = void 0;
    exports.getRecord = void 0;
    exports.getRecordActions = void 0;
    exports.getRecordAvatars = void 0;
    exports.getRecordCreateDefaults = void 0;
    exports.getRecordEditActions = void 0;
    exports.getRecordTemplateClone = void 0;
    exports.getRecordTemplateCreate = void 0;
    exports.getRecordUi = void 0;
    exports.getRecords = void 0;
    exports.getRelatedListActions = void 0;
    exports.getRelatedListCount = void 0;
    exports.getRelatedListInfo = void 0;
    exports.getRelatedListInfoBatch = void 0;
    exports.getRelatedListPreferences = void 0;
    exports.getRelatedListPreferencesBatch = void 0;
    exports.getRelatedListRecordActions = void 0;
    exports.getRelatedListRecords = void 0;
    exports.getRelatedListRecordsBatch = void 0;
    exports.getRelatedListsActions = void 0;
    exports.getRelatedListsCount = void 0;
    exports.getRelatedListsInfo = void 0;
    exports.getSearchFilterMetadata = void 0;
    exports.getSearchFilterOptions = void 0;
    exports.getSearchResults = void 0;
    exports.performQuickAction = void 0;
    exports.performUpdateRecordQuickAction = void 0;
    exports.updateListInfoByName = void 0;
    exports.updateListPreferences = void 0;
    exports.updateRecord = void 0;
    exports.updateRecordAvatar = void 0;
    // Imperative GET Adapters
    exports.getActionOverrides_imperative = void 0;
    exports.getAllApps_imperative = void 0;
    exports.getAppDetails_imperative = void 0;
    exports.getDuplicateConfiguration_imperative = void 0;
    exports.getDuplicates_imperative = void 0;
    exports.getFlexipageFormulaOverrides_imperative = void 0;
    exports.getGlobalActions_imperative = void 0;
    exports.getKeywordSearchResults_imperative = void 0;
    exports.getLayout_imperative = void 0;
    exports.getLayoutUserState_imperative = void 0;
    exports.getListInfoByName_imperative = void 0;
    exports.getListInfosByName_imperative = void 0;
    exports.getListInfosByObjectName_imperative = void 0;
    exports.getListObjectInfo_imperative = void 0;
    exports.getListPreferences_imperative = void 0;
    exports.getListRecordsByName_imperative = void 0;
    exports.getListUi_imperative = void 0;
    exports.getLookupActions_imperative = void 0;
    exports.getLookupMetadata_imperative = void 0;
    exports.getLookupRecords_imperative = void 0;
    exports.getNavItems_imperative = void 0;
    exports.getObjectCreateActions_imperative = void 0;
    exports.getObjectInfo_imperative = void 0;
    exports.getObjectInfos_imperative = void 0;
    exports.getPathLayout_imperative = void 0;
    exports.getPicklistValues_imperative = void 0;
    exports.getPicklistValuesByRecordType_imperative = void 0;
    exports.getQuickActionDefaults_imperative = void 0;
    exports.getQuickActionInfo_imperative = void 0;
    exports.getQuickActionLayout_imperative = void 0;
    exports.getRecord_imperative = void 0;
    exports.getRecordActions_imperative = void 0;
    exports.getRecordAvatars_imperative = void 0;
    exports.getRecordCreateDefaults_imperative = void 0;
    exports.getRecordEditActions_imperative = void 0;
    exports.getRecordTemplateClone_imperative = void 0;
    exports.getRecordTemplateCreate_imperative = void 0;
    exports.getRecordUi_imperative = void 0;
    exports.getRecords_imperative = void 0;
    exports.getRelatedListActions_imperative = void 0;
    exports.getRelatedListCount_imperative = void 0;
    exports.getRelatedListInfo_imperative = void 0;
    exports.getRelatedListInfoBatch_imperative = void 0;
    exports.getRelatedListPreferences_imperative = void 0;
    exports.getRelatedListPreferencesBatch_imperative = void 0;
    exports.getRelatedListRecordActions_imperative = void 0;
    exports.getRelatedListRecords_imperative = void 0;
    exports.getRelatedListRecordsBatch_imperative = void 0;
    exports.getRelatedListsActions_imperative = void 0;
    exports.getRelatedListsCount_imperative = void 0;
    exports.getRelatedListsInfo_imperative = void 0;
    exports.getSearchFilterMetadata_imperative = void 0;
    exports.getSearchFilterOptions_imperative = void 0;
    exports.getSearchResults_imperative = void 0;
    // Adapter Metadata
    const getActionOverridesMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$V
    };
    const getAllAppsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$M,
      ttl: 300000
    };
    const getAppDetailsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$L,
      ttl: 300000
    };
    const getDuplicateConfigurationMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$K,
      ttl: 900000
    };
    const getDuplicatesMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$s,
      ttl: 30000
    };
    const getFlexipageFormulaOverridesMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$U,
      ttl: 300000
    };
    const getGlobalActionsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$Z,
      ttl: 300000
    };
    const getKeywordSearchResultsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$a,
      ttl: 200
    };
    const getLayoutMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$J,
      ttl: 900000
    };
    const getLayoutUserStateMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$I,
      ttl: 900000
    };
    const getListInfoByNameMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$D,
      ttl: 900000
    };
    const getListInfosByNameMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$H
    };
    const getListInfosByObjectNameMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$G
    };
    const getListObjectInfoMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$B,
      ttl: 900000
    };
    const getListPreferencesMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$A,
      ttl: 900000
    };
    const getListRecordsByNameMetadata = {
      apiFamily: keyPrefix,
      name: 'getListRecordsByName',
      ttl: 30000
    };
    const getListUiMetadata = {
      apiFamily: keyPrefix,
      name: 'getListUi',
      ttl: 900000
    };
    const getLookupActionsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$X,
      ttl: 300000
    };
    const getLookupMetadataMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$c,
      ttl: 30000
    };
    const getLookupRecordsMetadata = {
      apiFamily: keyPrefix,
      name: 'getLookupRecords'
    };
    const getNavItemsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$y,
      ttl: 120000
    };
    const getObjectCreateActionsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$W,
      ttl: 300000
    };
    const getObjectInfoMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$_,
      ttl: 900000
    };
    const getObjectInfosMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$w
    };
    const getPathLayoutMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$t,
      ttl: 900000
    };
    const getPicklistValuesMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$u,
      ttl: 900000
    };
    const getPicklistValuesByRecordTypeMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$v,
      ttl: 300000
    };
    const getQuickActionDefaultsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$S,
      ttl: 900000
    };
    const getQuickActionInfoMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$T,
      ttl: 900000
    };
    const getQuickActionLayoutMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$Y,
      ttl: 900000
    };
    const getRecordMetadata = {
      apiFamily: keyPrefix,
      name: 'getRecord',
      ttl: 30000
    };
    const getRecordActionsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$R,
      ttl: 300000
    };
    const getRecordAvatarsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$r,
      ttl: 1800000
    };
    const getRecordCreateDefaultsMetadata = {
      apiFamily: keyPrefix,
      name: 'getRecordCreateDefaults',
      ttl: 900000
    };
    const getRecordEditActionsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$Q,
      ttl: 300000
    };
    const getRecordTemplateCloneMetadata = {
      apiFamily: keyPrefix,
      name: 'getRecordTemplateClone',
      ttl: 1000
    };
    const getRecordTemplateCreateMetadata = {
      apiFamily: keyPrefix,
      name: 'getRecordTemplateCreate',
      ttl: 900000
    };
    const getRecordUiMetadata = {
      apiFamily: keyPrefix,
      name: 'getRecordUi',
      ttl: 900000
    };
    const getRecordsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$q
    };
    const getRelatedListActionsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$O,
      ttl: 300000
    };
    const getRelatedListCountMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$o
    };
    const getRelatedListInfoMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$l,
      ttl: 900000
    };
    const getRelatedListInfoBatchMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$n
    };
    const getRelatedListPreferencesMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$i,
      ttl: 900000
    };
    const getRelatedListPreferencesBatchMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$j
    };
    const getRelatedListRecordActionsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$N,
      ttl: 300000
    };
    const getRelatedListRecordsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$f,
      ttl: 30000
    };
    const getRelatedListRecordsBatchMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$g
    };
    const getRelatedListsActionsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$P
    };
    const getRelatedListsCountMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$p
    };
    const getRelatedListsInfoMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$m
    };
    const getSearchFilterMetadataMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$e,
      ttl: 30000
    };
    const getSearchFilterOptionsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$d,
      ttl: 30000
    };
    const getSearchResultsMetadata = {
      apiFamily: keyPrefix,
      name: adapterName$b,
      ttl: 200
    };
    function bindExportsTo(luvio) {
      // LDS adapters
      const getActionOverrides_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getActionOverrides', getActionOverridesAdapterFactory), getActionOverridesMetadata);
      const getAllApps_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getAllApps', getAllAppsAdapterFactory), getAllAppsMetadata);
      const getAppDetails_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getAppDetails', getAppDetailsAdapterFactory), getAppDetailsMetadata);
      const getDuplicateConfiguration_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getDuplicateConfiguration', getDuplicateConfigurationAdapterFactory), getDuplicateConfigurationMetadata);
      const getDuplicates_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getDuplicates', getDuplicatesAdapterFactory), getDuplicatesMetadata);
      const getFlexipageFormulaOverrides_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getFlexipageFormulaOverrides', getFlexipageFormulaOverridesAdapterFactory), getFlexipageFormulaOverridesMetadata);
      const getGlobalActions_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getGlobalActions', getGlobalActionsAdapterFactory), getGlobalActionsMetadata);
      const getKeywordSearchResults_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getKeywordSearchResults', getKeywordSearchResultsAdapterFactory), getKeywordSearchResultsMetadata);
      const getLayout_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getLayout', getLayoutAdapterFactory), getLayoutMetadata);
      const getLayoutUserState_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getLayoutUserState', getLayoutUserStateAdapterFactory), getLayoutUserStateMetadata);
      const getListInfoByName_ldsAdapter = ldsBindings.createInstrumentedAdapter(createLDSAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getListInfoByName', getListInfoByNameAdapterFactory), luvio, 'getListInfoByName'), getListInfoByNameMetadata);
      const getListInfosByName_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getListInfosByName', getListInfosByNameAdapterFactory), getListInfosByNameMetadata);
      const getListInfosByObjectName_ldsAdapter = ldsBindings.createInstrumentedAdapter(createLDSAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getListInfosByObjectName', getListInfosByObjectNameAdapterFactory), luvio, 'getListInfosByObjectName'), getListInfosByObjectNameMetadata);
      const getListObjectInfo_ldsAdapter = ldsBindings.createInstrumentedAdapter(createLDSAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getListObjectInfo', getListObjectInfoAdapterFactory), luvio, 'getListObjectInfo'), getListObjectInfoMetadata);
      const getListPreferences_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getListPreferences', getListPreferencesAdapterFactory), getListPreferencesMetadata);
      const getListRecordsByName_ldsAdapter = ldsBindings.createInstrumentedAdapter(createLDSAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getListRecordsByName', factory$a), luvio, 'getListRecordsByName'), getListRecordsByNameMetadata);
      const getListUi_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getListUi', factory$h), getListUiMetadata);
      const getLookupActions_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getLookupActions', getLookupActionsAdapterFactory), getLookupActionsMetadata);
      const getLookupMetadata_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getLookupMetadata', getLookupMetadataAdapterFactory), getLookupMetadataMetadata);
      const getLookupRecords_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getLookupRecords', factory$9), getLookupRecordsMetadata);
      const getNavItems_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getNavItems', getNavItemsAdapterFactory), getNavItemsMetadata);
      const getObjectCreateActions_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getObjectCreateActions', getObjectCreateActionsAdapterFactory), getObjectCreateActionsMetadata);
      const getObjectInfo_ldsAdapter = ldsBindings.createInstrumentedAdapter(createLDSAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getObjectInfo', getObjectInfoAdapterFactory), luvio, 'getObjectInfo'), getObjectInfoMetadata);
      const getObjectInfos_ldsAdapter = ldsBindings.createInstrumentedAdapter(createLDSAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getObjectInfos', getObjectInfosAdapterFactory), luvio, 'getObjectInfos'), getObjectInfosMetadata);
      const getPathLayout_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getPathLayout', getPathLayoutAdapterFactory), getPathLayoutMetadata);
      const getPicklistValues_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getPicklistValues', getPicklistValuesAdapterFactory), getPicklistValuesMetadata);
      const getPicklistValuesByRecordType_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getPicklistValuesByRecordType', getPicklistValuesByRecordTypeAdapterFactory), getPicklistValuesByRecordTypeMetadata);
      const getQuickActionDefaults_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getQuickActionDefaults', getQuickActionDefaultsAdapterFactory), getQuickActionDefaultsMetadata);
      const getQuickActionInfo_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getQuickActionInfo', getQuickActionInfoAdapterFactory), getQuickActionInfoMetadata);
      const getQuickActionLayout_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getQuickActionLayout', getQuickActionLayoutAdapterFactory), getQuickActionLayoutMetadata);
      const getRecord_ldsAdapter = ldsBindings.createInstrumentedAdapter(createLDSAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getRecord', factory$f), luvio, 'getRecord'), getRecordMetadata);
      const getRecordActions_ldsAdapter = ldsBindings.createInstrumentedAdapter(createLDSAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getRecordActions', getRecordActionsAdapterFactory), luvio, 'getRecordActions'), getRecordActionsMetadata);
      const getRecordAvatars_ldsAdapter = ldsBindings.createInstrumentedAdapter(createLDSAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getRecordAvatars', getRecordAvatarsAdapterFactory), luvio, 'getRecordAvatars'), getRecordAvatarsMetadata);
      const getRecordCreateDefaults_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRecordCreateDefaults', factory$7), getRecordCreateDefaultsMetadata);
      const getRecordEditActions_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRecordEditActions', getRecordEditActionsAdapterFactory), getRecordEditActionsMetadata);
      const getRecordTemplateClone_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRecordTemplateClone', factory$6), getRecordTemplateCloneMetadata);
      const getRecordTemplateCreate_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRecordTemplateCreate', factory$5), getRecordTemplateCreateMetadata);
      const getRecordUi_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRecordUi', factory$g), getRecordUiMetadata);
      const getRecords_ldsAdapter = ldsBindings.createInstrumentedAdapter(createLDSAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getRecords', getRecordsAdapterFactory), luvio, 'getRecords'), getRecordsMetadata);
      const getRelatedListActions_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRelatedListActions', getRelatedListActionsAdapterFactory), getRelatedListActionsMetadata);
      const getRelatedListCount_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRelatedListCount', getRelatedListCountAdapterFactory), getRelatedListCountMetadata);
      const getRelatedListInfo_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRelatedListInfo', getRelatedListInfoAdapterFactory), getRelatedListInfoMetadata);
      const getRelatedListInfoBatch_ldsAdapter = ldsBindings.createInstrumentedAdapter(createRelatedListAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getRelatedListInfoBatch', getRelatedListInfoBatchAdapterFactory), luvio, 'getRelatedListInfoBatch'), getRelatedListInfoBatchMetadata);
      const getRelatedListPreferences_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRelatedListPreferences', getRelatedListPreferencesAdapterFactory), getRelatedListPreferencesMetadata);
      const getRelatedListPreferencesBatch_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRelatedListPreferencesBatch', getRelatedListPreferencesBatchAdapterFactory), getRelatedListPreferencesBatchMetadata);
      const getRelatedListRecordActions_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRelatedListRecordActions', getRelatedListRecordActionsAdapterFactory), getRelatedListRecordActionsMetadata);
      const getRelatedListRecords_ldsAdapter = ldsBindings.createInstrumentedAdapter(createRelatedListAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getRelatedListRecords', getRelatedListRecordsAdapterFactory), luvio, 'getRelatedListRecords'), getRelatedListRecordsMetadata);
      const getRelatedListRecordsBatch_ldsAdapter = ldsBindings.createInstrumentedAdapter(createRelatedListAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getRelatedListRecordsBatch', getRelatedListRecordsBatchAdapterFactory), luvio, 'getRelatedListRecordsBatch'), getRelatedListRecordsBatchMetadata);
      const getRelatedListsActions_ldsAdapter = ldsBindings.createInstrumentedAdapter(createRelatedListAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, 'getRelatedListsActions', getRelatedListsActionsAdapterFactory), luvio, 'getRelatedListsActions'), getRelatedListsActionsMetadata);
      const getRelatedListsCount_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRelatedListsCount', getRelatedListsCountAdapterFactory), getRelatedListsCountMetadata);
      const getRelatedListsInfo_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getRelatedListsInfo', getRelatedListsInfoAdapterFactory), getRelatedListsInfoMetadata);
      const getSearchFilterMetadata_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getSearchFilterMetadata', getSearchFilterMetadataAdapterFactory), getSearchFilterMetadataMetadata);
      const getSearchFilterOptions_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getSearchFilterOptions', getSearchFilterOptionsAdapterFactory), getSearchFilterOptionsMetadata);
      const getSearchResults_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getSearchResults', getSearchResultsAdapterFactory), getSearchResultsMetadata);
      function unwrapSnapshotData(factory) {
        const adapter = factory(luvio);
        return (...config) => adapter(...config).then(snapshot => snapshot.data);
      }
      return {
        // Wire Adapters
        createContentDocumentAndVersion: unwrapSnapshotData(factory$1),
        createContentVersion: unwrapSnapshotData(factory),
        createListInfo: ldsBindings.createLDSAdapter(luvio, adapterName$F, createListInfoAdapterFactory),
        createRecord: unwrapSnapshotData(factory$4),
        deleteListInfo: ldsBindings.createLDSAdapter(luvio, adapterName$E, deleteListInfoAdapterFactory),
        deleteRecord: ldsBindings.createLDSAdapter(luvio, 'deleteRecord', factory$3),
        executeBatchRecordOperations: unwrapSnapshotData(factory$e),
        getActionOverrides: ldsBindings.createWireAdapterConstructor(luvio, getActionOverrides_ldsAdapter, getActionOverridesMetadata),
        getAllApps: ldsBindings.createWireAdapterConstructor(luvio, getAllApps_ldsAdapter, getAllAppsMetadata),
        getAppDetails: ldsBindings.createWireAdapterConstructor(luvio, getAppDetails_ldsAdapter, getAppDetailsMetadata),
        getDuplicateConfiguration: ldsBindings.createWireAdapterConstructor(luvio, getDuplicateConfiguration_ldsAdapter, getDuplicateConfigurationMetadata),
        getDuplicates: ldsBindings.createWireAdapterConstructor(luvio, getDuplicates_ldsAdapter, getDuplicatesMetadata),
        getFlexipageFormulaOverrides: ldsBindings.createWireAdapterConstructor(luvio, getFlexipageFormulaOverrides_ldsAdapter, getFlexipageFormulaOverridesMetadata),
        getGlobalActions: ldsBindings.createWireAdapterConstructor(luvio, getGlobalActions_ldsAdapter, getGlobalActionsMetadata),
        getKeywordSearchResults: ldsBindings.createWireAdapterConstructor(luvio, getKeywordSearchResults_ldsAdapter, getKeywordSearchResultsMetadata),
        getLayout: ldsBindings.createWireAdapterConstructor(luvio, getLayout_ldsAdapter, getLayoutMetadata),
        getLayoutUserState: ldsBindings.createWireAdapterConstructor(luvio, getLayoutUserState_ldsAdapter, getLayoutUserStateMetadata),
        getListInfoByName: ldsBindings.createWireAdapterConstructor(luvio, getListInfoByName_ldsAdapter, getListInfoByNameMetadata),
        getListInfosByName: ldsBindings.createWireAdapterConstructor(luvio, getListInfosByName_ldsAdapter, getListInfosByNameMetadata),
        getListInfosByObjectName: ldsBindings.createWireAdapterConstructor(luvio, getListInfosByObjectName_ldsAdapter, getListInfosByObjectNameMetadata),
        getListObjectInfo: ldsBindings.createWireAdapterConstructor(luvio, getListObjectInfo_ldsAdapter, getListObjectInfoMetadata),
        getListPreferences: ldsBindings.createWireAdapterConstructor(luvio, getListPreferences_ldsAdapter, getListPreferencesMetadata),
        getListRecordsByName: ldsBindings.createInfiniteScrollingWireAdapterConstructor(luvio, getListRecordsByName_ldsAdapter, getListRecordsByNameMetadata),
        getListUi: ldsBindings.createInfiniteScrollingWireAdapterConstructor(luvio, getListUi_ldsAdapter, getListUiMetadata),
        getLookupActions: ldsBindings.createWireAdapterConstructor(luvio, getLookupActions_ldsAdapter, getLookupActionsMetadata),
        getLookupMetadata: ldsBindings.createWireAdapterConstructor(luvio, getLookupMetadata_ldsAdapter, getLookupMetadataMetadata),
        getLookupRecords: ldsBindings.createWireAdapterConstructor(luvio, getLookupRecords_ldsAdapter, getLookupRecordsMetadata),
        getNavItems: ldsBindings.createWireAdapterConstructor(luvio, getNavItems_ldsAdapter, getNavItemsMetadata),
        getObjectCreateActions: ldsBindings.createWireAdapterConstructor(luvio, getObjectCreateActions_ldsAdapter, getObjectCreateActionsMetadata),
        getPathLayout: ldsBindings.createWireAdapterConstructor(luvio, getPathLayout_ldsAdapter, getPathLayoutMetadata),
        getPicklistValues: ldsBindings.createWireAdapterConstructor(luvio, getPicklistValues_ldsAdapter, getPicklistValuesMetadata),
        getPicklistValuesByRecordType: ldsBindings.createWireAdapterConstructor(luvio, getPicklistValuesByRecordType_ldsAdapter, getPicklistValuesByRecordTypeMetadata),
        getQuickActionDefaults: ldsBindings.createWireAdapterConstructor(luvio, getQuickActionDefaults_ldsAdapter, getQuickActionDefaultsMetadata),
        getQuickActionInfo: ldsBindings.createWireAdapterConstructor(luvio, getQuickActionInfo_ldsAdapter, getQuickActionInfoMetadata),
        getQuickActionLayout: ldsBindings.createWireAdapterConstructor(luvio, getQuickActionLayout_ldsAdapter, getQuickActionLayoutMetadata),
        getRecord: ldsBindings.createWireAdapterConstructor(luvio, getRecord_ldsAdapter, getRecordMetadata),
        getRecordActions: ldsBindings.createWireAdapterConstructor(luvio, getRecordActions_ldsAdapter, getRecordActionsMetadata),
        getRecordAvatars: ldsBindings.createWireAdapterConstructor(luvio, getRecordAvatars_ldsAdapter, getRecordAvatarsMetadata),
        getRecordCreateDefaults: ldsBindings.createWireAdapterConstructor(luvio, getRecordCreateDefaults_ldsAdapter, getRecordCreateDefaultsMetadata),
        getRecordEditActions: ldsBindings.createWireAdapterConstructor(luvio, getRecordEditActions_ldsAdapter, getRecordEditActionsMetadata),
        getRecordTemplateClone: ldsBindings.createWireAdapterConstructor(luvio, getRecordTemplateClone_ldsAdapter, getRecordTemplateCloneMetadata),
        getRecordTemplateCreate: ldsBindings.createWireAdapterConstructor(luvio, getRecordTemplateCreate_ldsAdapter, getRecordTemplateCreateMetadata),
        getRecordUi: ldsBindings.createWireAdapterConstructor(luvio, getRecordUi_ldsAdapter, getRecordUiMetadata),
        getRecords: ldsBindings.createWireAdapterConstructor(luvio, getRecords_ldsAdapter, getRecordsMetadata),
        getRelatedListActions: ldsBindings.createWireAdapterConstructor(luvio, getRelatedListActions_ldsAdapter, getRelatedListActionsMetadata),
        getRelatedListCount: ldsBindings.createWireAdapterConstructor(luvio, getRelatedListCount_ldsAdapter, getRelatedListCountMetadata),
        getRelatedListInfo: ldsBindings.createWireAdapterConstructor(luvio, getRelatedListInfo_ldsAdapter, getRelatedListInfoMetadata),
        getRelatedListInfoBatch: ldsBindings.createWireAdapterConstructor(luvio, getRelatedListInfoBatch_ldsAdapter, getRelatedListInfoBatchMetadata),
        getRelatedListPreferences: ldsBindings.createWireAdapterConstructor(luvio, getRelatedListPreferences_ldsAdapter, getRelatedListPreferencesMetadata),
        getRelatedListPreferencesBatch: ldsBindings.createWireAdapterConstructor(luvio, getRelatedListPreferencesBatch_ldsAdapter, getRelatedListPreferencesBatchMetadata),
        getRelatedListRecordActions: ldsBindings.createWireAdapterConstructor(luvio, getRelatedListRecordActions_ldsAdapter, getRelatedListRecordActionsMetadata),
        getRelatedListRecords: ldsBindings.createInfiniteScrollingWireAdapterConstructor(luvio, getRelatedListRecords_ldsAdapter, getRelatedListRecordsMetadata),
        getRelatedListRecordsBatch: ldsBindings.createWireAdapterConstructor(luvio, getRelatedListRecordsBatch_ldsAdapter, getRelatedListRecordsBatchMetadata),
        getRelatedListsActions: ldsBindings.createWireAdapterConstructor(luvio, getRelatedListsActions_ldsAdapter, getRelatedListsActionsMetadata),
        getRelatedListsCount: ldsBindings.createWireAdapterConstructor(luvio, getRelatedListsCount_ldsAdapter, getRelatedListsCountMetadata),
        getRelatedListsInfo: ldsBindings.createWireAdapterConstructor(luvio, getRelatedListsInfo_ldsAdapter, getRelatedListsInfoMetadata),
        getSearchFilterMetadata: ldsBindings.createWireAdapterConstructor(luvio, getSearchFilterMetadata_ldsAdapter, getSearchFilterMetadataMetadata),
        getSearchFilterOptions: ldsBindings.createWireAdapterConstructor(luvio, getSearchFilterOptions_ldsAdapter, getSearchFilterOptionsMetadata),
        getSearchResults: ldsBindings.createWireAdapterConstructor(luvio, getSearchResults_ldsAdapter, getSearchResultsMetadata),
        performQuickAction: unwrapSnapshotData(factory$c),
        performUpdateRecordQuickAction: unwrapSnapshotData(factory$d),
        updateListInfoByName: ldsBindings.createLDSAdapter(luvio, adapterName$C, updateListInfoByNameAdapterFactory),
        updateListPreferences: ldsBindings.createLDSAdapter(luvio, adapterName$z, updateListPreferencesAdapterFactory),
        updateRecord: unwrapSnapshotData(factory$2),
        updateRecordAvatar: unwrapSnapshotData(factory$8),
        // One Store Enabled Adapters
        getObjectInfo: getLuvioOrOneStoreAdapter(ldsBindings.createWireAdapterConstructor(luvio, getObjectInfo_ldsAdapter, getObjectInfoMetadata), configurationForOneStoreEnabledAdapters.getGetObjectInfoAdapter()),
        getObjectInfos: getLuvioOrOneStoreAdapter(ldsBindings.createWireAdapterConstructor(luvio, getObjectInfos_ldsAdapter, getObjectInfosMetadata), configurationForOneStoreEnabledAdapters.getGetObjectInfosAdapter()),
        // Imperative Adapters
        getActionOverrides_imperative: ldsBindings.createImperativeAdapter(luvio, getActionOverrides_ldsAdapter, getActionOverridesMetadata),
        getAllApps_imperative: ldsBindings.createImperativeAdapter(luvio, getAllApps_ldsAdapter, getAllAppsMetadata),
        getAppDetails_imperative: ldsBindings.createImperativeAdapter(luvio, getAppDetails_ldsAdapter, getAppDetailsMetadata),
        getDuplicateConfiguration_imperative: ldsBindings.createImperativeAdapter(luvio, getDuplicateConfiguration_ldsAdapter, getDuplicateConfigurationMetadata),
        getDuplicates_imperative: ldsBindings.createImperativeAdapter(luvio, getDuplicates_ldsAdapter, getDuplicatesMetadata),
        getFlexipageFormulaOverrides_imperative: ldsBindings.createImperativeAdapter(luvio, getFlexipageFormulaOverrides_ldsAdapter, getFlexipageFormulaOverridesMetadata),
        getGlobalActions_imperative: ldsBindings.createImperativeAdapter(luvio, getGlobalActions_ldsAdapter, getGlobalActionsMetadata),
        getKeywordSearchResults_imperative: ldsBindings.createImperativeAdapter(luvio, getKeywordSearchResults_ldsAdapter, getKeywordSearchResultsMetadata),
        getLayout_imperative: ldsBindings.createImperativeAdapter(luvio, getLayout_ldsAdapter, getLayoutMetadata),
        getLayoutUserState_imperative: ldsBindings.createImperativeAdapter(luvio, getLayoutUserState_ldsAdapter, getLayoutUserStateMetadata),
        getListInfoByName_imperative: ldsBindings.createImperativeAdapter(luvio, getListInfoByName_ldsAdapter, getListInfoByNameMetadata),
        getListInfosByName_imperative: ldsBindings.createImperativeAdapter(luvio, getListInfosByName_ldsAdapter, getListInfosByNameMetadata),
        getListInfosByObjectName_imperative: ldsBindings.createImperativeAdapter(luvio, getListInfosByObjectName_ldsAdapter, getListInfosByObjectNameMetadata),
        getListObjectInfo_imperative: ldsBindings.createImperativeAdapter(luvio, getListObjectInfo_ldsAdapter, getListObjectInfoMetadata),
        getListPreferences_imperative: ldsBindings.createImperativeAdapter(luvio, getListPreferences_ldsAdapter, getListPreferencesMetadata),
        getListRecordsByName_imperative: ldsBindings.createImperativeAdapter(luvio, getListRecordsByName_ldsAdapter, getListRecordsByNameMetadata),
        getListUi_imperative: ldsBindings.createImperativeAdapter(luvio, getListUi_ldsAdapter, getListUiMetadata),
        getLookupActions_imperative: ldsBindings.createImperativeAdapter(luvio, getLookupActions_ldsAdapter, getLookupActionsMetadata),
        getLookupMetadata_imperative: ldsBindings.createImperativeAdapter(luvio, getLookupMetadata_ldsAdapter, getLookupMetadataMetadata),
        getLookupRecords_imperative: ldsBindings.createImperativeAdapter(luvio, getLookupRecords_ldsAdapter, getLookupRecordsMetadata),
        getNavItems_imperative: ldsBindings.createImperativeAdapter(luvio, getNavItems_ldsAdapter, getNavItemsMetadata),
        getObjectCreateActions_imperative: ldsBindings.createImperativeAdapter(luvio, getObjectCreateActions_ldsAdapter, getObjectCreateActionsMetadata),
        getObjectInfo_imperative: ldsBindings.createImperativeAdapter(luvio, getObjectInfo_ldsAdapter, getObjectInfoMetadata),
        getObjectInfos_imperative: ldsBindings.createImperativeAdapter(luvio, getObjectInfos_ldsAdapter, getObjectInfosMetadata),
        getPathLayout_imperative: ldsBindings.createImperativeAdapter(luvio, getPathLayout_ldsAdapter, getPathLayoutMetadata),
        getPicklistValues_imperative: ldsBindings.createImperativeAdapter(luvio, getPicklistValues_ldsAdapter, getPicklistValuesMetadata),
        getPicklistValuesByRecordType_imperative: ldsBindings.createImperativeAdapter(luvio, getPicklistValuesByRecordType_ldsAdapter, getPicklistValuesByRecordTypeMetadata),
        getQuickActionDefaults_imperative: ldsBindings.createImperativeAdapter(luvio, getQuickActionDefaults_ldsAdapter, getQuickActionDefaultsMetadata),
        getQuickActionInfo_imperative: ldsBindings.createImperativeAdapter(luvio, getQuickActionInfo_ldsAdapter, getQuickActionInfoMetadata),
        getQuickActionLayout_imperative: ldsBindings.createImperativeAdapter(luvio, getQuickActionLayout_ldsAdapter, getQuickActionLayoutMetadata),
        getRecord_imperative: ldsBindings.createImperativeAdapter(luvio, getRecord_ldsAdapter, getRecordMetadata),
        getRecordActions_imperative: ldsBindings.createImperativeAdapter(luvio, getRecordActions_ldsAdapter, getRecordActionsMetadata),
        getRecordAvatars_imperative: ldsBindings.createImperativeAdapter(luvio, getRecordAvatars_ldsAdapter, getRecordAvatarsMetadata),
        getRecordCreateDefaults_imperative: ldsBindings.createImperativeAdapter(luvio, getRecordCreateDefaults_ldsAdapter, getRecordCreateDefaultsMetadata),
        getRecordEditActions_imperative: ldsBindings.createImperativeAdapter(luvio, getRecordEditActions_ldsAdapter, getRecordEditActionsMetadata),
        getRecordTemplateClone_imperative: ldsBindings.createImperativeAdapter(luvio, getRecordTemplateClone_ldsAdapter, getRecordTemplateCloneMetadata),
        getRecordTemplateCreate_imperative: ldsBindings.createImperativeAdapter(luvio, getRecordTemplateCreate_ldsAdapter, getRecordTemplateCreateMetadata),
        getRecordUi_imperative: ldsBindings.createImperativeAdapter(luvio, getRecordUi_ldsAdapter, getRecordUiMetadata),
        getRecords_imperative: ldsBindings.createImperativeAdapter(luvio, getRecords_ldsAdapter, getRecordsMetadata),
        getRelatedListActions_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListActions_ldsAdapter, getRelatedListActionsMetadata),
        getRelatedListCount_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListCount_ldsAdapter, getRelatedListCountMetadata),
        getRelatedListInfo_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListInfo_ldsAdapter, getRelatedListInfoMetadata),
        getRelatedListInfoBatch_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListInfoBatch_ldsAdapter, getRelatedListInfoBatchMetadata),
        getRelatedListPreferences_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListPreferences_ldsAdapter, getRelatedListPreferencesMetadata),
        getRelatedListPreferencesBatch_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListPreferencesBatch_ldsAdapter, getRelatedListPreferencesBatchMetadata),
        getRelatedListRecordActions_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListRecordActions_ldsAdapter, getRelatedListRecordActionsMetadata),
        getRelatedListRecords_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListRecords_ldsAdapter, getRelatedListRecordsMetadata),
        getRelatedListRecordsBatch_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListRecordsBatch_ldsAdapter, getRelatedListRecordsBatchMetadata),
        getRelatedListsActions_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListsActions_ldsAdapter, getRelatedListsActionsMetadata),
        getRelatedListsCount_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListsCount_ldsAdapter, getRelatedListsCountMetadata),
        getRelatedListsInfo_imperative: ldsBindings.createImperativeAdapter(luvio, getRelatedListsInfo_ldsAdapter, getRelatedListsInfoMetadata),
        getSearchFilterMetadata_imperative: ldsBindings.createImperativeAdapter(luvio, getSearchFilterMetadata_ldsAdapter, getSearchFilterMetadataMetadata),
        getSearchFilterOptions_imperative: ldsBindings.createImperativeAdapter(luvio, getSearchFilterOptions_ldsAdapter, getSearchFilterOptionsMetadata),
        getSearchResults_imperative: ldsBindings.createImperativeAdapter(luvio, getSearchResults_ldsAdapter, getSearchResultsMetadata)
      };
    }
    ldsEngine.withDefaultLuvio(luvio => {
      ({
        createContentDocumentAndVersion: exports.createContentDocumentAndVersion,
        createContentVersion: exports.createContentVersion,
        createListInfo: exports.createListInfo,
        createRecord: exports.createRecord,
        deleteListInfo: exports.deleteListInfo,
        deleteRecord: exports.deleteRecord,
        executeBatchRecordOperations: exports.executeBatchRecordOperations,
        getActionOverrides: exports.getActionOverrides,
        getAllApps: exports.getAllApps,
        getAppDetails: exports.getAppDetails,
        getDuplicateConfiguration: exports.getDuplicateConfiguration,
        getDuplicates: exports.getDuplicates,
        getFlexipageFormulaOverrides: exports.getFlexipageFormulaOverrides,
        getGlobalActions: exports.getGlobalActions,
        getKeywordSearchResults: exports.getKeywordSearchResults,
        getLayout: exports.getLayout,
        getLayoutUserState: exports.getLayoutUserState,
        getListInfoByName: exports.getListInfoByName,
        getListInfosByName: exports.getListInfosByName,
        getListInfosByObjectName: exports.getListInfosByObjectName,
        getListObjectInfo: exports.getListObjectInfo,
        getListPreferences: exports.getListPreferences,
        getListRecordsByName: exports.getListRecordsByName,
        getListUi: exports.getListUi,
        getLookupActions: exports.getLookupActions,
        getLookupMetadata: exports.getLookupMetadata,
        getLookupRecords: exports.getLookupRecords,
        getNavItems: exports.getNavItems,
        getObjectCreateActions: exports.getObjectCreateActions,
        getObjectInfo: exports.getObjectInfo,
        getObjectInfos: exports.getObjectInfos,
        getPathLayout: exports.getPathLayout,
        getPicklistValues: exports.getPicklistValues,
        getPicklistValuesByRecordType: exports.getPicklistValuesByRecordType,
        getQuickActionDefaults: exports.getQuickActionDefaults,
        getQuickActionInfo: exports.getQuickActionInfo,
        getQuickActionLayout: exports.getQuickActionLayout,
        getRecord: exports.getRecord,
        getRecordActions: exports.getRecordActions,
        getRecordAvatars: exports.getRecordAvatars,
        getRecordCreateDefaults: exports.getRecordCreateDefaults,
        getRecordEditActions: exports.getRecordEditActions,
        getRecordTemplateClone: exports.getRecordTemplateClone,
        getRecordTemplateCreate: exports.getRecordTemplateCreate,
        getRecordUi: exports.getRecordUi,
        getRecords: exports.getRecords,
        getRelatedListActions: exports.getRelatedListActions,
        getRelatedListCount: exports.getRelatedListCount,
        getRelatedListInfo: exports.getRelatedListInfo,
        getRelatedListInfoBatch: exports.getRelatedListInfoBatch,
        getRelatedListPreferences: exports.getRelatedListPreferences,
        getRelatedListPreferencesBatch: exports.getRelatedListPreferencesBatch,
        getRelatedListRecordActions: exports.getRelatedListRecordActions,
        getRelatedListRecords: exports.getRelatedListRecords,
        getRelatedListRecordsBatch: exports.getRelatedListRecordsBatch,
        getRelatedListsActions: exports.getRelatedListsActions,
        getRelatedListsCount: exports.getRelatedListsCount,
        getRelatedListsInfo: exports.getRelatedListsInfo,
        getSearchFilterMetadata: exports.getSearchFilterMetadata,
        getSearchFilterOptions: exports.getSearchFilterOptions,
        getSearchResults: exports.getSearchResults,
        performQuickAction: exports.performQuickAction,
        performUpdateRecordQuickAction: exports.performUpdateRecordQuickAction,
        updateListInfoByName: exports.updateListInfoByName,
        updateListPreferences: exports.updateListPreferences,
        updateRecord: exports.updateRecord,
        updateRecordAvatar: exports.updateRecordAvatar,
        getActionOverrides_imperative: exports.getActionOverrides_imperative,
        getAllApps_imperative: exports.getAllApps_imperative,
        getAppDetails_imperative: exports.getAppDetails_imperative,
        getDuplicateConfiguration_imperative: exports.getDuplicateConfiguration_imperative,
        getDuplicates_imperative: exports.getDuplicates_imperative,
        getFlexipageFormulaOverrides_imperative: exports.getFlexipageFormulaOverrides_imperative,
        getGlobalActions_imperative: exports.getGlobalActions_imperative,
        getKeywordSearchResults_imperative: exports.getKeywordSearchResults_imperative,
        getLayout_imperative: exports.getLayout_imperative,
        getLayoutUserState_imperative: exports.getLayoutUserState_imperative,
        getListInfoByName_imperative: exports.getListInfoByName_imperative,
        getListInfosByName_imperative: exports.getListInfosByName_imperative,
        getListInfosByObjectName_imperative: exports.getListInfosByObjectName_imperative,
        getListObjectInfo_imperative: exports.getListObjectInfo_imperative,
        getListPreferences_imperative: exports.getListPreferences_imperative,
        getListRecordsByName_imperative: exports.getListRecordsByName_imperative,
        getListUi_imperative: exports.getListUi_imperative,
        getLookupActions_imperative: exports.getLookupActions_imperative,
        getLookupMetadata_imperative: exports.getLookupMetadata_imperative,
        getLookupRecords_imperative: exports.getLookupRecords_imperative,
        getNavItems_imperative: exports.getNavItems_imperative,
        getObjectCreateActions_imperative: exports.getObjectCreateActions_imperative,
        getObjectInfo_imperative: exports.getObjectInfo_imperative,
        getObjectInfos_imperative: exports.getObjectInfos_imperative,
        getPathLayout_imperative: exports.getPathLayout_imperative,
        getPicklistValues_imperative: exports.getPicklistValues_imperative,
        getPicklistValuesByRecordType_imperative: exports.getPicklistValuesByRecordType_imperative,
        getQuickActionDefaults_imperative: exports.getQuickActionDefaults_imperative,
        getQuickActionInfo_imperative: exports.getQuickActionInfo_imperative,
        getQuickActionLayout_imperative: exports.getQuickActionLayout_imperative,
        getRecord_imperative: exports.getRecord_imperative,
        getRecordActions_imperative: exports.getRecordActions_imperative,
        getRecordAvatars_imperative: exports.getRecordAvatars_imperative,
        getRecordCreateDefaults_imperative: exports.getRecordCreateDefaults_imperative,
        getRecordEditActions_imperative: exports.getRecordEditActions_imperative,
        getRecordTemplateClone_imperative: exports.getRecordTemplateClone_imperative,
        getRecordTemplateCreate_imperative: exports.getRecordTemplateCreate_imperative,
        getRecordUi_imperative: exports.getRecordUi_imperative,
        getRecords_imperative: exports.getRecords_imperative,
        getRelatedListActions_imperative: exports.getRelatedListActions_imperative,
        getRelatedListCount_imperative: exports.getRelatedListCount_imperative,
        getRelatedListInfo_imperative: exports.getRelatedListInfo_imperative,
        getRelatedListInfoBatch_imperative: exports.getRelatedListInfoBatch_imperative,
        getRelatedListPreferences_imperative: exports.getRelatedListPreferences_imperative,
        getRelatedListPreferencesBatch_imperative: exports.getRelatedListPreferencesBatch_imperative,
        getRelatedListRecordActions_imperative: exports.getRelatedListRecordActions_imperative,
        getRelatedListRecords_imperative: exports.getRelatedListRecords_imperative,
        getRelatedListRecordsBatch_imperative: exports.getRelatedListRecordsBatch_imperative,
        getRelatedListsActions_imperative: exports.getRelatedListsActions_imperative,
        getRelatedListsCount_imperative: exports.getRelatedListsCount_imperative,
        getRelatedListsInfo_imperative: exports.getRelatedListsInfo_imperative,
        getSearchFilterMetadata_imperative: exports.getSearchFilterMetadata_imperative,
        getSearchFilterOptions_imperative: exports.getSearchFilterOptions_imperative,
        getSearchResults_imperative: exports.getSearchResults_imperative
      } = bindExportsTo(luvio));
    });
    const REFRESH_UIAPI_KEY = 'refreshUiApi';
    const refresh = function (data) {
      return ldsBindings.refresh(data, REFRESH_UIAPI_KEY);
    };
    /** Custom adapters */
    // updateLayoutUserState adapter should always return undefined
    let baseUpdateLayoutUserState;
    const updateLayoutUserState = (apiName, recordTypeId, layoutType, mode, layoutUserStateInput) => {
      return baseUpdateLayoutUserState(apiName, recordTypeId, layoutType, mode, layoutUserStateInput).then(() => undefined);
    };
    // In order to export the imperative wire correctly, we need to add some safety checks
    // to ensure the config passed is correct
    let baseUpdateRelatedListInfo;
    const updateRelatedListInfo = config => {
      const value = baseUpdateRelatedListInfo(config);
      if (value === null) {
        {
          throw new Error('Invalid config for updateRelatedListInfo');
        }
      }
      if ('then' in value) {
        return value.then(snapshot => snapshot.data);
      }
      if (value.state === 'Error') {
        return Promise.reject(value.error);
      }
      return Promise.resolve(value.data);
    };
    let baseUpdateRelatedListPreferences;
    const updateRelatedListPreferences = config => {
      const value = baseUpdateRelatedListPreferences(config);
      if (value === null) {
        {
          throw new Error('Invalid config for updateRelatedListPreferences');
        }
      }
      if ('then' in value) {
        return value.then(snapshot => snapshot.data);
      }
      if (value.state === 'Error') {
        return Promise.reject(value.error);
      }
      return Promise.resolve(value.data);
    };
    /** SFDC utils */
    exports.getRecordNotifyChange = void 0;
    exports.notifyRecordUpdateAvailable = void 0;
    exports.notifyListViewSummaryUpdateAvailable = void 0;
    exports.notifyListInfoSummaryUpdateAvailable = void 0;
    exports.notifyListInfoUpdateAvailable = void 0;
    exports.notifyQuickActionDefaultsUpdateAvailable = void 0;
    exports.notifyListRecordCollectionUpdateAvailable = void 0;
    exports.notifyAllListRecordUpdateAvailable = void 0;
    exports.notifyAllListInfoSummaryUpdateAvailable = void 0;
    ldsEngine.withDefaultLuvio(luvio => {
      ldsBindings.bindWireRefresh(luvio);
      baseUpdateLayoutUserState = ldsBindings.createLDSAdapter(luvio, 'updateLayoutUserState', factory$b);
      baseUpdateRelatedListInfo = ldsBindings.createLDSAdapter(luvio, 'baseUpdateRelatedListInfo', updateRelatedListInfoAdapterFactory);
      baseUpdateRelatedListPreferences = ldsBindings.createLDSAdapter(luvio, 'baseUpdateRelatedListPreferences', updateRelatedListPreferencesAdapterFactory);
      exports.getRecordNotifyChange = throttle(60, 60000, ldsBindings.createLDSAdapter(luvio, 'getRecordNotifyChange', notifyChangeFactory), {
        allowFunction: instrumentation.getRecordNotifyChangeAllowed,
        dropFunction: instrumentation.getRecordNotifyChangeDropped
      });
      exports.notifyRecordUpdateAvailable = throttle(60, 60000, ldsBindings.createLDSAdapter(luvio, 'notifyRecordUpdateAvailable', notifyUpdateAvailableFactory$5), {
        allowFunction: instrumentation.notifyRecordUpdateAvailableAllowed,
        dropFunction: instrumentation.notifyRecordUpdateAvailableDropped
      });
      exports.notifyListViewSummaryUpdateAvailable = throttle(60, 60000, ldsBindings.createLDSAdapter(luvio, 'notifyListViewSummaryUpdateAvailable', notifyUpdateAvailableFactory$2));
      exports.notifyListInfoSummaryUpdateAvailable = throttle(60, 60000, ldsBindings.createLDSAdapter(luvio, 'notifyListInfoSummaryUpdateAvailable', notifyUpdateAvailableFactory$3));
      exports.notifyListInfoUpdateAvailable = throttle(60, 60000, ldsBindings.createLDSAdapter(luvio, 'notifyListInfoUpdateAvailable', notifyUpdateAvailableFactory$1));
      exports.notifyListRecordCollectionUpdateAvailable = throttle(60, 60000, ldsBindings.createLDSAdapter(luvio, 'notifyListRecordCollectionUpdateAvailable', notifyUpdateAvailableFactory$4));
      exports.notifyQuickActionDefaultsUpdateAvailable = throttle(60, 60000, ldsBindings.createLDSAdapter(luvio, 'notifyQuickActionDefaultsUpdateAvailable', notifyUpdateAvailableFactory));
      // Setting up storeWatchers for custom notifyUpdateAvailable endpoints
      setupListRecordCollectionStoreWatcher(luvio);
      setupListSummaryCollectionStoreWatcher(luvio);
      // Custom notifyUpdateAvailable endpoints for partial key support
      exports.notifyAllListRecordUpdateAvailable = throttle(60, 60000, setupNotifyAllListRecordUpdateAvailable(luvio));
      exports.notifyAllListInfoSummaryUpdateAvailable = throttle(60, 60000, setupNotifyAllListInfoSummaryUpdateAvailable(luvio));
    });
    // version: 1.309.0-dev21-4baf03ecaf
    const __lwc_hmr_context = { moduleHash : 'efaa5f9f88b1846dc70bbe2203c8c55b' };
    if (lwc.hot) {
        lwc.hot.register('force/ldsAdaptersUiapi/ldsAdaptersUiapi.js', 'efaa5f9f88b1846dc70bbe2203c8c55b', {"name":"ldsAdaptersUiapi","namespace":"force","enableLightningWebSecurityTransforms":false,"experimentalDynamicComponent":{"loader":"@salesforce/loader","strictSpecifier":false},"experimentalDynamicDirective":false,"enableDynamicComponents":true,"enableStaticContentOptimization":true,"outputConfig":{"sourcemap":false}});
    }

    exports.API_NAMESPACE = API_NAMESPACE;
    exports.InMemoryRecordRepresentationQueryEvaluator = InMemoryRecordRepresentationQueryEvaluator;
    exports.MRU = MRU;
    exports.ObjectInfoDirectoryEntryRepresentationType = RepresentationType$J;
    exports.ObjectInfoRepresentationType = RepresentationType$O;
    exports.RECORD_FIELDS_KEY_JUNCTION = RECORD_FIELDS_KEY_JUNCTION;
    exports.RECORD_ID_PREFIX = RECORD_ID_PREFIX;
    exports.RECORD_REPRESENTATION_NAME = RECORD_REPRESENTATION_NAME;
    exports.RECORD_VIEW_ENTITY_ID_PREFIX = RECORD_VIEW_ENTITY_ID_PREFIX;
    exports.RECORD_VIEW_ENTITY_REPRESENTATION_NAME = RECORD_VIEW_ENTITY_REPRESENTATION_NAME;
    exports.RecordRepresentationRepresentationType = RepresentationType$V;
    exports.RecordRepresentationTTL = TTL$z;
    exports.RecordRepresentationType = RepresentationType$V;
    exports.RecordRepresentationVersion = VERSION$1e;
    exports.UiApiNamespace = keyPrefix;
    exports.__lwc_hmr_context = __lwc_hmr_context;
    exports.buildRecordRepKeyFromId = buildRecordRepKeyFromId;
    exports.coerceFieldIdArray = getFieldApiNamesArray;
    exports.coerceObjectId = getObjectApiName$1;
    exports.coerceObjectIdArray = getObjectApiNamesArray;
    exports.configuration = configurationForRestAdapters;
    exports.createIngestRecordWithFields = createIngestRecordWithFields;
    exports.createLDSAdapterWithPrediction = createLDSAdapterWithPrediction;
    exports.createRecordInputFilteredByEditedFields = createRecordInputFilteredByEditedFields;
    exports.createRelatedListAdapterWithPrediction = createRelatedListAdapterWithPrediction;
    exports.extractRecordIdFromStoreKey = extractRecordIdFromStoreKey;
    exports.generateRecordInputForCreate = generateRecordInputForCreate;
    exports.generateRecordInputForUpdate = generateRecordInputForUpdate;
    exports.getFieldDisplayValue = getFieldDisplayValue;
    exports.getFieldValue = getFieldValue;
    exports.getListInfoByNameAdapterFactory = getListInfoByNameAdapterFactory;
    exports.getListInfosByObjectNameAdapterFactory = getListInfosByObjectNameAdapterFactory;
    exports.getListObjectInfoAdapterFactory = getListObjectInfoAdapterFactory;
    exports.getListRecordsByNameAdapterFactory = factory$a;
    exports.getObjectInfoAdapterFactory = getObjectInfoAdapterFactory;
    exports.getObjectInfoDirectoryAdapterFactory = getObjectInfoDirectoryAdapterFactory;
    exports.getObjectInfosAdapterFactory = getObjectInfosAdapterFactory;
    exports.getRecordActionsAdapterFactory = getRecordActionsAdapterFactory;
    exports.getRecordAdapterFactory = factory$f;
    exports.getRecordAvatarsAdapterFactory = getRecordAvatarsAdapterFactory;
    exports.getRecordId18 = getRecordId18;
    exports.getRecordInput = getRecordInput;
    exports.getRecordsAdapterFactory = getRecordsAdapterFactory;
    exports.getRelatedListInfoBatchAdapterFactory = getRelatedListInfoBatchAdapterFactory;
    exports.getRelatedListRecordsAdapterFactory = getRelatedListRecordsAdapterFactory;
    exports.getRelatedListRecordsBatchAdapterFactory = getRelatedListRecordsBatchAdapterFactory;
    exports.getRelatedListsActionsAdapterFactory = getRelatedListsActionsAdapterFactory;
    exports.getResponseCacheKeysContentDocumentCompositeRepresentation = getResponseCacheKeys;
    exports.getTypeCacheKeysRecord = getTypeCacheKeys$X;
    exports.ingestContentDocumentCompositeRepresentation = ingest;
    exports.ingestObjectInfo = ingest$H;
    exports.ingestQuickActionExecutionRepresentation = ingest$B;
    exports.ingestRecord = ingest$O;
    exports.instrument = instrument;
    exports.isStoreKeyRecordViewEntity = isStoreKeyRecordViewEntity;
    exports.keyBuilderContentDocumentCompositeRepresentation = keyBuilder;
    exports.keyBuilderFromTypeContentDocumentCompositeRepresentation = keyBuilderFromType;
    exports.keyBuilderFromTypeRecordRepresentation = keyBuilderFromType$D;
    exports.keyBuilderObjectInfo = keyBuilder$1Y;
    exports.keyBuilderQuickActionExecutionRepresentation = keyBuilder$1R;
    exports.keyBuilderRecord = keyBuilder$29;
    exports.refresh = refresh;
    exports.registerPrefetcher = registerPrefetcher;
    exports.updateLayoutUserState = updateLayoutUserState;
    exports.updateRelatedListInfo = updateRelatedListInfo;
    exports.updateRelatedListPreferences = updateRelatedListPreferences;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/uiRecordApi', ['exports', 'force/ldsAdaptersUiapi'], (function (exports, ldsAdaptersUiapi) {



    Object.defineProperty(exports, 'createContentDocumentAndVersion', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.createContentDocumentAndVersion; }
    });
    Object.defineProperty(exports, 'createRecord', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.createRecord; }
    });
    Object.defineProperty(exports, 'createRecordInputFilteredByEditedFields', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.createRecordInputFilteredByEditedFields; }
    });
    Object.defineProperty(exports, 'deleteRecord', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.deleteRecord; }
    });
    Object.defineProperty(exports, 'generateRecordInputForCreate', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.generateRecordInputForCreate; }
    });
    Object.defineProperty(exports, 'generateRecordInputForUpdate', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.generateRecordInputForUpdate; }
    });
    Object.defineProperty(exports, 'getFieldDisplayValue', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.getFieldDisplayValue; }
    });
    Object.defineProperty(exports, 'getFieldValue', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.getFieldValue; }
    });
    Object.defineProperty(exports, 'getRecord', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.getRecord; }
    });
    Object.defineProperty(exports, 'getRecordCreateDefaults', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.getRecordCreateDefaults; }
    });
    Object.defineProperty(exports, 'getRecordInput', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.getRecordInput; }
    });
    Object.defineProperty(exports, 'getRecordNotifyChange', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.getRecordNotifyChange; }
    });
    Object.defineProperty(exports, 'getRecordUi', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.getRecordUi; }
    });
    Object.defineProperty(exports, 'getRecords', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.getRecords; }
    });
    Object.defineProperty(exports, 'notifyRecordUpdateAvailable', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.notifyRecordUpdateAvailable; }
    });
    Object.defineProperty(exports, 'refresh', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.refresh; }
    });
    Object.defineProperty(exports, 'unstable_createContentDocumentAndVersion', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.createContentDocumentAndVersion; }
    });
    Object.defineProperty(exports, 'updateRecord', {
        enumerable: true,
        get: function () { return ldsAdaptersUiapi.updateRecord; }
    });

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_data_provider/recordUtils', ['exports', 'lightning/uiRecordApi', 'dxp_data_provider/dataProviderUtils', 'dxp_util/common'], (function (exports, uiRecordApi, dataProviderUtils, common) {

    const DATA_BIND_FIELD_RAW_VALUE = `${dataProviderUtils.DATA_PROVIDER_FIELD_METADATA_PREFIX}rawValue`;
    const DATA_BIND_FIELD_DISPLAY_VALUE = `${dataProviderUtils.DATA_PROVIDER_FIELD_METADATA_PREFIX}displayValue`;

    /**
     * Record fields are formated with ${objectApiName}.${field}
     *
     * @param {string} sfdcType field type
     * @param {string} field field
     * @returns {string} formatted field.
     */
    function formatField(sfdcType, field) {
      return `${sfdcType}.${field}`;
    }

    /**
     * Fetch data from record based on metadata
     *
     * @param {object} record the actual record
     * @param {object} field name of field
     * @param {string} metadata metadata such as _rawValue/_displayValue
     * @returns {any|null} record field value
     */
    function getFieldFromRecord(record, field, metadata) {
      if (!metadata) {
        // default behavior if no metadata
        return uiRecordApi.getFieldDisplayValue(record, field) || uiRecordApi.getFieldValue(record, field);
      } else if (metadata === DATA_BIND_FIELD_RAW_VALUE) {
        return uiRecordApi.getFieldValue(record, field);
      } else if (metadata === DATA_BIND_FIELD_DISPLAY_VALUE) {
        return uiRecordApi.getFieldDisplayValue(record, field);
      }

      // if metadata was some strange value
      return undefined;
    }

    /**
     * Fetch data from record based on metadata
     *
     * @param {string} objectApiName record object api name
     * @param {object} record the actual record
     * @param {object} field name of field
     * @param {string} metadata metadata such as _rawValue/_displayValue
     * @returns {any|null} record field value
     */
    const getFieldFromObjectRecord = common.curry((objectApiName, record, field, metadata) => {
      const formattedField = formatField(objectApiName, field);
      return getFieldFromRecord(record, formattedField, metadata);
    });

    Object.defineProperty(exports, 'isField', {
        enumerable: true,
        get: function () { return common.isField; }
    });
    exports.DATA_BIND_FIELD_DISPLAY_VALUE = DATA_BIND_FIELD_DISPLAY_VALUE;
    exports.DATA_BIND_FIELD_RAW_VALUE = DATA_BIND_FIELD_RAW_VALUE;
    exports.formatField = formatField;
    exports.getFieldFromObjectRecord = getFieldFromObjectRecord;
    exports.getFieldFromRecord = getFieldFromRecord;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/utilsInternal', ['exports'], (function (exports) {

  const objToString = Object.prototype.toString;
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const funcToString = Function.prototype.toString;
  const objectCtorString = funcToString.call(Object);
  const isInteger = value => {
    return Number.isInteger ? Number.isInteger(value) : typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
  };
  function isFunction(val) {
    return typeof val === 'function';
  }
  function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
  }
  function isPromiseLike(val) {
    return isObjectLike(val) && typeof val.then === 'function';
  }
  function isObject(value) {
    return isFunction(value) || isObjectLike(value);
  }
  function getObjectTag(v) {
    return objToString.call(v);
  }
  function isObjectByTag(v) {
    return getObjectTag(v) === '[object Object]';
  }
  function isPlainObject(value) {
    if (!isObjectLike(value) || !isObjectByTag(value)) {
      return false;
    }
    const proto = Object.getPrototypeOf(Object(value));
    if (proto === null) {
      return true;
    }
    const ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return isFunction(ctor) && ctor instanceof ctor && funcToString.call(ctor) === objectCtorString;
  }
  function isNil(value) {
    return value == null;
  }
  function isBlank(value) {
    return isNil(value) || typeof value !== 'string' || value.trim().length === 0;
  }
  function empty(value) {
    if (Array.isArray(value)) {
      return value.length === 0;
    }
    const type = typeof value;
    switch (type) {
      case 'string':
        return value.toString() === '';
      case 'boolean':
      case 'number':
      case 'function':
        return false;
      case 'object':
        return Object.keys(value ?? {}).length === 0;
      default:
        return value == null;
    }
  }

  const rootRef$1 = '#REF:$';
  function defaultCompareFn(a, b) {
    return a.localeCompare(b);
  }
  function baseDeepSort(value, compareFn, stack, errors, path = rootRef$1) {
    if (!isObjectLike(value)) {
      return value;
    }
    const obj = value;
    if (stack.has(obj)) {
      return value;
    }
    stack.set(obj, path);
    if (Array.isArray(obj)) {
      return obj.map((item, idx) => {
        const childPath = `${path}[${String(idx)}]`;
        return baseDeepSort(item, compareFn, stack, errors, childPath);
      });
    }
    if (isPlainObject(value)) {
      return Object.keys(value).sort(compareFn).reduce((acc, key) => {
        const childPath = `${path}.${key}`;
        acc[key] = baseDeepSort(value[key], compareFn, stack, errors, childPath);
        return acc;
      }, {});
    }
    {
      const message = `unsupported type '${getObjectTag(obj)}' found at '${path}'`;
      errors.push(new Error(message));
    }
    return value;
  }
  function deepSort(value, comparator) {
    const stack = new WeakMap();
    const errors = [];
    const sortedValue = baseDeepSort(value, isFunction(comparator) ? comparator : defaultCompareFn, stack, errors);
    const result = Object.create(null);
    Object.defineProperty(result, 'value', {
      enumerable: true,
      value: sortedValue
    });
    Object.defineProperty(result, 'errors', {
      enumerable: true,
      value: errors
    });
    return result;
  }

  function baseDeepFreeze(value, errors = [], ref = '#REF:$') {
    if (isObjectLike(value) && !Object.isFrozen(value)) {
      const obj = value;
      if ((typeof window === 'undefined' || "development" !== 'production') && !isPlainObject(obj) && !Array.isArray(obj)) {
        const message = `unsupported type '${getObjectTag(obj)}' found at '${ref}'`;
        errors.push(new Error(message));
      }
      Object.freeze(obj);
      for (const key of Object.keys(obj)) {
        baseDeepFreeze(obj[key], errors, `${ref}.${key}`);
      }
    }
    const result = Object.create(null);
    Object.defineProperty(result, 'value', {
      enumerable: true,
      value
    });
    Object.defineProperty(result, 'errors', {
      enumerable: true,
      value: errors
    });
    return result;
  }
  function deepFreeze(value) {
    return baseDeepFreeze(value);
  }

  const cache = new WeakSet();
  function redefineProperty(target, key) {
    try {
      const value = Reflect.get(target, key);
      Reflect.defineProperty(target, key, {
        enumerable: true,
        get() {
          return typeof value === 'object' && value !== null ? readonly(value) : value;
        }
      });
    } catch {
      // Intentionally empty
    }
  }
  function readonly(target) {
    if (typeof target !== 'object' || target === null || cache.has(target)) {
      return target;
    }
    cache.add(target);
    if (Object.isFrozen(target)) {
      const shallowClone = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
      for (const [key, value] of Object.entries(target)) {
        Reflect.set(shallowClone, key, typeof value === 'object' && value !== null ? readonly(value) : value);
      }
      return Object.freeze(shallowClone);
    }
    for (const key of Object.keys(target)) {
      redefineProperty(target, key);
    }
    return Object.freeze(target);
  }

  function get(obj, path, defaultValue) {
    const travel = regexp => String.prototype.split.call(path, regexp).filter(Boolean).reduce((res, key) => res !== null && res !== undefined ? res[key] : res, obj);
    const result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/);
    return result === undefined || result === obj ? defaultValue : result;
  }

  function circularRefReplacer() {
    const errors = [];
    const pathsUndefined = [];
    const stack = new WeakMap();
    const rootRef = '#REF:$';
    const undefRef = '#REF:undefined';
    function replacer(key, value) {
      const keyString = String(key);
      const parentPath = stack.get(this);
      const path = parentPath ? parentPath + (Array.isArray(this) ? `[${keyString}]` : '.' + keyString) : Array.isArray(this) ? `[${keyString}]` : keyString;
      if (!isObjectLike(value) || value !== Object(value)) {
        if (typeof value === 'undefined') {
          pathsUndefined.push(path);
          return undefRef;
        }
        return value;
      }
      const obj = value;
      if (stack.has(obj)) {
        const ref = stack.get(obj);
        return ref ? `${rootRef}${ref[0] === '[' ? '' : '.'}${ref}` : rootRef;
      }
      {
        if (!isPlainObject(obj) && !Array.isArray(obj)) {
          const currentRef = path ? `${rootRef}${path[0] === '[' ? '' : '.'}${path}` : rootRef;
          const message = `unsupported type '${getObjectTag(obj)}' found at '${currentRef}'`;
          errors.push(new Error(message));
        }
      }
      stack.set(obj, path);
      return obj;
    }
    replacer.errors = () => errors;
    replacer.pathsUndefined = () => pathsUndefined;
    return replacer;
  }
  function circularRefReviver() {
    const circular = new Map();
    const rootRef = '#REF:$';
    const undefRef = '#REF:undefined';
    function decycle(cyclicRef, rootValue) {
      const matches = circular.get(cyclicRef);
      let ref = cyclicRef.substring(rootRef.length);
      ref.indexOf('.') === 0 && (ref = ref.substring(1));
      const cyclicValue = ref ? get(rootValue, ref) : rootValue;
      for (const match of matches) {
        match.value[match.key] = cyclicValue;
      }
      circular.delete(cyclicRef);
    }
    return function reviver(key, value) {
      if (typeof value === 'string' && value.indexOf(rootRef) === 0) {
        if (!circular.has(value)) {
          circular.set(value, []);
        }
        circular.get(value).push({
          value: this,
          key
        });
        return value;
      }
      if (!isObjectLike(value) || value !== Object(value)) {
        return typeof value === 'string' && value === undefRef ? undefined : value;
      }
      if (key === '') {
        const rootValue = this[''];
        for (const k of circular.keys()) {
          decycle(k, rootValue);
        }
      }
      return value;
    };
  }
  function deepClone(value) {
    const respond = (v, errors) => {
      const result = Object.create(null);
      Object.defineProperty(result, 'value', {
        enumerable: true,
        value: v
      });
      Object.defineProperty(result, 'errors', {
        enumerable: true,
        value: errors
      });
      return result;
    };
    if (!isObject(value)) {
      return respond(typeof value === 'symbol' ? Symbol.prototype.valueOf.call(value) : value, []);
    }
    const replacer = circularRefReplacer();
    const clone = JSON.parse(JSON.stringify(value, replacer), circularRefReviver());
    const pathsUndefined = replacer.pathsUndefined();
    for (const pathUndefined of pathsUndefined) {
      const tokens = pathUndefined.split('.');
      tokens.reduce((prev, curr) => {
        if (isPlainObject(prev)) {
          !Object.prototype.hasOwnProperty.call(prev, curr) && (prev[curr] = undefined);
          return prev[curr];
        }
        return undefined;
      }, clone);
    }
    return respond(clone, replacer.errors());
  }

  const rootRef = '#REF:$';
  function baseDeepEqual(a, b, stack, errors, path = rootRef) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null || typeof a !== 'object' || typeof b !== 'object') {
      return a !== a && b !== b;
    }
    if (stack.has(a)) {
      return stack.get(a) === b;
    }
    stack.set(a, b);
    if (Array.isArray(a)) {
      const length = a.length;
      if (!Array.isArray(b) || length !== b.length) {
        return false;
      }
      for (let i = length; i-- !== 0;) {
        const childPath = `${path}[${String(i)}]`;
        if (!baseDeepEqual(a.at(i), b.at(i), stack, errors, childPath)) {
          return false;
        }
      }
      return true;
    } else if (isPlainObject(a)) {
      const keys = Reflect.ownKeys(a);
      const length = keys.length;
      if (!isPlainObject(b) || length !== Reflect.ownKeys(b).length) {
        return false;
      }
      for (let i = length; i-- !== 0;) {
        const key = keys.at(i);
        const childPath = `${path}.${String(key)}`;
        if (!Reflect.has(b, key) || !baseDeepEqual(Reflect.get(a, key), Reflect.get(b, key), stack, errors, childPath)) {
          return false;
        }
      }
      return true;
    }
    {
      const message = `unsupported type '${getObjectTag(a)}' found at '${path}'`;
      errors.push(new Error(message));
    }
    return false;
  }
  function deepEqual(value1, value2) {
    const stack = new WeakMap();
    const errors = [];
    const value = baseDeepEqual(value1, value2, stack, errors);
    const result = Object.create(null);
    Object.defineProperty(result, 'value', {
      enumerable: true,
      value
    });
    Object.defineProperty(result, 'errors', {
      enumerable: true,
      value: errors
    });
    return result;
  }

  function uuidv4Factory() {
    let lastId = 0;
    return () => {
      if (isFunction(crypto?.randomUUID)) {
        return crypto.randomUUID();
      } else if (isFunction(crypto?.getRandomValues)) {
        return [1e7, 1e3, 4e3, 8e3, 1e11].join('-').replace(/[018]/g, c => (Number(c) ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> Number(c) / 4).toString(16));
      }
      return String(++lastId);
    };
  }
  const uuidv4 = uuidv4Factory();
  function uuidValidate(uuid) {
    return typeof uuid === 'string' && /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(uuid);
  }

  const TIMEOUTS = new WeakMap();
  const TIMEOUTS_CHILDREN = new WeakMap();
  const QUEUE_TIMEOUT_EXTENSIONS = new WeakMap();
  function defer() {
    const deferred = {};
    deferred.promise = new Promise((resolve, reject) => {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    return deferred;
  }
  function clearDebounceTimeout(promise) {
    if (TIMEOUTS.has(promise)) {
      clearTimeout(TIMEOUTS.get(promise));
      TIMEOUTS_CHILDREN.has(promise) && clearTimeout(TIMEOUTS_CHILDREN.get(promise));
      TIMEOUTS.delete(promise);
      TIMEOUTS_CHILDREN.delete(promise);
      QUEUE_TIMEOUT_EXTENSIONS.delete(promise);
      return true;
    }
    return false;
  }
  function extendDebouncedTimeout(promise, wait = 0) {
    if (TIMEOUTS.has(promise)) {
      QUEUE_TIMEOUT_EXTENSIONS.set(promise, wait);
      return true;
    }
    return false;
  }
  function debounce(fn, wait = 0) {
    let deferred;
    let timeoutId;
    let pendingArgs = [];
    function flush() {
      const {
        promise,
        resolve,
        reject
      } = deferred;
      if (QUEUE_TIMEOUT_EXTENSIONS.has(promise)) {
        const childTimeoutId = setTimeout(flush.bind(this), QUEUE_TIMEOUT_EXTENSIONS.get(promise));
        TIMEOUTS_CHILDREN.set(promise, childTimeoutId);
        QUEUE_TIMEOUT_EXTENSIONS.delete(promise);
        return;
      }
      const currentArgs = pendingArgs;
      timeoutId = undefined;
      pendingArgs = [];
      try {
        const result = fn.apply(this, currentArgs[currentArgs.length - 1]);
        Promise.resolve(result).then(resolve, reject).finally(() => {
          deferred = undefined;
          TIMEOUTS.delete(promise);
          TIMEOUTS_CHILDREN.delete(promise);
          QUEUE_TIMEOUT_EXTENSIONS.delete(promise);
        });
      } catch (e) {
        reject(e);
      }
    }
    function debounced(...args) {
      if (deferred) {
        clearDebounceTimeout(deferred.promise);
      } else {
        deferred = defer();
      }
      pendingArgs.push(args);
      timeoutId = setTimeout(flush.bind(this), wait);
      const {
        promise
      } = deferred;
      TIMEOUTS.set(promise, timeoutId);
      return promise;
    }
    return debounced;
  }

  const CONDITION = Symbol();
  const PROPERTY_CONTEXT_VALUE = 'value';
  const TRAPS_FORBIDDEN = ['connect', 'disconnect', 'update'];
  function extractCallback(data, property) {
    const value = Reflect.get(data, property);
    const d = {
      ...data
    };
    Reflect.deleteProperty(d, property);
    const cb = typeof value === 'function' || typeof value === 'undefined' ? value : () => Boolean(value);
    return [cb, d];
  }
  function createConditionalAdapter(superclass, trapsOrCallback, callback) {
    const argsLength = arguments.length;
    let effectiveTraps;
    let defaultCallback;
    if (argsLength > 2) {
      if (typeof trapsOrCallback !== 'undefined' && !Array.isArray(trapsOrCallback)) {
        throw new TypeError(`[utils] traps need to be an array; '${typeof trapsOrCallback}' given`);
      }
      if (typeof callback !== 'undefined' && !isFunction(callback)) {
        throw new TypeError(`[utils] callback needs to be a function; '${typeof callback}' given`);
      }
      effectiveTraps = trapsOrCallback;
      defaultCallback = callback;
    } else if (argsLength > 1) {
      const isArray = Array.isArray(trapsOrCallback);
      const isFunc = isFunction(trapsOrCallback);
      if (typeof trapsOrCallback !== 'undefined' && !isArray && !isFunc) {
        throw new TypeError(`[utils] second parameter either needs to define traps via an array, or a callback function; '${typeof trapsOrCallback}' given`);
      }
      effectiveTraps = isArray ? trapsOrCallback : undefined;
      defaultCallback = isFunc ? trapsOrCallback : undefined;
    }
    const callbackSymbol = Symbol();
    const executeCallbackSymbol = Symbol();
    class ConditionalAdapter extends superclass {
      [executeCallbackSymbol](trap) {
        const effectiveCallback = this[callbackSymbol].last ?? this[callbackSymbol].default;
        return effectiveCallback?.(trap, this) ?? true;
      }
      constructor(...args) {
        super(...args);
        this[callbackSymbol] = {
          default: defaultCallback,
          last: defaultCallback
        };
        const instance = this;
        const customTraps = new Set(Array.isArray(effectiveTraps) && effectiveTraps.length > 0 ? effectiveTraps.filter(trap => !TRAPS_FORBIDDEN.includes(trap)) : []);
        for (const trap of customTraps) {
          const originalMethod = Reflect.get(this, trap);
          if (isFunction(originalMethod)) {
            Reflect.defineProperty(this, trap, {
              enumerable: true,
              writable: false,
              configurable: false,
              value: function (..._args) {
                if (instance[executeCallbackSymbol](trap)) {
                  return originalMethod?.apply(this, _args);
                }
              }
            });
          }
        }
      }
      update(config, context) {
        let effectiveConfig;
        let effectiveContext;
        if (Reflect.has(config, CONDITION)) {
          const [cb, effectiveConf] = extractCallback(config, CONDITION);
          effectiveConfig = effectiveConf;
          effectiveContext = context;
          this[callbackSymbol].last = cb;
        } else if (context && Reflect.has(context, PROPERTY_CONTEXT_VALUE)) {
          const [cb, ctx] = extractCallback(context.value, CONDITION);
          effectiveContext = {
            ...context,
            value: ctx
          };
          effectiveConfig = config;
          this[callbackSymbol].last = cb;
        } else {
          this[callbackSymbol].last = undefined;
          effectiveConfig = config;
          effectiveContext = context;
        }
        if (!Array.isArray(effectiveTraps) || Array.isArray(effectiveTraps) && (effectiveTraps.length === 0 || effectiveTraps.includes('update'))) {
          if (this[executeCallbackSymbol]('update')) {
            super.update(effectiveConfig, effectiveContext);
          }
        } else {
          super.update(effectiveConfig, effectiveContext);
        }
      }
      /*LWC compiler v7.1.5*/
    }
    ConditionalAdapter.contextSchema = {
      value: 'required'
    };
    return ConditionalAdapter;
  }

  function baseConvert(digits, sourceBase, destinationBase) {
    let start = 0;
    const result = [];
    const digitsCopy = [...digits];
    while (true) {
      let carry = 0,
        done = true;
      for (let i = start; i < digitsCopy.length; i++) {
        const p = sourceBase * carry + digitsCopy[i];
        digitsCopy[i] = Math.floor(p / destinationBase);
        carry = p % destinationBase;
        if (done) {
          if (!digitsCopy[i]) {
            start = i;
          } else {
            done = false;
          }
        }
      }
      result.unshift(carry);
      if (done) {
        return result;
      }
    }
  }

  const CHAR_TO_VALUE = '0123456789abcdefghijklmnopqrstuvwxyz';
  const VALUE_TO_CHAR = [...CHAR_TO_VALUE].reduce((acc, value, index) => {
    acc[value] = index;
    return acc;
  }, {});
  function base36Encode(str) {
    if (!str) {
      return str;
    }
    return baseConvert(new TextEncoder().encode(str), 256, 36).map(digit => CHAR_TO_VALUE[digit]).join('');
  }
  function base36Decode(str) {
    if (!str) {
      return str;
    }
    const base36Digits = [...str].map(char => {
      const digit = VALUE_TO_CHAR[char];
      if (digit === undefined) {
        throw new TypeError(`Invalid base 36 digit: ${char}`);
      }
      return digit;
    });
    const base256Digits = baseConvert(base36Digits, 36, 256);
    return new TextDecoder().decode(new Uint8Array(base256Digits));
  }

  function getCookie(cookieName) {
    return globalThis.document?.cookie.split(';').map(s => s.trim().split('=')).filter(([name]) => name.startsWith(cookieName)).map(([, value]) => value)[0];
  }

  function dateAdd(date, duration) {
    if (date instanceof Date) {
      const newdate = new Date(date);
      typeof duration?.years === 'number' && newdate.setFullYear(newdate.getFullYear() + duration.years);
      typeof duration?.months === 'number' && newdate.setMonth(newdate.getMonth() + duration.months);
      typeof duration?.days === 'number' && newdate.setDate(newdate.getDate() + duration.days);
      return newdate;
    }
    return undefined;
  }
  function dateSubtract(date, duration) {
    if (date instanceof Date) {
      const newdate = new Date(date);
      typeof duration?.years === 'number' && newdate.setFullYear(newdate.getFullYear() - duration.years);
      typeof duration?.months === 'number' && newdate.setMonth(newdate.getMonth() - duration.months);
      typeof duration?.days === 'number' && newdate.setDate(newdate.getDate() - duration.days);
      return newdate;
    }
    return undefined;
  }

  exports.CONDITION = CONDITION;
  exports.base36Decode = base36Decode;
  exports.base36Encode = base36Encode;
  exports.baseConvert = baseConvert;
  exports.circularRefReplacer = circularRefReplacer;
  exports.circularRefReviver = circularRefReviver;
  exports.clearDebounceTimeout = clearDebounceTimeout;
  exports.createConditionalAdapter = createConditionalAdapter;
  exports.dateAdd = dateAdd;
  exports.dateSubtract = dateSubtract;
  exports.debounce = debounce;
  exports.deepClone = deepClone;
  exports.deepEqual = deepEqual;
  exports.deepFreeze = deepFreeze;
  exports.deepSort = deepSort;
  exports.empty = empty;
  exports.extendDebouncedTimeout = extendDebouncedTimeout;
  exports.get = get;
  exports.getCookie = getCookie;
  exports.getObjectTag = getObjectTag;
  exports.isBlank = isBlank;
  exports.isFunction = isFunction;
  exports.isInteger = isInteger;
  exports.isNil = isNil;
  exports.isObject = isObject;
  exports.isObjectLike = isObjectLike;
  exports.isPlainObject = isPlainObject;
  exports.isPromiseLike = isPromiseLike;
  exports.readonly = readonly;
  exports.uuidValidate = uuidValidate;
  exports.uuidv4 = uuidv4;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/utils', ['exports', 'experience/utilsInternal'], (function (exports, utilsInternal) {



	Object.defineProperty(exports, 'clearDebounceTimeout', {
		enumerable: true,
		get: function () { return utilsInternal.clearDebounceTimeout; }
	});
	Object.defineProperty(exports, 'debounce', {
		enumerable: true,
		get: function () { return utilsInternal.debounce; }
	});
	Object.defineProperty(exports, 'empty', {
		enumerable: true,
		get: function () { return utilsInternal.empty; }
	});
	Object.defineProperty(exports, 'extendDebouncedTimeout', {
		enumerable: true,
		get: function () { return utilsInternal.extendDebouncedTimeout; }
	});
	Object.defineProperty(exports, 'get', {
		enumerable: true,
		get: function () { return utilsInternal.get; }
	});
	Object.defineProperty(exports, 'getObjectTag', {
		enumerable: true,
		get: function () { return utilsInternal.getObjectTag; }
	});
	Object.defineProperty(exports, 'isBlank', {
		enumerable: true,
		get: function () { return utilsInternal.isBlank; }
	});
	Object.defineProperty(exports, 'isFunction', {
		enumerable: true,
		get: function () { return utilsInternal.isFunction; }
	});
	Object.defineProperty(exports, 'isInteger', {
		enumerable: true,
		get: function () { return utilsInternal.isInteger; }
	});
	Object.defineProperty(exports, 'isNil', {
		enumerable: true,
		get: function () { return utilsInternal.isNil; }
	});
	Object.defineProperty(exports, 'isObject', {
		enumerable: true,
		get: function () { return utilsInternal.isObject; }
	});
	Object.defineProperty(exports, 'isObjectLike', {
		enumerable: true,
		get: function () { return utilsInternal.isObjectLike; }
	});
	Object.defineProperty(exports, 'isPlainObject', {
		enumerable: true,
		get: function () { return utilsInternal.isPlainObject; }
	});
	Object.defineProperty(exports, 'isPromiseLike', {
		enumerable: true,
		get: function () { return utilsInternal.isPromiseLike; }
	});

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/dataProvider', ['exports', 'lwc', 'experience/dataLayerObject', 'experience/utils'], (function (exports, lwc, _experienceDataLayerObject, utils) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var _experienceDataLayerObject__default = /*#__PURE__*/_interopDefaultCompat(_experienceDataLayerObject);

    const stc0 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {k: api_key, c: api_custom_element, i: api_iterator, s: api_slot, f: api_flatten} = $api;
      return api_flatten([$cmp.hasDataLayerObjects ? api_iterator($cmp.dataLayerObjects, function (dataLayerObject) {
        return api_custom_element("experience-data-layer-object", _experienceDataLayerObject__default.default, {
          props: {
            "scriptDataAttributes": dataLayerObject.attributes,
            "customObject": dataLayerObject.customObject
          },
          key: api_key(0, dataLayerObject.id)
        });
      }) : stc0, api_slot("", {
        key: 1,
        slotData: $cmp.dataProxyContext
      }, stc0, $slotset)]);
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = [""];
    tmpl.renderMode = "light";
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-1cva0bnnf5d";
    tmpl.legacyStylesheetToken = "experience-dataProvider_dataProvider";
    lwc.freezeTemplate(tmpl);

    const DATA_PROVIDER_ACTION_EVENT_NAME = 'sfdc__dataprovider_action';
    class DataProviderActionEvent extends CustomEvent {
      constructor(type, payload, callbackOrOptions) {
        const options = {
          onSuccess: utils.isFunction(callbackOrOptions) ? callbackOrOptions : utils.isPlainObject(callbackOrOptions) && utils.isFunction(callbackOrOptions.onSuccess) ? callbackOrOptions.onSuccess : undefined,
          onError: utils.isFunction(callbackOrOptions) ? callbackOrOptions : utils.isPlainObject(callbackOrOptions) && utils.isFunction(callbackOrOptions.onError) ? callbackOrOptions.onError : undefined
        };
        super(DATA_PROVIDER_ACTION_EVENT_NAME, {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            type,
            payload,
            options
          }
        });
      }
      /*LWC compiler v7.1.5*/
    }

    class DataProviderConnectionAdapter {
      constructor(dataCallback) {
        this.dataCallback = dataCallback;
      }
      update() {}
      connect() {
        this.dataCallback({
          connected: true
        });
      }
      disconnect() {
        this.dataCallback({
          connected: false
        });
      }
    }

    const registeredActionsMap = new WeakMap();
    function isDataProviderConstructor(obj) {
      return function evaluate(_obj) {
        if (utils.isFunction(_obj) && _obj.constructor === __lwc_component_class_internal.constructor) {
          return true;
        }
        const proto = _obj != null ? Object.getPrototypeOf(_obj) : null;
        if (proto != null) {
          return evaluate(proto);
        }
        return false;
      }(obj);
    }
    function getDataProviderConstructorChain(obj) {
      const chain = [];
      (function evaluate(_obj, isProvider) {
        if (isProvider) {
          chain.push(_obj);
        }
        const proto = _obj != null ? Object.getPrototypeOf(_obj) : null;
        if (isDataProviderConstructor(proto)) {
          evaluate(proto, true);
        }
      })(obj, isDataProviderConstructor(obj));
      return chain.reverse();
    }
    function registerAction(ctor, type, handler) {
      if (!isDataProviderConstructor(ctor)) {
        throw new TypeError(`[dataProvider] parameter 'ctor' needs to be a DataProvider constructor`);
      }
      if (typeof type !== 'string') {
        throw new TypeError(`[dataProvider] parameter 'type' needs to be a string`);
      }
      if (!utils.isFunction(handler)) {
        throw new TypeError(`[dataProvider] parameter 'handler' needs to be a function`);
      }
      if (!registeredActionsMap.has(ctor)) {
        registeredActionsMap.set(ctor, {});
      }
      const container = registeredActionsMap.get(ctor);
      if (Reflect.has(container, type)) {
        throw new TypeError(`[dataProvider] a handler has already been registered for action type '${type}'`);
      }
      container[type] = handler;
    }
    function getRegisteredActions(ctor) {
      return getDataProviderConstructorChain(ctor).reduce((acc, _ctor) => {
        if (registeredActionsMap.has(_ctor)) {
          const actionsMap = registeredActionsMap.get(_ctor);
          return {
            ...acc,
            ...actionsMap
          };
        }
        return acc;
      }, {});
    }

    const handleDataProviderActionEventFieldSymbol = Symbol('handleDataProviderActionEventField');
    const handleDataProviderActionEventSymbol = Symbol('handleDataProviderActionEvent');
    const SFDC_DATA_ATTRIBUTE = Symbol();
    const SFDC_PROVIDER_ATTRIBUTE = Symbol();
    class DataProvider extends lwc.LightningElement {
      wireConnectedState({
        connected
      }) {
        if (connected) {
          this.addEventListener(DATA_PROVIDER_ACTION_EVENT_NAME, this[handleDataProviderActionEventFieldSymbol]);
        } else {
          this.removeEventListener(DATA_PROVIDER_ACTION_EVENT_NAME, this[handleDataProviderActionEventFieldSymbol]);
        }
      }
      get sfdcData() {
        return this._sfdcData;
      }
      set sfdcData(value) {
        this._sfdcData = value;
      }
      get dataProxyContext() {
        return {
          [SFDC_DATA_ATTRIBUTE]: this.getData(),
          [SFDC_PROVIDER_ATTRIBUTE]: this
        };
      }
      hasData(_prop) {
        return true;
      }
      updateComponents() {
        // TODO: Remove once commerce data provider is updated.
      }
      getData() {
        return this.sfdcData;
      }
      get hasDataLayerObjects() {
        return !!this.dataLayerObjects && this.dataLayerObjects.length > 0;
      }
      constructor() {
        super();
        this[handleDataProviderActionEventFieldSymbol] = this[handleDataProviderActionEventSymbol].bind(this);
        this.sfdcFields = [];
        this.sfdcIsPreviewMode = false;
        this.sfdcType = void 0;
        this.sfdcExpressionKey = void 0;
        this.sfdcIsViewLevelDataProvider = false;
        this.generatedTemplate = void 0;
        this._sfdcData = void 0;
        this.dataLayerObjects = void 0;
        this._sfdcData = {};
      }
      [handleDataProviderActionEventSymbol](event) {
        if (event.defaultPrevented) {
          return;
        }
        const {
          detail,
          target
        } = event;
        const {
          type,
          payload,
          options
        } = detail;
        const actions = getRegisteredActions(Object.getPrototypeOf(this).constructor);
        if (Reflect.has(actions, type)) {
          event.preventDefault();
          event.stopPropagation();
          const hasSuccessCallback = utils.isFunction(options.onSuccess);
          const hasErrorCallback = utils.isFunction(options.onError);
          try {
            const result = actions[type].call(this, payload, this, target);
            if (result instanceof Promise) {
              result.then(value => {
                hasSuccessCallback && options.onSuccess?.call(undefined, value, true);
                return value;
              }, err => {
                if ("development" !== 'production') {
                  console.warn('[dataProvider] error during action execution:', err);
                }
                hasErrorCallback && options.onError?.call(undefined, err, false);
              });
            } else {
              hasSuccessCallback && options.onSuccess?.call(undefined, result, true);
            }
          } catch (err) {
            {
              console.warn('[dataProvider] error during action execution:', err);
            }
            hasErrorCallback && options.onError?.call(undefined, err, false);
          }
        }
      }
      /*LWC compiler v7.1.5*/
    }
    DataProvider.renderMode = 'light';
    DataProvider.preloadData = void 0;
    lwc.registerDecorators(DataProvider, {
      publicProps: {
        sfdcFields: {
          config: 0
        },
        sfdcIsPreviewMode: {
          config: 0
        },
        sfdcType: {
          config: 0
        },
        sfdcExpressionKey: {
          config: 0
        },
        sfdcIsViewLevelDataProvider: {
          config: 0
        },
        generatedTemplate: {
          config: 0
        },
        sfdcData: {
          config: 3
        }
      },
      publicMethods: ["hasData", "updateComponents", "getData"],
      track: {
        _sfdcData: 1
      },
      wire: {
        wireConnectedState: {
          adapter: DataProviderConnectionAdapter,
          method: 1,
          config: function ($cmp) {
            return {};
          }
        }
      },
      fields: ["dataLayerObjects"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(DataProvider, {
      tmpl: _tmpl,
      sel: "experience-data-provider",
      apiVersion: 62
    });

    exports.DataProviderActionEvent = DataProviderActionEvent;
    exports.SFDC_DATA_ATTRIBUTE = SFDC_DATA_ATTRIBUTE;
    exports.SFDC_PROVIDER_ATTRIBUTE = SFDC_PROVIDER_ATTRIBUTE;
    exports.default = __lwc_component_class_internal;
    exports.registerAction = registerAction;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_data_provider/navigableDataProvider', ['exports', 'lwc', '@salesforce/community/basePath', 'experience/dataProvider', 'lightning/navigation', 'dxp_data_provider/dataProviderUtils', 'dxp_util/common', 'dxp_data_provider/recordUtils'], (function (exports, lwc, basePath, DataProvider, navigation, dataProviderUtils, common, recordUtils) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var basePath__default = /*#__PURE__*/_interopDefaultCompat(basePath);
    var DataProvider__default = /*#__PURE__*/_interopDefaultCompat(DataProvider);

    var _tmpl = void 0;

    const CMS_CONTENT_PAGE_TYPE = "standard__managedContentPage";
    const DETAIL_LINK_METADATA_ACCESS = "_detailURL";
    const SynchronizeUrl = Symbol("synchronizeUrl");

    /**
     * A Navigable Data Provider is a data provider that can be used to navigate between pages.
     *
     * @class NavigableDataProvider
     */
    class NavigableDataProvider extends DataProvider__default.default {
      constructor(...args) {
        super(...args);
        this.currentPageReference = void 0;
        this._navContext = void 0;
        this._detailPageUrlLoaded = false;
        this._contentTypeFQN = void 0;
        this.detailPageUrl = void 0;
      }
      // default is 'shadow'

      /**
       * Return page reference object
       *
       * @type {object}
       * @readonly
       * @memberof NavigableDataProvider
       */
      get pageReference() {
        return {
          type: CMS_CONTENT_PAGE_TYPE,
          attributes: {
            contentTypeName: this.sfdcType,
            contentKey: this.contentKey ?? ""
          }
        };
      }
      get sfdcType() {
        return this._contentTypeFQN;
      }
      set sfdcType(type) {
        this._contentTypeFQN = type;
        this[SynchronizeUrl]();
      }
      toCmsData(cmsData) {
        const getified = common.getify({
          ...cmsData,
          [DETAIL_LINK_METADATA_ACCESS]: ""
        }, {
          getter: (target, key) => () => {
            if (key === DETAIL_LINK_METADATA_ACCESS) {
              return this.detailPageUrl;
            }
            const value = common.get(target, key);
            // prefix the urls if the key is "url"
            // or if the value is Rich Text with at least one image tag
            return key === "url" ? dataProviderUtils.resolve(value) : this.isRichTextWithImg(value) ? this.fixUrlsInRichText(value) : value;
          },
          patchRecord: false
        });
        getified[dataProviderUtils.DATA_PROVIDER_DATA_ACCESS] = getified;
        return getified;
      }

      /**
       * Returns true if the value string is rich text and contains at least one image tag
       *
       * @param {string} value input string
       * @returns {boolean} whether value string is rich text and contains at least one image tag
       */
      isRichTextWithImg(value) {
        let parser = new DOMParser();
        let doc = parser.parseFromString(value, "text/html");
        return doc.querySelector("img") ? true : false;
      }

      /**
       * Prefixes all the cms urls in the rich text with Site Base Path
       *
       * @param {string} value input string
       * @returns {string} modified rich text with all cms urls prefixed with Site Base Path
       */
      fixUrlsInRichText(value) {
        if (value) {
          let prefix = `${basePath__default.default}/sfsites/c`;
          let regEx = new RegExp(`(?:${prefix})?(/cms/)`, "g");
          return value.replace(regEx, prefix + "$1");
        }
        return value;
      }

      /**
       * Gets the navigation context.
       *
       * @param {object} navContext navigation context
       */
      wireNavContext(navContext) {
        this._navContext = navContext;
        this[SynchronizeUrl]();
      }

      /**
       * Get current page reference
       *
       * @param {object} currentPageReference current page reference
       */
      wireCurrentPageReference(currentPageReference) {
        this.currentPageReference = currentPageReference;

        /* istanbul ignore else */
        if (currentPageReference) {
          this.handleCurrentPageReferenceChange(currentPageReference);
        }
      }

      /**
       * Synchronize Url when NavContext is ready.
       */
      [SynchronizeUrl]() {
        /* istanbul ignore else */
        if (this._navContext) {
          // Generate a URL to a detail page
          this.detailPageUrl = navigation.generateUrl(this._navContext, this.pageReference);
          this._detailPageUrlLoaded = true;
          this.handleContextChange(this._navContext);
        }
      }
      getData(metadata) {
        if (metadata === DETAIL_LINK_METADATA_ACCESS) {
          return this.detailPageUrl;
        }
        return this.sfdcData;
      }

      /**
       * getField is used for Item.* expression since 234, for 242+ we will move to expression service
       *
       * @deprecated Expression service expect getData to return full plain object.
       *
       * @param {string} field name of field
       * @param {string} metadata metadata of field
       * @returns {object} value if field
       */
      getField(field, metadata) {
        field = Array.isArray(field) ? field.join(".") : field;
        if (metadata) {
          return common.get(this.sfdcData, `${field}.${metadata}`);
        }

        // A field has value and displayValue, but fieldValue is null
        // Means displayValue and value are both null
        // should return fieldValue such as {!Item.BillingCountry}, if
        // value and displayValue are both null, should return null
        const fieldValue = common.get(this.sfdcData, `${field}.${common.SFDC_DEFAULT}`);
        const propertyValue = common.get(this.sfdcData, field);
        return common.ifElse(fieldValue || recordUtils.isField(propertyValue), fieldValue, propertyValue);
      }

      /**
       * No-op method to handle the context change.
       */
      /* istanbul ignore next */
      handleContextChange() {}

      /**
       * No-op method to handle the current page reference change.
       */
      handleCurrentPageReferenceChange() {}
      /*LWC compiler v7.1.5*/
    }
    /**
     * Enable the component to render as lightDOM
     *
     * @static
     */
    NavigableDataProvider.renderMode = "light";
    lwc.registerDecorators(NavigableDataProvider, {
      track: {
        currentPageReference: 1,
        _navContext: 1
      },
      wire: {
        wireNavContext: {
          adapter: navigation.NavigationContext,
          method: 1,
          config: function ($cmp) {
            return {};
          }
        },
        wireCurrentPageReference: {
          adapter: navigation.CurrentPageReference,
          method: 1,
          config: function ($cmp) {
            return {};
          }
        }
      },
      fields: ["_detailPageUrlLoaded", "_contentTypeFQN", "detailPageUrl"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(NavigableDataProvider, {
      tmpl: _tmpl,
      sel: "dxp_data_provider-navigable-data-provider",
      apiVersion: 62
    });

    exports.CMS_CONTENT_PAGE_TYPE = CMS_CONTENT_PAGE_TYPE;
    exports.DETAIL_LINK_METADATA_ACCESS = DETAIL_LINK_METADATA_ACCESS;
    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@luvio/runtime', ['force/luvioRuntimeWebruntime'], function(m) { return m && typeof m === 'object' && 'default' in m ? m.default : m; });
(function() { LWR.define('force/luvioRegistry', ['exports', 'lwc'], (function (exports, lwc) {

    /**
     * Copyright (c) 2022, Salesforce, Inc.,
     * All rights reserved.
     * For full license text, see the LICENSE.txt file
     */

    /*  *******************************************************************************************
     *  ATTENTION!
     *  THIS IS A GENERATED FILE FROM https://github.com/salesforce-experience-platform-emu/lds-lightning-platform
     *  If you would like to contribute to LDS, please follow the steps outlined in the git repo.
     *  Any changes made to this file in p4 will be automatically overwritten.
     *  *******************************************************************************************
     */
    /* proxy-compat-disable */
    /**
     * Copyright (c) 2022, Salesforce, Inc.,
     * All rights reserved.
     * For full license text, see the LICENSE.txt file
     */

    /**
     * Callbacks to be invoked when registrations happen.
     */
    const callbacks = [];
    /**
     * Registrations that have already occurred.
     *
     * Note that Registrations are maintained as a list rather than a map to allow
     * the same id to be registered multiple times with potentially different
     * data.
     */
    const registrations = [];
    /**
     * Invokes callback for each Registration, both past & future. That is, callback
     * will be invoked exactly as many times as register() is called.
     *
     * Note that Registration ids are not guaranteed to be unique. The meaning of
     * multiple Registrations with the same id is determined by the caller(s) of
     * register().
     */
    function forEachRegistration(callback) {
      callbacks.push(callback);
      registrations.forEach(r => callback(r));
    }
    /**
     * Invokes callback when the specified id is registered.
     *
     * Note that callback may be invoked:
     *
     *    - multiple times if multiple calls to register() specify the id
     *    - never if the specified id is never registered
     */
    function withRegistration(id, callback) {
      forEachRegistration(r => {
        if (r.id === id) {
          callback(r);
        }
      });
    }
    /**
     * Returns all current Registrations that match the specified id. If no matching
     * Registrations are found, [] is returned.
     */
    function findRegistrations(id) {
      return registrations.filter(r => r.id === id);
    }
    /**
     * Register an id and associated data.
     *
     * Callers of register() should make types available that include:
     *
     *    - the id they will register
     *    - definitions for any additional properties on their Registration objects
     *
     * For example:
     *
     *    export type MyRegistration = {
     *        id: 'myRegistrationId',
     *
     *        // some value that others might need
     *        myValue: string,
     *
     *        // some function that others might want to call
     *        myFunction: () => void,
     *    };
     *    register({ id: 'myRegistrationId', myValue: 'foo', myFunction: () => {} } as MyRegistration);
     *
     * The registry itself does not dictate the format of ids nor attempt to coordinate
     * uniqueness of id values.
     *
     * The same id can be registered multiple times with different Registration
     * objects.
     */
    function register(r) {
      registrations.push(r);
      callbacks.forEach(callback => callback(r));
    }
    // version: 1.278.0-a388a38f0
    const __lwc_hmr_context = { moduleHash : '337e2f351c3b3c0bb447df317317ab3e' };
    if (lwc.hot) {
        lwc.hot.register('force/luvioRegistry/luvioRegistry.js', '337e2f351c3b3c0bb447df317317ab3e', {"name":"luvioRegistry","namespace":"force","enableLightningWebSecurityTransforms":false,"experimentalDynamicComponent":{"loader":"@salesforce/loader","strictSpecifier":false},"experimentalDynamicDirective":false,"enableDynamicComponents":true,"enableStaticContentOptimization":true,"outputConfig":{"sourcemap":false}});
    }

    exports.__lwc_hmr_context = __lwc_hmr_context;
    exports.findRegistrations = findRegistrations;
    exports.forEachRegistration = forEachRegistration;
    exports.register = register;
    exports.withRegistration = withRegistration;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@luvio/registry', ['force/luvioRegistry'], function(m) { return m && typeof m === 'object' && 'default' in m ? m.default : m; });
(function() { LWR.define('experience/uri', ['exports'], (function (exports) {

  function encode(str) {
    return encodeURIComponent(str).replace(/[!'()~]/g, match => '%' + match.charCodeAt(0).toString(16).toUpperCase());
  }
  function composeQueryString(params) {
    const args = typeof params === 'object' && params != null ? params : {};
    if ('URLSearchParams' in globalThis) {
      return new URLSearchParams(args).toString();
    }
    return Object.keys(args).map(k => encode(k) + '=' + encode(args[k])).join('&');
  }

  function composeUri(uri, args) {
    const u = typeof uri === 'string' ? uri : '';
    const q = composeQueryString(args);
    if (q) {
      const ch = u.indexOf('?') !== -1 ? '&' : '?';
      return `${u}${ch}${q}`;
    }
    return u;
  }

  exports.composeQueryString = composeQueryString;
  exports.composeUri = composeUri;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/coercion', ['exports'], (function (exports) {

  function coerceBooleanProperty(value) {
    return value != null && `${value}`.toLowerCase() !== 'false';
  }

  function isNumberValue(value) {
    return !isNaN(parseFloat(String(value))) && !isNaN(Number(value));
  }
  function coerceNumberProperty(value, fallbackValue = 0) {
    return isNumberValue(value) ? Number(value) : fallbackValue;
  }

  function isObjectLike(value) {
    return value != null && typeof value === 'object';
  }
  function isNumber(value) {
    return typeof value === 'number' || isObjectLike(value) && Object.prototype.toString.call(value) === '[object Number]';
  }
  function isNaN$1(value) {
    return isNumber(value) && value !== +value;
  }
  function coerceStringProperty(value, fallbackValue) {
    const stringValue = value == null || isNaN$1(value) ? '' : value.toString();
    return stringValue.length > 0 ? stringValue : fallbackValue;
  }

  exports.coerceBooleanProperty = coerceBooleanProperty;
  exports.coerceNumberProperty = coerceNumberProperty;
  exports.coerceStringProperty = coerceStringProperty;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/serializeError', ['exports', 'lwc'], (function (exports, lwc) {

  var _tmpl = void 0;

  const list = [EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, globalThis.DOMException, globalThis.AssertionError, globalThis.SystemError].filter(Boolean).map(constructor => [constructor.name, constructor]);
  const errorConstructors = new Map(list);
  const __lwc_component_class_internal = lwc.registerComponent(errorConstructors, {
    tmpl: _tmpl,
    sel: "experience-serialize-error",
    apiVersion: 62
  });

  class NonError extends Error {
    constructor(message) {
      super(NonError._prepareSuperMessage(message));
      this.name = 'NonError';
    }
    static _prepareSuperMessage(message) {
      try {
        return JSON.stringify(message);
      } catch {
        return String(message);
      }
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(NonError, {
    fields: ["name"]
  });
  const commonProperties = [{
    property: 'name',
    enumerable: false
  }, {
    property: 'message',
    enumerable: false
  }, {
    property: 'stack',
    enumerable: false
  }, {
    property: 'code',
    enumerable: true
  }, {
    property: 'cause',
    enumerable: false
  }];
  const toJsonWasCalled = Symbol('.toJSON was called');
  const toJSON = from => {
    from[toJsonWasCalled] = true;
    const json = from.toJSON();
    delete from[toJsonWasCalled];
    return json;
  };
  const getErrorConstructor = name => __lwc_component_class_internal.get(name) ?? Error;
  const destroyCircular = ({
    from,
    seen,
    to,
    forceEnumerable,
    maxDepth,
    depth,
    useToJSON,
    serialize
  }) => {
    if (!to) {
      if (Array.isArray(from)) {
        to = [];
      } else if (!serialize && isErrorLike(from)) {
        const Error = getErrorConstructor(from.name);
        to = new Error();
      } else {
        to = {};
      }
    }
    seen.push(from);
    if (depth >= maxDepth) {
      return to;
    }
    if (useToJSON && typeof from.toJSON === 'function' && from[toJsonWasCalled] !== true) {
      return toJSON(from);
    }
    const continueDestroyCircular = value => destroyCircular({
      from: value,
      seen: [...seen],
      forceEnumerable,
      maxDepth,
      depth,
      useToJSON,
      serialize
    });
    for (const [key, value] of Object.entries(from)) {
      if (typeof Buffer === 'function' && Buffer.isBuffer(value)) {
        to[key] = '[object Buffer]';
        continue;
      }
      if (value !== null && typeof value === 'object' && typeof value.pipe === 'function') {
        to[key] = '[object Stream]';
        continue;
      }
      if (typeof value === 'function') {
        continue;
      }
      if (!value || typeof value !== 'object') {
        to[key] = value;
        continue;
      }
      if (!seen.includes(from[key])) {
        depth++;
        to[key] = continueDestroyCircular(from[key]);
        continue;
      }
      to[key] = '[Circular]';
    }
    for (const {
      property,
      enumerable
    } of commonProperties) {
      if (typeof from[property] !== 'undefined' && from[property] !== null) {
        Object.defineProperty(to, property, {
          value: isErrorLike(from[property]) ? continueDestroyCircular(from[property]) : from[property],
          enumerable: forceEnumerable ? true : enumerable,
          configurable: true,
          writable: true
        });
      }
    }
    return to;
  };
  function serializeError(value, options = {}) {
    const {
      maxDepth = Number.POSITIVE_INFINITY,
      useToJSON = true
    } = options;
    if (typeof value === 'object' && value !== null) {
      return destroyCircular({
        from: value,
        seen: [],
        forceEnumerable: true,
        maxDepth,
        depth: 0,
        useToJSON,
        serialize: true
      });
    }
    if (typeof value === 'function') {
      return `[Function: ${value.name ?? 'anonymous'}]`;
    }
    return value;
  }
  function deserializeError(value, options = {}) {
    const {
      maxDepth = Number.POSITIVE_INFINITY
    } = options;
    if (value instanceof Error) {
      return value;
    }
    if (isMinimumViableSerializedError(value)) {
      const Error = getErrorConstructor(value.name);
      return destroyCircular({
        from: value,
        seen: [],
        to: new Error(),
        maxDepth,
        depth: 0,
        serialize: false
      });
    }
    return new NonError(value);
  }
  function isErrorLike(value) {
    return Boolean(value) && typeof value === 'object' && 'name' in value && 'message' in value && 'stack' in value;
  }
  function isMinimumViableSerializedError(value) {
    return Boolean(value) && typeof value === 'object' && 'message' in value && !Array.isArray(value);
  }

  function registerErrorConstructor(type, ctor) {
    __lwc_component_class_internal.set(type, ctor);
  }

  exports.deserializeError = deserializeError;
  exports.registerErrorConstructor = registerErrorConstructor;
  exports.serializeError = serializeError;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/data', ['exports', 'experience/utils', 'lwc', 'experience/coercion', 'experience/serializeError', 'transport', 'experience/uri'], (function (exports, utils, lwc, coercion, serializeError, transport, uri) {

  const DEFAULT_ABORT_REASON = 'Aborted';
  class AbortError extends Error {
    constructor(message) {
      super(coercion.coerceStringProperty(message, DEFAULT_ABORT_REASON));
      this.name = 'AbortError';
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(AbortError, {
    fields: ["name"]
  });
  serializeError.registerErrorConstructor('AbortError', AbortError);

  const ABORT = Symbol('abort');
  const ABORT_SIGNAL = Symbol('abortSignal');
  const ABORTERS = new WeakMap();
  class AbortablePromise extends Promise {
    static from(promise) {
      if (promise instanceof AbortablePromise) {
        return promise;
      } else if (promise instanceof Promise || typeof promise.catch === 'function') {
        return new AbortablePromise((resolve, reject) => promise.then(resolve).catch(reject));
      }
      return new AbortablePromise((resolve, reject) => promise.then(resolve, reject));
    }
    static connect(parent, child) {
      const parentEntry = ABORTERS.get(parent);
      const childEntry = ABORTERS.get(child);
      const {
        controller: parentController
      } = parentEntry;
      const {
        controller: childController
      } = childEntry;
      const {
        signal: parentSignal
      } = parentController;
      const {
        signal: childSignal
      } = childController;
      if (parentSignal === childSignal) {
        return;
      }
      childEntry.parent = parentEntry;
      const ensureReason = (receiver, donor) => {
        !receiver.reason && (receiver.reason = donor.reason);
      };
      if (childSignal.aborted && !parentSignal.aborted) {
        ensureReason(parentEntry, childEntry);
        parentController.abort();
      } else if (parentSignal.aborted && !childSignal.aborted) {
        ensureReason(childEntry, parentEntry);
        childController.abort();
      } else {
        const parentHandler = () => {
          childSignal.removeEventListener('abort', parentHandler);
          if (!childSignal.aborted) {
            ensureReason(childEntry, parentEntry);
            childController.abort();
          }
        };
        const childHandler = () => {
          childSignal.removeEventListener('abort', childHandler);
          if (!parentSignal.aborted) {
            ensureReason(parentEntry, childEntry);
            parentController.abort();
          }
        };
        parentSignal.addEventListener('abort', parentHandler);
        childSignal.addEventListener('abort', childHandler);
      }
    }
    constructor(executor) {
      const abortController = new AbortController();
      const {
        signal
      } = abortController;
      let isFulfilled = false;
      const aborter = reason => {
        ABORTERS.get(this).reason = reason || DEFAULT_ABORT_REASON;
        abortController.abort();
      };
      super((resolve, reject) => {
        const resolver = value => {
          !isFulfilled && !signal.aborted && resolve(value);
          isFulfilled = true;
        };
        const rejector = reason => {
          !isFulfilled && !signal.aborted && reject(reason);
          isFulfilled = true;
        };
        const abortHandler = () => {
          signal.removeEventListener('abort', abortHandler);
          const abortEntry = ABORTERS.get(this);
          let isHandled = !!abortEntry.isHandled;
          let parentAbortEntry = abortEntry.parent;
          while (parentAbortEntry) {
            isHandled = isHandled || !!parentAbortEntry.isHandled;
            parentAbortEntry = parentAbortEntry.parent;
          }
          abortEntry.isHandled = true;
          if (!isFulfilled && !isHandled) {
            isFulfilled = true;
            const abortReason = abortEntry.reason;
            reject(new AbortError(abortReason instanceof Error ? abortReason.message : abortReason));
          }
        };
        signal.addEventListener('abort', abortHandler);
        executor(resolver, rejector, aborter, signal);
      });
      this[ABORT] = void 0;
      this[ABORT_SIGNAL] = void 0;
      ABORTERS.set(this, {
        controller: abortController
      });
      this[ABORT] = aborter.bind(null);
      this[ABORT_SIGNAL] = signal;
    }
    _wrapHandler(handler) {
      if (!utils.isFunction(handler)) {
        return handler;
      }
      return result => {
        let handlerResult = handler(result);
        if (handlerResult instanceof AbortablePromise) {
          AbortablePromise.connect(this, handlerResult);
        } else if (handlerResult instanceof Promise) {
          const abortableResult = handlerResult = AbortablePromise.from(handlerResult);
          AbortablePromise.connect(this, abortableResult);
        }
        if (this[ABORT_SIGNAL].aborted) {
          const abortReason = ABORTERS.get(this).reason;
          throw new AbortError(abortReason instanceof Error ? abortReason.message : abortReason);
        }
        return handlerResult;
      };
    }
    then(onFulfilled, onRejected) {
      const child = AbortablePromise.from(super.then(this._wrapHandler(onFulfilled), this._wrapHandler(onRejected)));
      AbortablePromise.connect(this, child);
      return child;
    }
    catch(onRejected) {
      const child = AbortablePromise.from(super.catch(this._wrapHandler(onRejected)));
      AbortablePromise.connect(this, child);
      return child;
    }
    finally(onFinally) {
      const child = AbortablePromise.from(super.finally(this._wrapHandler(onFinally)));
      AbortablePromise.connect(this, child);
      return child;
    }
    /*LWC compiler v7.1.5*/
  }

  class FetchResponse {
    constructor(response, data) {
      this.response = response;
      this.data = data;
    }
  }
  function isFetchResponse(value) {
    return value instanceof FetchResponse;
  }
  function createFetchResponse(response, data) {
    const result = new FetchResponse(response, data);
    Object.freeze(result);
    return result;
  }

  const RESPONSE_TYPES_OPAQUE = ['opaque', 'opaqueredirect'];
  async function defaultHandleResponse(response) {
    const [resp, data] = isFetchResponse(response) ? [response.response, response.data] : [response, response];
    if (resp instanceof Response && !resp.ok && !RESPONSE_TYPES_OPAQUE.includes(resp.type)) {
      throw await data;
    }
    return data;
  }
  function execute(url, requestInit, signal) {
    let effectiveRequestInit = {
      ...requestInit
    };
    delete effectiveRequestInit.interceptRequest;
    delete effectiveRequestInit.interceptResponse;
    let handleResponse = defaultHandleResponse;
    if (requestInit && utils.isFunction(requestInit.interceptResponse)) {
      const {
        interceptResponse
      } = requestInit;
      handleResponse = response => {
        const interceptorResult = interceptResponse(response, url, effectiveRequestInit);
        if (utils.isPromiseLike(interceptorResult)) {
          return Promise.resolve(interceptorResult).then(defaultHandleResponse);
        }
        return defaultHandleResponse(interceptorResult);
      };
    }
    const executeRequest = ({
      url: _url,
      requestInit: _reqInit
    } = {}) => {
      if (_reqInit && typeof _reqInit === 'object') {
        effectiveRequestInit = {
          ..._reqInit,
          signal
        };
        delete effectiveRequestInit.interceptRequest;
        delete effectiveRequestInit.interceptResponse;
      }
      return transport.fetch(_url || url, effectiveRequestInit).then(handleResponse);
    };
    if (requestInit && utils.isFunction(requestInit.interceptRequest)) {
      const {
        interceptRequest
      } = requestInit;
      const interceptorResult = interceptRequest(url, effectiveRequestInit);
      if (utils.isPromiseLike(interceptorResult)) {
        return Promise.resolve(interceptorResult).then(executeRequest);
      }
      return executeRequest(interceptorResult);
    }
    return executeRequest();
  }
  function fetchAbortable(executor) {
    let resolve;
    let reject;
    let abort;
    let signal;
    const mainPromise = new AbortablePromise((_resolve, _reject, _abort, _signal) => {
      resolve = _resolve;
      reject = _reject;
      abort = _abort;
      signal = _signal;
    });
    let isAborted = false;
    signal.addEventListener('abort', () => isAborted = true);
    const fetcher = (requestInfo, requestInit) => {
      const isRequest = requestInfo instanceof Request;
      const init = requestInit && typeof requestInit === 'object' ? {
        ...requestInit,
        signal
      } : {
        signal
      };
      const reqInit = isRequest ? {
        ...requestInfo.clone(),
        ...init
      } : init;
      const url = isRequest ? requestInfo.url : requestInfo;
      if (!isAborted) {
        execute(url, reqInit, signal).then(_r => !isAborted && resolve(_r)).catch(reason => !isAborted && reject(reason));
      }
      return mainPromise;
    };
    executor(fetcher, abort, signal);
    return mainPromise;
  }

  const defaultRequestInterceptor = (url, requestInit) => {
    return {
      url,
      requestInit: {
        method: 'GET',
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'application/json;charset=UTF-8'
        },
        ...(requestInit && typeof requestInit === 'object' ? requestInit : {})
      }
    };
  };
  function createResponseInterceptor(obtainData) {
    return (response, _url, _requestInit) => {
      if (response instanceof Response) {
        const {
          headers,
          status
        } = response;
        const contentType = headers.get('content-type');
        if (typeof contentType === 'string' && contentType.includes('application/json')) {
          const contentLength = headers.has('content-length') && headers.get('transfer-encoding') !== 'chunked' ? Number(headers.get('content-length')) : -1;
          if (status === 204 || contentLength === 0) {
            return null;
          }
          const effectiveData = obtainData(response, _url, _requestInit);
          return createFetchResponse(response, effectiveData);
        }
      }
      return response;
    };
  }
  const defaultResponseInterceptor = createResponseInterceptor(response => response.ok ? response.json() : response);
  function prepareRequestInit(requestInit) {
    const reqInit = requestInit && typeof requestInit === 'object' ? {
      ...requestInit
    } : {};
    if (!utils.isFunction(reqInit.interceptRequest)) {
      reqInit.interceptRequest = defaultRequestInterceptor;
    }
    if (!utils.isFunction(reqInit.interceptResponse)) {
      reqInit.interceptResponse = defaultResponseInterceptor;
    }
    return reqInit;
  }
  function fetchService(executorOrRequestInfo, requestInit) {
    return fetchAbortable((fetch, abort, signal) => {
      if (typeof executorOrRequestInfo === 'function') {
        const fetcher = (reqInfo, reqInit) => fetch(reqInfo, prepareRequestInit(reqInit));
        executorOrRequestInfo(fetcher, abort, signal);
      } else {
        fetch(executorOrRequestInfo, prepareRequestInit(requestInit));
      }
    });
  }

  function verifyType(prop, type = 'string') {
    return prop === null || (type === 'array' ? typeof prop === 'undefined' || Array.isArray(prop) : ['undefined', type].includes(typeof prop));
  }
  function isFetchErrorResponse(value) {
    return value !== null && typeof value === 'object' && Reflect.has(value, 'message') && Reflect.has(value, 'type') && verifyType(value?.message) && verifyType(value?.type) && verifyType(value?.arguments, 'object');
  }
  function isFetchErrorData(value) {
    return value !== null && typeof value === 'object' && Reflect.has(value, 'status') && Reflect.has(value, 'errors') && verifyType(value?.status, 'number') && verifyType(value?.errors, 'array');
  }
  function normalizeArguments(args) {
    if (args) {
      return Reflect.ownKeys(args).reduce((acc, key) => {
        typeof key === 'string' && Reflect.set(acc, key, Reflect.get(args, key));
        return acc;
      }, {});
    }
    return {};
  }
  function toFetchErrorResponse$1({
    message,
    type,
    arguments: args
  }) {
    return {
      message: message ?? '',
      type: type ?? '',
      arguments: normalizeArguments(args)
    };
  }
  function normalizeErrors(value) {
    if (Array.isArray(value)) {
      return value.reduce((acc, element) => {
        if (isFetchErrorResponse(element)) {
          acc.push(toFetchErrorResponse$1(element));
        }
        return acc;
      }, []);
    } else if (isFetchErrorResponse(value)) {
      return [toFetchErrorResponse$1(value)];
    }
    return [];
  }
  function normalizeMessage(errors) {
    return errors.find(error => error.message.length > 0)?.message ?? '';
  }
  function normalizeData(value) {
    if (isFetchErrorData(value)) {
      const {
        status,
        errors
      } = value;
      return {
        status: status ?? null,
        errors: normalizeErrors(errors)
      };
    }
    return {
      status: null,
      errors: normalizeErrors(value)
    };
  }
  class FetchError extends Error {
    constructor(data) {
      super();
      this.name = 'FetchError';
      this.errors = [];
      this.status = null;
      let {
        status,
        errors
      } = normalizeData(data);
      this.status = status;
      this.errors = errors;
      this.message = normalizeMessage(errors);
      Object.defineProperty(this, 'errors', {
        enumerable: true,
        configurable: false,
        get: () => errors,
        set(v) {
          errors = normalizeErrors(v);
          this.message = normalizeMessage(errors);
        }
      });
      Object.defineProperty(this, 'status', {
        enumerable: true,
        configurable: false,
        get: () => status,
        set(v) {
          status = typeof v === 'number' ? v : null;
        }
      });
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(FetchError, {
    fields: ["name", "errors", "status"]
  });
  serializeError.registerErrorConstructor('FetchError', FetchError);

  function isConnectApiErrorResponse(value) {
    function verifyType(prop) {
      return typeof prop === 'string' || typeof prop === 'undefined' || prop === null;
    }
    return value !== null && typeof value === 'object' && Reflect.has(value, 'message') && Reflect.has(value, 'errorCode') && verifyType(value?.message) && verifyType(value?.errorCode);
  }
  function extractArguments(requestInit) {
    function filterStringEntries(it) {
      const acc = {};
      for (const [key, value] of it) {
        if (typeof value === 'string') {
          acc[key] = value;
        }
      }
      return acc;
    }
    if (requestInit && typeof requestInit === 'object' && (Reflect.has(requestInit, 'url') || Reflect.has(requestInit, 'body'))) {
      const {
        url: urlString = '',
        body
      } = requestInit;
      const acc = body instanceof URLSearchParams ? Object.fromEntries(body.entries()) : body instanceof FormData ? filterStringEntries(body.entries()) : {};
      try {
        const {
          searchParams
        } = new URL(urlString);
        return {
          ...acc,
          ...Object.fromEntries(searchParams.entries())
        };
      } catch {
        return acc;
      }
    }
    return {};
  }
  function toFetchErrorResponse({
    message,
    errorCode
  }, requestInit) {
    return {
      type: errorCode ?? '',
      message: message ?? '',
      arguments: extractArguments(requestInit)
    };
  }
  function transformConnectApiErrorResponse(value, requestInit) {
    if (Array.isArray(value)) {
      return value.reduce((acc, element) => {
        if (isConnectApiErrorResponse(element)) {
          acc.push(toFetchErrorResponse(element, requestInit));
        }
        return acc;
      }, []);
    } else if (isConnectApiErrorResponse(value)) {
      return [toFetchErrorResponse(value, requestInit)];
    }
    return [];
  }
  const connectApiResponseInterceptor = createResponseInterceptor((response, url, requestInit) => {
    return response.ok ? response.json() : response.json().then(errors => {
      throw new FetchError({
        status: response.status,
        errors: transformConnectApiErrorResponse(errors, {
          ...requestInit,
          url
        })
      });
    });
  });

  Object.defineProperty(exports, 'composeQueryString', {
    enumerable: true,
    get: function () { return uri.composeQueryString; }
  });
  Object.defineProperty(exports, 'composeUri', {
    enumerable: true,
    get: function () { return uri.composeUri; }
  });
  exports.ABORT = ABORT;
  exports.ABORT_SIGNAL = ABORT_SIGNAL;
  exports.AbortError = AbortError;
  exports.AbortablePromise = AbortablePromise;
  exports.FetchError = FetchError;
  exports.connectApiResponseInterceptor = connectApiResponseInterceptor;
  exports.createFetchResponse = createFetchResponse;
  exports.createResponseInterceptor = createResponseInterceptor;
  exports.defaultRequestInterceptor = defaultRequestInterceptor;
  exports.defaultResponseInterceptor = defaultResponseInterceptor;
  exports.fetchAbortable = fetchAbortable;
  exports.fetchService = fetchService;
  exports.transformConnectApiErrorResponse = transformConnectApiErrorResponse;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/store', ['exports', 'experience/utils', 'experience/utilsInternal', '@luvio/runtime', '@luvio/registry', 'experience/serializeError', 'lwc', 'experience/data'], (function (exports, utils, utilsInternal, runtime, registry, serializeError$1, lwc, data) {

  const INSTANCES = new Map();
  const ACTIONS_TO_INSTANCES = new Map();
  const LOADING_PROMISES = new Map();
  const CONNECTED_ADAPTER_PATHS = {};
  const ADAPTERS_DEBOUNCE = new WeakMap();
  const ADAPTERS_DEBOUNCING = new Map();
  const ADAPTERS_SSR_PERMITTED = new WeakMap();
  const CACHE_TTL = 300;

  const STORE_KEY = 'experience::ɵɵStore';
  const STORE_KEY_META = 'experience::ɵɵMeta';
  const META_KEY_ERRORS = 'ɵɵErrors';
  const commandRuntimeStore = new runtime.InMemoryStore();
  commandRuntimeStore.set(STORE_KEY, {});
  commandRuntimeStore.set(STORE_KEY_META, {});
  let effectiveStore = commandRuntimeStore;
  function getState() {
    return effectiveStore.get(STORE_KEY);
  }
  function getMeta() {
    return effectiveStore.get(STORE_KEY_META);
  }
  function getStateValue(key) {
    return Reflect.get(getState(), key);
  }
  function setStateValue(key, value) {
    const state = getState();
    Reflect.set(state, key, value);
    effectiveStore.set(STORE_KEY, state);
  }
  function getMetaValue(key) {
    return Reflect.get(getMeta(), key);
  }
  function setMetaValue(key, value) {
    const meta = getMeta();
    Reflect.set(meta, key, value);
    effectiveStore.set(STORE_KEY_META, meta);
  }
  function hasErrorProp(storeName, prop, ...props) {
    const path = JSON.stringify([storeName, prop, ...props]);
    const entries = getMeta();
    return Reflect.has(entries, META_KEY_ERRORS) && entries[META_KEY_ERRORS][path] === true;
  }
  function addErrorProp(storeName, prop, ...props) {
    const path = JSON.stringify([storeName, prop, ...props]);
    const entries = getMeta();
    !Reflect.has(entries, META_KEY_ERRORS) && (entries[META_KEY_ERRORS] = {});
    entries[META_KEY_ERRORS][path] = true;
  }
  function deleteErrorProp(storeName, prop, ...props) {
    const path = JSON.stringify([storeName, prop, ...props]);
    const entries = getMeta();
    delete entries[META_KEY_ERRORS]?.[path];
  }
  function set(obj, path, value) {
    path.reduce((acc, key, i) => {
      if (i === path.length - 1) {
        acc[key] = value;
      } else if (!Reflect.has(acc, key)) {
        acc[key] = {};
      } else if (typeof acc[key] === 'object' && acc[key] !== null) {
        acc[key] = {
          ...acc[key]
        };
      }
      return acc[key];
    }, obj);
  }
  function ensureState(store) {
    if (store !== effectiveStore) {
      if (!store.keys().contains(STORE_KEY_META)) {
        store.set(STORE_KEY_META, {});
      }
      const meta = store.get(STORE_KEY_META);
      if (!store.keys().contains(STORE_KEY)) {
        store.set(STORE_KEY, {});
      } else if (Reflect.has(meta, META_KEY_ERRORS)) {
        const state = store.get(STORE_KEY);
        const errors = meta[META_KEY_ERRORS];
        Object.keys(errors).forEach(key => {
          const path = JSON.parse(key);
          if (path.length > 2) {
            set(state, path, {
              data: undefined,
              error: undefined,
              loaded: false,
              loading: false
            });
          } else {
            set(state, path, undefined);
          }
        });
        Object.entries(state).forEach(([key, value]) => {
          state[key] = utilsInternal.readonly(value);
        });
      }
      store.set(STORE_KEY_META, {});
    }
    return store;
  }
  const commandModuleRegistration = {
    id: 'commandModule',
    runtimeDependencies: {
      store: true
    },
    setCommandRuntime: ({
      store
    }) => effectiveStore = ensureState(store)
  };
  registry.register(commandModuleRegistration);

  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const validStoreAdapterKeys = ['data', 'error', 'loaded', 'loading'];
  function loadWithDebounceContext(adapter, debounced) {
    ADAPTERS_DEBOUNCE.set(adapter, debounced);
    const result = adapter.load();
    ADAPTERS_DEBOUNCE.delete(adapter);
    return result;
  }
  function serializeError(ex) {
    const serialized = serializeError$1.serializeError(ex);
    return typeof serialized === 'string' ? serialized : JSON.stringify(serialized);
  }
  function deserializeError(error) {
    const strip = err => {
      if (err.name === 'NonError') {
        err.message = err.message.replace(/^"|"$/g, '');
      }
      return err;
    };
    try {
      return strip(serializeError$1.deserializeError(JSON.parse(error)));
    } catch (e) {
      return strip(serializeError$1.deserializeError(error));
    }
  }
  function assertKeyString(k) {
    const isKey = typeof k === 'string';
    {
      if (!isKey) {
        const message = `invalid type '${typeof k}' for key '${JSON.stringify(k)}'`;
        console.warn(`[store] ${message}`);
        throw new Error(message);
      }
      if (['.', '[', ']'].some(token => k.indexOf(token) !== -1)) {
        const message = `invalid character used in key '${k}'. Forbidden are: .[]`;
        console.warn(`[store] ${message}`);
        throw new Error(message);
      }
    }
    return k;
  }
  function isStoreAdapterEntry(v) {
    return utils.isPlainObject(v) && Object.keys(v).every(key => validStoreAdapterKeys.includes(key)) && (typeof v.error === 'string' || typeof v.error === 'undefined') && typeof v.loaded === 'boolean' && typeof v.loading === 'boolean';
  }
  function isStoreAdapterEntryContainer(v) {
    if (utils.isPlainObject(v)) {
      const keys = Object.keys(v);
      return keys.length > 0 && keys.some(prop => isStoreAdapterEntry(v[prop]));
    }
    return false;
  }
  function unwrapStoreAdapterEntryContainer(container, entryKey) {
    entryKey = typeof entryKey === 'string' ? entryKey : '{}';
    const entry = utils.isPlainObject(container) ? container[entryKey] : undefined;
    const isObj = utils.isPlainObject(entry);
    if (isObj && typeof entry.error === 'string') {
      return deserializeError(entry.error);
    }
    return isObj ? entry.data : undefined;
  }
  function wrapStoreAdapterEntryContainer(value, entryKey) {
    if (isStoreAdapterEntryContainer(value)) {
      return value;
    }
    const defaults = value instanceof Error ? {
      data: undefined,
      error: serializeError(value)
    } : {
      data: value,
      error: undefined
    };
    entryKey = typeof entryKey === 'string' ? entryKey : '{}';
    return {
      [entryKey]: {
        ...defaults,
        loaded: true,
        loading: false
      }
    };
  }
  function wrap(delegate, value, key, entryKey) {
    const path = `${delegate.name}.${assertKeyString(key)}`;
    const currentValue = delegate.get(key);
    const deepMergeValue = (...objects) => {
      return objects.reduce((acc, obj) => {
        const isContainer = isStoreAdapterEntryContainer(obj);
        Object.keys(obj).forEach(k => {
          const pVal = acc[k];
          const oVal = obj[k];
          if (isContainer && utils.isPlainObject(pVal) && utils.isPlainObject(oVal)) {
            acc[k] = deepMergeValue(pVal, oVal);
          } else {
            acc[k] = oVal;
          }
        });
        return acc;
      }, {});
    };
    const mergeValue = container => {
      return utils.isPlainObject(currentValue) ? deepMergeValue(utilsInternal.deepClone(currentValue).value, container) : container;
    };
    if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, path) && CONNECTED_ADAPTER_PATHS[path] > 0 || isStoreAdapterEntryContainer(currentValue)) {
      return mergeValue(wrapStoreAdapterEntryContainer(value, entryKey));
    }
    return value;
  }
  function wrapAll(delegate, value, key) {
    const path = `${delegate.name}.${assertKeyString(key)}`;
    const currentValue = delegate.get(key);
    if (isStoreAdapterEntryContainer(currentValue)) {
      return Object.keys(currentValue).reduce((acc, k) => {
        const container = wrapStoreAdapterEntryContainer(value, k);
        acc[k] = {
          ...currentValue[k],
          ...container[k]
        };
        return acc;
      }, {});
    } else if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, path) && CONNECTED_ADAPTER_PATHS[path] > 0) {
      return Object.keys(CONNECTED_ADAPTER_PATHS).reduce((acc, k) => {
        if (k.indexOf(`${path}.`) !== -1) {
          const ek = k.substring(k.lastIndexOf('.') + 1);
          const container = wrapStoreAdapterEntryContainer(value, ek);
          acc[ek] = container[ek];
        }
        return acc;
      }, {});
    }
    return value;
  }
  function obtainLocalState(delegate, entryKey, asPlugin = false) {
    const isAdapterMode = Array.isArray(entryKey);
    const adapterEntryKey = entryKey?.at?.(1);
    function unwrap(key, value) {
      const path = `${delegate.name}.${assertKeyString(key)}`;
      if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, path) && CONNECTED_ADAPTER_PATHS[path] > 0 || isStoreAdapterEntryContainer(value)) {
        return utils.isPlainObject(value) ? unwrapStoreAdapterEntryContainer(value, adapterEntryKey) : undefined;
      }
      return value;
    }
    class LocalState {
      get name() {
        return delegate.name;
      }
      get size() {
        if (isAdapterMode && utils.isPlainObject(delegate.container)) {
          return Object.entries(delegate.container).reduce((acc, [k, v]) => {
            const p = `${delegate.name}.${k}`;
            if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, p) && CONNECTED_ADAPTER_PATHS[p] > 0 || isStoreAdapterEntryContainer(v)) {
              if (utils.isPlainObject(v) && hasOwnProperty.call(v, entryKey[1])) {
                acc++;
              }
            } else {
              acc++;
            }
            return acc;
          }, 0);
        }
        return delegate.size;
      }
      has(key) {
        const result = delegate.has(key);
        if (isAdapterMode) {
          const value = delegate.get(key);
          const path = `${delegate.name}.${assertKeyString(key)}`;
          if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, path) && CONNECTED_ADAPTER_PATHS[path] > 0 || isStoreAdapterEntryContainer(value)) {
            return utils.isPlainObject(value) && hasOwnProperty.call(value, entryKey[1]);
          }
        }
        return result;
      }
      get(key) {
        const value = delegate.get(key);
        return isAdapterMode ? unwrap(key, value) : value;
      }
      set(key, data) {
        const effectiveValue = isAdapterMode ? wrap(delegate, data, key, adapterEntryKey) : wrapAll(delegate, data, key);
        delegate.set(key, effectiveValue);
      }
      delete(key) {
        if (isAdapterMode && isStoreAdapterEntryContainer(delegate.get(key))) {
          const currentValue = delegate.get(key);
          const hasProp = hasOwnProperty.call(currentValue, entryKey[1]);
          if (hasProp) {
            const effectiveValue = {
              ...currentValue
            };
            delete effectiveValue[entryKey[1]];
            if (Object.keys(effectiveValue).length === 0) {
              delegate.delete(key);
            } else {
              delegate.set(key, effectiveValue);
            }
          }
          return hasProp;
        }
        return delegate.delete(key);
      }
      clear() {
        delegate.clear();
      }
      update(key, updater) {
        const effectiveUpdater = value => {
          const effectiveValue = isAdapterMode ? unwrap(key, value) : value;
          const updatedValue = updater(effectiveValue);
          return isAdapterMode ? wrap(delegate, updatedValue, key, adapterEntryKey) : wrapAll(delegate, updatedValue, key);
        };
        return delegate.update(key, effectiveUpdater);
      }
      dispatch(type, payload) {
        return delegate.dispatch(type, payload);
      }
    }
    class LocalPluginState extends LocalState {
      subscribe(key, fnOrSubscriber) {
        return delegate.subscribe(key, fnOrSubscriber);
      }
      subscribeAction(type, fnOrSubscriber) {
        return utils.isFunction(fnOrSubscriber) ? delegate.subscribeAction(type, fnOrSubscriber) : delegate.subscribeAction(type, fnOrSubscriber);
      }
      /*LWC compiler v7.1.5*/
    }
    return asPlugin ? new LocalPluginState() : new LocalState();
  }
  function obtainLocalAdapter(delegate) {
    class LocalAdapter {
      get config() {
        return delegate.config;
      }
      get() {
        return delegate.get();
      }
      load() {
        return loadWithDebounceContext(delegate, true);
      }
      subscribe(fnOrSubscriber) {
        return utils.isFunction(fnOrSubscriber) ? delegate.subscribe(fnOrSubscriber) : delegate.subscribe(fnOrSubscriber);
      }
      subscribeAction(type, fnOrSubscriber) {
        return utils.isFunction(fnOrSubscriber) ? delegate.subscribeAction(type, fnOrSubscriber) : delegate.subscribeAction(type, fnOrSubscriber);
      }
      subscribeLoad(fnOrSubscriber) {
        return utils.isFunction(fnOrSubscriber) ? delegate.subscribeLoad(fnOrSubscriber) : delegate.subscribeLoad(fnOrSubscriber);
      }
    }
    return new LocalAdapter();
  }
  function subscribe(key, subscriber, subs) {
    !subs[key] && (subs[key] = []);
    subs[key].push(subscriber);
    return {
      unsubscribe() {
        const s = subs[key];
        const i = s?.indexOf(subscriber);
        i > -1 && s.splice(i, 1);
      }
    };
  }
  function notifySubscriber(subscriber, category, localState, stage, type, payload, error) {
    const fn = subscriber[stage];
    if (utils.isFunction(fn)) {
      try {
        const action = {
          type,
          payload
        };
        stage === 'error' ? fn(action, localState, error) : fn(action, localState);
      } catch (e) {
        {
          console.warn(`[store] error in ${stage} ${category} subscribers:`);
          console.warn(e);
        }
      }
    }
  }
  function notifySubscribers(subscribers, category, localState, stage, type, payload, error) {
    if (subscribers[type]) {
      const subs = subscribers[type];
      for (const sub of subs) {
        if (stage === 'error') {
          notifySubscriber(sub, category, localState, stage, type, payload, error);
        } else {
          notifySubscriber(sub, category, localState, stage, type, payload);
        }
      }
    }
  }
  function patchSubscriber(subscriber, localStateGetter, actionHandler = action => action) {
    function patchSubscriberFunction(subscriberFn) {
      return (action, state, error) => {
        error ? subscriberFn(actionHandler(action), localStateGetter(), error) : subscriberFn(actionHandler(action), localStateGetter());
      };
    }
    return Object.entries(subscriber).reduce((acc, [key, value]) => {
      acc[key] = patchSubscriberFunction(value);
      return acc;
    }, {});
  }
  function createStoreAdapter(AdapterClass, config, ...parameters) {
    const params = arguments.length > 2 ? parameters : [];
    const instance = new AdapterClass(...params);
    ADAPTERS_SSR_PERMITTED.set(instance, true);
    instance.update(utils.isPlainObject(config) ? config : {});
    instance.connect();
    return instance;
  }
  function getStoreAdapterValue(AdapterClass, config, ...parameters) {
    const instance = createStoreAdapter(AdapterClass, config, ...parameters);
    return instance.get().then(entry => entry.data).finally(() => {
      instance.disconnect();
    });
  }
  function distributeStoreAdapterValue(AdapterClass, value, ...parameters) {
    const instance = createStoreAdapter(AdapterClass, {}, ...parameters);
    instance.disconnect();
    const store = instance['store'];
    const sliceKey = instance['key'];
    const slice = Reflect.get(store.container, sliceKey);
    const path = `${store.name}.${assertKeyString(sliceKey)}`;
    if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, path) && CONNECTED_ADAPTER_PATHS[path] > 0 || isStoreAdapterEntryContainer(slice)) {
      store.set(sliceKey, wrapAll(store, value, sliceKey));
    } else {
      store.set(sliceKey, value);
    }
  }
  function setStoreAdapterValue(AdapterClass, value, config, ...parameters) {
    const instance = createStoreAdapter(AdapterClass, config, ...parameters);
    const store = instance['store'];
    const sliceKey = instance['key'];
    instance.disconnect();
    store.set(sliceKey, wrap(store, value, sliceKey, instance['entryKey']));
  }
  function deleteStoreAdapterValue(AdapterClass, config, ...parameters) {
    const instance = createStoreAdapter(AdapterClass, config, ...parameters);
    const state = obtainLocalState(instance['store'], [instance['key'], instance['entryKey'], instance['uuid']]);
    instance.disconnect();
    if (!instance.options?.discard && !instance['store'].options.discard) {
      state.delete(instance['key']);
    }
  }
  function toEntryKey(config, context) {
    const orderedContext = utilsInternal.deepSort(context ?? {}).value;
    const orderedConfig = utilsInternal.deepSort(config ?? {}).value;
    const contextKey = JSON.stringify(orderedContext, utilsInternal.circularRefReplacer());
    const configKey = JSON.stringify(orderedConfig, utilsInternal.circularRefReplacer());
    return `${contextKey}:${configKey}`;
  }
  function hasSubscribers(store, key, config, context) {
    const pathRoot = `${store.name}.${key}`;
    if (utils.isPlainObject(config) || utils.isPlainObject(context)) {
      const entryKey = toEntryKey(config, context);
      const pathEntry = `${pathRoot}.${entryKey}`;
      return Reflect.has(CONNECTED_ADAPTER_PATHS, pathEntry) && Number(CONNECTED_ADAPTER_PATHS[pathEntry]) > 0;
    }
    return Reflect.has(CONNECTED_ADAPTER_PATHS, pathRoot) && Number(CONNECTED_ADAPTER_PATHS[pathRoot]) > 0 || Reflect.has(store['subscribers'], key) && store['subscribers']?.[key]?.length > 0;
  }

  class StoreActionError extends Error {
    constructor(error) {
      super(typeof error === 'string' ? error : error instanceof Error ? error.message : undefined);
      this.name = 'StoreActionError';
      this.error = error;
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(StoreActionError, {
    fields: ["name"]
  });
  serializeError$1.registerErrorConstructor('StoreActionError', StoreActionError);

  class Store {
    constructor(name, options = Object.freeze({})) {
      this.actions = {};
      this.actionSubscribers = {};
      this.subscribers = {};
      this.localState = obtainLocalState(this);
      this.name = name;
      this.options = options;
      if (INSTANCES.has(name)) {
        return INSTANCES.get(name);
      }
      INSTANCES.set(name, this);
      if (Reflect.has(options, 'state')) {
        this._updateContainer(utils.isFunction(options.state) ? options.state() : options.state);
      } else if (!utils.isPlainObject(getStateValue(this.name))) {
        setStateValue(this.name, {});
      }
      if (utils.isPlainObject(options.actions)) {
        for (const [type, action] of Object.entries(options.actions)) {
          if (utils.isPlainObject(action) && typeof action.namespace === 'string' && utils.isFunction(action.handler)) {
            const {
              namespace,
              handler
            } = action;
            const namespacedAction = `${namespace}/${type}`;
            if (ACTIONS_TO_INSTANCES.has(namespacedAction)) {
              throw new TypeError(`[store] handler already registered for action type in namespace '${namespace}': ${type}`);
            }
            ACTIONS_TO_INSTANCES.set(namespacedAction, this);
            this._registerAction(type, handler);
          } else if (utils.isFunction(action)) {
            this._registerAction(type, action);
          } else {
            throw new TypeError(`[store] invalid action configuration for store '${name}': ${type}`);
          }
        }
      }
      const pluginState = obtainLocalState(this, undefined, true);
      if (Array.isArray(options.plugins)) {
        for (const plugin of options.plugins) {
          plugin(pluginState);
        }
      }
    }
    get size() {
      return Object.keys(this.container).length;
    }
    get container() {
      return getStateValue(this.name);
    }
    _updateContainer(value) {
      const val = utilsInternal.readonly(value);
      setStateValue(this.name, utils.isPlainObject(val) ? val : {});
    }
    _has(key) {
      return Reflect.has(this.container, key);
    }
    _get(key) {
      const container = this.container;
      const data = Reflect.has(container, key) ? container[key] : undefined;
      if (hasErrorProp(this.name, key)) {
        return deserializeError(data);
      }
      return data;
    }
    _delete(key) {
      if (this._has(key)) {
        this._notify(key, () => {
          deleteErrorProp(this.name, key);
          const {
            [key]: _,
            ...newContainer
          } = this.container;
          this._updateContainer(newContainer);
        });
        return true;
      }
      return false;
    }
    _update(key, data) {
      this._notify(key, () => this._set(key, data));
    }
    _set(key, data) {
      const isError = data instanceof Error;
      const value = isError ? serializeError(data) : data;
      if (isError) {
        addErrorProp(this.name, key);
      } else {
        deleteErrorProp(this.name, key);
      }
      this._updateContainer({
        ...this.container,
        [key]: value
      });
    }
    _notify(key, handler) {
      const oldValue = this._get(key);
      this._notifyMutationSubscribers('before', key, oldValue instanceof Error ? undefined : oldValue);
      utils.isFunction(handler) && handler();
      const value = this._get(key);
      if (value instanceof Error) {
        this._notifyMutationSubscribers('error', key, undefined, value);
      } else {
        this._notifyMutationSubscribers('after', key, value);
      }
    }
    _registerAction(type, handler) {
      this.actions[type] = payload => {
        try {
          const res = handler.call(null, this.localState, payload);
          return Promise.resolve(res);
        } catch (e) {
          return Promise.reject(e);
        }
      };
    }
    _notifyActionSubscribers(stage, type, payload, error) {
      notifySubscribers(this.actionSubscribers, 'action', this.localState, stage, type, payload, error);
    }
    _notifyMutationSubscribers(stage, key, value, error) {
      notifySubscribers(this.subscribers, 'mutation', this.localState, stage, key, value, error);
    }
    _dispatchAction(type, handler, payload) {
      const effectivePayload = utilsInternal.readonly(payload);
      this._notifyActionSubscribers('before', type, effectivePayload);
      return new Promise((resolve, reject) => {
        handler(effectivePayload).then(res => {
          this._notifyActionSubscribers('after', type, res);
          resolve(res);
        }).catch(error => {
          const err = error instanceof Error ? error : new StoreActionError(error);
          this._notifyActionSubscribers('error', type, effectivePayload, err);
          reject(err);
        });
      });
    }
    has(key) {
      return this._has(assertKeyString(key));
    }
    get(key) {
      return this._get(assertKeyString(key));
    }
    set(key, data) {
      this._update(assertKeyString(key), data);
    }
    delete(key) {
      return this._delete(assertKeyString(key));
    }
    clear() {
      for (const key of Object.keys(this.container)) {
        this._delete(key);
      }
    }
    update(key, updater) {
      if (utils.isFunction(updater)) {
        const k = assertKeyString(key);
        this._update(k, updater(this._get(k)));
      }
    }
    dispatch(type, payload) {
      const handler = this.actions[type];
      if (utils.isFunction(handler)) {
        return this._dispatchAction(type, handler, payload);
      }
      if (type.includes('/') && ACTIONS_TO_INSTANCES.has(type)) {
        const effectiveType = type.substring(type.indexOf('/') + 1);
        const responsibleStore = ACTIONS_TO_INSTANCES.get(type);
        return responsibleStore.dispatch(effectiveType, payload);
      }
      const message = `unknown action type: ${type}`;
      {
        console.warn(`[store] ${message}`);
      }
      return Promise.reject(new TypeError(message));
    }
    subscribe(key, fnOrSubscriber) {
      const toSubscriber = input => typeof input === 'function' ? {
        after: input,
        error: input
      } : input;
      const k = assertKeyString(key);
      const subscriber = toSubscriber(fnOrSubscriber);
      const subscribers = this.subscribers;
      const subscription = subscribe(k, subscriber, subscribers);
      const discard = typeof window !== 'undefined' && this.options?.discard === true;
      const effectiveSubscription = {
        unsubscribe: () => {
          subscription.unsubscribe();
          if (discard && (!Reflect.has(subscribers, k) || subscribers[k].length === 0)) {
            delete subscribers[k];
            this._delete(k);
          }
        }
      };
      if (this._has(k)) {
        const v = this._get(k);
        v instanceof Error ? notifySubscriber(subscriber, 'mutation', this.localState, 'error', k, undefined, v) : notifySubscriber(subscriber, 'mutation', this.localState, 'after', k, v);
      }
      return effectiveSubscription;
    }
    subscribeAction(type, fnOrSubscriber) {
      const subscriber = typeof fnOrSubscriber === 'function' ? {
        after: fnOrSubscriber,
        error: fnOrSubscriber
      } : fnOrSubscriber;
      if (type.includes('/') && ACTIONS_TO_INSTANCES.has(type)) {
        const effectiveType = type.substring(type.indexOf('/') + 1);
        const responsibleStore = ACTIONS_TO_INSTANCES.get(type);
        return responsibleStore.subscribeAction(effectiveType, fnOrSubscriber);
      }
      return subscribe(type, subscriber, this.actionSubscribers);
    }
  }

  const defaultConfig = Object.freeze({});
  function obtainLoader(options) {
    const {
      loader
    } = options || {};
    const isObj = utils.isPlainObject(loader);
    return {
      handler: !isObj && utils.isFunction(loader) ? loader : isObj && utils.isFunction(loader.handler) ? loader.handler : undefined,
      abortable: isObj && loader.abortable === true
    };
  }
  function empty(loading = false) {
    return {
      data: undefined,
      error: undefined,
      loaded: false,
      loading
    };
  }
  function createLooseSubscriber(subscriber, subs, activeUnsub, key) {
    const entry = activeUnsub ? {
      key,
      subscriber,
      unsubscribable: activeUnsub
    } : {
      key,
      subscriber
    };
    subs.push(entry);
    return {
      unsubscribe: () => {
        entry.unsubscribable?.unsubscribe();
        const s = subs;
        const i = s.indexOf(entry);
        i > -1 && s.splice(i, 1);
      }
    };
  }
  function disarmLooseSubscribers(rawSubs) {
    for (const entry of rawSubs) {
      delete entry.unsubscribable;
    }
  }
  function obtainAdapterControlledPath(store, key, entryKey) {
    const rootPath = `${store.name}.${key}`;
    return entryKey ? `${rootPath}.${entryKey}` : rootPath;
  }
  function updateAdapterControlledPathsCounter(store, key, entryKey, update = 1) {
    const pathRoot = obtainAdapterControlledPath(store, key);
    const pathEntry = `${pathRoot}.${entryKey}`;
    [pathRoot, pathEntry].forEach(path => {
      const count = CONNECTED_ADAPTER_PATHS[path];
      const newCount = (utils.isInteger(count) ? count : 0) + update;
      if (newCount > 0) {
        CONNECTED_ADAPTER_PATHS[path] = newCount;
      } else {
        delete CONNECTED_ADAPTER_PATHS[path];
      }
    });
  }
  function ensureEntry(entry) {
    return isStoreAdapterEntry(entry) ? entry : empty();
  }
  class StoreAdapter {
    get config() {
      return this._config || defaultConfig;
    }
    constructor(dataCallback, store, key, options) {
      this.uuid = utilsInternal.uuidv4();
      this.connectors = [];
      this.rawMutationSubscribers = [];
      this.rawActionSubscribers = [];
      this.rawLoadSubscribers = [];
      this.loadSubscribers = {};
      this.activeSubscriptions = [];
      this.localState = void 0;
      this.isConnected = false;
      this.isSubscribed = false;
      this._config = void 0;
      this._context = void 0;
      this.entryKey = void 0;
      this.lastCallbackEntry = void 0;
      this.dataCallback = dataCallback;
      this.store = store;
      this.key = key;
      this.options = options;
      if (options && Array.isArray(options.connectors)) {
        for (const connector of options.connectors) {
          if (utils.isPlainObject(connector)) {
            this.connectors.push(connector);
          } else if (utils.isFunction(connector)) {
            this.connectors.push({
              connect: connector
            });
          }
        }
      }
    }
    get loadingPromises() {
      return LOADING_PROMISES.get(this.store.name);
    }
    _notifyConnectors(stage) {
      for (const connector of this.connectors) {
        if (utils.isFunction(connector[stage])) {
          connector[stage](obtainLocalAdapter(this), {
            type: this.key,
            payload: this.config
          }, this.localState);
        }
      }
    }
    _notifyLoadSubscribers(stage, error) {
      const {
        data
      } = this._read();
      notifySubscribers(this.loadSubscribers, 'load', this.localState, stage, this.key, data, error);
    }
    _obtainLoadingPromiseKey() {
      return `${assertKeyString(this.key)}:${this.entryKey}`;
    }
    _obtainRawEntryContainer() {
      return this.store.get(this.key);
    }
    _obtainEntryContainer() {
      const entry = this._obtainRawEntryContainer();
      return utils.isPlainObject(entry) ? {
        ...entry
      } : {};
    }
    _obtainEntry(entry) {
      const e = utils.isPlainObject(entry) ? entry : this._obtainEntryContainer();
      return e?.[this.entryKey];
    }
    _read(entry) {
      return ensureEntry(entry || this._obtainEntry());
    }
    _writeContainer(container) {
      this.store.set(this.key, container);
    }
    _write(value, entryKey = this.entryKey) {
      const container = this._obtainEntryContainer();
      container[entryKey] = value;
      this._updateMeta('w', entryKey);
      this._writeContainer(container);
    }
    _updateMeta(mode, entryKey = this.entryKey) {
      const metaKey = `${this.store.name}:${assertKeyString(this.key)}`;
      const metaValue = getMetaValue(metaKey) ?? {};
      if (mode === 'd') {
        Reflect.deleteProperty(metaValue, entryKey);
      } else {
        Reflect.set(metaValue, entryKey, performance.now() + performance.timeOrigin);
      }
      setMetaValue(metaKey, metaValue);
    }
    _callback(value) {
      if (this.isConnected && this.dataCallback && !utilsInternal.deepEqual(value, this.lastCallbackEntry).value) {
        this.lastCallbackEntry = value;
        const {
          error
        } = value;
        const cbVal = {
          ...value
        };
        cbVal.error = typeof error === 'string' ? deserializeError(error) : undefined;
        utilsInternal.readonly(cbVal);
        this.dataCallback.call(null, cbVal);
      }
    }
    _removeLoadingPromise(loadingPromiseKey) {
      const loadingPromises = this.loadingPromises;
      const loadingPromise = loadingPromises?.get(loadingPromiseKey);
      loadingPromises?.delete(loadingPromiseKey);
      utils.clearDebounceTimeout(loadingPromise);
      utils.clearDebounceTimeout(ADAPTERS_DEBOUNCING.get(loadingPromiseKey));
    }
    _unsubscribe() {
      if (this.isSubscribed) {
        this.isSubscribed = false;
        updateAdapterControlledPathsCounter(this.store, this.key, this.entryKey, -1);
        const discard = typeof window !== 'undefined' && (this.options?.discard || this.store.options.discard) === true;
        if (discard && utils.isPlainObject(this._obtainRawEntryContainer())) {
          const entryKeyPath = obtainAdapterControlledPath(this.store, this.key, this.entryKey);
          if (!Reflect.has(CONNECTED_ADAPTER_PATHS, entryKeyPath)) {
            const container = this._obtainEntryContainer();
            delete container[this.entryKey];
            if (Object.keys(container).length === 0) {
              const metaKey = `${this.store.name}:${assertKeyString(this.key)}`;
              setMetaValue(metaKey, {});
              this.store.delete(this.key);
            } else {
              this._updateMeta('d');
              this._writeContainer(container);
            }
          }
        }
        this._notifyConnectors('disconnect');
      }
      for (const sub of this.activeSubscriptions) {
        sub.unsubscribe();
      }
      this.activeSubscriptions.splice(0, this.activeSubscriptions.length);
      disarmLooseSubscribers(this.rawMutationSubscribers);
      disarmLooseSubscribers(this.rawActionSubscribers);
      disarmLooseSubscribers(this.rawLoadSubscribers);
      for (const key of Object.keys(this.loadSubscribers)) {
        delete this.loadSubscribers[key];
      }
      delete this.lastCallbackEntry;
    }
    _subscribe() {
      if (!this.isConnected || !this._config) {
        return;
      }
      this._unsubscribe();
      const comparedEntryKey = toEntryKey(this._config, this._context);
      if (this.entryKey !== comparedEntryKey) {
        this.entryKey = comparedEntryKey;
        this.localState = obtainLocalState(this.store, [this.key, this.entryKey, this.uuid]);
        const initialContainer = this._obtainRawEntryContainer();
        if (typeof initialContainer !== 'undefined' && !isStoreAdapterEntryContainer(initialContainer)) {
          const transformedContainer = wrapStoreAdapterEntryContainer(initialContainer, this.entryKey);
          {
            const entryRootPath = obtainAdapterControlledPath(this.store, this.key);
            const entryKeyPath = `${entryRootPath}.${this.entryKey}`;
            console.warn(`[store-adapter] entry for path '${entryKeyPath}' is connected to a store adapter, yet the data doesn't have the required shape.`);
            console.warn(`[store-adapter] going to transform data:`, initialContainer);
          }
          Object.keys(transformedContainer).forEach(entryKey => this._updateMeta('w', entryKey));
          this._writeContainer(transformedContainer);
        }
      }
      updateAdapterControlledPathsCounter(this.store, this.key, this.entryKey);
      if (!LOADING_PROMISES.has(this.store.name)) {
        LOADING_PROMISES.set(this.store.name, new Map());
      }
      this._notifyConnectors('connect');
      for (const entry of this.rawLoadSubscribers) {
        const activeUnsub = subscribe(this.key, entry.subscriber, this.loadSubscribers);
        this.activeSubscriptions.push(activeUnsub);
        entry.unsubscribable = activeUnsub;
      }
      this.isSubscribed = true;
      const mutationHandler = () => {
        let oldPayload;
        const beforeHandler = ({
          payload
        }) => {
          oldPayload = payload;
        };
        const afterHandler = ({
          payload
        }) => {
          if (this.entryKey && (utils.isPlainObject(oldPayload) && Reflect.has(oldPayload, this.entryKey) || utils.isPlainObject(payload) && Reflect.has(payload, this.entryKey))) {
            const newEntry = this._obtainEntry(payload);
            this._isValid(newEntry) && this._callback(this._read(newEntry));
          }
        };
        return {
          before: beforeHandler,
          after: afterHandler,
          error: afterHandler
        };
      };
      this.activeSubscriptions.push(this.store.subscribe(this.key, mutationHandler()));
      if (!obtainLoader(this.options).handler || typeof window === 'undefined' && !ADAPTERS_SSR_PERMITTED.get(this)) {
        this._callback(this._read());
      } else {
        this._getAsync(this._read());
      }
      for (const entry of this.rawMutationSubscribers) {
        const activeUnsub = this.store.subscribe(this.key, entry.subscriber);
        this.activeSubscriptions.push(activeUnsub);
        entry.unsubscribable = activeUnsub;
      }
      for (const entry of this.rawActionSubscribers) {
        const activeUnsub = this.store.subscribeAction(entry.key, entry.subscriber);
        this.activeSubscriptions.push(activeUnsub);
        entry.unsubscribable = activeUnsub;
      }
    }
    _getAsync(entry) {
      const loadingPromiseKey = this._obtainLoadingPromiseKey();
      const loadingPromise = this.loadingPromises?.get(loadingPromiseKey);
      const hasLoadingPromise = utils.isPromiseLike(loadingPromise);
      if (hasLoadingPromise) {
        return loadingPromise;
      } else if (!entry.loaded && !entry.loading) {
        return loadWithDebounceContext(this, false);
      } else if (entry.loading && !hasLoadingPromise) {
        return loadWithDebounceContext(this, false);
      }
      if (!this._isValid(entry)) {
        return loadWithDebounceContext(this, false);
      }
      return Promise.resolve(utilsInternal.readonly(entry));
    }
    _isValid(entry) {
      if (this.options && utils.isFunction(this.options.validator)) {
        try {
          if (!this.options.validator({
            type: this.key,
            payload: utilsInternal.readonly(entry)
          }, obtainLocalAdapter(this), this.localState)) {
            return false;
          }
        } catch {
          // Intentionally empty
        }
      }
      const metaKey = `${this.store.name}:${assertKeyString(this.key)}`;
      const lastUpdated = getMetaValue(metaKey)?.[this.entryKey];
      if (typeof lastUpdated === 'number') {
        const ttl = typeof this.options?.cache?.ttl === 'number' && !Number.isNaN(this.options.cache.ttl) && this.options.cache.ttl >= -1 ? this.options?.cache?.ttl : CACHE_TTL;
        if (ttl === -1) {
          return true;
        }
        const now = performance.now();
        const then = lastUpdated - performance.timeOrigin;
        const diff = now - then;
        return ttl * 1000 >= diff;
      }
      return true;
    }
    _load(loadHandler, loadingPromiseKey) {
      this._notifyLoadSubscribers('before');
      const {
        name: storeName
      } = this.store;
      try {
        const shouldDebounce = ADAPTERS_DEBOUNCE.get(this) !== false;
        const effectiveLoadHandler = shouldDebounce ? utils.debounce(loadHandler) : loadHandler;
        const result = effectiveLoadHandler({
          type: this.key,
          payload: this._config
        }, this.localState);
        if (utils.isPromiseLike(result)) {
          shouldDebounce && ADAPTERS_DEBOUNCING.set(loadingPromiseKey, result);
          const abortableResultPromise = data.AbortablePromise.from(result);
          const loadingPromise = abortableResultPromise.then(data => {
            const currentLoadingPromiseKey = this._obtainLoadingPromiseKey();
            const currentLoadingPromise = this.loadingPromises?.get(currentLoadingPromiseKey);
            if (currentLoadingPromiseKey !== loadingPromiseKey) {
              ADAPTERS_DEBOUNCING.delete(loadingPromiseKey);
              this._removeLoadingPromise(loadingPromiseKey);
              const oldEntryKey = loadingPromiseKey.substring(loadingPromiseKey.indexOf(':') + 1);
              deleteErrorProp(storeName, this.key, oldEntryKey);
              this._write({
                data,
                error: undefined,
                loaded: true,
                loading: false
              }, oldEntryKey);
            } else if (currentLoadingPromise && currentLoadingPromise === loadingPromise) {
              ADAPTERS_DEBOUNCING.delete(currentLoadingPromiseKey);
              this._removeLoadingPromise(currentLoadingPromiseKey);
              deleteErrorProp(storeName, this.key, this.entryKey);
              this._write({
                data,
                error: undefined,
                loaded: true,
                loading: false
              });
              this._notifyLoadSubscribers('after');
            }
            return utilsInternal.readonly(this._read());
          }, ex => {
            const currentLoadingPromiseKey = this._obtainLoadingPromiseKey();
            const currentLoadingPromise = this.loadingPromises?.get(currentLoadingPromiseKey);
            if (currentLoadingPromiseKey !== loadingPromiseKey) {
              ADAPTERS_DEBOUNCING.delete(loadingPromiseKey);
              this._removeLoadingPromise(loadingPromiseKey);
              const oldEntryKey = loadingPromiseKey.substring(loadingPromiseKey.indexOf(':') + 1);
              if (ex instanceof data.AbortError) {
                deleteErrorProp(storeName, this.key, oldEntryKey);
                const container = this._obtainEntryContainer();
                this._write({
                  ...ensureEntry(container?.[oldEntryKey]),
                  loading: false
                }, oldEntryKey);
              } else {
                addErrorProp(storeName, this.key, oldEntryKey);
                this._write({
                  data: undefined,
                  error: serializeError(ex),
                  loaded: true,
                  loading: false
                }, oldEntryKey);
              }
            } else if (currentLoadingPromise && currentLoadingPromise === loadingPromise) {
              ADAPTERS_DEBOUNCING.delete(currentLoadingPromiseKey);
              this._removeLoadingPromise(currentLoadingPromiseKey);
              if (ex instanceof data.AbortError) {
                deleteErrorProp(storeName, this.key, this.entryKey);
                this._write({
                  ...this._read(),
                  loading: false
                });
                this._notifyLoadSubscribers('after');
              } else {
                addErrorProp(storeName, this.key, this.entryKey);
                this._write({
                  data: undefined,
                  error: serializeError(ex),
                  loaded: true,
                  loading: false
                });
                this._notifyLoadSubscribers('error', ex);
              }
            }
            return utilsInternal.readonly(this._read());
          });
          this.loadingPromises?.set(loadingPromiseKey, loadingPromise);
          this._write({
            ...this._read(),
            loading: true
          });
          return loadingPromise;
        }
        deleteErrorProp(storeName, this.key, this.entryKey);
        this._write({
          data: result,
          error: undefined,
          loaded: true,
          loading: false
        });
        this._notifyLoadSubscribers('after');
      } catch (ex) {
        if (ex instanceof data.AbortError) {
          deleteErrorProp(storeName, this.key, this.entryKey);
          this._write({
            ...this._read(),
            loading: false
          });
          this._notifyLoadSubscribers('after');
        } else {
          addErrorProp(storeName, this.key, this.entryKey);
          const error = serializeError(ex);
          this._write({
            data: undefined,
            error,
            loaded: true,
            loading: false
          });
          this._notifyLoadSubscribers('error', ex);
        }
      }
      ADAPTERS_DEBOUNCING.delete(loadingPromiseKey);
      return Promise.resolve(utilsInternal.readonly(this._read()));
    }
    update(config, context) {
      this._config = utilsInternal.readonly(config);
      this._context = utilsInternal.readonly(context ?? {});
      this._subscribe();
    }
    connect() {
      if (!this.isConnected) {
        ADAPTERS_SSR_PERMITTED.has(this) && ADAPTERS_SSR_PERMITTED.set(this, true);
        this.isConnected = true;
        this._subscribe();
      }
    }
    disconnect() {
      if (this.isConnected) {
        ADAPTERS_SSR_PERMITTED.has(this) && ADAPTERS_SSR_PERMITTED.set(this, false);
        this.isConnected = false;
        this._unsubscribe();
      }
    }
    get() {
      const promise = this._getAsync(this._read());
      return promise.then(entry => {
        if (typeof entry.error === 'string') {
          throw deserializeError(entry.error);
        }
        return entry;
      });
    }
    load() {
      const loaderConfig = obtainLoader(this.options);
      if (!this.isSubscribed || !loaderConfig.handler) {
        return Promise.resolve(utilsInternal.readonly(this._read()));
      }
      const currentLoadingPromiseKey = this._obtainLoadingPromiseKey();
      const currentLoadingPromise = this.loadingPromises?.get(currentLoadingPromiseKey);
      if (utils.isPromiseLike(currentLoadingPromise) && (utils.extendDebouncedTimeout(currentLoadingPromise) || utils.extendDebouncedTimeout(ADAPTERS_DEBOUNCING.get(currentLoadingPromiseKey)))) {
        return currentLoadingPromise;
      }
      const {
        handler: loadHandler
      } = loaderConfig;
      return this._load(loadHandler, currentLoadingPromiseKey);
    }
    subscribe(fnOrSubscriber) {
      const localStateGetter = () => this.localState;
      const actionHandler = action => {
        const {
          payload
        } = action;
        return {
          type: action.type,
          payload: payload?.[this.entryKey]?.data
        };
      };
      const subscriber = utils.isFunction(fnOrSubscriber) ? patchSubscriber({
        after: fnOrSubscriber,
        error: fnOrSubscriber
      }, localStateGetter, actionHandler) : patchSubscriber(fnOrSubscriber, localStateGetter, actionHandler);
      const activeUnsub = this.isSubscribed ? this.store.subscribe(this.key, subscriber) : undefined;
      activeUnsub && this.activeSubscriptions.push(activeUnsub);
      return createLooseSubscriber(subscriber, this.rawMutationSubscribers, activeUnsub);
    }
    subscribeAction(type, fnOrSubscriber) {
      const localStateGetter = () => this.localState;
      const subscriber = typeof fnOrSubscriber === 'function' ? patchSubscriber({
        after: fnOrSubscriber,
        error: fnOrSubscriber
      }, localStateGetter) : patchSubscriber(fnOrSubscriber, localStateGetter);
      const activeUnsub = this.isSubscribed ? this.store.subscribeAction(type, subscriber) : undefined;
      activeUnsub && this.activeSubscriptions.push(activeUnsub);
      return createLooseSubscriber(subscriber, this.rawActionSubscribers, activeUnsub, type);
    }
    subscribeLoad(fnOrSubscriber) {
      const localStateGetter = () => this.localState;
      const subscriber = utils.isFunction(fnOrSubscriber) ? patchSubscriber({
        after: fnOrSubscriber,
        error: fnOrSubscriber
      }, localStateGetter) : patchSubscriber(fnOrSubscriber, localStateGetter);
      const activeUnsub = this.isSubscribed ? subscribe(this.key, subscriber, this.loadSubscribers) : undefined;
      activeUnsub && this.activeSubscriptions.push(activeUnsub);
      return createLooseSubscriber(subscriber, this.rawLoadSubscribers, activeUnsub);
    }
  }

  exports.Store = Store;
  exports.StoreActionError = StoreActionError;
  exports.StoreAdapter = StoreAdapter;
  exports.deleteStoreAdapterValue = deleteStoreAdapterValue;
  exports.deserializeError = deserializeError;
  exports.distributeStoreAdapterValue = distributeStoreAdapterValue;
  exports.getStoreAdapterValue = getStoreAdapterValue;
  exports.hasSubscribers = hasSubscribers;
  exports.serializeError = serializeError;
  exports.setStoreAdapterValue = setStoreAdapterValue;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('force/ldsAdaptersCmsAuthoring', ['exports', 'lwc', 'force/ldsBindings', 'force/ldsEngineWebruntime', 'force/luvioEngine'], (function (exports, lwc, ldsBindings, ldsEngine, luvioEngine) {

    const {
      hasOwnProperty: ObjectPrototypeHasOwnProperty
    } = Object.prototype;
    const {
      keys: ObjectKeys$1,
      create: ObjectCreate$1
    } = Object;
    const {
      isArray: ArrayIsArray$1
    } = Array;
    /**
     * Validates an adapter config is well-formed.
     * @param config The config to validate.
     * @param adapter The adapter validation configuration.
     * @param oneOf The keys the config must contain at least one of.
     * @throws A TypeError if config doesn't satisfy the adapter's config validation.
     */
    function validateConfig(config, adapter, oneOf) {
      const {
        displayName
      } = adapter;
      const {
        required,
        optional,
        unsupported
      } = adapter.parameters;
      if (config === undefined || required.every(req => ObjectPrototypeHasOwnProperty.call(config, req)) === false) {
        throw new TypeError(`adapter ${displayName} configuration must specify ${required.sort().join(', ')}`);
      }
      if (oneOf && oneOf.some(req => ObjectPrototypeHasOwnProperty.call(config, req)) === false) {
        throw new TypeError(`adapter ${displayName} configuration must specify one of ${oneOf.sort().join(', ')}`);
      }
      if (unsupported !== undefined && unsupported.some(req => ObjectPrototypeHasOwnProperty.call(config, req))) {
        throw new TypeError(`adapter ${displayName} does not yet support ${unsupported.sort().join(', ')}`);
      }
      const supported = required.concat(optional);
      if (ObjectKeys$1(config).some(key => !supported.includes(key))) {
        throw new TypeError(`adapter ${displayName} configuration supports only ${supported.sort().join(', ')}`);
      }
    }
    function untrustedIsObject(untrusted) {
      return typeof untrusted === 'object' && untrusted !== null && ArrayIsArray$1(untrusted) === false;
    }
    function areRequiredParametersPresent(config, configPropertyNames) {
      return configPropertyNames.parameters.required.every(req => req in config);
    }
    const snapshotRefreshOptions = {
      overrides: {
        headers: {
          'Cache-Control': 'no-cache'
        }
      }
    };
    function generateParamConfigMetadata(name, required, resourceType, typeCheckShape, isArrayShape = false, coerceFn) {
      return {
        name,
        required,
        resourceType,
        typeCheckShape,
        isArrayShape,
        coerceFn
      };
    }
    function buildAdapterValidationConfig(displayName, paramsMeta) {
      const required = paramsMeta.filter(p => p.required).map(p => p.name);
      const optional = paramsMeta.filter(p => !p.required).map(p => p.name);
      return {
        displayName,
        parameters: {
          required,
          optional
        }
      };
    }
    const keyPrefix = 'CMSAuthoring';
    const {
      keys: ObjectKeys,
      create: ObjectCreate,
      assign: ObjectAssign
    } = Object;
    const {
      isArray: ArrayIsArray
    } = Array;
    const {
      stringify: JSONStringify
    } = JSON;
    function equalsArray(a, b, equalsItem) {
      const aLength = a.length;
      const bLength = b.length;
      if (aLength !== bLength) {
        return false;
      }
      for (let i = 0; i < aLength; i++) {
        if (equalsItem(a[i], b[i]) === false) {
          return false;
        }
      }
      return true;
    }
    function createLink(ref) {
      return {
        __ref: luvioEngine.serializeStructuredKey(ref)
      };
    }
    function validate$1d(obj, path = 'ManagedContentCloneStatusRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_status = obj.status;
        const path_status = path + '.status';
        if (typeof obj_status !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_status + '" (at "' + path_status + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$1c(obj, path = 'ManagedContentFailedVariantsRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_errorMessage = obj.errorMessage;
        const path_errorMessage = path + '.errorMessage';
        if (typeof obj_errorMessage !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_errorMessage + '" (at "' + path_errorMessage + '")');
        }
        const obj_language = obj.language;
        const path_language = path + '.language';
        if (typeof obj_language !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_language + '" (at "' + path_language + '")');
        }
        const obj_sourceManagedContentVariantId = obj.sourceManagedContentVariantId;
        const path_sourceManagedContentVariantId = path + '.sourceManagedContentVariantId';
        if (typeof obj_sourceManagedContentVariantId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_sourceManagedContentVariantId + '" (at "' + path_sourceManagedContentVariantId + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$1b(obj, path = 'ManagedContentFolderSummaryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_resourceUrl = obj.resourceUrl;
        const path_resourceUrl = path + '.resourceUrl';
        if (typeof obj_resourceUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_resourceUrl + '" (at "' + path_resourceUrl + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$1a(obj, path = 'ManagedContentClonedVariantRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_language = obj.language;
        const path_language = path + '.language';
        if (typeof obj_language !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_language + '" (at "' + path_language + '")');
        }
        const obj_managedContentVariantId = obj.managedContentVariantId;
        const path_managedContentVariantId = path + '.managedContentVariantId';
        if (typeof obj_managedContentVariantId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentVariantId + '" (at "' + path_managedContentVariantId + '")');
        }
        const obj_resourceURL = obj.resourceURL;
        const path_resourceURL = path + '.resourceURL';
        let obj_resourceURL_union0 = null;
        const obj_resourceURL_union0_error = (() => {
          if (typeof obj_resourceURL !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_resourceURL + '" (at "' + path_resourceURL + '")');
          }
        })();
        if (obj_resourceURL_union0_error != null) {
          obj_resourceURL_union0 = obj_resourceURL_union0_error.message;
        }
        let obj_resourceURL_union1 = null;
        const obj_resourceURL_union1_error = (() => {
          if (obj_resourceURL !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_resourceURL + '" (at "' + path_resourceURL + '")');
          }
        })();
        if (obj_resourceURL_union1_error != null) {
          obj_resourceURL_union1 = obj_resourceURL_union1_error.message;
        }
        if (obj_resourceURL_union0 && obj_resourceURL_union1) {
          let message = 'Object doesn\'t match union (at "' + path_resourceURL + '")';
          message += '\n' + obj_resourceURL_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_resourceURL_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$z = 100;
    const VERSION$H = "7066162a0da609712a7a7b3fa365ed68";
    function validate$19(obj, path = 'ManagedContentDocumentCloneRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.apiName !== undefined) {
          const obj_apiName = obj.apiName;
          const path_apiName = path + '.apiName';
          let obj_apiName_union0 = null;
          const obj_apiName_union0_error = (() => {
            if (typeof obj_apiName !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
            }
          })();
          if (obj_apiName_union0_error != null) {
            obj_apiName_union0 = obj_apiName_union0_error.message;
          }
          let obj_apiName_union1 = null;
          const obj_apiName_union1_error = (() => {
            if (obj_apiName !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
            }
          })();
          if (obj_apiName_union1_error != null) {
            obj_apiName_union1 = obj_apiName_union1_error.message;
          }
          if (obj_apiName_union0 && obj_apiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_apiName + '")';
            message += '\n' + obj_apiName_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_apiName_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_cloneStatus = obj.cloneStatus;
        const path_cloneStatus = path + '.cloneStatus';
        const referencepath_cloneStatusValidationError = validate$1d(obj_cloneStatus, path_cloneStatus);
        if (referencepath_cloneStatusValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentCloneStatusRepresentation (at "' + path_cloneStatus + '")\n';
          message += referencepath_cloneStatusValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_contentKey = obj.contentKey;
        const path_contentKey = path + '.contentKey';
        if (typeof obj_contentKey !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentKey + '" (at "' + path_contentKey + '")');
        }
        if (obj.errorMessage !== undefined) {
          const obj_errorMessage = obj.errorMessage;
          const path_errorMessage = path + '.errorMessage';
          let obj_errorMessage_union0 = null;
          const obj_errorMessage_union0_error = (() => {
            if (typeof obj_errorMessage !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_errorMessage + '" (at "' + path_errorMessage + '")');
            }
          })();
          if (obj_errorMessage_union0_error != null) {
            obj_errorMessage_union0 = obj_errorMessage_union0_error.message;
          }
          let obj_errorMessage_union1 = null;
          const obj_errorMessage_union1_error = (() => {
            if (obj_errorMessage !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_errorMessage + '" (at "' + path_errorMessage + '")');
            }
          })();
          if (obj_errorMessage_union1_error != null) {
            obj_errorMessage_union1 = obj_errorMessage_union1_error.message;
          }
          if (obj_errorMessage_union0 && obj_errorMessage_union1) {
            let message = 'Object doesn\'t match union (at "' + path_errorMessage + '")';
            message += '\n' + obj_errorMessage_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_errorMessage_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_failedVariants = obj.failedVariants;
        const path_failedVariants = path + '.failedVariants';
        if (!ArrayIsArray(obj_failedVariants)) {
          return new TypeError('Expected "array" but received "' + typeof obj_failedVariants + '" (at "' + path_failedVariants + '")');
        }
        for (let i = 0; i < obj_failedVariants.length; i++) {
          const obj_failedVariants_item = obj_failedVariants[i];
          const path_failedVariants_item = path_failedVariants + '[' + i + ']';
          const referencepath_failedVariants_itemValidationError = validate$1c(obj_failedVariants_item, path_failedVariants_item);
          if (referencepath_failedVariants_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentFailedVariantsRepresentation (at "' + path_failedVariants_item + '")\n';
            message += referencepath_failedVariants_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        if (obj.folder !== undefined) {
          const obj_folder = obj.folder;
          const path_folder = path + '.folder';
          const referencepath_folderValidationError = validate$1b(obj_folder, path_folder);
          if (referencepath_folderValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentFolderSummaryRepresentation (at "' + path_folder + '")\n';
            message += referencepath_folderValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        if (obj.managedContentId !== undefined) {
          const obj_managedContentId = obj.managedContentId;
          const path_managedContentId = path + '.managedContentId';
          let obj_managedContentId_union0 = null;
          const obj_managedContentId_union0_error = (() => {
            if (typeof obj_managedContentId !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_managedContentId + '" (at "' + path_managedContentId + '")');
            }
          })();
          if (obj_managedContentId_union0_error != null) {
            obj_managedContentId_union0 = obj_managedContentId_union0_error.message;
          }
          let obj_managedContentId_union1 = null;
          const obj_managedContentId_union1_error = (() => {
            if (obj_managedContentId !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_managedContentId + '" (at "' + path_managedContentId + '")');
            }
          })();
          if (obj_managedContentId_union1_error != null) {
            obj_managedContentId_union1 = obj_managedContentId_union1_error.message;
          }
          if (obj_managedContentId_union0 && obj_managedContentId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_managedContentId + '")';
            message += '\n' + obj_managedContentId_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_managedContentId_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        if (obj.resourceURL !== undefined) {
          const obj_resourceURL = obj.resourceURL;
          const path_resourceURL = path + '.resourceURL';
          let obj_resourceURL_union0 = null;
          const obj_resourceURL_union0_error = (() => {
            if (typeof obj_resourceURL !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_resourceURL + '" (at "' + path_resourceURL + '")');
            }
          })();
          if (obj_resourceURL_union0_error != null) {
            obj_resourceURL_union0 = obj_resourceURL_union0_error.message;
          }
          let obj_resourceURL_union1 = null;
          const obj_resourceURL_union1_error = (() => {
            if (obj_resourceURL !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_resourceURL + '" (at "' + path_resourceURL + '")');
            }
          })();
          if (obj_resourceURL_union1_error != null) {
            obj_resourceURL_union1 = obj_resourceURL_union1_error.message;
          }
          if (obj_resourceURL_union0 && obj_resourceURL_union1) {
            let message = 'Object doesn\'t match union (at "' + path_resourceURL + '")';
            message += '\n' + obj_resourceURL_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_resourceURL_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_sourceContentKeyOrId = obj.sourceContentKeyOrId;
        const path_sourceContentKeyOrId = path + '.sourceContentKeyOrId';
        if (typeof obj_sourceContentKeyOrId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_sourceContentKeyOrId + '" (at "' + path_sourceContentKeyOrId + '")');
        }
        if (obj.title !== undefined) {
          const obj_title = obj.title;
          const path_title = path + '.title';
          let obj_title_union0 = null;
          const obj_title_union0_error = (() => {
            if (typeof obj_title !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
            }
          })();
          if (obj_title_union0_error != null) {
            obj_title_union0 = obj_title_union0_error.message;
          }
          let obj_title_union1 = null;
          const obj_title_union1_error = (() => {
            if (obj_title !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_title + '" (at "' + path_title + '")');
            }
          })();
          if (obj_title_union1_error != null) {
            obj_title_union1 = obj_title_union1_error.message;
          }
          if (obj_title_union0 && obj_title_union1) {
            let message = 'Object doesn\'t match union (at "' + path_title + '")';
            message += '\n' + obj_title_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_title_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_variants = obj.variants;
        const path_variants = path + '.variants';
        if (!ArrayIsArray(obj_variants)) {
          return new TypeError('Expected "array" but received "' + typeof obj_variants + '" (at "' + path_variants + '")');
        }
        for (let i = 0; i < obj_variants.length; i++) {
          const obj_variants_item = obj_variants[i];
          const path_variants_item = path_variants + '[' + i + ']';
          const referencepath_variants_itemValidationError = validate$1a(obj_variants_item, path_variants_item);
          if (referencepath_variants_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentClonedVariantRepresentation (at "' + path_variants_item + '")\n';
            message += referencepath_variants_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$z = 'ManagedContentDocumentCloneRepresentation';
    function keyBuilder$17(luvio, config) {
      return keyPrefix + '::' + RepresentationType$z + ':' + config.id;
    }
    function keyBuilderFromType$i(luvio, object) {
      const keyParams = {
        id: object.contentKey
      };
      return keyBuilder$17(luvio, keyParams);
    }
    function normalize$z(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1o = function ManagedContentDocumentCloneRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$H,
        private: [],
        opaque: true
      };
    };
    function equals$H(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$z = function ManagedContentDocumentCloneRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$19(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$i(luvio, input);
      const ttlToUse = TTL$z;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$z, "CMSAuthoring", VERSION$H, RepresentationType$z, equals$H);
      return createLink(key);
    };
    function getTypeCacheKeys$z(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$i(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$z,
        mergeable: false
      });
    }
    function select$1n(luvio, params) {
      return select$1o();
    }
    function getResponseCacheKeys$J(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$z(storeKeyMap, luvio, response);
    }
    function ingestSuccess$K(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$i(luvio, body);
      luvio.storeIngest(key, ingest$z, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1n(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$J(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/' + config.urlParams.contentKeyOrId + '/clone',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$J = 'cloneManagedContentDocument';
    const cloneManagedContentDocument_ConfigPropertyMetadata = [generateParamConfigMetadata('contentKeyOrId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('apiName', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('contentSpaceOrFolderId', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('includeVariants', false, 2 /* Body */, 1 /* Boolean */), generateParamConfigMetadata('title', false, 2 /* Body */, 0 /* String */)];
    const cloneManagedContentDocument_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$J, cloneManagedContentDocument_ConfigPropertyMetadata);
    const createResourceParams$J = /*#__PURE__*/luvioEngine.createResourceParams(cloneManagedContentDocument_ConfigPropertyMetadata);
    function typeCheckConfig$J(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, cloneManagedContentDocument_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$J(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$J(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$J(luvio, config, options) {
      const resourceParams = createResourceParams$J(config);
      const request = createResourceRequest$J(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$K(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$J(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const cloneManagedContentDocumentAdapterFactory = luvio => {
      return function cloneManagedContentDocument(untrustedConfig) {
        const config = validateAdapterConfig$J(untrustedConfig, cloneManagedContentDocument_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "cloneManagedContentDocument"');
        }
        return buildNetworkSnapshot$J(luvio, config);
      };
    };
    function validate$18(obj, path = 'ManagedContentDeploymentInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.channelIds !== undefined) {
          const obj_channelIds = obj.channelIds;
          const path_channelIds = path + '.channelIds';
          if (!ArrayIsArray(obj_channelIds)) {
            return new TypeError('Expected "array" but received "' + typeof obj_channelIds + '" (at "' + path_channelIds + '")');
          }
          for (let i = 0; i < obj_channelIds.length; i++) {
            const obj_channelIds_item = obj_channelIds[i];
            const path_channelIds_item = path_channelIds + '[' + i + ']';
            if (typeof obj_channelIds_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_channelIds_item + '" (at "' + path_channelIds_item + '")');
            }
          }
        }
        if (obj.contentIds !== undefined) {
          const obj_contentIds = obj.contentIds;
          const path_contentIds = path + '.contentIds';
          if (!ArrayIsArray(obj_contentIds)) {
            return new TypeError('Expected "array" but received "' + typeof obj_contentIds + '" (at "' + path_contentIds + '")');
          }
          for (let i = 0; i < obj_contentIds.length; i++) {
            const obj_contentIds_item = obj_contentIds[i];
            const path_contentIds_item = path_contentIds + '[' + i + ']';
            if (typeof obj_contentIds_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_contentIds_item + '" (at "' + path_contentIds_item + '")');
            }
          }
        }
        const obj_contentSpaceId = obj.contentSpaceId;
        const path_contentSpaceId = path + '.contentSpaceId';
        if (typeof obj_contentSpaceId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentSpaceId + '" (at "' + path_contentSpaceId + '")');
        }
        if (obj.description !== undefined) {
          const obj_description = obj.description;
          const path_description = path + '.description';
          if (typeof obj_description !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_description + '" (at "' + path_description + '")');
          }
        }
        if (obj.executeStagedDeployments !== undefined) {
          const obj_executeStagedDeployments = obj.executeStagedDeployments;
          const path_executeStagedDeployments = path + '.executeStagedDeployments';
          if (typeof obj_executeStagedDeployments !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_executeStagedDeployments + '" (at "' + path_executeStagedDeployments + '")');
          }
        }
        if (obj.includeContentReferences !== undefined) {
          const obj_includeContentReferences = obj.includeContentReferences;
          const path_includeContentReferences = path + '.includeContentReferences';
          if (typeof obj_includeContentReferences !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_includeContentReferences + '" (at "' + path_includeContentReferences + '")');
          }
        }
        if (obj.scheduledDate !== undefined) {
          const obj_scheduledDate = obj.scheduledDate;
          const path_scheduledDate = path + '.scheduledDate';
          if (typeof obj_scheduledDate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_scheduledDate + '" (at "' + path_scheduledDate + '")');
          }
        }
        if (obj.variantIds !== undefined) {
          const obj_variantIds = obj.variantIds;
          const path_variantIds = path + '.variantIds';
          if (!ArrayIsArray(obj_variantIds)) {
            return new TypeError('Expected "array" but received "' + typeof obj_variantIds + '" (at "' + path_variantIds + '")');
          }
          for (let i = 0; i < obj_variantIds.length; i++) {
            const obj_variantIds_item = obj_variantIds[i];
            const path_variantIds_item = path_variantIds + '[' + i + ']';
            if (typeof obj_variantIds_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_variantIds_item + '" (at "' + path_variantIds_item + '")');
            }
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const VERSION$G = "7297fb0dbfe8f664d76179a65037c290";
    function validate$17(obj, path = 'ManagedContentTypeSummaryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fullyQualifiedName = obj.fullyQualifiedName;
        const path_fullyQualifiedName = path + '.fullyQualifiedName';
        if (typeof obj_fullyQualifiedName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fullyQualifiedName + '" (at "' + path_fullyQualifiedName + '")');
        }
        if (obj.name !== undefined) {
          const obj_name = obj.name;
          const path_name = path + '.name';
          if (typeof obj_name !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1m = function ManagedContentTypeSummaryRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$G,
        private: [],
        selections: [{
          name: 'fullyQualifiedName',
          kind: 'Scalar'
        }, {
          name: 'name',
          kind: 'Scalar',
          required: false
        }]
      };
    };
    function equals$G(existing, incoming) {
      const existing_fullyQualifiedName = existing.fullyQualifiedName;
      const incoming_fullyQualifiedName = incoming.fullyQualifiedName;
      if (!(existing_fullyQualifiedName === incoming_fullyQualifiedName)) {
        return false;
      }
      const existing_name = existing.name;
      const incoming_name = incoming.name;
      // if at least one of these optionals is defined
      if (existing_name !== undefined || incoming_name !== undefined) {
        // if one of these is not defined we know the other is defined and therefore
        // not equal
        if (existing_name === undefined || incoming_name === undefined) {
          return false;
        }
        if (!(existing_name === incoming_name)) {
          return false;
        }
      }
      return true;
    }
    const VERSION$F = "c30d880a3dba684a405d1cf961af2b76";
    function validate$16(obj, path = 'ManagedContentVariantSnapshotSummaryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentType = obj.contentType;
        const path_contentType = path + '.contentType';
        let obj_contentType_union0 = null;
        const obj_contentType_union0_error = (() => {
          const referencepath_contentTypeValidationError = validate$17(obj_contentType, path_contentType);
          if (referencepath_contentTypeValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentTypeSummaryRepresentation (at "' + path_contentType + '")\n';
            message += referencepath_contentTypeValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_contentType_union0_error != null) {
          obj_contentType_union0 = obj_contentType_union0_error.message;
        }
        let obj_contentType_union1 = null;
        const obj_contentType_union1_error = (() => {
          if (obj_contentType !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_contentType + '" (at "' + path_contentType + '")');
          }
        })();
        if (obj_contentType_union1_error != null) {
          obj_contentType_union1 = obj_contentType_union1_error.message;
        }
        if (obj_contentType_union0 && obj_contentType_union1) {
          let message = 'Object doesn\'t match union (at "' + path_contentType + '")';
          message += '\n' + obj_contentType_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_contentType_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
          if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union0_error != null) {
          obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
          if (obj_id !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        })();
        if (obj_id_union1_error != null) {
          obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
          let message = 'Object doesn\'t match union (at "' + path_id + '")';
          message += '\n' + obj_id_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_id_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_language = obj.language;
        const path_language = path + '.language';
        let obj_language_union0 = null;
        const obj_language_union0_error = (() => {
          if (typeof obj_language !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_language + '" (at "' + path_language + '")');
          }
        })();
        if (obj_language_union0_error != null) {
          obj_language_union0 = obj_language_union0_error.message;
        }
        let obj_language_union1 = null;
        const obj_language_union1_error = (() => {
          if (obj_language !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_language + '" (at "' + path_language + '")');
          }
        })();
        if (obj_language_union1_error != null) {
          obj_language_union1 = obj_language_union1_error.message;
        }
        if (obj_language_union0 && obj_language_union1) {
          let message = 'Object doesn\'t match union (at "' + path_language + '")';
          message += '\n' + obj_language_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_language_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        let obj_lastModifiedDate_union0 = null;
        const obj_lastModifiedDate_union0_error = (() => {
          if (typeof obj_lastModifiedDate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
          }
        })();
        if (obj_lastModifiedDate_union0_error != null) {
          obj_lastModifiedDate_union0 = obj_lastModifiedDate_union0_error.message;
        }
        let obj_lastModifiedDate_union1 = null;
        const obj_lastModifiedDate_union1_error = (() => {
          if (obj_lastModifiedDate !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
          }
        })();
        if (obj_lastModifiedDate_union1_error != null) {
          obj_lastModifiedDate_union1 = obj_lastModifiedDate_union1_error.message;
        }
        if (obj_lastModifiedDate_union0 && obj_lastModifiedDate_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lastModifiedDate + '")';
          message += '\n' + obj_lastModifiedDate_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lastModifiedDate_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        let obj_name_union0 = null;
        const obj_name_union0_error = (() => {
          if (typeof obj_name !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
          }
        })();
        if (obj_name_union0_error != null) {
          obj_name_union0 = obj_name_union0_error.message;
        }
        let obj_name_union1 = null;
        const obj_name_union1_error = (() => {
          if (obj_name !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_name + '" (at "' + path_name + '")');
          }
        })();
        if (obj_name_union1_error != null) {
          obj_name_union1 = obj_name_union1_error.message;
        }
        if (obj_name_union0 && obj_name_union1) {
          let message = 'Object doesn\'t match union (at "' + path_name + '")';
          message += '\n' + obj_name_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_name_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_urlValue = obj.urlValue;
        const path_urlValue = path + '.urlValue';
        let obj_urlValue_union0 = null;
        const obj_urlValue_union0_error = (() => {
          if (typeof obj_urlValue !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_urlValue + '" (at "' + path_urlValue + '")');
          }
        })();
        if (obj_urlValue_union0_error != null) {
          obj_urlValue_union0 = obj_urlValue_union0_error.message;
        }
        let obj_urlValue_union1 = null;
        const obj_urlValue_union1_error = (() => {
          if (obj_urlValue !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_urlValue + '" (at "' + path_urlValue + '")');
          }
        })();
        if (obj_urlValue_union1_error != null) {
          obj_urlValue_union1 = obj_urlValue_union1_error.message;
        }
        if (obj_urlValue_union0 && obj_urlValue_union1) {
          let message = 'Object doesn\'t match union (at "' + path_urlValue + '")';
          message += '\n' + obj_urlValue_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_urlValue_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1l = function ManagedContentVariantSnapshotSummaryRepresentationSelect() {
      const {
        selections: ManagedContentTypeSummaryRepresentation__selections,
        opaque: ManagedContentTypeSummaryRepresentation__opaque
      } = select$1m();
      return {
        kind: 'Fragment',
        version: VERSION$F,
        private: [],
        selections: [{
          name: 'contentType',
          kind: 'Object',
          nullable: true,
          selections: ManagedContentTypeSummaryRepresentation__selections
        }, {
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'language',
          kind: 'Scalar'
        }, {
          name: 'lastModifiedDate',
          kind: 'Scalar'
        }, {
          name: 'name',
          kind: 'Scalar'
        }, {
          name: 'urlValue',
          kind: 'Scalar'
        }]
      };
    };
    function equals$F(existing, incoming) {
      const existing_contentType = existing.contentType;
      const incoming_contentType = incoming.contentType;
      if (!(existing_contentType === incoming_contentType || existing_contentType != null && incoming_contentType != null && equals$G(existing_contentType, incoming_contentType))) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_language = existing.language;
      const incoming_language = incoming.language;
      if (!(existing_language === incoming_language)) {
        return false;
      }
      const existing_lastModifiedDate = existing.lastModifiedDate;
      const incoming_lastModifiedDate = incoming.lastModifiedDate;
      if (!(existing_lastModifiedDate === incoming_lastModifiedDate)) {
        return false;
      }
      const existing_name = existing.name;
      const incoming_name = incoming.name;
      if (!(existing_name === incoming_name)) {
        return false;
      }
      const existing_urlValue = existing.urlValue;
      const incoming_urlValue = incoming.urlValue;
      if (!(existing_urlValue === incoming_urlValue)) {
        return false;
      }
      return true;
    }
    const VERSION$E = "f99d45f1e809783023bfd9dbe2fe4a6c";
    function validate$15(obj, path = 'ManagedContentDeploymentItemRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_action = obj.action;
        const path_action = path + '.action';
        if (typeof obj_action !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_action + '" (at "' + path_action + '")');
        }
        const obj_deploymentId = obj.deploymentId;
        const path_deploymentId = path + '.deploymentId';
        if (typeof obj_deploymentId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_deploymentId + '" (at "' + path_deploymentId + '")');
        }
        const obj_deploymentItemId = obj.deploymentItemId;
        const path_deploymentItemId = path + '.deploymentItemId';
        if (typeof obj_deploymentItemId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_deploymentItemId + '" (at "' + path_deploymentItemId + '")');
        }
        const obj_isTopLevel = obj.isTopLevel;
        const path_isTopLevel = path + '.isTopLevel';
        if (typeof obj_isTopLevel !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isTopLevel + '" (at "' + path_isTopLevel + '")');
        }
        const obj_mcvSnapshotSummary = obj.mcvSnapshotSummary;
        const path_mcvSnapshotSummary = path + '.mcvSnapshotSummary';
        const referencepath_mcvSnapshotSummaryValidationError = validate$16(obj_mcvSnapshotSummary, path_mcvSnapshotSummary);
        if (referencepath_mcvSnapshotSummaryValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentVariantSnapshotSummaryRepresentation (at "' + path_mcvSnapshotSummary + '")\n';
          message += referencepath_mcvSnapshotSummaryValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_snapshotId = obj.snapshotId;
        const path_snapshotId = path + '.snapshotId';
        if (typeof obj_snapshotId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_snapshotId + '" (at "' + path_snapshotId + '")');
        }
        const obj_targetId = obj.targetId;
        const path_targetId = path + '.targetId';
        let obj_targetId_union0 = null;
        const obj_targetId_union0_error = (() => {
          if (typeof obj_targetId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_targetId + '" (at "' + path_targetId + '")');
          }
        })();
        if (obj_targetId_union0_error != null) {
          obj_targetId_union0 = obj_targetId_union0_error.message;
        }
        let obj_targetId_union1 = null;
        const obj_targetId_union1_error = (() => {
          if (obj_targetId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_targetId + '" (at "' + path_targetId + '")');
          }
        })();
        if (obj_targetId_union1_error != null) {
          obj_targetId_union1 = obj_targetId_union1_error.message;
        }
        if (obj_targetId_union0 && obj_targetId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_targetId + '")';
          message += '\n' + obj_targetId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_targetId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_variantId = obj.variantId;
        const path_variantId = path + '.variantId';
        let obj_variantId_union0 = null;
        const obj_variantId_union0_error = (() => {
          if (typeof obj_variantId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_variantId + '" (at "' + path_variantId + '")');
          }
        })();
        if (obj_variantId_union0_error != null) {
          obj_variantId_union0 = obj_variantId_union0_error.message;
        }
        let obj_variantId_union1 = null;
        const obj_variantId_union1_error = (() => {
          if (obj_variantId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_variantId + '" (at "' + path_variantId + '")');
          }
        })();
        if (obj_variantId_union1_error != null) {
          obj_variantId_union1 = obj_variantId_union1_error.message;
        }
        if (obj_variantId_union0 && obj_variantId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_variantId + '")';
          message += '\n' + obj_variantId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_variantId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1k = function ManagedContentDeploymentItemRepresentationSelect() {
      const {
        selections: ManagedContentVariantSnapshotSummaryRepresentation__selections,
        opaque: ManagedContentVariantSnapshotSummaryRepresentation__opaque
      } = select$1l();
      return {
        kind: 'Fragment',
        version: VERSION$E,
        private: [],
        selections: [{
          name: 'action',
          kind: 'Scalar'
        }, {
          name: 'deploymentId',
          kind: 'Scalar'
        }, {
          name: 'deploymentItemId',
          kind: 'Scalar'
        }, {
          name: 'isTopLevel',
          kind: 'Scalar'
        }, {
          name: 'mcvSnapshotSummary',
          kind: 'Object',
          selections: ManagedContentVariantSnapshotSummaryRepresentation__selections
        }, {
          name: 'snapshotId',
          kind: 'Scalar'
        }, {
          name: 'targetId',
          kind: 'Scalar'
        }, {
          name: 'variantId',
          kind: 'Scalar'
        }]
      };
    };
    function equals$E(existing, incoming) {
      const existing_isTopLevel = existing.isTopLevel;
      const incoming_isTopLevel = incoming.isTopLevel;
      if (!(existing_isTopLevel === incoming_isTopLevel)) {
        return false;
      }
      const existing_action = existing.action;
      const incoming_action = incoming.action;
      if (!(existing_action === incoming_action)) {
        return false;
      }
      const existing_deploymentId = existing.deploymentId;
      const incoming_deploymentId = incoming.deploymentId;
      if (!(existing_deploymentId === incoming_deploymentId)) {
        return false;
      }
      const existing_deploymentItemId = existing.deploymentItemId;
      const incoming_deploymentItemId = incoming.deploymentItemId;
      if (!(existing_deploymentItemId === incoming_deploymentItemId)) {
        return false;
      }
      const existing_snapshotId = existing.snapshotId;
      const incoming_snapshotId = incoming.snapshotId;
      if (!(existing_snapshotId === incoming_snapshotId)) {
        return false;
      }
      const existing_mcvSnapshotSummary = existing.mcvSnapshotSummary;
      const incoming_mcvSnapshotSummary = incoming.mcvSnapshotSummary;
      if (!equals$F(existing_mcvSnapshotSummary, incoming_mcvSnapshotSummary)) {
        return false;
      }
      const existing_targetId = existing.targetId;
      const incoming_targetId = incoming.targetId;
      if (!(existing_targetId === incoming_targetId)) {
        return false;
      }
      const existing_variantId = existing.variantId;
      const incoming_variantId = incoming.variantId;
      if (!(existing_variantId === incoming_variantId)) {
        return false;
      }
      return true;
    }
    const VERSION$D = "4b75ed6ff448da86412b605f7e775a62";
    function validate$14(obj, path = 'ManagedContentUserSummaryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        if (obj.name !== undefined) {
          const obj_name = obj.name;
          const path_name = path + '.name';
          if (typeof obj_name !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
          }
        }
        const obj_resourceUrl = obj.resourceUrl;
        const path_resourceUrl = path + '.resourceUrl';
        if (typeof obj_resourceUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_resourceUrl + '" (at "' + path_resourceUrl + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$1j = function ManagedContentUserSummaryRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$D,
        private: [],
        selections: [{
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'name',
          kind: 'Scalar',
          required: false
        }, {
          name: 'resourceUrl',
          kind: 'Scalar'
        }]
      };
    };
    function equals$D(existing, incoming) {
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_name = existing.name;
      const incoming_name = incoming.name;
      // if at least one of these optionals is defined
      if (existing_name !== undefined || incoming_name !== undefined) {
        // if one of these is not defined we know the other is defined and therefore
        // not equal
        if (existing_name === undefined || incoming_name === undefined) {
          return false;
        }
        if (!(existing_name === incoming_name)) {
          return false;
        }
      }
      const existing_resourceUrl = existing.resourceUrl;
      const incoming_resourceUrl = incoming.resourceUrl;
      if (!(existing_resourceUrl === incoming_resourceUrl)) {
        return false;
      }
      return true;
    }
    const TTL$y = 100;
    const VERSION$C = "f7e3c655efe77a7c9968ade15a6029b1";
    function validate$13(obj, path = 'ManagedContentDeploymentRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        let obj_createdBy_union0 = null;
        const obj_createdBy_union0_error = (() => {
          if (typeof obj_createdBy !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_createdBy + '" (at "' + path_createdBy + '")');
          }
        })();
        if (obj_createdBy_union0_error != null) {
          obj_createdBy_union0 = obj_createdBy_union0_error.message;
        }
        let obj_createdBy_union1 = null;
        const obj_createdBy_union1_error = (() => {
          if (obj_createdBy !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_createdBy + '" (at "' + path_createdBy + '")');
          }
        })();
        if (obj_createdBy_union1_error != null) {
          obj_createdBy_union1 = obj_createdBy_union1_error.message;
        }
        if (obj_createdBy_union0 && obj_createdBy_union1) {
          let message = 'Object doesn\'t match union (at "' + path_createdBy + '")';
          message += '\n' + obj_createdBy_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_createdBy_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_deploymentDescription = obj.deploymentDescription;
        const path_deploymentDescription = path + '.deploymentDescription';
        let obj_deploymentDescription_union0 = null;
        const obj_deploymentDescription_union0_error = (() => {
          if (typeof obj_deploymentDescription !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_deploymentDescription + '" (at "' + path_deploymentDescription + '")');
          }
        })();
        if (obj_deploymentDescription_union0_error != null) {
          obj_deploymentDescription_union0 = obj_deploymentDescription_union0_error.message;
        }
        let obj_deploymentDescription_union1 = null;
        const obj_deploymentDescription_union1_error = (() => {
          if (obj_deploymentDescription !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_deploymentDescription + '" (at "' + path_deploymentDescription + '")');
          }
        })();
        if (obj_deploymentDescription_union1_error != null) {
          obj_deploymentDescription_union1 = obj_deploymentDescription_union1_error.message;
        }
        if (obj_deploymentDescription_union0 && obj_deploymentDescription_union1) {
          let message = 'Object doesn\'t match union (at "' + path_deploymentDescription + '")';
          message += '\n' + obj_deploymentDescription_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_deploymentDescription_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_deploymentId = obj.deploymentId;
        const path_deploymentId = path + '.deploymentId';
        if (typeof obj_deploymentId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_deploymentId + '" (at "' + path_deploymentId + '")');
        }
        const obj_deploymentItems = obj.deploymentItems;
        const path_deploymentItems = path + '.deploymentItems';
        if (!ArrayIsArray(obj_deploymentItems)) {
          return new TypeError('Expected "array" but received "' + typeof obj_deploymentItems + '" (at "' + path_deploymentItems + '")');
        }
        for (let i = 0; i < obj_deploymentItems.length; i++) {
          const obj_deploymentItems_item = obj_deploymentItems[i];
          const path_deploymentItems_item = path_deploymentItems + '[' + i + ']';
          const referencepath_deploymentItems_itemValidationError = validate$15(obj_deploymentItems_item, path_deploymentItems_item);
          if (referencepath_deploymentItems_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentDeploymentItemRepresentation (at "' + path_deploymentItems_item + '")\n';
            message += referencepath_deploymentItems_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_deploymentName = obj.deploymentName;
        const path_deploymentName = path + '.deploymentName';
        let obj_deploymentName_union0 = null;
        const obj_deploymentName_union0_error = (() => {
          if (typeof obj_deploymentName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_deploymentName + '" (at "' + path_deploymentName + '")');
          }
        })();
        if (obj_deploymentName_union0_error != null) {
          obj_deploymentName_union0 = obj_deploymentName_union0_error.message;
        }
        let obj_deploymentName_union1 = null;
        const obj_deploymentName_union1_error = (() => {
          if (obj_deploymentName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_deploymentName + '" (at "' + path_deploymentName + '")');
          }
        })();
        if (obj_deploymentName_union1_error != null) {
          obj_deploymentName_union1 = obj_deploymentName_union1_error.message;
        }
        if (obj_deploymentName_union0 && obj_deploymentName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_deploymentName + '")';
          message += '\n' + obj_deploymentName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_deploymentName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_deploymentStatus = obj.deploymentStatus;
        const path_deploymentStatus = path + '.deploymentStatus';
        let obj_deploymentStatus_union0 = null;
        const obj_deploymentStatus_union0_error = (() => {
          if (typeof obj_deploymentStatus !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_deploymentStatus + '" (at "' + path_deploymentStatus + '")');
          }
        })();
        if (obj_deploymentStatus_union0_error != null) {
          obj_deploymentStatus_union0 = obj_deploymentStatus_union0_error.message;
        }
        let obj_deploymentStatus_union1 = null;
        const obj_deploymentStatus_union1_error = (() => {
          if (obj_deploymentStatus !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_deploymentStatus + '" (at "' + path_deploymentStatus + '")');
          }
        })();
        if (obj_deploymentStatus_union1_error != null) {
          obj_deploymentStatus_union1 = obj_deploymentStatus_union1_error.message;
        }
        if (obj_deploymentStatus_union0 && obj_deploymentStatus_union1) {
          let message = 'Object doesn\'t match union (at "' + path_deploymentStatus + '")';
          message += '\n' + obj_deploymentStatus_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_deploymentStatus_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        let obj_lastModifiedBy_union0 = null;
        const obj_lastModifiedBy_union0_error = (() => {
          const referencepath_lastModifiedByValidationError = validate$14(obj_lastModifiedBy, path_lastModifiedBy);
          if (referencepath_lastModifiedByValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_lastModifiedBy + '")\n';
            message += referencepath_lastModifiedByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_lastModifiedBy_union0_error != null) {
          obj_lastModifiedBy_union0 = obj_lastModifiedBy_union0_error.message;
        }
        let obj_lastModifiedBy_union1 = null;
        const obj_lastModifiedBy_union1_error = (() => {
          if (obj_lastModifiedBy !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedBy + '" (at "' + path_lastModifiedBy + '")');
          }
        })();
        if (obj_lastModifiedBy_union1_error != null) {
          obj_lastModifiedBy_union1 = obj_lastModifiedBy_union1_error.message;
        }
        if (obj_lastModifiedBy_union0 && obj_lastModifiedBy_union1) {
          let message = 'Object doesn\'t match union (at "' + path_lastModifiedBy + '")';
          message += '\n' + obj_lastModifiedBy_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_lastModifiedBy_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_scheduledDate = obj.scheduledDate;
        const path_scheduledDate = path + '.scheduledDate';
        let obj_scheduledDate_union0 = null;
        const obj_scheduledDate_union0_error = (() => {
          if (typeof obj_scheduledDate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_scheduledDate + '" (at "' + path_scheduledDate + '")');
          }
        })();
        if (obj_scheduledDate_union0_error != null) {
          obj_scheduledDate_union0 = obj_scheduledDate_union0_error.message;
        }
        let obj_scheduledDate_union1 = null;
        const obj_scheduledDate_union1_error = (() => {
          if (obj_scheduledDate !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_scheduledDate + '" (at "' + path_scheduledDate + '")');
          }
        })();
        if (obj_scheduledDate_union1_error != null) {
          obj_scheduledDate_union1 = obj_scheduledDate_union1_error.message;
        }
        if (obj_scheduledDate_union0 && obj_scheduledDate_union1) {
          let message = 'Object doesn\'t match union (at "' + path_scheduledDate + '")';
          message += '\n' + obj_scheduledDate_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_scheduledDate_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$y = 'ManagedContentDeploymentRepresentation';
    function keyBuilder$16(luvio, config) {
      return keyPrefix + '::' + RepresentationType$y + ':' + config.id;
    }
    function keyBuilderFromType$h(luvio, object) {
      const keyParams = {
        id: object.deploymentId
      };
      return keyBuilder$16(luvio, keyParams);
    }
    function normalize$y(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1i = function ManagedContentDeploymentRepresentationSelect() {
      const {
        selections: ManagedContentDeploymentItemRepresentation__selections,
        opaque: ManagedContentDeploymentItemRepresentation__opaque
      } = select$1k();
      const {
        selections: ManagedContentUserSummaryRepresentation__selections,
        opaque: ManagedContentUserSummaryRepresentation__opaque
      } = select$1j();
      return {
        kind: 'Fragment',
        version: VERSION$C,
        private: [],
        selections: [{
          name: 'createdBy',
          kind: 'Scalar'
        }, {
          name: 'deploymentDescription',
          kind: 'Scalar'
        }, {
          name: 'deploymentId',
          kind: 'Scalar'
        }, {
          name: 'deploymentItems',
          kind: 'Object',
          plural: true,
          selections: ManagedContentDeploymentItemRepresentation__selections
        }, {
          name: 'deploymentName',
          kind: 'Scalar'
        }, {
          name: 'deploymentStatus',
          kind: 'Scalar'
        }, {
          name: 'lastModifiedBy',
          kind: 'Object',
          nullable: true,
          selections: ManagedContentUserSummaryRepresentation__selections
        }, {
          name: 'scheduledDate',
          kind: 'Scalar'
        }]
      };
    };
    function equals$C(existing, incoming) {
      const existing_deploymentId = existing.deploymentId;
      const incoming_deploymentId = incoming.deploymentId;
      if (!(existing_deploymentId === incoming_deploymentId)) {
        return false;
      }
      const existing_createdBy = existing.createdBy;
      const incoming_createdBy = incoming.createdBy;
      if (!(existing_createdBy === incoming_createdBy)) {
        return false;
      }
      const existing_deploymentDescription = existing.deploymentDescription;
      const incoming_deploymentDescription = incoming.deploymentDescription;
      if (!(existing_deploymentDescription === incoming_deploymentDescription)) {
        return false;
      }
      const existing_deploymentItems = existing.deploymentItems;
      const incoming_deploymentItems = incoming.deploymentItems;
      const equals_deploymentItems_items = equalsArray(existing_deploymentItems, incoming_deploymentItems, (existing_deploymentItems_item, incoming_deploymentItems_item) => {
        if (!equals$E(existing_deploymentItems_item, incoming_deploymentItems_item)) {
          return false;
        }
      });
      if (equals_deploymentItems_items === false) {
        return false;
      }
      const existing_deploymentName = existing.deploymentName;
      const incoming_deploymentName = incoming.deploymentName;
      if (!(existing_deploymentName === incoming_deploymentName)) {
        return false;
      }
      const existing_deploymentStatus = existing.deploymentStatus;
      const incoming_deploymentStatus = incoming.deploymentStatus;
      if (!(existing_deploymentStatus === incoming_deploymentStatus)) {
        return false;
      }
      const existing_lastModifiedBy = existing.lastModifiedBy;
      const incoming_lastModifiedBy = incoming.lastModifiedBy;
      if (!(existing_lastModifiedBy === incoming_lastModifiedBy || existing_lastModifiedBy != null && incoming_lastModifiedBy != null && equals$D(existing_lastModifiedBy, incoming_lastModifiedBy))) {
        return false;
      }
      const existing_scheduledDate = existing.scheduledDate;
      const incoming_scheduledDate = incoming.scheduledDate;
      if (!(existing_scheduledDate === incoming_scheduledDate)) {
        return false;
      }
      return true;
    }
    const ingest$y = function ManagedContentDeploymentRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$13(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$h(luvio, input);
      const ttlToUse = TTL$y;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$y, "CMSAuthoring", VERSION$C, RepresentationType$y, equals$C);
      return createLink(key);
    };
    function getTypeCacheKeys$y(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$h(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$y,
        mergeable: false
      });
    }
    function select$1h(luvio, params) {
      return select$1i();
    }
    function getResponseCacheKeys$I(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$y(storeKeyMap, luvio, response);
    }
    function ingestSuccess$J(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$h(luvio, body);
      luvio.storeIngest(key, ingest$y, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1h(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$I(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/cms/deployments',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$I = 'createDeployment';
    const createDeployment_ConfigPropertyMetadata = [generateParamConfigMetadata('DeploymentInput', true, 2 /* Body */, 4 /* Unsupported */)];
    const createDeployment_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$I, createDeployment_ConfigPropertyMetadata);
    const createResourceParams$I = /*#__PURE__*/luvioEngine.createResourceParams(createDeployment_ConfigPropertyMetadata);
    function typeCheckConfig$I(untrustedConfig) {
      const config = {};
      const untrustedConfig_DeploymentInput = untrustedConfig.DeploymentInput;
      const referenceManagedContentDeploymentInputRepresentationValidationError = validate$18(untrustedConfig_DeploymentInput);
      if (referenceManagedContentDeploymentInputRepresentationValidationError === null) {
        config.DeploymentInput = untrustedConfig_DeploymentInput;
      }
      return config;
    }
    function validateAdapterConfig$I(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$I(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$I(luvio, config, options) {
      const resourceParams = createResourceParams$I(config);
      const request = createResourceRequest$I(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$J(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$I(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const createDeploymentAdapterFactory = luvio => {
      return function createDeployment(untrustedConfig) {
        const config = validateAdapterConfig$I(untrustedConfig, createDeployment_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "createDeployment"');
        }
        return buildNetworkSnapshot$I(luvio, config);
      };
    };
    function validate$12(obj, path = 'ManagedContentInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentBody = obj.contentBody;
        const path_contentBody = path + '.contentBody';
        if (typeof obj_contentBody !== 'object' || ArrayIsArray(obj_contentBody) || obj_contentBody === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_contentBody + '" (at "' + path_contentBody + '")');
        }
        const obj_contentBody_keys = ObjectKeys(obj_contentBody);
        for (let i = 0; i < obj_contentBody_keys.length; i++) {
          const key = obj_contentBody_keys[i];
          const obj_contentBody_prop = obj_contentBody[key];
          const path_contentBody_prop = path_contentBody + '["' + key + '"]';
          if (obj_contentBody_prop === undefined) {
            return new TypeError('Expected "defined" but received "' + typeof obj_contentBody_prop + '" (at "' + path_contentBody_prop + '")');
          }
        }
        const obj_contentSpaceOrFolderId = obj.contentSpaceOrFolderId;
        const path_contentSpaceOrFolderId = path + '.contentSpaceOrFolderId';
        if (typeof obj_contentSpaceOrFolderId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentSpaceOrFolderId + '" (at "' + path_contentSpaceOrFolderId + '")');
        }
        const obj_contentType = obj.contentType;
        const path_contentType = path + '.contentType';
        if (typeof obj_contentType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentType + '" (at "' + path_contentType + '")');
        }
        if (obj.title !== undefined) {
          const obj_title = obj.title;
          const path_title = path + '.title';
          if (typeof obj_title !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
          }
        }
        if (obj.urlName !== undefined) {
          const obj_urlName = obj.urlName;
          const path_urlName = path + '.urlName';
          if (typeof obj_urlName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_urlName + '" (at "' + path_urlName + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$11(obj, path = 'ManagedContentSpaceSummaryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_resourceUrl = obj.resourceUrl;
        const path_resourceUrl = path + '.resourceUrl';
        if (typeof obj_resourceUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_resourceUrl + '" (at "' + path_resourceUrl + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$10(obj, path = 'ManagedContentVariantStatusRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_status = obj.status;
        const path_status = path + '.status';
        if (typeof obj_status !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_status + '" (at "' + path_status + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$x = 100;
    const VERSION$B = "32da7ab9bec2902e7f2b1d1e9aa618f1";
    function validate$$(obj, path = 'ManagedContentDocumentRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.apiName !== undefined) {
          const obj_apiName = obj.apiName;
          const path_apiName = path + '.apiName';
          let obj_apiName_union0 = null;
          const obj_apiName_union0_error = (() => {
            if (typeof obj_apiName !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
            }
          })();
          if (obj_apiName_union0_error != null) {
            obj_apiName_union0 = obj_apiName_union0_error.message;
          }
          let obj_apiName_union1 = null;
          const obj_apiName_union1_error = (() => {
            if (obj_apiName !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
            }
          })();
          if (obj_apiName_union1_error != null) {
            obj_apiName_union1 = obj_apiName_union1_error.message;
          }
          if (obj_apiName_union0 && obj_apiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_apiName + '")';
            message += '\n' + obj_apiName_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_apiName_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_contentBody = obj.contentBody;
        const path_contentBody = path + '.contentBody';
        if (typeof obj_contentBody !== 'object' || ArrayIsArray(obj_contentBody) || obj_contentBody === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_contentBody + '" (at "' + path_contentBody + '")');
        }
        const obj_contentBody_keys = ObjectKeys(obj_contentBody);
        for (let i = 0; i < obj_contentBody_keys.length; i++) {
          const key = obj_contentBody_keys[i];
          const obj_contentBody_prop = obj_contentBody[key];
          const path_contentBody_prop = path_contentBody + '["' + key + '"]';
          if (obj_contentBody_prop === undefined) {
            return new TypeError('Expected "defined" but received "' + typeof obj_contentBody_prop + '" (at "' + path_contentBody_prop + '")');
          }
        }
        const obj_contentKey = obj.contentKey;
        const path_contentKey = path + '.contentKey';
        if (typeof obj_contentKey !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentKey + '" (at "' + path_contentKey + '")');
        }
        const obj_contentSpace = obj.contentSpace;
        const path_contentSpace = path + '.contentSpace';
        const referencepath_contentSpaceValidationError = validate$11(obj_contentSpace, path_contentSpace);
        if (referencepath_contentSpaceValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentSpaceSummaryRepresentation (at "' + path_contentSpace + '")\n';
          message += referencepath_contentSpaceValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_contentType = obj.contentType;
        const path_contentType = path + '.contentType';
        const referencepath_contentTypeValidationError = validate$17(obj_contentType, path_contentType);
        if (referencepath_contentTypeValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentTypeSummaryRepresentation (at "' + path_contentType + '")\n';
          message += referencepath_contentTypeValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        const referencepath_createdByValidationError = validate$14(obj_createdBy, path_createdBy);
        if (referencepath_createdByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_createdBy + '")\n';
          message += referencepath_createdByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        const obj_folder = obj.folder;
        const path_folder = path + '.folder';
        const referencepath_folderValidationError = validate$1b(obj_folder, path_folder);
        if (referencepath_folderValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentFolderSummaryRepresentation (at "' + path_folder + '")\n';
          message += referencepath_folderValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_isPublished = obj.isPublished;
        const path_isPublished = path + '.isPublished';
        if (typeof obj_isPublished !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isPublished + '" (at "' + path_isPublished + '")');
        }
        const obj_language = obj.language;
        const path_language = path + '.language';
        if (typeof obj_language !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_language + '" (at "' + path_language + '")');
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        const referencepath_lastModifiedByValidationError = validate$14(obj_lastModifiedBy, path_lastModifiedBy);
        if (referencepath_lastModifiedByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_lastModifiedBy + '")\n';
          message += referencepath_lastModifiedByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
        const obj_managedContentId = obj.managedContentId;
        const path_managedContentId = path + '.managedContentId';
        if (typeof obj_managedContentId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentId + '" (at "' + path_managedContentId + '")');
        }
        const obj_managedContentVariantId = obj.managedContentVariantId;
        const path_managedContentVariantId = path + '.managedContentVariantId';
        if (typeof obj_managedContentVariantId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentVariantId + '" (at "' + path_managedContentVariantId + '")');
        }
        const obj_managedContentVersionId = obj.managedContentVersionId;
        const path_managedContentVersionId = path + '.managedContentVersionId';
        if (typeof obj_managedContentVersionId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentVersionId + '" (at "' + path_managedContentVersionId + '")');
        }
        if (obj.status !== undefined) {
          const obj_status = obj.status;
          const path_status = path + '.status';
          let obj_status_union0 = null;
          const obj_status_union0_error = (() => {
            const referencepath_statusValidationError = validate$10(obj_status, path_status);
            if (referencepath_statusValidationError !== null) {
              let message = 'Object doesn\'t match ManagedContentVariantStatusRepresentation (at "' + path_status + '")\n';
              message += referencepath_statusValidationError.message.split('\n').map(line => '\t' + line).join('\n');
              return new TypeError(message);
            }
          })();
          if (obj_status_union0_error != null) {
            obj_status_union0 = obj_status_union0_error.message;
          }
          let obj_status_union1 = null;
          const obj_status_union1_error = (() => {
            if (obj_status !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_status + '" (at "' + path_status + '")');
            }
          })();
          if (obj_status_union1_error != null) {
            obj_status_union1 = obj_status_union1_error.message;
          }
          if (obj_status_union0 && obj_status_union1) {
            let message = 'Object doesn\'t match union (at "' + path_status + '")';
            message += '\n' + obj_status_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_status_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_title = obj.title;
        const path_title = path + '.title';
        if (typeof obj_title !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
        }
        const obj_urlName = obj.urlName;
        const path_urlName = path + '.urlName';
        if (typeof obj_urlName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_urlName + '" (at "' + path_urlName + '")');
        }
        const obj_version = obj.version;
        const path_version = path + '.version';
        if (typeof obj_version !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_version + '" (at "' + path_version + '")');
        }
        const obj_versionNumber = obj.versionNumber;
        const path_versionNumber = path + '.versionNumber';
        let obj_versionNumber_union0 = null;
        const obj_versionNumber_union0_error = (() => {
          if (typeof obj_versionNumber !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_versionNumber + '" (at "' + path_versionNumber + '")');
          }
        })();
        if (obj_versionNumber_union0_error != null) {
          obj_versionNumber_union0 = obj_versionNumber_union0_error.message;
        }
        let obj_versionNumber_union1 = null;
        const obj_versionNumber_union1_error = (() => {
          if (obj_versionNumber !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_versionNumber + '" (at "' + path_versionNumber + '")');
          }
        })();
        if (obj_versionNumber_union1_error != null) {
          obj_versionNumber_union1 = obj_versionNumber_union1_error.message;
        }
        if (obj_versionNumber_union0 && obj_versionNumber_union1) {
          let message = 'Object doesn\'t match union (at "' + path_versionNumber + '")';
          message += '\n' + obj_versionNumber_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_versionNumber_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$x = 'ManagedContentDocumentRepresentation';
    function keyBuilder$15(luvio, config) {
      return keyPrefix + '::' + RepresentationType$x + ':' + config.content_key + ':' + config.language + ':' + config.version;
    }
    function keyBuilderFromType$g(luvio, object) {
      const keyParams = {
        content_key: object.contentKey,
        language: object.language,
        version: object.version
      };
      return keyBuilder$15(luvio, keyParams);
    }
    function normalize$x(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1g = function ManagedContentDocumentRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$B,
        private: [],
        opaque: true
      };
    };
    function equals$B(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$x = function ManagedContentDocumentRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$$(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$g(luvio, input);
      const ttlToUse = TTL$x;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$x, "CMSAuthoring", VERSION$B, RepresentationType$x, equals$B);
      return createLink(key);
    };
    function getTypeCacheKeys$x(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$g(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$x,
        mergeable: false
      });
    }
    function select$1f(luvio, params) {
      return select$1g();
    }
    function getResponseCacheKeys$H(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$x(storeKeyMap, luvio, response);
    }
    function ingestSuccess$I(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$g(luvio, body);
      luvio.storeIngest(key, ingest$x, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1f(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$H(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function ingestSuccess$H(luvio, resourceParams, response) {
      // Version can come either from versionNumber field in case of v2 content, or managedContentVersionId field in case of v1 content.
      response.body.version = response.body.versionNumber || response.body.managedContentVersionId;
      return ingestSuccess$I(luvio, resourceParams, response);
    }
    const adapterName$H = 'createManagedContent';
    const createManagedContent_ConfigPropertyMetadata = [generateParamConfigMetadata('ManagedContentInputParam', true, 2 /* Body */, 4 /* Unsupported */)];
    const createManagedContent_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$H, createManagedContent_ConfigPropertyMetadata);
    const createResourceParams$H = /*#__PURE__*/luvioEngine.createResourceParams(createManagedContent_ConfigPropertyMetadata);
    function typeCheckConfig$H(untrustedConfig) {
      const config = {};
      const untrustedConfig_ManagedContentInputParam = untrustedConfig.ManagedContentInputParam;
      const referenceManagedContentInputRepresentationValidationError = validate$12(untrustedConfig_ManagedContentInputParam);
      if (referenceManagedContentInputRepresentationValidationError === null) {
        config.ManagedContentInputParam = untrustedConfig_ManagedContentInputParam;
      }
      return config;
    }
    function validateAdapterConfig$H(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$H(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$H(luvio, config, options) {
      const resourceParams = createResourceParams$H(config);
      const request = createResourceRequest$H(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$H(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$H(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const createManagedContentAdapterFactory = luvio => {
      return function createManagedContent(untrustedConfig) {
        const config = validateAdapterConfig$H(untrustedConfig, createManagedContent_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "createManagedContent"');
        }
        return buildNetworkSnapshot$H(luvio, config);
      };
    };
    function validate$_(obj, path = 'ManagedContentExportContentV2JobRequestInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_folderIds = obj.folderIds;
        const path_folderIds = path + '.folderIds';
        if (!ArrayIsArray(obj_folderIds)) {
          return new TypeError('Expected "array" but received "' + typeof obj_folderIds + '" (at "' + path_folderIds + '")');
        }
        for (let i = 0; i < obj_folderIds.length; i++) {
          const obj_folderIds_item = obj_folderIds[i];
          const path_folderIds_item = path_folderIds + '[' + i + ']';
          if (typeof obj_folderIds_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_folderIds_item + '" (at "' + path_folderIds_item + '")');
          }
        }
        const obj_includeReferenceContent = obj.includeReferenceContent;
        const path_includeReferenceContent = path + '.includeReferenceContent';
        if (typeof obj_includeReferenceContent !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_includeReferenceContent + '" (at "' + path_includeReferenceContent + '")');
        }
        const obj_includeTaxonomyTerms = obj.includeTaxonomyTerms;
        const path_includeTaxonomyTerms = path + '.includeTaxonomyTerms';
        if (typeof obj_includeTaxonomyTerms !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_includeTaxonomyTerms + '" (at "' + path_includeTaxonomyTerms + '")');
        }
        const obj_includeTranslations = obj.includeTranslations;
        const path_includeTranslations = path + '.includeTranslations';
        if (typeof obj_includeTranslations !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_includeTranslations + '" (at "' + path_includeTranslations + '")');
        }
        const obj_managedContentIds = obj.managedContentIds;
        const path_managedContentIds = path + '.managedContentIds';
        if (!ArrayIsArray(obj_managedContentIds)) {
          return new TypeError('Expected "array" but received "' + typeof obj_managedContentIds + '" (at "' + path_managedContentIds + '")');
        }
        for (let i = 0; i < obj_managedContentIds.length; i++) {
          const obj_managedContentIds_item = obj_managedContentIds[i];
          const path_managedContentIds_item = path_managedContentIds + '[' + i + ']';
          if (typeof obj_managedContentIds_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_managedContentIds_item + '" (at "' + path_managedContentIds_item + '")');
          }
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$w = 100;
    const VERSION$A = "9ae4bb8336d074517f1c980f5f3f7d82";
    function validate$Z(obj, path = 'ManagedContentV2JobRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        if (typeof obj_createdBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdBy + '" (at "' + path_createdBy + '")');
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        const obj_errorBodyUrl = obj.errorBodyUrl;
        const path_errorBodyUrl = path + '.errorBodyUrl';
        let obj_errorBodyUrl_union0 = null;
        const obj_errorBodyUrl_union0_error = (() => {
          if (typeof obj_errorBodyUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_errorBodyUrl + '" (at "' + path_errorBodyUrl + '")');
          }
        })();
        if (obj_errorBodyUrl_union0_error != null) {
          obj_errorBodyUrl_union0 = obj_errorBodyUrl_union0_error.message;
        }
        let obj_errorBodyUrl_union1 = null;
        const obj_errorBodyUrl_union1_error = (() => {
          if (obj_errorBodyUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_errorBodyUrl + '" (at "' + path_errorBodyUrl + '")');
          }
        })();
        if (obj_errorBodyUrl_union1_error != null) {
          obj_errorBodyUrl_union1 = obj_errorBodyUrl_union1_error.message;
        }
        if (obj_errorBodyUrl_union0 && obj_errorBodyUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_errorBodyUrl + '")';
          message += '\n' + obj_errorBodyUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_errorBodyUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_inputBodyUrl = obj.inputBodyUrl;
        const path_inputBodyUrl = path + '.inputBodyUrl';
        let obj_inputBodyUrl_union0 = null;
        const obj_inputBodyUrl_union0_error = (() => {
          if (typeof obj_inputBodyUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_inputBodyUrl + '" (at "' + path_inputBodyUrl + '")');
          }
        })();
        if (obj_inputBodyUrl_union0_error != null) {
          obj_inputBodyUrl_union0 = obj_inputBodyUrl_union0_error.message;
        }
        let obj_inputBodyUrl_union1 = null;
        const obj_inputBodyUrl_union1_error = (() => {
          if (obj_inputBodyUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_inputBodyUrl + '" (at "' + path_inputBodyUrl + '")');
          }
        })();
        if (obj_inputBodyUrl_union1_error != null) {
          obj_inputBodyUrl_union1 = obj_inputBodyUrl_union1_error.message;
        }
        if (obj_inputBodyUrl_union0 && obj_inputBodyUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_inputBodyUrl + '")';
          message += '\n' + obj_inputBodyUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_inputBodyUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_jobType = obj.jobType;
        const path_jobType = path + '.jobType';
        if (typeof obj_jobType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_jobType + '" (at "' + path_jobType + '")');
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        if (typeof obj_lastModifiedBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedBy + '" (at "' + path_lastModifiedBy + '")');
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
        const obj_lastStatusUpdateDate = obj.lastStatusUpdateDate;
        const path_lastStatusUpdateDate = path + '.lastStatusUpdateDate';
        if (typeof obj_lastStatusUpdateDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastStatusUpdateDate + '" (at "' + path_lastStatusUpdateDate + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_outputBodyUrl = obj.outputBodyUrl;
        const path_outputBodyUrl = path + '.outputBodyUrl';
        let obj_outputBodyUrl_union0 = null;
        const obj_outputBodyUrl_union0_error = (() => {
          if (typeof obj_outputBodyUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_outputBodyUrl + '" (at "' + path_outputBodyUrl + '")');
          }
        })();
        if (obj_outputBodyUrl_union0_error != null) {
          obj_outputBodyUrl_union0 = obj_outputBodyUrl_union0_error.message;
        }
        let obj_outputBodyUrl_union1 = null;
        const obj_outputBodyUrl_union1_error = (() => {
          if (obj_outputBodyUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_outputBodyUrl + '" (at "' + path_outputBodyUrl + '")');
          }
        })();
        if (obj_outputBodyUrl_union1_error != null) {
          obj_outputBodyUrl_union1 = obj_outputBodyUrl_union1_error.message;
        }
        if (obj_outputBodyUrl_union0 && obj_outputBodyUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_outputBodyUrl + '")';
          message += '\n' + obj_outputBodyUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_outputBodyUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_startDate = obj.startDate;
        const path_startDate = path + '.startDate';
        let obj_startDate_union0 = null;
        const obj_startDate_union0_error = (() => {
          if (typeof obj_startDate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_startDate + '" (at "' + path_startDate + '")');
          }
        })();
        if (obj_startDate_union0_error != null) {
          obj_startDate_union0 = obj_startDate_union0_error.message;
        }
        let obj_startDate_union1 = null;
        const obj_startDate_union1_error = (() => {
          if (obj_startDate !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_startDate + '" (at "' + path_startDate + '")');
          }
        })();
        if (obj_startDate_union1_error != null) {
          obj_startDate_union1 = obj_startDate_union1_error.message;
        }
        if (obj_startDate_union0 && obj_startDate_union1) {
          let message = 'Object doesn\'t match union (at "' + path_startDate + '")';
          message += '\n' + obj_startDate_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_startDate_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_status = obj.status;
        const path_status = path + '.status';
        if (typeof obj_status !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_status + '" (at "' + path_status + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$w = 'ManagedContentV2JobRepresentation';
    function keyBuilder$14(luvio, config) {
      return keyPrefix + '::' + RepresentationType$w + ':' + config.id;
    }
    function keyBuilderFromType$f(luvio, object) {
      const keyParams = {
        id: object.id
      };
      return keyBuilder$14(luvio, keyParams);
    }
    function normalize$w(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1e = function ManagedContentV2JobRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$A,
        private: [],
        opaque: true
      };
    };
    function equals$A(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$w = function ManagedContentV2JobRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$Z(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$f(luvio, input);
      const ttlToUse = TTL$w;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$w, "CMSAuthoring", VERSION$A, RepresentationType$w, equals$A);
      return createLink(key);
    };
    function getTypeCacheKeys$w(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$f(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$w,
        mergeable: false
      });
    }
    function select$1d(luvio, params) {
      return select$1e();
    }
    function getResponseCacheKeys$G(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$w(storeKeyMap, luvio, response);
    }
    function ingestSuccess$G(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$f(luvio, body);
      luvio.storeIngest(key, ingest$w, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1d(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$G(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/spaces/' + config.urlParams.contentSpaceId + '/contents/export',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$G = 'createManagedContentExportV2Job';
    const createManagedContentExportV2Job_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('managedContentV2JobRequest', true, 2 /* Body */, 4 /* Unsupported */)];
    const createManagedContentExportV2Job_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$G, createManagedContentExportV2Job_ConfigPropertyMetadata);
    const createResourceParams$G = /*#__PURE__*/luvioEngine.createResourceParams(createManagedContentExportV2Job_ConfigPropertyMetadata);
    function typeCheckConfig$G(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, createManagedContentExportV2Job_ConfigPropertyMetadata);
      const untrustedConfig_managedContentV2JobRequest = untrustedConfig.managedContentV2JobRequest;
      const referenceManagedContentExportContentV2JobRequestInputRepresentationValidationError = validate$_(untrustedConfig_managedContentV2JobRequest);
      if (referenceManagedContentExportContentV2JobRequestInputRepresentationValidationError === null) {
        config.managedContentV2JobRequest = untrustedConfig_managedContentV2JobRequest;
      }
      return config;
    }
    function validateAdapterConfig$G(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$G(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$G(luvio, config, options) {
      const resourceParams = createResourceParams$G(config);
      const request = createResourceRequest$G(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$G(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$G(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const createManagedContentExportV2JobAdapterFactory = luvio => {
      return function createManagedContentExportV2Job(untrustedConfig) {
        const config = validateAdapterConfig$G(untrustedConfig, createManagedContentExportV2Job_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "createManagedContentExportV2Job"');
        }
        return buildNetworkSnapshot$G(luvio, config);
      };
    };
    function validate$Y(obj, path = 'ManagedContentV2JobRequestInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_autoPublish = obj.autoPublish;
        const path_autoPublish = path + '.autoPublish';
        if (typeof obj_autoPublish !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_autoPublish + '" (at "' + path_autoPublish + '")');
        }
        const obj_managedContentBodyId = obj.managedContentBodyId;
        const path_managedContentBodyId = path + '.managedContentBodyId';
        if (typeof obj_managedContentBodyId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentBodyId + '" (at "' + path_managedContentBodyId + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function select$1c(luvio, params) {
      return select$1e();
    }
    function getResponseCacheKeys$F(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$w(storeKeyMap, luvio, response);
    }
    function ingestSuccess$F(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$f(luvio, body);
      luvio.storeIngest(key, ingest$w, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1c(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$F(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/spaces/' + config.urlParams.contentSpaceId + '/contents/import',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$F = 'createManagedContentImportV2Job';
    const createManagedContentImportV2Job_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('managedContentV2JobRequest', true, 2 /* Body */, 4 /* Unsupported */)];
    const createManagedContentImportV2Job_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$F, createManagedContentImportV2Job_ConfigPropertyMetadata);
    const createResourceParams$F = /*#__PURE__*/luvioEngine.createResourceParams(createManagedContentImportV2Job_ConfigPropertyMetadata);
    function typeCheckConfig$F(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, createManagedContentImportV2Job_ConfigPropertyMetadata);
      const untrustedConfig_managedContentV2JobRequest = untrustedConfig.managedContentV2JobRequest;
      const referenceManagedContentV2JobRequestInputRepresentationValidationError = validate$Y(untrustedConfig_managedContentV2JobRequest);
      if (referenceManagedContentV2JobRequestInputRepresentationValidationError === null) {
        config.managedContentV2JobRequest = untrustedConfig_managedContentV2JobRequest;
      }
      return config;
    }
    function validateAdapterConfig$F(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$F(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$F(luvio, config, options) {
      const resourceParams = createResourceParams$F(config);
      const request = createResourceRequest$F(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$F(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$F(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const createManagedContentImportV2JobAdapterFactory = luvio => {
      return function createManagedContentImportV2Job(untrustedConfig) {
        const config = validateAdapterConfig$F(untrustedConfig, createManagedContentImportV2Job_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "createManagedContentImportV2Job"');
        }
        return buildNetworkSnapshot$F(luvio, config);
      };
    };
    const TTL$v = 3600000;
    const VERSION$z = "7752c6a8bb6b113a02bfde83f39e5957";
    function validate$X(obj, path = 'ManagedContentVariantRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentBody = obj.contentBody;
        const path_contentBody = path + '.contentBody';
        if (typeof obj_contentBody !== 'object' || ArrayIsArray(obj_contentBody) || obj_contentBody === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_contentBody + '" (at "' + path_contentBody + '")');
        }
        const obj_contentBody_keys = ObjectKeys(obj_contentBody);
        for (let i = 0; i < obj_contentBody_keys.length; i++) {
          const key = obj_contentBody_keys[i];
          const obj_contentBody_prop = obj_contentBody[key];
          const path_contentBody_prop = path_contentBody + '["' + key + '"]';
          if (obj_contentBody_prop === undefined) {
            return new TypeError('Expected "defined" but received "' + typeof obj_contentBody_prop + '" (at "' + path_contentBody_prop + '")');
          }
        }
        const obj_contentKey = obj.contentKey;
        const path_contentKey = path + '.contentKey';
        if (typeof obj_contentKey !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentKey + '" (at "' + path_contentKey + '")');
        }
        const obj_contentSpace = obj.contentSpace;
        const path_contentSpace = path + '.contentSpace';
        const referencepath_contentSpaceValidationError = validate$11(obj_contentSpace, path_contentSpace);
        if (referencepath_contentSpaceValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentSpaceSummaryRepresentation (at "' + path_contentSpace + '")\n';
          message += referencepath_contentSpaceValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_contentType = obj.contentType;
        const path_contentType = path + '.contentType';
        const referencepath_contentTypeValidationError = validate$17(obj_contentType, path_contentType);
        if (referencepath_contentTypeValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentTypeSummaryRepresentation (at "' + path_contentType + '")\n';
          message += referencepath_contentTypeValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        const referencepath_createdByValidationError = validate$14(obj_createdBy, path_createdBy);
        if (referencepath_createdByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_createdBy + '")\n';
          message += referencepath_createdByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        const obj_folder = obj.folder;
        const path_folder = path + '.folder';
        const referencepath_folderValidationError = validate$1b(obj_folder, path_folder);
        if (referencepath_folderValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentFolderSummaryRepresentation (at "' + path_folder + '")\n';
          message += referencepath_folderValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_isPublished = obj.isPublished;
        const path_isPublished = path + '.isPublished';
        if (typeof obj_isPublished !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isPublished + '" (at "' + path_isPublished + '")');
        }
        const obj_language = obj.language;
        const path_language = path + '.language';
        if (typeof obj_language !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_language + '" (at "' + path_language + '")');
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        const referencepath_lastModifiedByValidationError = validate$14(obj_lastModifiedBy, path_lastModifiedBy);
        if (referencepath_lastModifiedByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_lastModifiedBy + '")\n';
          message += referencepath_lastModifiedByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
        const obj_managedContentId = obj.managedContentId;
        const path_managedContentId = path + '.managedContentId';
        if (typeof obj_managedContentId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentId + '" (at "' + path_managedContentId + '")');
        }
        const obj_managedContentVariantId = obj.managedContentVariantId;
        const path_managedContentVariantId = path + '.managedContentVariantId';
        if (typeof obj_managedContentVariantId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentVariantId + '" (at "' + path_managedContentVariantId + '")');
        }
        const obj_managedContentVersionId = obj.managedContentVersionId;
        const path_managedContentVersionId = path + '.managedContentVersionId';
        if (typeof obj_managedContentVersionId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentVersionId + '" (at "' + path_managedContentVersionId + '")');
        }
        const obj_status = obj.status;
        const path_status = path + '.status';
        const referencepath_statusValidationError = validate$10(obj_status, path_status);
        if (referencepath_statusValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentVariantStatusRepresentation (at "' + path_status + '")\n';
          message += referencepath_statusValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_title = obj.title;
        const path_title = path + '.title';
        if (typeof obj_title !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
        }
        const obj_urlName = obj.urlName;
        const path_urlName = path + '.urlName';
        if (typeof obj_urlName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_urlName + '" (at "' + path_urlName + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$v = 'ManagedContentVariantRepresentation';
    function keyBuilder$13(luvio, config) {
      return keyPrefix + '::' + RepresentationType$v + ':' + config.id;
    }
    function keyBuilderFromType$e(luvio, object) {
      const keyParams = {
        id: object.managedContentVariantId
      };
      return keyBuilder$13(luvio, keyParams);
    }
    function normalize$v(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1b = function ManagedContentVariantRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$z,
        private: [],
        opaque: true
      };
    };
    function equals$z(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$v = function ManagedContentVariantRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$X(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$e(luvio, input);
      const ttlToUse = TTL$v;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$v, "CMSAuthoring", VERSION$z, RepresentationType$v, equals$z);
      return createLink(key);
    };
    function getTypeCacheKeys$v(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$e(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$v,
        mergeable: false
      });
    }
    const TTL$u = 100;
    const VERSION$y = "2671ddf8ce03873a61079e99f376e1b6";
    function validate$W(obj, path = 'ManagedContentVariantCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentKeyOrId = obj.contentKeyOrId;
        const path_contentKeyOrId = path + '.contentKeyOrId';
        if (typeof obj_contentKeyOrId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentKeyOrId + '" (at "' + path_contentKeyOrId + '")');
        }
        if (obj.currentPageUrl !== undefined) {
          const obj_currentPageUrl = obj.currentPageUrl;
          const path_currentPageUrl = path + '.currentPageUrl';
          let obj_currentPageUrl_union0 = null;
          const obj_currentPageUrl_union0_error = (() => {
            if (typeof obj_currentPageUrl !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
            }
          })();
          if (obj_currentPageUrl_union0_error != null) {
            obj_currentPageUrl_union0 = obj_currentPageUrl_union0_error.message;
          }
          let obj_currentPageUrl_union1 = null;
          const obj_currentPageUrl_union1_error = (() => {
            if (obj_currentPageUrl !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
            }
          })();
          if (obj_currentPageUrl_union1_error != null) {
            obj_currentPageUrl_union1 = obj_currentPageUrl_union1_error.message;
          }
          if (obj_currentPageUrl_union0 && obj_currentPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_currentPageUrl + '")';
            message += '\n' + obj_currentPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_currentPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        if (obj.nextPageUrl !== undefined) {
          const obj_nextPageUrl = obj.nextPageUrl;
          const path_nextPageUrl = path + '.nextPageUrl';
          let obj_nextPageUrl_union0 = null;
          const obj_nextPageUrl_union0_error = (() => {
            if (typeof obj_nextPageUrl !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
          })();
          if (obj_nextPageUrl_union0_error != null) {
            obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
          }
          let obj_nextPageUrl_union1 = null;
          const obj_nextPageUrl_union1_error = (() => {
            if (obj_nextPageUrl !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
          })();
          if (obj_nextPageUrl_union1_error != null) {
            obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
          }
          if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
            message += '\n' + obj_nextPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_nextPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_total = obj.total;
        const path_total = path + '.total';
        if (typeof obj_total !== 'number' || typeof obj_total === 'number' && Math.floor(obj_total) !== obj_total) {
          return new TypeError('Expected "integer" but received "' + typeof obj_total + '" (at "' + path_total + '")');
        }
        const obj_variants = obj.variants;
        const path_variants = path + '.variants';
        if (!ArrayIsArray(obj_variants)) {
          return new TypeError('Expected "array" but received "' + typeof obj_variants + '" (at "' + path_variants + '")');
        }
        for (let i = 0; i < obj_variants.length; i++) {
          const obj_variants_item = obj_variants[i];
          const path_variants_item = path_variants + '[' + i + ']';
          const referencepath_variants_itemValidationError = validate$X(obj_variants_item, path_variants_item);
          if (referencepath_variants_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentVariantRepresentation (at "' + path_variants_item + '")\n';
            message += referencepath_variants_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$u = 'ManagedContentVariantCollectionRepresentation';
    function keyBuilder$12(luvio, config) {
      return keyPrefix + '::' + RepresentationType$u + ':' + config.id;
    }
    function keyBuilderFromType$d(luvio, object) {
      const keyParams = {
        id: object.contentKeyOrId
      };
      return keyBuilder$12(luvio, keyParams);
    }
    function normalize$u(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$1a = function ManagedContentVariantCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$y,
        private: [],
        opaque: true
      };
    };
    function equals$y(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$u = function ManagedContentVariantCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$W(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$d(luvio, input);
      const ttlToUse = TTL$u;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$u, "CMSAuthoring", VERSION$y, RepresentationType$u, equals$y);
      return createLink(key);
    };
    function getTypeCacheKeys$u(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$d(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$u,
        mergeable: false
      });
    }
    function select$19(luvio, params) {
      return select$1a();
    }
    function getResponseCacheKeys$E(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$u(storeKeyMap, luvio, response);
    }
    function ingestSuccess$E(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$d(luvio, body);
      luvio.storeIngest(key, ingest$u, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$19(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$E(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/' + config.urlParams.contentKeyOrId + '/translate',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function ingestSuccess$D(luvio, resourceParams, response) {
      // assign content key from request param to response body
      response.body.contentKeyOrId = resourceParams.urlParams.contentKeyOrId;
      return ingestSuccess$E(luvio, resourceParams, response);
    }
    const adapterName$E = 'createManagedContentTranslationVariants';
    const createManagedContentTranslationVariants_ConfigPropertyMetadata = [generateParamConfigMetadata('contentKeyOrId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('targetLanguages', true, 2 /* Body */, 0 /* String */, true)];
    const createManagedContentTranslationVariants_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$E, createManagedContentTranslationVariants_ConfigPropertyMetadata);
    const createResourceParams$E = /*#__PURE__*/luvioEngine.createResourceParams(createManagedContentTranslationVariants_ConfigPropertyMetadata);
    function typeCheckConfig$E(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, createManagedContentTranslationVariants_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$E(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$E(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$E(luvio, config, options) {
      const resourceParams = createResourceParams$E(config);
      const request = createResourceRequest$E(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$D(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$E(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const createManagedContentTranslationVariantsAdapterFactory = luvio => {
      return function createManagedContentTranslationVariants(untrustedConfig) {
        const config = validateAdapterConfig$E(untrustedConfig, createManagedContentTranslationVariants_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "createManagedContentTranslationVariants"');
        }
        return buildNetworkSnapshot$E(luvio, config);
      };
    };
    function validate$V(obj, path = 'ManagedContentVariantInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentBody = obj.contentBody;
        const path_contentBody = path + '.contentBody';
        if (typeof obj_contentBody !== 'object' || ArrayIsArray(obj_contentBody) || obj_contentBody === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_contentBody + '" (at "' + path_contentBody + '")');
        }
        const obj_contentBody_keys = ObjectKeys(obj_contentBody);
        for (let i = 0; i < obj_contentBody_keys.length; i++) {
          const key = obj_contentBody_keys[i];
          const obj_contentBody_prop = obj_contentBody[key];
          const path_contentBody_prop = path_contentBody + '["' + key + '"]';
          if (obj_contentBody_prop === undefined) {
            return new TypeError('Expected "defined" but received "' + typeof obj_contentBody_prop + '" (at "' + path_contentBody_prop + '")');
          }
        }
        const obj_language = obj.language;
        const path_language = path + '.language';
        if (typeof obj_language !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_language + '" (at "' + path_language + '")');
        }
        const obj_managedContentKeyOrId = obj.managedContentKeyOrId;
        const path_managedContentKeyOrId = path + '.managedContentKeyOrId';
        if (typeof obj_managedContentKeyOrId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentKeyOrId + '" (at "' + path_managedContentKeyOrId + '")');
        }
        if (obj.title !== undefined) {
          const obj_title = obj.title;
          const path_title = path + '.title';
          if (typeof obj_title !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
          }
        }
        if (obj.urlName !== undefined) {
          const obj_urlName = obj.urlName;
          const path_urlName = path + '.urlName';
          if (typeof obj_urlName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_urlName + '" (at "' + path_urlName + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function select$18(luvio, params) {
      return select$1b();
    }
    function getResponseCacheKeys$D(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$v(storeKeyMap, luvio, response);
    }
    function ingestSuccess$C(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$e(luvio, body);
      luvio.storeIngest(key, ingest$v, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$18(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$D(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/variants',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$D = 'createManagedContentVariant';
    const createManagedContentVariant_ConfigPropertyMetadata = [generateParamConfigMetadata('managedContentVariantInputParam', true, 2 /* Body */, 4 /* Unsupported */)];
    const createManagedContentVariant_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$D, createManagedContentVariant_ConfigPropertyMetadata);
    const createResourceParams$D = /*#__PURE__*/luvioEngine.createResourceParams(createManagedContentVariant_ConfigPropertyMetadata);
    function typeCheckConfig$D(untrustedConfig) {
      const config = {};
      const untrustedConfig_managedContentVariantInputParam = untrustedConfig.managedContentVariantInputParam;
      const referenceManagedContentVariantInputRepresentationValidationError = validate$V(untrustedConfig_managedContentVariantInputParam);
      if (referenceManagedContentVariantInputRepresentationValidationError === null) {
        config.managedContentVariantInputParam = untrustedConfig_managedContentVariantInputParam;
      }
      return config;
    }
    function validateAdapterConfig$D(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$D(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$D(luvio, config, options) {
      const resourceParams = createResourceParams$D(config);
      const request = createResourceRequest$D(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$C(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$D(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const createManagedContentVariantAdapterFactory = luvio => {
      return function createManagedContentVariant(untrustedConfig) {
        const config = validateAdapterConfig$D(untrustedConfig, createManagedContentVariant_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "createManagedContentVariant"');
        }
        return buildNetworkSnapshot$D(luvio, config);
      };
    };
    function select$17(luvio, params) {
      return select$1i();
    }
    function getResponseCacheKeys$C(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$y(storeKeyMap, luvio, response);
    }
    function ingestSuccess$B(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$h(luvio, body);
      luvio.storeIngest(key, ingest$y, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$17(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$C(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/schedules',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$C = 'createSchedule';
    const createSchedule_ConfigPropertyMetadata = [generateParamConfigMetadata('action', true, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('contextContentSpaceId', true, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('description', true, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('expireDate', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('publishContentReference', false, 2 /* Body */, 1 /* Boolean */), generateParamConfigMetadata('refVariantIds', true, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('scheduleDate', true, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('variantIds', true, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('versionIds', false, 2 /* Body */, 0 /* String */, true)];
    const createSchedule_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$C, createSchedule_ConfigPropertyMetadata);
    const createResourceParams$C = /*#__PURE__*/luvioEngine.createResourceParams(createSchedule_ConfigPropertyMetadata);
    function typeCheckConfig$C(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, createSchedule_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$C(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$C(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$C(luvio, config, options) {
      const resourceParams = createResourceParams$C(config);
      const request = createResourceRequest$C(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$B(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$C(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const createScheduleAdapterFactory = luvio => {
      return function createSchedule(untrustedConfig) {
        const config = validateAdapterConfig$C(untrustedConfig, createSchedule_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "createSchedule"');
        }
        return buildNetworkSnapshot$C(luvio, config);
      };
    };
    function validate$U(obj, path = 'ManagedContentTranslationV2RequestInputRep') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_folderIds = obj.folderIds;
        const path_folderIds = path + '.folderIds';
        if (!ArrayIsArray(obj_folderIds)) {
          return new TypeError('Expected "array" but received "' + typeof obj_folderIds + '" (at "' + path_folderIds + '")');
        }
        for (let i = 0; i < obj_folderIds.length; i++) {
          const obj_folderIds_item = obj_folderIds[i];
          const path_folderIds_item = path_folderIds + '[' + i + ']';
          if (typeof obj_folderIds_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_folderIds_item + '" (at "' + path_folderIds_item + '")');
          }
        }
        const obj_managedContentBodyId = obj.managedContentBodyId;
        const path_managedContentBodyId = path + '.managedContentBodyId';
        if (typeof obj_managedContentBodyId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentBodyId + '" (at "' + path_managedContentBodyId + '")');
        }
        const obj_managedContentVariantIds = obj.managedContentVariantIds;
        const path_managedContentVariantIds = path + '.managedContentVariantIds';
        if (!ArrayIsArray(obj_managedContentVariantIds)) {
          return new TypeError('Expected "array" but received "' + typeof obj_managedContentVariantIds + '" (at "' + path_managedContentVariantIds + '")');
        }
        for (let i = 0; i < obj_managedContentVariantIds.length; i++) {
          const obj_managedContentVariantIds_item = obj_managedContentVariantIds[i];
          const path_managedContentVariantIds_item = path_managedContentVariantIds + '[' + i + ']';
          if (typeof obj_managedContentVariantIds_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_managedContentVariantIds_item + '" (at "' + path_managedContentVariantIds_item + '")');
          }
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_parentFolderId = obj.parentFolderId;
        const path_parentFolderId = path + '.parentFolderId';
        if (typeof obj_parentFolderId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_parentFolderId + '" (at "' + path_parentFolderId + '")');
        }
        const obj_sourceLanguage = obj.sourceLanguage;
        const path_sourceLanguage = path + '.sourceLanguage';
        if (typeof obj_sourceLanguage !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_sourceLanguage + '" (at "' + path_sourceLanguage + '")');
        }
        const obj_targetLanguages = obj.targetLanguages;
        const path_targetLanguages = path + '.targetLanguages';
        if (!ArrayIsArray(obj_targetLanguages)) {
          return new TypeError('Expected "array" but received "' + typeof obj_targetLanguages + '" (at "' + path_targetLanguages + '")');
        }
        for (let i = 0; i < obj_targetLanguages.length; i++) {
          const obj_targetLanguages_item = obj_targetLanguages[i];
          const path_targetLanguages_item = path_targetLanguages + '[' + i + ']';
          if (typeof obj_targetLanguages_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_targetLanguages_item + '" (at "' + path_targetLanguages_item + '")');
          }
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$t = 100;
    const VERSION$x = "52e643b998d6763482c6d74542b38408";
    function validate$T(obj, path = 'ManagedContentTranslationV2Representation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        if (typeof obj_createdBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdBy + '" (at "' + path_createdBy + '")');
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        const obj_errorBodyUrl = obj.errorBodyUrl;
        const path_errorBodyUrl = path + '.errorBodyUrl';
        let obj_errorBodyUrl_union0 = null;
        const obj_errorBodyUrl_union0_error = (() => {
          if (typeof obj_errorBodyUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_errorBodyUrl + '" (at "' + path_errorBodyUrl + '")');
          }
        })();
        if (obj_errorBodyUrl_union0_error != null) {
          obj_errorBodyUrl_union0 = obj_errorBodyUrl_union0_error.message;
        }
        let obj_errorBodyUrl_union1 = null;
        const obj_errorBodyUrl_union1_error = (() => {
          if (obj_errorBodyUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_errorBodyUrl + '" (at "' + path_errorBodyUrl + '")');
          }
        })();
        if (obj_errorBodyUrl_union1_error != null) {
          obj_errorBodyUrl_union1 = obj_errorBodyUrl_union1_error.message;
        }
        if (obj_errorBodyUrl_union0 && obj_errorBodyUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_errorBodyUrl + '")';
          message += '\n' + obj_errorBodyUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_errorBodyUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_inputBodyUrl = obj.inputBodyUrl;
        const path_inputBodyUrl = path + '.inputBodyUrl';
        let obj_inputBodyUrl_union0 = null;
        const obj_inputBodyUrl_union0_error = (() => {
          if (typeof obj_inputBodyUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_inputBodyUrl + '" (at "' + path_inputBodyUrl + '")');
          }
        })();
        if (obj_inputBodyUrl_union0_error != null) {
          obj_inputBodyUrl_union0 = obj_inputBodyUrl_union0_error.message;
        }
        let obj_inputBodyUrl_union1 = null;
        const obj_inputBodyUrl_union1_error = (() => {
          if (obj_inputBodyUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_inputBodyUrl + '" (at "' + path_inputBodyUrl + '")');
          }
        })();
        if (obj_inputBodyUrl_union1_error != null) {
          obj_inputBodyUrl_union1 = obj_inputBodyUrl_union1_error.message;
        }
        if (obj_inputBodyUrl_union0 && obj_inputBodyUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_inputBodyUrl + '")';
          message += '\n' + obj_inputBodyUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_inputBodyUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_jobType = obj.jobType;
        const path_jobType = path + '.jobType';
        if (typeof obj_jobType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_jobType + '" (at "' + path_jobType + '")');
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        if (typeof obj_lastModifiedBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedBy + '" (at "' + path_lastModifiedBy + '")');
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
        const obj_lastStatusUpdateDate = obj.lastStatusUpdateDate;
        const path_lastStatusUpdateDate = path + '.lastStatusUpdateDate';
        if (typeof obj_lastStatusUpdateDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastStatusUpdateDate + '" (at "' + path_lastStatusUpdateDate + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_outputBodyUrl = obj.outputBodyUrl;
        const path_outputBodyUrl = path + '.outputBodyUrl';
        let obj_outputBodyUrl_union0 = null;
        const obj_outputBodyUrl_union0_error = (() => {
          if (typeof obj_outputBodyUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_outputBodyUrl + '" (at "' + path_outputBodyUrl + '")');
          }
        })();
        if (obj_outputBodyUrl_union0_error != null) {
          obj_outputBodyUrl_union0 = obj_outputBodyUrl_union0_error.message;
        }
        let obj_outputBodyUrl_union1 = null;
        const obj_outputBodyUrl_union1_error = (() => {
          if (obj_outputBodyUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_outputBodyUrl + '" (at "' + path_outputBodyUrl + '")');
          }
        })();
        if (obj_outputBodyUrl_union1_error != null) {
          obj_outputBodyUrl_union1 = obj_outputBodyUrl_union1_error.message;
        }
        if (obj_outputBodyUrl_union0 && obj_outputBodyUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_outputBodyUrl + '")';
          message += '\n' + obj_outputBodyUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_outputBodyUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_startDate = obj.startDate;
        const path_startDate = path + '.startDate';
        let obj_startDate_union0 = null;
        const obj_startDate_union0_error = (() => {
          if (typeof obj_startDate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_startDate + '" (at "' + path_startDate + '")');
          }
        })();
        if (obj_startDate_union0_error != null) {
          obj_startDate_union0 = obj_startDate_union0_error.message;
        }
        let obj_startDate_union1 = null;
        const obj_startDate_union1_error = (() => {
          if (obj_startDate !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_startDate + '" (at "' + path_startDate + '")');
          }
        })();
        if (obj_startDate_union1_error != null) {
          obj_startDate_union1 = obj_startDate_union1_error.message;
        }
        if (obj_startDate_union0 && obj_startDate_union1) {
          let message = 'Object doesn\'t match union (at "' + path_startDate + '")';
          message += '\n' + obj_startDate_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_startDate_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_status = obj.status;
        const path_status = path + '.status';
        if (typeof obj_status !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_status + '" (at "' + path_status + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$t = 'ManagedContentTranslationV2Representation';
    function keyBuilder$11(luvio, config) {
      return keyPrefix + '::' + RepresentationType$t + ':' + config.id;
    }
    function keyBuilderFromType$c(luvio, object) {
      const keyParams = {
        id: object.id
      };
      return keyBuilder$11(luvio, keyParams);
    }
    function normalize$t(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$16 = function ManagedContentTranslationV2RepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$x,
        private: [],
        opaque: true
      };
    };
    function equals$x(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$t = function ManagedContentTranslationV2RepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$T(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$c(luvio, input);
      const ttlToUse = TTL$t;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$t, "CMSAuthoring", VERSION$x, RepresentationType$t, equals$x);
      return createLink(key);
    };
    function getTypeCacheKeys$t(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$c(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$t,
        mergeable: false
      });
    }
    function select$15(luvio, params) {
      return select$16();
    }
    function getResponseCacheKeys$B(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$t(storeKeyMap, luvio, response);
    }
    function ingestSuccess$A(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$c(luvio, body);
      luvio.storeIngest(key, ingest$t, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$15(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$B(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/content/spaces/' + config.urlParams.contentSpaceId + '/translation',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$B = 'createTranslationV2Job';
    const createTranslationV2Job_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('translationV2Request', true, 2 /* Body */, 4 /* Unsupported */)];
    const createTranslationV2Job_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$B, createTranslationV2Job_ConfigPropertyMetadata);
    const createResourceParams$B = /*#__PURE__*/luvioEngine.createResourceParams(createTranslationV2Job_ConfigPropertyMetadata);
    function typeCheckConfig$B(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, createTranslationV2Job_ConfigPropertyMetadata);
      const untrustedConfig_translationV2Request = untrustedConfig.translationV2Request;
      const referenceManagedContentTranslationV2RequestInputRepValidationError = validate$U(untrustedConfig_translationV2Request);
      if (referenceManagedContentTranslationV2RequestInputRepValidationError === null) {
        config.translationV2Request = untrustedConfig_translationV2Request;
      }
      return config;
    }
    function validateAdapterConfig$B(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$B(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$B(luvio, config, options) {
      const resourceParams = createResourceParams$B(config);
      const request = createResourceRequest$B(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$A(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$B(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const createTranslationV2JobAdapterFactory = luvio => {
      return function createTranslationV2Job(untrustedConfig) {
        const config = validateAdapterConfig$B(untrustedConfig, createTranslationV2Job_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "createTranslationV2Job"');
        }
        return buildNetworkSnapshot$B(luvio, config);
      };
    };
    function keyBuilder$10(luvio, params) {
      return keyBuilder$13(luvio, {
        id: params.urlParams.variantId
      });
    }
    function getResponseCacheKeys$A(cacheKeyMap, luvio, resourceParams) {
      const key = keyBuilder$10(luvio, resourceParams);
      cacheKeyMap.set(key, {
        namespace: keyPrefix,
        representationName: RepresentationType$v,
        mergeable: false
      });
    }
    function evictSuccess(luvio, resourceParams) {
      const key = keyBuilder$10(luvio, resourceParams);
      luvio.storeEvict(key);
    }
    function createResourceRequest$A(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/variants/' + config.urlParams.variantId + '',
        method: 'delete',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$A = 'deleteManagedContentVariant';
    const deleteManagedContentVariant_ConfigPropertyMetadata = [generateParamConfigMetadata('variantId', true, 0 /* UrlParameter */, 0 /* String */)];
    const deleteManagedContentVariant_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$A, deleteManagedContentVariant_ConfigPropertyMetadata);
    const createResourceParams$A = /*#__PURE__*/luvioEngine.createResourceParams(deleteManagedContentVariant_ConfigPropertyMetadata);
    function typeCheckConfig$A(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, deleteManagedContentVariant_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$A(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$A(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$A(luvio, config, options) {
      const resourceParams = createResourceParams$A(config);
      const request = createResourceRequest$A(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(() => {
        return luvio.handleSuccessResponse(() => {
          evictSuccess(luvio, resourceParams);
          return luvio.storeBroadcast();
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$A(cache, luvio, resourceParams);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const deleteManagedContentVariantAdapterFactory = luvio => {
      return function CMSAuthoringdeleteManagedContentVariant(untrustedConfig) {
        const config = validateAdapterConfig$A(untrustedConfig, deleteManagedContentVariant_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error(`Invalid config for "${adapterName$A}"`);
        }
        return buildNetworkSnapshot$A(luvio, config);
      };
    };
    const VERSION$w = "7e57fd77c4503be9a8822f2603a04df3";
    function validate$S(obj, path = 'ManagedContentJobBodyRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_bodyType = obj.bodyType;
        const path_bodyType = path + '.bodyType';
        if (typeof obj_bodyType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_bodyType + '" (at "' + path_bodyType + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$14 = function ManagedContentJobBodyRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$w,
        private: [],
        selections: [{
          name: 'bodyType',
          kind: 'Scalar'
        }, {
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'name',
          kind: 'Scalar'
        }, {
          name: 'url',
          kind: 'Scalar'
        }]
      };
    };
    function equals$w(existing, incoming) {
      const existing_bodyType = existing.bodyType;
      const incoming_bodyType = incoming.bodyType;
      if (!(existing_bodyType === incoming_bodyType)) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_name = existing.name;
      const incoming_name = incoming.name;
      if (!(existing_name === incoming_name)) {
        return false;
      }
      const existing_url = existing.url;
      const incoming_url = incoming.url;
      if (!(existing_url === incoming_url)) {
        return false;
      }
      return true;
    }
    const VERSION$v = "eba1876bba76cb05d9cbb8a968bd6796";
    function validate$R(obj, path = 'ManagedContentJobBodyCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_jobBodies = obj.jobBodies;
        const path_jobBodies = path + '.jobBodies';
        if (!ArrayIsArray(obj_jobBodies)) {
          return new TypeError('Expected "array" but received "' + typeof obj_jobBodies + '" (at "' + path_jobBodies + '")');
        }
        for (let i = 0; i < obj_jobBodies.length; i++) {
          const obj_jobBodies_item = obj_jobBodies[i];
          const path_jobBodies_item = path_jobBodies + '[' + i + ']';
          const referencepath_jobBodies_itemValidationError = validate$S(obj_jobBodies_item, path_jobBodies_item);
          if (referencepath_jobBodies_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentJobBodyRepresentation (at "' + path_jobBodies_item + '")\n';
            message += referencepath_jobBodies_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$13 = function ManagedContentJobBodyCollectionRepresentationSelect() {
      const {
        selections: ManagedContentJobBodyRepresentation__selections,
        opaque: ManagedContentJobBodyRepresentation__opaque
      } = select$14();
      return {
        kind: 'Fragment',
        version: VERSION$v,
        private: [],
        selections: [{
          name: 'jobBodies',
          kind: 'Object',
          plural: true,
          selections: ManagedContentJobBodyRepresentation__selections
        }]
      };
    };
    function equals$v(existing, incoming) {
      const existing_jobBodies = existing.jobBodies;
      const incoming_jobBodies = incoming.jobBodies;
      const equals_jobBodies_items = equalsArray(existing_jobBodies, incoming_jobBodies, (existing_jobBodies_item, incoming_jobBodies_item) => {
        if (!equals$w(existing_jobBodies_item, incoming_jobBodies_item)) {
          return false;
        }
      });
      if (equals_jobBodies_items === false) {
        return false;
      }
      return true;
    }
    const TTL$s = 100;
    const VERSION$u = "9c2de7843d4d4e7784d56c7f83c58f0e";
    function validate$Q(obj, path = 'ManagedContentV2JobDetailRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_body = obj.body;
        const path_body = path + '.body';
        let obj_body_union0 = null;
        const obj_body_union0_error = (() => {
          const referencepath_bodyValidationError = validate$R(obj_body, path_body);
          if (referencepath_bodyValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentJobBodyCollectionRepresentation (at "' + path_body + '")\n';
            message += referencepath_bodyValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_body_union0_error != null) {
          obj_body_union0 = obj_body_union0_error.message;
        }
        let obj_body_union1 = null;
        const obj_body_union1_error = (() => {
          if (obj_body !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_body + '" (at "' + path_body + '")');
          }
        })();
        if (obj_body_union1_error != null) {
          obj_body_union1 = obj_body_union1_error.message;
        }
        if (obj_body_union0 && obj_body_union1) {
          let message = 'Object doesn\'t match union (at "' + path_body + '")';
          message += '\n' + obj_body_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_body_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_createdById = obj.createdById;
        const path_createdById = path + '.createdById';
        if (typeof obj_createdById !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdById + '" (at "' + path_createdById + '")');
        }
        const obj_createdByName = obj.createdByName;
        const path_createdByName = path + '.createdByName';
        if (typeof obj_createdByName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdByName + '" (at "' + path_createdByName + '")');
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        let obj_createdDate_union0 = null;
        const obj_createdDate_union0_error = (() => {
          if (typeof obj_createdDate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
          }
        })();
        if (obj_createdDate_union0_error != null) {
          obj_createdDate_union0 = obj_createdDate_union0_error.message;
        }
        let obj_createdDate_union1 = null;
        const obj_createdDate_union1_error = (() => {
          if (obj_createdDate !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
          }
        })();
        if (obj_createdDate_union1_error != null) {
          obj_createdDate_union1 = obj_createdDate_union1_error.message;
        }
        if (obj_createdDate_union0 && obj_createdDate_union1) {
          let message = 'Object doesn\'t match union (at "' + path_createdDate + '")';
          message += '\n' + obj_createdDate_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_createdDate_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_jobType = obj.jobType;
        const path_jobType = path + '.jobType';
        if (typeof obj_jobType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_jobType + '" (at "' + path_jobType + '")');
        }
        const obj_lastStatusUpdateDate = obj.lastStatusUpdateDate;
        const path_lastStatusUpdateDate = path + '.lastStatusUpdateDate';
        if (typeof obj_lastStatusUpdateDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastStatusUpdateDate + '" (at "' + path_lastStatusUpdateDate + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_status = obj.status;
        const path_status = path + '.status';
        if (typeof obj_status !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_status + '" (at "' + path_status + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$s = 'ManagedContentV2JobDetailRepresentation';
    function keyBuilder$$(luvio, config) {
      return keyPrefix + '::' + RepresentationType$s + ':' + config.id;
    }
    function keyBuilderFromType$b(luvio, object) {
      const keyParams = {
        id: object.id
      };
      return keyBuilder$$(luvio, keyParams);
    }
    function normalize$s(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$12 = function ManagedContentV2JobDetailRepresentationSelect() {
      const {
        selections: ManagedContentJobBodyCollectionRepresentation__selections,
        opaque: ManagedContentJobBodyCollectionRepresentation__opaque
      } = select$13();
      return {
        kind: 'Fragment',
        version: VERSION$u,
        private: [],
        selections: [{
          name: 'body',
          kind: 'Object',
          nullable: true,
          selections: ManagedContentJobBodyCollectionRepresentation__selections
        }, {
          name: 'createdById',
          kind: 'Scalar'
        }, {
          name: 'createdByName',
          kind: 'Scalar'
        }, {
          name: 'createdDate',
          kind: 'Scalar'
        }, {
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'jobType',
          kind: 'Scalar'
        }, {
          name: 'lastStatusUpdateDate',
          kind: 'Scalar'
        }, {
          name: 'name',
          kind: 'Scalar'
        }, {
          name: 'status',
          kind: 'Scalar'
        }, {
          name: 'type',
          kind: 'Scalar'
        }]
      };
    };
    function equals$u(existing, incoming) {
      const existing_createdById = existing.createdById;
      const incoming_createdById = incoming.createdById;
      if (!(existing_createdById === incoming_createdById)) {
        return false;
      }
      const existing_createdByName = existing.createdByName;
      const incoming_createdByName = incoming.createdByName;
      if (!(existing_createdByName === incoming_createdByName)) {
        return false;
      }
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_jobType = existing.jobType;
      const incoming_jobType = incoming.jobType;
      if (!(existing_jobType === incoming_jobType)) {
        return false;
      }
      const existing_lastStatusUpdateDate = existing.lastStatusUpdateDate;
      const incoming_lastStatusUpdateDate = incoming.lastStatusUpdateDate;
      if (!(existing_lastStatusUpdateDate === incoming_lastStatusUpdateDate)) {
        return false;
      }
      const existing_name = existing.name;
      const incoming_name = incoming.name;
      if (!(existing_name === incoming_name)) {
        return false;
      }
      const existing_status = existing.status;
      const incoming_status = incoming.status;
      if (!(existing_status === incoming_status)) {
        return false;
      }
      const existing_type = existing.type;
      const incoming_type = incoming.type;
      if (!(existing_type === incoming_type)) {
        return false;
      }
      const existing_body = existing.body;
      const incoming_body = incoming.body;
      if (!(existing_body === incoming_body || existing_body != null && incoming_body != null && equals$v(existing_body, incoming_body))) {
        return false;
      }
      const existing_createdDate = existing.createdDate;
      const incoming_createdDate = incoming.createdDate;
      if (!(existing_createdDate === incoming_createdDate)) {
        return false;
      }
      return true;
    }
    const ingest$s = function ManagedContentV2JobDetailRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$Q(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$b(luvio, input);
      const ttlToUse = TTL$s;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$s, "CMSAuthoring", VERSION$u, RepresentationType$s, equals$u);
      return createLink(key);
    };
    function getTypeCacheKeys$s(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$b(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$s,
        mergeable: false
      });
    }
    const TTL$r = 100;
    const VERSION$t = "75cfd71e168144693d36fa16f7d8f4d0";
    function validate$P(obj, path = 'ManagedContentJobCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_jobs = obj.jobs;
        const path_jobs = path + '.jobs';
        if (!ArrayIsArray(obj_jobs)) {
          return new TypeError('Expected "array" but received "' + typeof obj_jobs + '" (at "' + path_jobs + '")');
        }
        for (let i = 0; i < obj_jobs.length; i++) {
          const obj_jobs_item = obj_jobs[i];
          const path_jobs_item = path_jobs + '[' + i + ']';
          if (typeof obj_jobs_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_jobs_item + '" (at "' + path_jobs_item + '")');
          }
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
          if (typeof obj_nextPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union0_error != null) {
          obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
          if (obj_nextPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union1_error != null) {
          obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
          message += '\n' + obj_nextPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
          if (typeof obj_previousPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union0_error != null) {
          obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
          if (obj_previousPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union1_error != null) {
          obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
          message += '\n' + obj_previousPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$r = 'ManagedContentJobCollectionRepresentation';
    function normalize$r(input, existing, path, luvio, store, timestamp) {
      const input_jobs = input.jobs;
      const input_jobs_id = path.fullPath + '__jobs';
      for (let i = 0; i < input_jobs.length; i++) {
        const input_jobs_item = input_jobs[i];
        let input_jobs_item_id = input_jobs_id + '__' + i;
        input_jobs[i] = ingest$s(input_jobs_item, {
          fullPath: input_jobs_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$11 = function ManagedContentJobCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$t,
        private: [],
        selections: [{
          name: 'currentPageUrl',
          kind: 'Scalar'
        }, {
          name: 'jobs',
          kind: 'Link',
          plural: true,
          fragment: select$12()
        }, {
          name: 'nextPageUrl',
          kind: 'Scalar'
        }, {
          name: 'previousPageUrl',
          kind: 'Scalar'
        }]
      };
    };
    function equals$t(existing, incoming) {
      const existing_currentPageUrl = existing.currentPageUrl;
      const incoming_currentPageUrl = incoming.currentPageUrl;
      if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
      }
      const existing_jobs = existing.jobs;
      const incoming_jobs = incoming.jobs;
      const equals_jobs_items = equalsArray(existing_jobs, incoming_jobs, (existing_jobs_item, incoming_jobs_item) => {
        if (!(existing_jobs_item.__ref === incoming_jobs_item.__ref)) {
          return false;
        }
      });
      if (equals_jobs_items === false) {
        return false;
      }
      const existing_nextPageUrl = existing.nextPageUrl;
      const incoming_nextPageUrl = incoming.nextPageUrl;
      if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
      }
      const existing_previousPageUrl = existing.previousPageUrl;
      const incoming_previousPageUrl = incoming.previousPageUrl;
      if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
      }
      return true;
    }
    const ingest$r = function ManagedContentJobCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$P(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$r;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$r, "CMSAuthoring", VERSION$t, RepresentationType$r, equals$t);
      return createLink(key);
    };
    function getTypeCacheKeys$r(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$r,
        mergeable: false
      });
      const input_jobs_length = input.jobs.length;
      for (let i = 0; i < input_jobs_length; i++) {
        getTypeCacheKeys$s(rootKeySet, luvio, input.jobs[i]);
      }
    }
    function select$10(luvio, params) {
      return select$11();
    }
    function keyBuilder$_(luvio, params) {
      return keyPrefix + '::ManagedContentJobCollectionRepresentation:(' + 'jobType:' + params.queryParams.jobType + ',' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'contentSpaceId:' + params.urlParams.contentSpaceId + ')';
    }
    function getResponseCacheKeys$z(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$r(storeKeyMap, luvio, response, () => keyBuilder$_(luvio, resourceParams));
    }
    function ingestSuccess$z(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$_(luvio, resourceParams);
      luvio.storeIngest(key, ingest$r, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$10(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$p(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$_(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$r,
        namespace: keyPrefix,
        version: VERSION$t,
        representationName: RepresentationType$r
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$z(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/cms/spaces/' + config.urlParams.contentSpaceId + '/jobs',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$z = 'getAllCMSJobsForSpace';
    const getAllCMSJobsForSpace_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('jobType', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('page', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */)];
    const getAllCMSJobsForSpace_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$z, getAllCMSJobsForSpace_ConfigPropertyMetadata);
    const createResourceParams$z = /*#__PURE__*/luvioEngine.createResourceParams(getAllCMSJobsForSpace_ConfigPropertyMetadata);
    function keyBuilder$Z(luvio, config) {
      const resourceParams = createResourceParams$z(config);
      return keyBuilder$_(luvio, resourceParams);
    }
    function typeCheckConfig$z(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getAllCMSJobsForSpace_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$z(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$z(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$p(luvio, config) {
      createResourceParams$z(config);
      return select$10();
    }
    function onFetchResponseSuccess$s(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$z(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$z(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$p(luvio, config, resourceParams, response) {
      const snapshot = ingestError$p(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$z(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$z(luvio, config, options) {
      const resourceParams = createResourceParams$z(config);
      const request = createResourceRequest$z(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$s(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$z(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$p(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$p(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$z, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$p(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$Z(luvio, config),
        node: adapterFragment$p(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$z(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getAllCMSJobsForSpaceAdapterFactory = luvio => function CMSAuthoring__getAllCMSJobsForSpace(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$z(untrustedConfig, getAllCMSJobsForSpace_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$p, buildNetworkSnapshotCachePolicy$p);
    };
    function select$$(luvio, params) {
      return select$12();
    }
    function keyBuilder$Y(luvio, params) {
      return keyBuilder$$(luvio, {
        id: params.urlParams.jobId
      });
    }
    function getResponseCacheKeys$y(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$s(storeKeyMap, luvio, response);
    }
    function ingestSuccess$y(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$Y(luvio, resourceParams);
      luvio.storeIngest(key, ingest$s, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$$(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$o(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$Y(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$s,
        namespace: keyPrefix,
        version: VERSION$u,
        representationName: RepresentationType$s
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$y(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/cms/spaces/' + config.urlParams.contentSpaceId + '/jobs/' + config.urlParams.jobId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function createResourceRequestFromRepresentation$5(representation) {
      const config = {
        urlParams: {}
      };
      config.urlParams.jobId = representation.id;
      return createResourceRequest$y(config);
    }
    const adapterName$y = 'getCMSJobForSpace';
    const getCMSJobForSpace_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('jobId', true, 0 /* UrlParameter */, 0 /* String */)];
    const getCMSJobForSpace_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$y, getCMSJobForSpace_ConfigPropertyMetadata);
    const createResourceParams$y = /*#__PURE__*/luvioEngine.createResourceParams(getCMSJobForSpace_ConfigPropertyMetadata);
    function keyBuilder$X(luvio, config) {
      const resourceParams = createResourceParams$y(config);
      return keyBuilder$Y(luvio, resourceParams);
    }
    function typeCheckConfig$y(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getCMSJobForSpace_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$y(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$y(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$o(luvio, config) {
      createResourceParams$y(config);
      return select$$();
    }
    function onFetchResponseSuccess$r(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$y(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$y(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$o(luvio, config, resourceParams, response) {
      const snapshot = ingestError$o(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$y(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$y(luvio, config, options) {
      const resourceParams = createResourceParams$y(config);
      const request = createResourceRequest$y(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$r(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$y(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$o(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$o(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$y, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$o(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$X(luvio, config),
        node: adapterFragment$o(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$y(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getCMSJobForSpaceAdapterFactory = luvio => function CMSAuthoring__getCMSJobForSpace(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$y(untrustedConfig, getCMSJobForSpace_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$o, buildNetworkSnapshotCachePolicy$o);
    };
    const notifyChangeFactory$5 = (luvio, options) => {
      return function getCmsSpacesJobsByContentSpaceIdAndJobIdNotifyChange(configs) {
        const keys = configs.map(c => keyBuilder$$(luvio, c));
        luvio.getNotifyChangeStoreEntries(keys).then(entries => {
          for (let i = 0, len = entries.length; i < len; i++) {
            const {
              key,
              record: val
            } = entries[i];
            const refreshRequest = createResourceRequestFromRepresentation$5(val);
            luvio.dispatchResourceRequest(refreshRequest, options).then(response => {
              return luvio.handleSuccessResponse(() => {
                const {
                  body
                } = response;
                luvio.storeIngest(key, ingest$s, body);
                return luvio.storeBroadcast();
              }, () => {
                const cache = new luvioEngine.StoreKeyMap();
                getTypeCacheKeys$s(cache, luvio, response.body);
                return cache;
              });
            }, error => {
              return luvio.handleErrorResponse(() => {
                const errorSnapshot = luvio.errorSnapshot(error);
                luvio.storeIngestError(key, errorSnapshot, {
                  ttl: TTL$s,
                  namespace: keyPrefix,
                  version: VERSION$u,
                  representationName: RepresentationType$s
                });
                return luvio.storeBroadcast().then(() => errorSnapshot);
              });
            });
          }
        });
      };
    };
    function validate$O(obj, path = 'ManagedContentCollectionItemTypeSummaryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fullyQualifiedName = obj.fullyQualifiedName;
        const path_fullyQualifiedName = path + '.fullyQualifiedName';
        if (typeof obj_fullyQualifiedName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fullyQualifiedName + '" (at "' + path_fullyQualifiedName + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$N(obj, path = 'ManagedContentCollectionItemRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_body = obj.body;
        const path_body = path + '.body';
        if (typeof obj_body !== 'object' || ArrayIsArray(obj_body) || obj_body === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_body + '" (at "' + path_body + '")');
        }
        const obj_body_keys = ObjectKeys(obj_body);
        for (let i = 0; i < obj_body_keys.length; i++) {
          const key = obj_body_keys[i];
          const obj_body_prop = obj_body[key];
          const path_body_prop = path_body + '["' + key + '"]';
          if (obj_body_prop === undefined) {
            return new TypeError('Expected "defined" but received "' + typeof obj_body_prop + '" (at "' + path_body_prop + '")');
          }
        }
        const obj_contentType = obj.contentType;
        const path_contentType = path + '.contentType';
        const referencepath_contentTypeValidationError = validate$O(obj_contentType, path_contentType);
        if (referencepath_contentTypeValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentCollectionItemTypeSummaryRepresentation (at "' + path_contentType + '")\n';
          message += referencepath_contentTypeValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$q = 100;
    const VERSION$s = "eeea454f1268ece5c3e24c986688b876";
    function validate$M(obj, path = 'ManagedContentCollectionDetailRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_collectionKey = obj.collectionKey;
        const path_collectionKey = path + '.collectionKey';
        if (typeof obj_collectionKey !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_collectionKey + '" (at "' + path_collectionKey + '")');
        }
        const obj_collectionType = obj.collectionType;
        const path_collectionType = path + '.collectionType';
        const referencepath_collectionTypeValidationError = validate$17(obj_collectionType, path_collectionType);
        if (referencepath_collectionTypeValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentTypeSummaryRepresentation (at "' + path_collectionType + '")\n';
          message += referencepath_collectionTypeValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_isPublished = obj.isPublished;
        const path_isPublished = path + '.isPublished';
        if (typeof obj_isPublished !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isPublished + '" (at "' + path_isPublished + '")');
        }
        const obj_items = obj.items;
        const path_items = path + '.items';
        if (!ArrayIsArray(obj_items)) {
          return new TypeError('Expected "array" but received "' + typeof obj_items + '" (at "' + path_items + '")');
        }
        for (let i = 0; i < obj_items.length; i++) {
          const obj_items_item = obj_items[i];
          const path_items_item = path_items + '[' + i + ']';
          const referencepath_items_itemValidationError = validate$N(obj_items_item, path_items_item);
          if (referencepath_items_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentCollectionItemRepresentation (at "' + path_items_item + '")\n';
            message += referencepath_items_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_language = obj.language;
        const path_language = path + '.language';
        if (typeof obj_language !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_language + '" (at "' + path_language + '")');
        }
        const obj_title = obj.title;
        const path_title = path + '.title';
        if (typeof obj_title !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
        }
        const obj_total = obj.total;
        const path_total = path + '.total';
        if (typeof obj_total !== 'number' || typeof obj_total === 'number' && Math.floor(obj_total) !== obj_total) {
          return new TypeError('Expected "integer" but received "' + typeof obj_total + '" (at "' + path_total + '")');
        }
        const obj_urlName = obj.urlName;
        const path_urlName = path + '.urlName';
        if (typeof obj_urlName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_urlName + '" (at "' + path_urlName + '")');
        }
        const obj_versionNumber = obj.versionNumber;
        const path_versionNumber = path + '.versionNumber';
        if (typeof obj_versionNumber !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_versionNumber + '" (at "' + path_versionNumber + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$q = 'ManagedContentCollectionDetailRepresentation';
    function keyBuilder$W(luvio, config) {
      return keyPrefix + '::' + RepresentationType$q + ':' + config.collection_key + ':' + config.language + ':' + config.version;
    }
    function keyBuilderFromType$a(luvio, object) {
      const keyParams = {
        collection_key: object.collectionKey,
        language: object.language,
        version: object.versionNumber
      };
      return keyBuilder$W(luvio, keyParams);
    }
    function normalize$q(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$_ = function ManagedContentCollectionDetailRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$s,
        private: [],
        opaque: true
      };
    };
    function equals$s(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$q = function ManagedContentCollectionDetailRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$M(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$a(luvio, input);
      const ttlToUse = TTL$q;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$q, "CMSAuthoring", VERSION$s, RepresentationType$q, equals$s);
      return createLink(key);
    };
    function getTypeCacheKeys$q(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$a(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$q,
        mergeable: false
      });
    }
    function select$Z(luvio, params) {
      return select$_();
    }
    function keyBuilder$V(luvio, params) {
      return keyBuilder$W(luvio, {
        collection_key: params.urlParams.collectionKeyOrId,
        language: params.queryParams.language || '',
        version: params.queryParams.version || ''
      });
    }
    function getResponseCacheKeys$x(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$q(storeKeyMap, luvio, response);
    }
    function ingestSuccess$x(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$V(luvio, resourceParams);
      luvio.storeIngest(key, ingest$q, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$Z(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$n(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$V(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$q,
        namespace: keyPrefix,
        version: VERSION$s,
        representationName: RepresentationType$q
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$x(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/collections/' + config.urlParams.collectionKeyOrId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function onFetchResponseSuccess$q(luvio, config, resourceParams, response) {
      let updatedResourceParams = resourceParams;
      // If language is not provided in request resource params, use language from the response
      // and update the response params. As this resource params will be used to build a cache key.
      if (updatedResourceParams.queryParams.language === undefined) {
        updatedResourceParams.queryParams.language = response.body.language;
      }
      // If version is not provided in request resource params, use versionNumber from the response
      // and update the response params. As this resource params will be used to build a cache key.
      if (updatedResourceParams.queryParams.version === undefined) {
        updatedResourceParams.queryParams.version = response.body.versionNumber;
      }
      return onFetchResponseSuccess$p(luvio, config, updatedResourceParams, response);
    }
    const adapterName$x = 'getCollectionItems';
    const getCollectionItems_ConfigPropertyMetadata = [generateParamConfigMetadata('collectionKeyOrId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('language', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('version', false, 1 /* QueryParameter */, 0 /* String */)];
    const getCollectionItems_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$x, getCollectionItems_ConfigPropertyMetadata);
    const createResourceParams$x = /*#__PURE__*/luvioEngine.createResourceParams(getCollectionItems_ConfigPropertyMetadata);
    function keyBuilder$U(luvio, config) {
      const resourceParams = createResourceParams$x(config);
      return keyBuilder$V(luvio, resourceParams);
    }
    function typeCheckConfig$x(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getCollectionItems_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$x(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$x(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$n(luvio, config) {
      createResourceParams$x(config);
      return select$Z();
    }
    function onFetchResponseSuccess$p(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$x(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$x(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$n(luvio, config, resourceParams, response) {
      const snapshot = ingestError$n(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$x(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$x(luvio, config, options) {
      const resourceParams = createResourceParams$x(config);
      const request = createResourceRequest$x(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$q(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$x(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$n(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$n(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$x, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$n(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$U(luvio, config),
        node: adapterFragment$n(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$x(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getCollectionItemsAdapterFactory = luvio => function CMSAuthoring__getCollectionItems(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$x(untrustedConfig, getCollectionItems_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$n, buildNetworkSnapshotCachePolicy$n);
    };
    const TTL$p = 100;
    const VERSION$r = "b2c15aa80814ecd854e68bf635879e35";
    function validate$L(obj, path = 'ManagedContentDeploymentCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_deployments = obj.deployments;
        const path_deployments = path + '.deployments';
        if (!ArrayIsArray(obj_deployments)) {
          return new TypeError('Expected "array" but received "' + typeof obj_deployments + '" (at "' + path_deployments + '")');
        }
        for (let i = 0; i < obj_deployments.length; i++) {
          const obj_deployments_item = obj_deployments[i];
          const path_deployments_item = path_deployments + '[' + i + ']';
          if (typeof obj_deployments_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_deployments_item + '" (at "' + path_deployments_item + '")');
          }
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
          if (typeof obj_nextPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union0_error != null) {
          obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
          if (obj_nextPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union1_error != null) {
          obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
          message += '\n' + obj_nextPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
          if (typeof obj_previousPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union0_error != null) {
          obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
          if (obj_previousPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
          }
        })();
        if (obj_previousPageUrl_union1_error != null) {
          obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
          message += '\n' + obj_previousPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previousPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$p = 'ManagedContentDeploymentCollectionRepresentation';
    function normalize$p(input, existing, path, luvio, store, timestamp) {
      const input_deployments = input.deployments;
      const input_deployments_id = path.fullPath + '__deployments';
      for (let i = 0; i < input_deployments.length; i++) {
        const input_deployments_item = input_deployments[i];
        let input_deployments_item_id = input_deployments_id + '__' + i;
        input_deployments[i] = ingest$y(input_deployments_item, {
          fullPath: input_deployments_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$Y = function ManagedContentDeploymentCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$r,
        private: [],
        selections: [{
          name: 'currentPageUrl',
          kind: 'Scalar'
        }, {
          name: 'deployments',
          kind: 'Link',
          plural: true,
          fragment: select$1i()
        }, {
          name: 'nextPageUrl',
          kind: 'Scalar'
        }, {
          name: 'previousPageUrl',
          kind: 'Scalar'
        }]
      };
    };
    function equals$r(existing, incoming) {
      const existing_currentPageUrl = existing.currentPageUrl;
      const incoming_currentPageUrl = incoming.currentPageUrl;
      if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
      }
      const existing_deployments = existing.deployments;
      const incoming_deployments = incoming.deployments;
      const equals_deployments_items = equalsArray(existing_deployments, incoming_deployments, (existing_deployments_item, incoming_deployments_item) => {
        if (!(existing_deployments_item.__ref === incoming_deployments_item.__ref)) {
          return false;
        }
      });
      if (equals_deployments_items === false) {
        return false;
      }
      const existing_nextPageUrl = existing.nextPageUrl;
      const incoming_nextPageUrl = incoming.nextPageUrl;
      if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
      }
      const existing_previousPageUrl = existing.previousPageUrl;
      const incoming_previousPageUrl = incoming.previousPageUrl;
      if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
      }
      return true;
    }
    const ingest$p = function ManagedContentDeploymentCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$L(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$p;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$p, "CMSAuthoring", VERSION$r, RepresentationType$p, equals$r);
      return createLink(key);
    };
    function getTypeCacheKeys$p(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$p,
        mergeable: false
      });
      const input_deployments_length = input.deployments.length;
      for (let i = 0; i < input_deployments_length; i++) {
        getTypeCacheKeys$y(rootKeySet, luvio, input.deployments[i]);
      }
    }
    function select$X(luvio, params) {
      return select$Y();
    }
    function keyBuilder$T(luvio, params) {
      return keyPrefix + '::ManagedContentDeploymentCollectionRepresentation:(' + 'contentSpaceId:' + params.queryParams.contentSpaceId + ',' + 'deploymentId:' + params.queryParams.deploymentId + ',' + 'deploymentStatus:' + params.queryParams.deploymentStatus + ',' + 'deploymentType:' + params.queryParams.deploymentType + ',' + 'managedContentVersionId:' + params.queryParams.managedContentVersionId + ',' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'variantIds:' + params.queryParams.variantIds + ')';
    }
    function getResponseCacheKeys$w(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$p(storeKeyMap, luvio, response, () => keyBuilder$T(luvio, resourceParams));
    }
    function ingestSuccess$w(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$T(luvio, resourceParams);
      luvio.storeIngest(key, ingest$p, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$X(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$m(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$T(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$p,
        namespace: keyPrefix,
        version: VERSION$r,
        representationName: RepresentationType$p
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$w(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/cms/deployments',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$w = 'getDeployments';
    const oneOfConfigPropertiesIdentifier = ['deploymentId', 'contentSpaceId', 'variantIds', 'managedContentVersionId'];
    const getDeployments_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('deploymentId', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('deploymentStatus', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('deploymentType', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('managedContentVersionId', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('page', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('variantIds', false, 1 /* QueryParameter */, 0 /* String */, true)];
    const getDeployments_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$w, getDeployments_ConfigPropertyMetadata);
    const createResourceParams$w = /*#__PURE__*/luvioEngine.createResourceParams(getDeployments_ConfigPropertyMetadata);
    function keyBuilder$S(luvio, config) {
      const resourceParams = createResourceParams$w(config);
      return keyBuilder$T(luvio, resourceParams);
    }
    function typeCheckConfig$w(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getDeployments_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$w(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames, oneOfConfigPropertiesIdentifier);
      }
      const config = typeCheckConfig$w(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      if (config.deploymentId === undefined && config.contentSpaceId === undefined && config.variantIds === undefined && config.managedContentVersionId === undefined) {
        return null;
      }
      return config;
    }
    function adapterFragment$m(luvio, config) {
      createResourceParams$w(config);
      return select$X();
    }
    function onFetchResponseSuccess$o(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$w(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$w(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$m(luvio, config, resourceParams, response) {
      const snapshot = ingestError$m(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$w(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$w(luvio, config, options) {
      const resourceParams = createResourceParams$w(config);
      const request = createResourceRequest$w(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$o(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$w(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$m(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$m(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$w, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$m(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$S(luvio, config),
        node: adapterFragment$m(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$w(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getDeploymentsAdapterFactory = luvio => function CMSAuthoring__getDeployments(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$w(untrustedConfig, getDeployments_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$m, buildNetworkSnapshotCachePolicy$m);
    };
    function validate$K(obj, path = 'MCSFolderShareTargetRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_resourceUrl = obj.resourceUrl;
        const path_resourceUrl = path + '.resourceUrl';
        if (typeof obj_resourceUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_resourceUrl + '" (at "' + path_resourceUrl + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$o = 1000;
    const VERSION$q = "c0ff97bb4eb8268055467aedb9fff9d4";
    function validate$J(obj, path = 'MCSFolderShareTargetCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_shareTargets = obj.shareTargets;
        const path_shareTargets = path + '.shareTargets';
        if (!ArrayIsArray(obj_shareTargets)) {
          return new TypeError('Expected "array" but received "' + typeof obj_shareTargets + '" (at "' + path_shareTargets + '")');
        }
        for (let i = 0; i < obj_shareTargets.length; i++) {
          const obj_shareTargets_item = obj_shareTargets[i];
          const path_shareTargets_item = path_shareTargets + '[' + i + ']';
          const referencepath_shareTargets_itemValidationError = validate$K(obj_shareTargets_item, path_shareTargets_item);
          if (referencepath_shareTargets_itemValidationError !== null) {
            let message = 'Object doesn\'t match MCSFolderShareTargetRepresentation (at "' + path_shareTargets_item + '")\n';
            message += referencepath_shareTargets_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$o = 'MCSFolderShareTargetCollectionRepresentation';
    function normalize$o(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$W = function MCSFolderShareTargetCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$q,
        private: [],
        opaque: true
      };
    };
    function equals$q(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$o = function MCSFolderShareTargetCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$J(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$o;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$o, "CMSAuthoring", VERSION$q, RepresentationType$o, equals$q);
      return createLink(key);
    };
    function getTypeCacheKeys$o(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$o,
        mergeable: false
      });
    }
    function select$V(luvio, params) {
      return select$W();
    }
    function keyBuilder$R(luvio, params) {
      return keyPrefix + '::MCSFolderShareTargetCollectionRepresentation:(' + 'folderId:' + params.urlParams.folderId + ')';
    }
    function getResponseCacheKeys$v(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$o(storeKeyMap, luvio, response, () => keyBuilder$R(luvio, resourceParams));
    }
    function ingestSuccess$v(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$R(luvio, resourceParams);
      luvio.storeIngest(key, ingest$o, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$V(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$l(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$R(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$o,
        namespace: keyPrefix,
        version: VERSION$q,
        representationName: RepresentationType$o
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$v(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/folders/' + config.urlParams.folderId + '/share-targets',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$v = 'getMCSFolderShareTargets';
    const getMCSFolderShareTargets_ConfigPropertyMetadata = [generateParamConfigMetadata('folderId', true, 0 /* UrlParameter */, 0 /* String */)];
    const getMCSFolderShareTargets_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$v, getMCSFolderShareTargets_ConfigPropertyMetadata);
    const createResourceParams$v = /*#__PURE__*/luvioEngine.createResourceParams(getMCSFolderShareTargets_ConfigPropertyMetadata);
    function keyBuilder$Q(luvio, config) {
      const resourceParams = createResourceParams$v(config);
      return keyBuilder$R(luvio, resourceParams);
    }
    function typeCheckConfig$v(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getMCSFolderShareTargets_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$v(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$v(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$l(luvio, config) {
      createResourceParams$v(config);
      return select$V();
    }
    function onFetchResponseSuccess$n(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$v(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$v(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$l(luvio, config, resourceParams, response) {
      const snapshot = ingestError$l(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$v(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$v(luvio, config, options) {
      const resourceParams = createResourceParams$v(config);
      const request = createResourceRequest$v(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$n(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$v(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$l(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$l(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$v, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$l(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$Q(luvio, config),
        node: adapterFragment$l(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$v(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getMCSFolderShareTargetsAdapterFactory = luvio => function CMSAuthoring__getMCSFolderShareTargets(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$v(untrustedConfig, getMCSFolderShareTargets_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$l, buildNetworkSnapshotCachePolicy$l);
    };
    function validate$I(obj, path = 'MCSFolderShareRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_shareStatus = obj.shareStatus;
        const path_shareStatus = path + '.shareStatus';
        if (typeof obj_shareStatus !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_shareStatus + '" (at "' + path_shareStatus + '")');
        }
        const obj_targetId = obj.targetId;
        const path_targetId = path + '.targetId';
        if (typeof obj_targetId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_targetId + '" (at "' + path_targetId + '")');
        }
        if (obj.targetLabel !== undefined) {
          const obj_targetLabel = obj.targetLabel;
          const path_targetLabel = path + '.targetLabel';
          if (typeof obj_targetLabel !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_targetLabel + '" (at "' + path_targetLabel + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$n = 1000;
    const VERSION$p = "fd0d4ff311a83d25ce2992ff58ca6d41";
    function validate$H(obj, path = 'MCSFolderShareCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_folderId = obj.folderId;
        const path_folderId = path + '.folderId';
        if (typeof obj_folderId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_folderId + '" (at "' + path_folderId + '")');
        }
        const obj_shares = obj.shares;
        const path_shares = path + '.shares';
        if (!ArrayIsArray(obj_shares)) {
          return new TypeError('Expected "array" but received "' + typeof obj_shares + '" (at "' + path_shares + '")');
        }
        for (let i = 0; i < obj_shares.length; i++) {
          const obj_shares_item = obj_shares[i];
          const path_shares_item = path_shares + '[' + i + ']';
          const referencepath_shares_itemValidationError = validate$I(obj_shares_item, path_shares_item);
          if (referencepath_shares_itemValidationError !== null) {
            let message = 'Object doesn\'t match MCSFolderShareRepresentation (at "' + path_shares_item + '")\n';
            message += referencepath_shares_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$n = 'MCSFolderShareCollectionRepresentation';
    function keyBuilder$P(luvio, config) {
      return keyPrefix + '::' + RepresentationType$n + ':' + config.id;
    }
    function keyBuilderFromType$9(luvio, object) {
      const keyParams = {
        id: object.folderId
      };
      return keyBuilder$P(luvio, keyParams);
    }
    function normalize$n(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$U = function MCSFolderShareCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$p,
        private: [],
        opaque: true
      };
    };
    function equals$p(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$n = function MCSFolderShareCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$H(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$9(luvio, input);
      const ttlToUse = TTL$n;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$n, "CMSAuthoring", VERSION$p, RepresentationType$n, equals$p);
      return createLink(key);
    };
    function getTypeCacheKeys$n(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$9(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$n,
        mergeable: false
      });
    }
    function select$T(luvio, params) {
      return select$U();
    }
    function keyBuilder$O(luvio, params) {
      return keyBuilder$P(luvio, {
        id: params.urlParams.folderId
      });
    }
    function getResponseCacheKeys$u(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$n(storeKeyMap, luvio, response);
    }
    function ingestSuccess$u(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$O(luvio, resourceParams);
      luvio.storeIngest(key, ingest$n, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$T(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$k(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$O(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$n,
        namespace: keyPrefix,
        version: VERSION$p,
        representationName: RepresentationType$n
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$u(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/folders/' + config.urlParams.folderId + '/shares',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function createResourceRequestFromRepresentation$4(representation) {
      const config = {
        urlParams: {}
      };
      config.urlParams.folderId = representation.folderId;
      return createResourceRequest$u(config);
    }
    const adapterName$u = 'getMCSFolderShares';
    const getMCSFolderShares_ConfigPropertyMetadata = [generateParamConfigMetadata('folderId', true, 0 /* UrlParameter */, 0 /* String */)];
    const getMCSFolderShares_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$u, getMCSFolderShares_ConfigPropertyMetadata);
    const createResourceParams$u = /*#__PURE__*/luvioEngine.createResourceParams(getMCSFolderShares_ConfigPropertyMetadata);
    function keyBuilder$N(luvio, config) {
      const resourceParams = createResourceParams$u(config);
      return keyBuilder$O(luvio, resourceParams);
    }
    function typeCheckConfig$u(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getMCSFolderShares_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$u(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$u(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$k(luvio, config) {
      createResourceParams$u(config);
      return select$T();
    }
    function onFetchResponseSuccess$m(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$u(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$u(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$k(luvio, config, resourceParams, response) {
      const snapshot = ingestError$k(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$u(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$u(luvio, config, options) {
      const resourceParams = createResourceParams$u(config);
      const request = createResourceRequest$u(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$m(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$u(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$k(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$k(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$u, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$k(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$N(luvio, config),
        node: adapterFragment$k(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$u(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getMCSFolderSharesAdapterFactory = luvio => function CMSAuthoring__getMCSFolderShares(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$u(untrustedConfig, getMCSFolderShares_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$k, buildNetworkSnapshotCachePolicy$k);
    };
    const notifyChangeFactory$4 = (luvio, options) => {
      return function getConnectCmsFoldersSharesByFolderIdNotifyChange(configs) {
        const keys = configs.map(c => keyBuilder$P(luvio, c));
        luvio.getNotifyChangeStoreEntries(keys).then(entries => {
          for (let i = 0, len = entries.length; i < len; i++) {
            const {
              key,
              record: val
            } = entries[i];
            const refreshRequest = createResourceRequestFromRepresentation$4(val);
            luvio.dispatchResourceRequest(refreshRequest, options).then(response => {
              return luvio.handleSuccessResponse(() => {
                const {
                  body
                } = response;
                luvio.storeIngest(key, ingest$n, body);
                return luvio.storeBroadcast();
              }, () => {
                const cache = new luvioEngine.StoreKeyMap();
                getTypeCacheKeys$n(cache, luvio, response.body);
                return cache;
              });
            }, error => {
              return luvio.handleErrorResponse(() => {
                const errorSnapshot = luvio.errorSnapshot(error);
                luvio.storeIngestError(key, errorSnapshot, {
                  ttl: TTL$n,
                  namespace: keyPrefix,
                  version: VERSION$p,
                  representationName: RepresentationType$n
                });
                return luvio.storeBroadcast().then(() => errorSnapshot);
              });
            });
          }
        });
      };
    };
    function select$S(luvio, params) {
      return select$1g();
    }
    function keyBuilder$M(luvio, params) {
      return keyBuilder$15(luvio, {
        content_key: params.urlParams.contentKeyOrId,
        language: params.queryParams.language || '',
        version: params.queryParams.version || ''
      });
    }
    function getResponseCacheKeys$t(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$x(storeKeyMap, luvio, response);
    }
    function ingestSuccess$t(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$M(luvio, resourceParams);
      luvio.storeIngest(key, ingest$x, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$S(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$j(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$M(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$x,
        namespace: keyPrefix,
        version: VERSION$B,
        representationName: RepresentationType$x
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$t(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/' + config.urlParams.contentKeyOrId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function onFetchResponseSuccess$l(luvio, config, resourceParams, response) {
      var _a;
      // Version can come either from versionNumber field in case of v2 content,
      // or managedContentVersionId field in case of v1 content.
      response.body.version = response.body.versionNumber || response.body.managedContentVersionId;
      // If managedContentId is passed instead of a contentKey, we have to
      // map the contentKey back to contentKeyOrId from the request urlParams
      // so that the snapshot matches correctly, as mentioned in luvio.raml
      // for ManagedContentDocumentRepresentation (content_key: contentKey).
      // With this we can pass managedContentId or contentKey and the wireadapter
      // would behave correctly irrespective of which field is passed.
      resourceParams.urlParams.contentKeyOrId = response.body.contentKey;
      // If language is not provided in the request resource params use language
      // returned in the response and update resource params with that language,
      // since this resource params are used to build a cache key to verify that
      // data was ingested into cache.
      // Always use language returned in the response.
      // We use the language in the Luvio cache key. To make Luvio happy the
      // requested language in the query params and the language returned in the
      // language field in the response must match.
      // Is not always the case with our API since we are doing a language
      // fallback on the server side if language is not provided or there is no
      // content in the requested language.
      // We don't throw 404 and instead return content in the fallback language
      // which results in the language field in the reponse to have different
      // value compared to the requested language in the query params which makes
      // Luvio unhappily throw an error.
      // There are multiple possible cases:
      // 1. Language query parameter is provided, we have the content in that
      //    language and return it. In that case language in the response will be
      //    the same as in the language query parameter which makes below code a
      //    noop, laguages in the response and query parameter match, Luvio is
      //    happy.
      // 2. Langauge query parameter is not provided, undefined, null, or empty
      //    string. In that case we return content in the defaul language and
      //    should set language in the query parameters to the language in the
      //    response to make Luvio happy.
      // 3. Language query parameter is provided, but we don't have content in
      //    that language. In that case we fallback to the languge configured as
      //    fallback language for the requested language and return content in the
      //    fallback language and should set language in the query parameters to
      //    the language in the response to make Luvio happy.
      resourceParams.queryParams.language = response.body.language;
      // If version is not provided in the request resource params use version
      // returned in the response and update resource params with that version,
      // since this resource params are used to build a cache key to verify that
      // data was ingested into cache.
      (_a = resourceParams.queryParams).version || (_a.version = response.body.version);
      return onFetchResponseSuccess$k(luvio, config, resourceParams, response);
    }
    const adapterName$t = 'getManagedContent';
    const getManagedContent_ConfigPropertyMetadata = [generateParamConfigMetadata('contentKeyOrId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('language', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('version', false, 1 /* QueryParameter */, 0 /* String */)];
    const getManagedContent_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$t, getManagedContent_ConfigPropertyMetadata);
    const createResourceParams$t = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContent_ConfigPropertyMetadata);
    function keyBuilder$L(luvio, config) {
      const resourceParams = createResourceParams$t(config);
      return keyBuilder$M(luvio, resourceParams);
    }
    function typeCheckConfig$t(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContent_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$t(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$t(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$j(luvio, config) {
      createResourceParams$t(config);
      return select$S();
    }
    function onFetchResponseSuccess$k(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$t(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$t(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$j(luvio, config, resourceParams, response) {
      const snapshot = ingestError$j(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$t(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$t(luvio, config, options) {
      const resourceParams = createResourceParams$t(config);
      const request = createResourceRequest$t(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$l(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$t(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$j(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$j(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$t, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$j(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$L(luvio, config),
        node: adapterFragment$j(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$t(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentAdapterFactory = luvio => function CMSAuthoring__getManagedContent(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$t(untrustedConfig, getManagedContent_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$j, buildNetworkSnapshotCachePolicy$j);
    };
    function validate$G(obj, path = 'ManagedContentLanguageSummaryRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_displayLabel = obj.displayLabel;
        const path_displayLabel = path + '.displayLabel';
        if (typeof obj_displayLabel !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_displayLabel + '" (at "' + path_displayLabel + '")');
        }
        const obj_locale = obj.locale;
        const path_locale = path + '.locale';
        if (typeof obj_locale !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_locale + '" (at "' + path_locale + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$F(obj, path = 'ManagedContentSpaceFolderItemRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.contentKey !== undefined) {
          const obj_contentKey = obj.contentKey;
          const path_contentKey = path + '.contentKey';
          if (typeof obj_contentKey !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_contentKey + '" (at "' + path_contentKey + '")');
          }
        }
        if (obj.contentType !== undefined) {
          const obj_contentType = obj.contentType;
          const path_contentType = path + '.contentType';
          const referencepath_contentTypeValidationError = validate$17(obj_contentType, path_contentType);
          if (referencepath_contentTypeValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentTypeSummaryRepresentation (at "' + path_contentType + '")\n';
            message += referencepath_contentTypeValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        if (typeof obj_createdBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdBy + '" (at "' + path_createdBy + '")');
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        if (obj.folderType !== undefined) {
          const obj_folderType = obj.folderType;
          const path_folderType = path + '.folderType';
          if (typeof obj_folderType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_folderType + '" (at "' + path_folderType + '")');
          }
        }
        if (obj.hasChildFolders !== undefined) {
          const obj_hasChildFolders = obj.hasChildFolders;
          const path_hasChildFolders = path + '.hasChildFolders';
          if (typeof obj_hasChildFolders !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_hasChildFolders + '" (at "' + path_hasChildFolders + '")');
          }
        }
        const obj_isFolder = obj.isFolder;
        const path_isFolder = path + '.isFolder';
        if (typeof obj_isFolder !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isFolder + '" (at "' + path_isFolder + '")');
        }
        if (obj.isPublished !== undefined) {
          const obj_isPublished = obj.isPublished;
          const path_isPublished = path + '.isPublished';
          if (typeof obj_isPublished !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_isPublished + '" (at "' + path_isPublished + '")');
          }
        }
        if (obj.isShared !== undefined) {
          const obj_isShared = obj.isShared;
          const path_isShared = path + '.isShared';
          if (typeof obj_isShared !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_isShared + '" (at "' + path_isShared + '")');
          }
        }
        if (obj.language !== undefined) {
          const obj_language = obj.language;
          const path_language = path + '.language';
          const referencepath_languageValidationError = validate$G(obj_language, path_language);
          if (referencepath_languageValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentLanguageSummaryRepresentation (at "' + path_language + '")\n';
            message += referencepath_languageValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        if (typeof obj_lastModifiedBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedBy + '" (at "' + path_lastModifiedBy + '")');
        }
        const obj_lastModifiedByName = obj.lastModifiedByName;
        const path_lastModifiedByName = path + '.lastModifiedByName';
        if (typeof obj_lastModifiedByName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedByName + '" (at "' + path_lastModifiedByName + '")');
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
        const obj_managedContentOrFolderId = obj.managedContentOrFolderId;
        const path_managedContentOrFolderId = path + '.managedContentOrFolderId';
        if (typeof obj_managedContentOrFolderId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentOrFolderId + '" (at "' + path_managedContentOrFolderId + '")');
        }
        if (obj.managedContentVariantId !== undefined) {
          const obj_managedContentVariantId = obj.managedContentVariantId;
          const path_managedContentVariantId = path + '.managedContentVariantId';
          if (typeof obj_managedContentVariantId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_managedContentVariantId + '" (at "' + path_managedContentVariantId + '")');
          }
        }
        const obj_mimeType = obj.mimeType;
        const path_mimeType = path + '.mimeType';
        if (typeof obj_mimeType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_mimeType + '" (at "' + path_mimeType + '")');
        }
        if (obj.status !== undefined) {
          const obj_status = obj.status;
          const path_status = path + '.status';
          if (typeof obj_status !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_status + '" (at "' + path_status + '")');
          }
        }
        const obj_title = obj.title;
        const path_title = path + '.title';
        if (typeof obj_title !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$m = 100;
    const VERSION$o = "e85b8f02eca0f2e88859e6f3a061e56b";
    function validate$E(obj, path = 'ManagedContentSpaceFolderItemCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_folderId = obj.folderId;
        const path_folderId = path + '.folderId';
        if (typeof obj_folderId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_folderId + '" (at "' + path_folderId + '")');
        }
        const obj_folderItems = obj.folderItems;
        const path_folderItems = path + '.folderItems';
        if (!ArrayIsArray(obj_folderItems)) {
          return new TypeError('Expected "array" but received "' + typeof obj_folderItems + '" (at "' + path_folderItems + '")');
        }
        for (let i = 0; i < obj_folderItems.length; i++) {
          const obj_folderItems_item = obj_folderItems[i];
          const path_folderItems_item = path_folderItems + '[' + i + ']';
          const referencepath_folderItems_itemValidationError = validate$F(obj_folderItems_item, path_folderItems_item);
          if (referencepath_folderItems_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentSpaceFolderItemRepresentation (at "' + path_folderItems_item + '")\n';
            message += referencepath_folderItems_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_parentFolderId = obj.parentFolderId;
        const path_parentFolderId = path + '.parentFolderId';
        let obj_parentFolderId_union0 = null;
        const obj_parentFolderId_union0_error = (() => {
          if (typeof obj_parentFolderId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_parentFolderId + '" (at "' + path_parentFolderId + '")');
          }
        })();
        if (obj_parentFolderId_union0_error != null) {
          obj_parentFolderId_union0 = obj_parentFolderId_union0_error.message;
        }
        let obj_parentFolderId_union1 = null;
        const obj_parentFolderId_union1_error = (() => {
          if (obj_parentFolderId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_parentFolderId + '" (at "' + path_parentFolderId + '")');
          }
        })();
        if (obj_parentFolderId_union1_error != null) {
          obj_parentFolderId_union1 = obj_parentFolderId_union1_error.message;
        }
        if (obj_parentFolderId_union0 && obj_parentFolderId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_parentFolderId + '")';
          message += '\n' + obj_parentFolderId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_parentFolderId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$m = 'ManagedContentSpaceFolderItemCollectionRepresentation';
    function normalize$m(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$R = function ManagedContentSpaceFolderItemCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$o,
        private: [],
        opaque: true
      };
    };
    function equals$o(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$m = function ManagedContentSpaceFolderItemCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$E(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$m;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$m, "CMSAuthoring", VERSION$o, RepresentationType$m, equals$o);
      return createLink(key);
    };
    function getTypeCacheKeys$m(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$m,
        mergeable: false
      });
    }
    function select$Q(luvio, params) {
      return select$R();
    }
    function keyBuilder$K(luvio, params) {
      return keyPrefix + '::ManagedContentSpaceFolderItemCollectionRepresentation:(' + 'contentTypeFilter:' + params.queryParams.contentTypeFilter + ',' + 'contentTypes:' + params.queryParams.contentTypes + ',' + 'filter:' + params.queryParams.filter + ',' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'queryTerm:' + params.queryParams.queryTerm + ',' + 'showPublishedOnly:' + params.queryParams.showPublishedOnly + ',' + 'showSharedWithSpaceFolder:' + params.queryParams.showSharedWithSpaceFolder + ',' + 'folderId:' + params.urlParams.folderId + ')';
    }
    function getResponseCacheKeys$s(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$m(storeKeyMap, luvio, response, () => keyBuilder$K(luvio, resourceParams));
    }
    function ingestSuccess$s(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$K(luvio, resourceParams);
      luvio.storeIngest(key, ingest$m, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$Q(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$i(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$K(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$m,
        namespace: keyPrefix,
        version: VERSION$o,
        representationName: RepresentationType$m
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$s(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/folders/' + config.urlParams.folderId + '/items',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$s = 'getManagedContentByFolderId';
    const getManagedContentByFolderId_ConfigPropertyMetadata = [generateParamConfigMetadata('folderId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('contentTypeFilter', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('contentTypes', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('filter', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('page', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('queryTerm', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('showPublishedOnly', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('showSharedWithSpaceFolder', false, 1 /* QueryParameter */, 1 /* Boolean */)];
    const getManagedContentByFolderId_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$s, getManagedContentByFolderId_ConfigPropertyMetadata);
    const createResourceParams$s = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentByFolderId_ConfigPropertyMetadata);
    function keyBuilder$J(luvio, config) {
      const resourceParams = createResourceParams$s(config);
      return keyBuilder$K(luvio, resourceParams);
    }
    function typeCheckConfig$s(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentByFolderId_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$s(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$s(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$i(luvio, config) {
      createResourceParams$s(config);
      return select$Q();
    }
    function onFetchResponseSuccess$j(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$s(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$s(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$i(luvio, config, resourceParams, response) {
      const snapshot = ingestError$i(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$s(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$s(luvio, config, options) {
      const resourceParams = createResourceParams$s(config);
      const request = createResourceRequest$s(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$j(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$s(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$i(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$i(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$s, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$i(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$J(luvio, config),
        node: adapterFragment$i(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$s(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentByFolderIdAdapterFactory = luvio => function CMSAuthoring__getManagedContentByFolderId(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$s(untrustedConfig, getManagedContentByFolderId_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$i, buildNetworkSnapshotCachePolicy$i);
    };
    function select$P(luvio, params) {
      return select$1g();
    }
    function keyBuilder$I(luvio, params) {
      return keyBuilder$15(luvio, {
        content_key: params.urlParams.contentKeyOrId,
        language: params.queryParams.language || '',
        version: params.queryParams.version || ''
      });
    }
    function getResponseCacheKeys$r(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$x(storeKeyMap, luvio, response);
    }
    function ingestSuccess$r(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$I(luvio, resourceParams);
      luvio.storeIngest(key, ingest$x, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$P(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$h(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$I(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$x,
        namespace: keyPrefix,
        version: VERSION$B,
        representationName: RepresentationType$x
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$r(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/sites/' + config.urlParams.siteId + '/cms/contents/' + config.urlParams.contentKeyOrId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function onFetchResponseSuccess$i(luvio, config, resourceParams, response) {
      var _a;
      // Version can come either from versionNumber field in case of v2 content,
      // or managedContentVersionId field in case of v1 content.
      response.body.version = response.body.versionNumber || response.body.managedContentVersionId;
      // If managedContentId is passed instead of a contentKey, we have to
      // map the contentKey back to contentKeyOrId from the request urlParams
      // so that the snapshot matches correctly, as mentioned in luvio.raml
      // for ManagedContentDocumentRepresentation (content_key: contentKey).
      // With this we can pass managedContentId or contentKey and the wireadapter
      // would behave correctly irrespective of which field is passed.
      resourceParams.urlParams.contentKeyOrId = response.body.contentKey;
      // If language is not provided in the request resource params use language
      // returned in the response and update resource params with that language,
      // since this resource params are used to build a cache key to verify that
      // data was ingested into cache.
      // Always use language returned in the response.
      // We use the language in the Luvio cache key. To make Luvio happy the
      // requested language in the query params and the language returned in the
      // language field in the response must match.
      // Is not always the case with our API since we are doing a language
      // fallback on the server side if language is not provided or there is no
      // content in the requested language.
      // We don't throw 404 and instead return content in the fallback language
      // which results in the language field in the reponse to have different
      // value compared to the requested language in the query params which makes
      // Luvio unhappily throw an error.
      // There are multiple possible cases:
      // 1. Language query parameter is provided, we have the content in that
      //    language and return it. In that case language in the response will be
      //    the same as in the language query parameter which makes below code a
      //    noop, laguages in the response and query parameter match, Luvio is
      //    happy.
      // 2. Langauge query parameter is not provided, undefined, null, or empty
      //    string. In that case we return content in the defaul language and
      //    should set language in the query parameters to the language in the
      //    response to make Luvio happy.
      // 3. Language query parameter is provided, but we don't have content in
      //    that language. In that case we fallback to the languge configured as
      //    fallback language for the requested language and return content in the
      //    fallback language and should set language in the query parameters to
      //    the language in the response to make Luvio happy.
      resourceParams.queryParams.language = response.body.language;
      // If version is not provided in the request resource params use version
      // returned in the response and update resource params with that version,
      // since this resource params are used to build a cache key to verify that
      // data was ingested into cache.
      (_a = resourceParams.queryParams).version || (_a.version = response.body.version);
      return onFetchResponseSuccess$h(luvio, config, resourceParams, response);
    }
    const adapterName$r = 'getManagedContentForSite';
    const getManagedContentForSite_ConfigPropertyMetadata = [generateParamConfigMetadata('contentKeyOrId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('siteId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('language', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('version', false, 1 /* QueryParameter */, 0 /* String */)];
    const getManagedContentForSite_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$r, getManagedContentForSite_ConfigPropertyMetadata);
    const createResourceParams$r = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentForSite_ConfigPropertyMetadata);
    function keyBuilder$H(luvio, config) {
      const resourceParams = createResourceParams$r(config);
      return keyBuilder$I(luvio, resourceParams);
    }
    function typeCheckConfig$r(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentForSite_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$r(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$r(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$h(luvio, config) {
      createResourceParams$r(config);
      return select$P();
    }
    function onFetchResponseSuccess$h(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$r(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$r(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$h(luvio, config, resourceParams, response) {
      const snapshot = ingestError$h(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$r(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$r(luvio, config, options) {
      const resourceParams = createResourceParams$r(config);
      const request = createResourceRequest$r(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$i(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$r(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$h(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$h(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$r, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$h(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$H(luvio, config),
        node: adapterFragment$h(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$r(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentForSiteAdapterFactory = luvio => function CMSAuthoring__getManagedContentForSite(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$r(untrustedConfig, getManagedContentForSite_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$h, buildNetworkSnapshotCachePolicy$h);
    };
    const VERSION$n = "2776cb6ca1e69cee658bef8b7dfa629f";
    function validate$D(obj, path = 'ManagedContentPreviewRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_channelName = obj.channelName;
        const path_channelName = path + '.channelName';
        let obj_channelName_union0 = null;
        const obj_channelName_union0_error = (() => {
          if (typeof obj_channelName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_channelName + '" (at "' + path_channelName + '")');
          }
        })();
        if (obj_channelName_union0_error != null) {
          obj_channelName_union0 = obj_channelName_union0_error.message;
        }
        let obj_channelName_union1 = null;
        const obj_channelName_union1_error = (() => {
          if (obj_channelName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_channelName + '" (at "' + path_channelName + '")');
          }
        })();
        if (obj_channelName_union1_error != null) {
          obj_channelName_union1 = obj_channelName_union1_error.message;
        }
        if (obj_channelName_union0 && obj_channelName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_channelName + '")';
          message += '\n' + obj_channelName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_channelName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_guestPreviewEndpoint = obj.guestPreviewEndpoint;
        const path_guestPreviewEndpoint = path + '.guestPreviewEndpoint';
        let obj_guestPreviewEndpoint_union0 = null;
        const obj_guestPreviewEndpoint_union0_error = (() => {
          if (typeof obj_guestPreviewEndpoint !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_guestPreviewEndpoint + '" (at "' + path_guestPreviewEndpoint + '")');
          }
        })();
        if (obj_guestPreviewEndpoint_union0_error != null) {
          obj_guestPreviewEndpoint_union0 = obj_guestPreviewEndpoint_union0_error.message;
        }
        let obj_guestPreviewEndpoint_union1 = null;
        const obj_guestPreviewEndpoint_union1_error = (() => {
          if (obj_guestPreviewEndpoint !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_guestPreviewEndpoint + '" (at "' + path_guestPreviewEndpoint + '")');
          }
        })();
        if (obj_guestPreviewEndpoint_union1_error != null) {
          obj_guestPreviewEndpoint_union1 = obj_guestPreviewEndpoint_union1_error.message;
        }
        if (obj_guestPreviewEndpoint_union0 && obj_guestPreviewEndpoint_union1) {
          let message = 'Object doesn\'t match union (at "' + path_guestPreviewEndpoint + '")';
          message += '\n' + obj_guestPreviewEndpoint_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_guestPreviewEndpoint_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_previewEndpoint = obj.previewEndpoint;
        const path_previewEndpoint = path + '.previewEndpoint';
        let obj_previewEndpoint_union0 = null;
        const obj_previewEndpoint_union0_error = (() => {
          if (typeof obj_previewEndpoint !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_previewEndpoint + '" (at "' + path_previewEndpoint + '")');
          }
        })();
        if (obj_previewEndpoint_union0_error != null) {
          obj_previewEndpoint_union0 = obj_previewEndpoint_union0_error.message;
        }
        let obj_previewEndpoint_union1 = null;
        const obj_previewEndpoint_union1_error = (() => {
          if (obj_previewEndpoint !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_previewEndpoint + '" (at "' + path_previewEndpoint + '")');
          }
        })();
        if (obj_previewEndpoint_union1_error != null) {
          obj_previewEndpoint_union1 = obj_previewEndpoint_union1_error.message;
        }
        if (obj_previewEndpoint_union0 && obj_previewEndpoint_union1) {
          let message = 'Object doesn\'t match union (at "' + path_previewEndpoint + '")';
          message += '\n' + obj_previewEndpoint_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_previewEndpoint_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$O = function ManagedContentPreviewRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$n,
        private: [],
        selections: [{
          name: 'channelName',
          kind: 'Scalar'
        }, {
          name: 'guestPreviewEndpoint',
          kind: 'Scalar'
        }, {
          name: 'previewEndpoint',
          kind: 'Scalar'
        }]
      };
    };
    function equals$n(existing, incoming) {
      const existing_channelName = existing.channelName;
      const incoming_channelName = incoming.channelName;
      if (!(existing_channelName === incoming_channelName)) {
        return false;
      }
      const existing_guestPreviewEndpoint = existing.guestPreviewEndpoint;
      const incoming_guestPreviewEndpoint = incoming.guestPreviewEndpoint;
      if (!(existing_guestPreviewEndpoint === incoming_guestPreviewEndpoint)) {
        return false;
      }
      const existing_previewEndpoint = existing.previewEndpoint;
      const incoming_previewEndpoint = incoming.previewEndpoint;
      if (!(existing_previewEndpoint === incoming_previewEndpoint)) {
        return false;
      }
      return true;
    }
    const TTL$l = 1000;
    const VERSION$m = "2ea0d489f57171bd8c65e01f79843327";
    function validate$C(obj, path = 'ManagedContentPreviewCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_previews = obj.previews;
        const path_previews = path + '.previews';
        if (!ArrayIsArray(obj_previews)) {
          return new TypeError('Expected "array" but received "' + typeof obj_previews + '" (at "' + path_previews + '")');
        }
        for (let i = 0; i < obj_previews.length; i++) {
          const obj_previews_item = obj_previews[i];
          const path_previews_item = path_previews + '[' + i + ']';
          const referencepath_previews_itemValidationError = validate$D(obj_previews_item, path_previews_item);
          if (referencepath_previews_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentPreviewRepresentation (at "' + path_previews_item + '")\n';
            message += referencepath_previews_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$l = 'ManagedContentPreviewCollectionRepresentation';
    function normalize$l(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$N = function ManagedContentPreviewCollectionRepresentationSelect() {
      const {
        selections: ManagedContentPreviewRepresentation__selections,
        opaque: ManagedContentPreviewRepresentation__opaque
      } = select$O();
      return {
        kind: 'Fragment',
        version: VERSION$m,
        private: [],
        selections: [{
          name: 'previews',
          kind: 'Object',
          plural: true,
          selections: ManagedContentPreviewRepresentation__selections
        }]
      };
    };
    function equals$m(existing, incoming) {
      const existing_previews = existing.previews;
      const incoming_previews = incoming.previews;
      const equals_previews_items = equalsArray(existing_previews, incoming_previews, (existing_previews_item, incoming_previews_item) => {
        if (!equals$n(existing_previews_item, incoming_previews_item)) {
          return false;
        }
      });
      if (equals_previews_items === false) {
        return false;
      }
      return true;
    }
    const ingest$l = function ManagedContentPreviewCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$C(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$l;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$l, "CMSAuthoring", VERSION$m, RepresentationType$l, equals$m);
      return createLink(key);
    };
    function getTypeCacheKeys$l(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$l,
        mergeable: false
      });
    }
    function select$M(luvio, params) {
      return select$N();
    }
    function keyBuilder$G(luvio, params) {
      return keyPrefix + '::ManagedContentPreviewCollectionRepresentation:(' + 'isPreviewable:' + params.queryParams.isPreviewable + ',' + 'managedContentTypeName:' + params.queryParams.managedContentTypeName + ',' + 'contentSpaceId:' + params.urlParams.contentSpaceId + ')';
    }
    function getResponseCacheKeys$q(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$l(storeKeyMap, luvio, response, () => keyBuilder$G(luvio, resourceParams));
    }
    function ingestSuccess$q(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$G(luvio, resourceParams);
      luvio.storeIngest(key, ingest$l, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$M(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$g(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$G(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$l,
        namespace: keyPrefix,
        version: VERSION$m,
        representationName: RepresentationType$l
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$q(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/spaces/' + config.urlParams.contentSpaceId + '/preview-endpoints',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$q = 'getManagedContentPreviews';
    const getManagedContentPreviews_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('isPreviewable', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('managedContentTypeName', false, 1 /* QueryParameter */, 0 /* String */)];
    const getManagedContentPreviews_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$q, getManagedContentPreviews_ConfigPropertyMetadata);
    const createResourceParams$q = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentPreviews_ConfigPropertyMetadata);
    function keyBuilder$F(luvio, config) {
      const resourceParams = createResourceParams$q(config);
      return keyBuilder$G(luvio, resourceParams);
    }
    function typeCheckConfig$q(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentPreviews_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$q(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$q(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$g(luvio, config) {
      createResourceParams$q(config);
      return select$M();
    }
    function onFetchResponseSuccess$g(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$q(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$q(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$g(luvio, config, resourceParams, response) {
      const snapshot = ingestError$g(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$q(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$q(luvio, config, options) {
      const resourceParams = createResourceParams$q(config);
      const request = createResourceRequest$q(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$g(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$q(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$g(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$g(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$q, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$g(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$F(luvio, config),
        node: adapterFragment$g(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$q(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentPreviewsAdapterFactory = luvio => function CMSAuthoring__getManagedContentPreviews(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$q(untrustedConfig, getManagedContentPreviews_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$g, buildNetworkSnapshotCachePolicy$g);
    };
    const VERSION$l = "1a16e1314a2482d9aa8e0da45957846e";
    function validate$B(obj, path = 'ManagedContentProviderRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_componentDefinition = obj.componentDefinition;
        const path_componentDefinition = path + '.componentDefinition';
        if (typeof obj_componentDefinition !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_componentDefinition + '" (at "' + path_componentDefinition + '")');
        }
        const obj_icon = obj.icon;
        const path_icon = path + '.icon';
        if (typeof obj_icon !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_icon + '" (at "' + path_icon + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const select$L = function ManagedContentProviderRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$l,
        private: [],
        selections: [{
          name: 'componentDefinition',
          kind: 'Scalar'
        }, {
          name: 'icon',
          kind: 'Scalar'
        }, {
          name: 'name',
          kind: 'Scalar'
        }, {
          name: 'type',
          kind: 'Scalar'
        }]
      };
    };
    function equals$l(existing, incoming) {
      const existing_componentDefinition = existing.componentDefinition;
      const incoming_componentDefinition = incoming.componentDefinition;
      if (!(existing_componentDefinition === incoming_componentDefinition)) {
        return false;
      }
      const existing_icon = existing.icon;
      const incoming_icon = incoming.icon;
      if (!(existing_icon === incoming_icon)) {
        return false;
      }
      const existing_name = existing.name;
      const incoming_name = incoming.name;
      if (!(existing_name === incoming_name)) {
        return false;
      }
      const existing_type = existing.type;
      const incoming_type = incoming.type;
      if (!(existing_type === incoming_type)) {
        return false;
      }
      return true;
    }
    const TTL$k = 120000;
    const VERSION$k = "2b181cae4ba3acd340f11988d5b92475";
    function validate$A(obj, path = 'ManagedContentProviderCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
          if (typeof obj_nextPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union0_error != null) {
          obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
          if (obj_nextPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union1_error != null) {
          obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
          message += '\n' + obj_nextPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_providers = obj.providers;
        const path_providers = path + '.providers';
        if (!ArrayIsArray(obj_providers)) {
          return new TypeError('Expected "array" but received "' + typeof obj_providers + '" (at "' + path_providers + '")');
        }
        for (let i = 0; i < obj_providers.length; i++) {
          const obj_providers_item = obj_providers[i];
          const path_providers_item = path_providers + '[' + i + ']';
          const referencepath_providers_itemValidationError = validate$B(obj_providers_item, path_providers_item);
          if (referencepath_providers_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentProviderRepresentation (at "' + path_providers_item + '")\n';
            message += referencepath_providers_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_total = obj.total;
        const path_total = path + '.total';
        if (typeof obj_total !== 'number' || typeof obj_total === 'number' && Math.floor(obj_total) !== obj_total) {
          return new TypeError('Expected "integer" but received "' + typeof obj_total + '" (at "' + path_total + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$k = 'ManagedContentProviderCollectionRepresentation';
    function normalize$k(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$K = function ManagedContentProviderCollectionRepresentationSelect() {
      const {
        selections: ManagedContentProviderRepresentation__selections,
        opaque: ManagedContentProviderRepresentation__opaque
      } = select$L();
      return {
        kind: 'Fragment',
        version: VERSION$k,
        private: [],
        selections: [{
          name: 'currentPageUrl',
          kind: 'Scalar'
        }, {
          name: 'nextPageUrl',
          kind: 'Scalar'
        }, {
          name: 'providers',
          kind: 'Object',
          plural: true,
          selections: ManagedContentProviderRepresentation__selections
        }, {
          name: 'total',
          kind: 'Scalar'
        }]
      };
    };
    function equals$k(existing, incoming) {
      const existing_total = existing.total;
      const incoming_total = incoming.total;
      if (!(existing_total === incoming_total)) {
        return false;
      }
      const existing_currentPageUrl = existing.currentPageUrl;
      const incoming_currentPageUrl = incoming.currentPageUrl;
      if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
      }
      const existing_nextPageUrl = existing.nextPageUrl;
      const incoming_nextPageUrl = incoming.nextPageUrl;
      if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
      }
      const existing_providers = existing.providers;
      const incoming_providers = incoming.providers;
      const equals_providers_items = equalsArray(existing_providers, incoming_providers, (existing_providers_item, incoming_providers_item) => {
        if (!equals$l(existing_providers_item, incoming_providers_item)) {
          return false;
        }
      });
      if (equals_providers_items === false) {
        return false;
      }
      return true;
    }
    const ingest$k = function ManagedContentProviderCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$A(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$k;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$k, "CMSAuthoring", VERSION$k, RepresentationType$k, equals$k);
      return createLink(key);
    };
    function getTypeCacheKeys$k(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$k,
        mergeable: false
      });
    }
    function select$J(luvio, params) {
      return select$K();
    }
    function keyBuilder$E(luvio, params) {
      return keyPrefix + '::ManagedContentProviderCollectionRepresentation:(' + ')';
    }
    function getResponseCacheKeys$p(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$k(storeKeyMap, luvio, response, () => keyBuilder$E());
    }
    function ingestSuccess$p(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$E();
      luvio.storeIngest(key, ingest$k, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$J(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$f(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$E();
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$k,
        namespace: keyPrefix,
        version: VERSION$k,
        representationName: RepresentationType$k
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$p(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/content/providers',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$p = 'getManagedContentProviders';
    const getManagedContentProviders_ConfigPropertyMetadata = [];
    const getManagedContentProviders_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$p, getManagedContentProviders_ConfigPropertyMetadata);
    const createResourceParams$p = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentProviders_ConfigPropertyMetadata);
    function keyBuilder$D(luvio, config) {
      createResourceParams$p(config);
      return keyBuilder$E();
    }
    function typeCheckConfig$p(untrustedConfig) {
      const config = {};
      return config;
    }
    function validateAdapterConfig$p(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$p();
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$f(luvio, config) {
      createResourceParams$p(config);
      return select$J();
    }
    function onFetchResponseSuccess$f(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$p(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$p(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$f(luvio, config, resourceParams, response) {
      const snapshot = ingestError$f(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$p(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$p(luvio, config, options) {
      const resourceParams = createResourceParams$p(config);
      const request = createResourceRequest$p();
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$f(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$p(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$f(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$f(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$p, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$f(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$D(luvio, config),
        node: adapterFragment$f(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$p(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentProvidersAdapterFactory = luvio => function CMSAuthoring__getManagedContentProviders(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$p(untrustedConfig, getManagedContentProviders_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$f, buildNetworkSnapshotCachePolicy$f);
    };
    function validate$z(obj, path = 'AbstractManagedContentReferencedByItemRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.contentType !== undefined) {
          const obj_contentType = obj.contentType;
          const path_contentType = path + '.contentType';
          let obj_contentType_union0 = null;
          const obj_contentType_union0_error = (() => {
            const referencepath_contentTypeValidationError = validate$17(obj_contentType, path_contentType);
            if (referencepath_contentTypeValidationError !== null) {
              let message = 'Object doesn\'t match ManagedContentTypeSummaryRepresentation (at "' + path_contentType + '")\n';
              message += referencepath_contentTypeValidationError.message.split('\n').map(line => '\t' + line).join('\n');
              return new TypeError(message);
            }
          })();
          if (obj_contentType_union0_error != null) {
            obj_contentType_union0 = obj_contentType_union0_error.message;
          }
          let obj_contentType_union1 = null;
          const obj_contentType_union1_error = (() => {
            if (obj_contentType !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_contentType + '" (at "' + path_contentType + '")');
            }
          })();
          if (obj_contentType_union1_error != null) {
            obj_contentType_union1 = obj_contentType_union1_error.message;
          }
          if (obj_contentType_union0 && obj_contentType_union1) {
            let message = 'Object doesn\'t match union (at "' + path_contentType + '")';
            message += '\n' + obj_contentType_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_contentType_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        if (obj.networkId !== undefined) {
          const obj_networkId = obj.networkId;
          const path_networkId = path + '.networkId';
          if (typeof obj_networkId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_networkId + '" (at "' + path_networkId + '")');
          }
        }
        const obj_referenceTypes = obj.referenceTypes;
        const path_referenceTypes = path + '.referenceTypes';
        if (!ArrayIsArray(obj_referenceTypes)) {
          return new TypeError('Expected "array" but received "' + typeof obj_referenceTypes + '" (at "' + path_referenceTypes + '")');
        }
        for (let i = 0; i < obj_referenceTypes.length; i++) {
          const obj_referenceTypes_item = obj_referenceTypes[i];
          const path_referenceTypes_item = path_referenceTypes + '[' + i + ']';
          if (typeof obj_referenceTypes_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_referenceTypes_item + '" (at "' + path_referenceTypes_item + '")');
          }
        }
        if (obj.siteId !== undefined) {
          const obj_siteId = obj.siteId;
          const path_siteId = path + '.siteId';
          if (typeof obj_siteId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_siteId + '" (at "' + path_siteId + '")');
          }
        }
        if (obj.siteName !== undefined) {
          const obj_siteName = obj.siteName;
          const path_siteName = path + '.siteName';
          if (typeof obj_siteName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_siteName + '" (at "' + path_siteName + '")');
          }
        }
        if (obj.title !== undefined) {
          const obj_title = obj.title;
          const path_title = path + '.title';
          let obj_title_union0 = null;
          const obj_title_union0_error = (() => {
            if (typeof obj_title !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
            }
          })();
          if (obj_title_union0_error != null) {
            obj_title_union0 = obj_title_union0_error.message;
          }
          let obj_title_union1 = null;
          const obj_title_union1_error = (() => {
            if (obj_title !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_title + '" (at "' + path_title + '")');
            }
          })();
          if (obj_title_union1_error != null) {
            obj_title_union1 = obj_title_union1_error.message;
          }
          if (obj_title_union0 && obj_title_union1) {
            let message = 'Object doesn\'t match union (at "' + path_title + '")';
            message += '\n' + obj_title_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_title_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$j = 100;
    const VERSION$j = "c297f5edbe1b51eadd89e68f176520ba";
    function validate$y(obj, path = 'ManagedContentReferencedByCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
          if (typeof obj_nextPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union0_error != null) {
          obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
          if (obj_nextPageUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        })();
        if (obj_nextPageUrl_union1_error != null) {
          obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
          message += '\n' + obj_nextPageUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_nextPageUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_referencedBy = obj.referencedBy;
        const path_referencedBy = path + '.referencedBy';
        if (!ArrayIsArray(obj_referencedBy)) {
          return new TypeError('Expected "array" but received "' + typeof obj_referencedBy + '" (at "' + path_referencedBy + '")');
        }
        for (let i = 0; i < obj_referencedBy.length; i++) {
          const obj_referencedBy_item = obj_referencedBy[i];
          const path_referencedBy_item = path_referencedBy + '[' + i + ']';
          const referencepath_referencedBy_itemValidationError = validate$z(obj_referencedBy_item, path_referencedBy_item);
          if (referencepath_referencedBy_itemValidationError !== null) {
            let message = 'Object doesn\'t match AbstractManagedContentReferencedByItemRepresentation (at "' + path_referencedBy_item + '")\n';
            message += referencepath_referencedBy_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_total = obj.total;
        const path_total = path + '.total';
        if (typeof obj_total !== 'number' || typeof obj_total === 'number' && Math.floor(obj_total) !== obj_total) {
          return new TypeError('Expected "integer" but received "' + typeof obj_total + '" (at "' + path_total + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$j = 'ManagedContentReferencedByCollectionRepresentation';
    function normalize$j(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$I = function ManagedContentReferencedByCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$j,
        private: [],
        opaque: true
      };
    };
    function equals$j(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$j = function ManagedContentReferencedByCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$y(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$j;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$j, "CMSAuthoring", VERSION$j, RepresentationType$j, equals$j);
      return createLink(key);
    };
    function getTypeCacheKeys$j(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$j,
        mergeable: false
      });
    }
    function select$H(luvio, params) {
      return select$I();
    }
    function keyBuilder$C(luvio, params) {
      return keyPrefix + '::ManagedContentReferencedByCollectionRepresentation:(' + 'includeReferenceDetails:' + params.queryParams.includeReferenceDetails + ',' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'referenceType:' + params.queryParams.referenceType + ',' + 'contentKeyOrId:' + params.urlParams.contentKeyOrId + ')';
    }
    function getResponseCacheKeys$o(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$j(storeKeyMap, luvio, response, () => keyBuilder$C(luvio, resourceParams));
    }
    function ingestSuccess$o(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$C(luvio, resourceParams);
      luvio.storeIngest(key, ingest$j, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$H(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$e(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$C(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$j,
        namespace: keyPrefix,
        version: VERSION$j,
        representationName: RepresentationType$j
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$o(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/' + config.urlParams.contentKeyOrId + '/referenced-by',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$o = 'getManagedContentReferencedBy';
    const getManagedContentReferencedBy_ConfigPropertyMetadata = [generateParamConfigMetadata('contentKeyOrId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('includeReferenceDetails', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('page', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('referenceType', false, 1 /* QueryParameter */, 0 /* String */)];
    const getManagedContentReferencedBy_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$o, getManagedContentReferencedBy_ConfigPropertyMetadata);
    const createResourceParams$o = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentReferencedBy_ConfigPropertyMetadata);
    function keyBuilder$B(luvio, config) {
      const resourceParams = createResourceParams$o(config);
      return keyBuilder$C(luvio, resourceParams);
    }
    function typeCheckConfig$o(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentReferencedBy_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$o(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$o(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$e(luvio, config) {
      createResourceParams$o(config);
      return select$H();
    }
    function onFetchResponseSuccess$e(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$o(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$o(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$e(luvio, config, resourceParams, response) {
      const snapshot = ingestError$e(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$o(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$o(luvio, config, options) {
      const resourceParams = createResourceParams$o(config);
      const request = createResourceRequest$o(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$e(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$o(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$e(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$e(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$o, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$e(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$B(luvio, config),
        node: adapterFragment$e(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$o(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentReferencedByAdapterFactory = luvio => function CMSAuthoring__getManagedContentReferencedBy(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$o(untrustedConfig, getManagedContentReferencedBy_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$e, buildNetworkSnapshotCachePolicy$e);
    };
    const TTL$i = 100;
    const VERSION$i = "3a5747378dc29ae71f5d09b77bed28f9";
    function validate$x(obj, path = 'ManagedContentSingleItemDocumentRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.apiName !== undefined) {
          const obj_apiName = obj.apiName;
          const path_apiName = path + '.apiName';
          let obj_apiName_union0 = null;
          const obj_apiName_union0_error = (() => {
            if (typeof obj_apiName !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
            }
          })();
          if (obj_apiName_union0_error != null) {
            obj_apiName_union0 = obj_apiName_union0_error.message;
          }
          let obj_apiName_union1 = null;
          const obj_apiName_union1_error = (() => {
            if (obj_apiName !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
            }
          })();
          if (obj_apiName_union1_error != null) {
            obj_apiName_union1 = obj_apiName_union1_error.message;
          }
          if (obj_apiName_union0 && obj_apiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_apiName + '")';
            message += '\n' + obj_apiName_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_apiName_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_contentBody = obj.contentBody;
        const path_contentBody = path + '.contentBody';
        if (typeof obj_contentBody !== 'object' || ArrayIsArray(obj_contentBody) || obj_contentBody === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_contentBody + '" (at "' + path_contentBody + '")');
        }
        const obj_contentBody_keys = ObjectKeys(obj_contentBody);
        for (let i = 0; i < obj_contentBody_keys.length; i++) {
          const key = obj_contentBody_keys[i];
          const obj_contentBody_prop = obj_contentBody[key];
          const path_contentBody_prop = path_contentBody + '["' + key + '"]';
          if (obj_contentBody_prop === undefined) {
            return new TypeError('Expected "defined" but received "' + typeof obj_contentBody_prop + '" (at "' + path_contentBody_prop + '")');
          }
        }
        const obj_contentKey = obj.contentKey;
        const path_contentKey = path + '.contentKey';
        if (typeof obj_contentKey !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentKey + '" (at "' + path_contentKey + '")');
        }
        const obj_contentSpace = obj.contentSpace;
        const path_contentSpace = path + '.contentSpace';
        const referencepath_contentSpaceValidationError = validate$11(obj_contentSpace, path_contentSpace);
        if (referencepath_contentSpaceValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentSpaceSummaryRepresentation (at "' + path_contentSpace + '")\n';
          message += referencepath_contentSpaceValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_contentType = obj.contentType;
        const path_contentType = path + '.contentType';
        const referencepath_contentTypeValidationError = validate$17(obj_contentType, path_contentType);
        if (referencepath_contentTypeValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentTypeSummaryRepresentation (at "' + path_contentType + '")\n';
          message += referencepath_contentTypeValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        const referencepath_createdByValidationError = validate$14(obj_createdBy, path_createdBy);
        if (referencepath_createdByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_createdBy + '")\n';
          message += referencepath_createdByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        const obj_folder = obj.folder;
        const path_folder = path + '.folder';
        let obj_folder_union0 = null;
        const obj_folder_union0_error = (() => {
          const referencepath_folderValidationError = validate$1b(obj_folder, path_folder);
          if (referencepath_folderValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentFolderSummaryRepresentation (at "' + path_folder + '")\n';
            message += referencepath_folderValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        })();
        if (obj_folder_union0_error != null) {
          obj_folder_union0 = obj_folder_union0_error.message;
        }
        let obj_folder_union1 = null;
        const obj_folder_union1_error = (() => {
          if (obj_folder !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_folder + '" (at "' + path_folder + '")');
          }
        })();
        if (obj_folder_union1_error != null) {
          obj_folder_union1 = obj_folder_union1_error.message;
        }
        if (obj_folder_union0 && obj_folder_union1) {
          let message = 'Object doesn\'t match union (at "' + path_folder + '")';
          message += '\n' + obj_folder_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_folder_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_isPublished = obj.isPublished;
        const path_isPublished = path + '.isPublished';
        if (typeof obj_isPublished !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isPublished + '" (at "' + path_isPublished + '")');
        }
        const obj_language = obj.language;
        const path_language = path + '.language';
        if (typeof obj_language !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_language + '" (at "' + path_language + '")');
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        const referencepath_lastModifiedByValidationError = validate$14(obj_lastModifiedBy, path_lastModifiedBy);
        if (referencepath_lastModifiedByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_lastModifiedBy + '")\n';
          message += referencepath_lastModifiedByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
        const obj_managedContentId = obj.managedContentId;
        const path_managedContentId = path + '.managedContentId';
        if (typeof obj_managedContentId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentId + '" (at "' + path_managedContentId + '")');
        }
        const obj_managedContentVariantId = obj.managedContentVariantId;
        const path_managedContentVariantId = path + '.managedContentVariantId';
        if (typeof obj_managedContentVariantId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentVariantId + '" (at "' + path_managedContentVariantId + '")');
        }
        const obj_managedContentVersionId = obj.managedContentVersionId;
        const path_managedContentVersionId = path + '.managedContentVersionId';
        if (typeof obj_managedContentVersionId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentVersionId + '" (at "' + path_managedContentVersionId + '")');
        }
        if (obj.status !== undefined) {
          const obj_status = obj.status;
          const path_status = path + '.status';
          let obj_status_union0 = null;
          const obj_status_union0_error = (() => {
            const referencepath_statusValidationError = validate$10(obj_status, path_status);
            if (referencepath_statusValidationError !== null) {
              let message = 'Object doesn\'t match ManagedContentVariantStatusRepresentation (at "' + path_status + '")\n';
              message += referencepath_statusValidationError.message.split('\n').map(line => '\t' + line).join('\n');
              return new TypeError(message);
            }
          })();
          if (obj_status_union0_error != null) {
            obj_status_union0 = obj_status_union0_error.message;
          }
          let obj_status_union1 = null;
          const obj_status_union1_error = (() => {
            if (obj_status !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_status + '" (at "' + path_status + '")');
            }
          })();
          if (obj_status_union1_error != null) {
            obj_status_union1 = obj_status_union1_error.message;
          }
          if (obj_status_union0 && obj_status_union1) {
            let message = 'Object doesn\'t match union (at "' + path_status + '")';
            message += '\n' + obj_status_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_status_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_title = obj.title;
        const path_title = path + '.title';
        if (typeof obj_title !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
        }
        const obj_urlName = obj.urlName;
        const path_urlName = path + '.urlName';
        if (typeof obj_urlName !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_urlName + '" (at "' + path_urlName + '")');
        }
        const obj_versionNumber = obj.versionNumber;
        const path_versionNumber = path + '.versionNumber';
        let obj_versionNumber_union0 = null;
        const obj_versionNumber_union0_error = (() => {
          if (typeof obj_versionNumber !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_versionNumber + '" (at "' + path_versionNumber + '")');
          }
        })();
        if (obj_versionNumber_union0_error != null) {
          obj_versionNumber_union0 = obj_versionNumber_union0_error.message;
        }
        let obj_versionNumber_union1 = null;
        const obj_versionNumber_union1_error = (() => {
          if (obj_versionNumber !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_versionNumber + '" (at "' + path_versionNumber + '")');
          }
        })();
        if (obj_versionNumber_union1_error != null) {
          obj_versionNumber_union1 = obj_versionNumber_union1_error.message;
        }
        if (obj_versionNumber_union0 && obj_versionNumber_union1) {
          let message = 'Object doesn\'t match union (at "' + path_versionNumber + '")';
          message += '\n' + obj_versionNumber_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_versionNumber_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$i = 'ManagedContentSingleItemDocumentRepresentation';
    function normalize$i(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$G = function ManagedContentSingleItemDocumentRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$i,
        private: [],
        opaque: true
      };
    };
    function equals$i(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$i = function ManagedContentSingleItemDocumentRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$x(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$i;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$i, "CMSAuthoring", VERSION$i, RepresentationType$i, equals$i);
      return createLink(key);
    };
    function getTypeCacheKeys$i(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$i,
        mergeable: false
      });
    }
    function select$F(luvio, params) {
      return select$G();
    }
    function keyBuilder$A(luvio, params) {
      return keyPrefix + '::ManagedContentSingleItemDocumentRepresentation:(' + 'contentSpaceId:' + params.urlParams.contentSpaceId + ',' + 'contentTypeFQN:' + params.urlParams.contentTypeFQN + ')';
    }
    function getResponseCacheKeys$n(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$i(storeKeyMap, luvio, response, () => keyBuilder$A(luvio, resourceParams));
    }
    function ingestSuccess$n(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$A(luvio, resourceParams);
      luvio.storeIngest(key, ingest$i, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$F(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$d(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$A(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$i,
        namespace: keyPrefix,
        version: VERSION$i,
        representationName: RepresentationType$i
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$n(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/spaces/' + config.urlParams.contentSpaceId + '/single-item-content/' + config.urlParams.contentTypeFQN + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$n = 'getManagedContentSingleItem';
    const getManagedContentSingleItem_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('contentTypeFQN', true, 0 /* UrlParameter */, 0 /* String */)];
    const getManagedContentSingleItem_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$n, getManagedContentSingleItem_ConfigPropertyMetadata);
    const createResourceParams$n = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentSingleItem_ConfigPropertyMetadata);
    function keyBuilder$z(luvio, config) {
      const resourceParams = createResourceParams$n(config);
      return keyBuilder$A(luvio, resourceParams);
    }
    function typeCheckConfig$n(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentSingleItem_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$n(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$n(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$d(luvio, config) {
      createResourceParams$n(config);
      return select$F();
    }
    function onFetchResponseSuccess$d(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$n(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$n(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$d(luvio, config, resourceParams, response) {
      const snapshot = ingestError$d(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$n(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$n(luvio, config, options) {
      const resourceParams = createResourceParams$n(config);
      const request = createResourceRequest$n(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$d(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$n(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$d(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$d(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$n, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$d(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$z(luvio, config),
        node: adapterFragment$d(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$n(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentSingleItemAdapterFactory = luvio => function CMSAuthoring__getManagedContentSingleItem(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$n(untrustedConfig, getManagedContentSingleItem_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$d, buildNetworkSnapshotCachePolicy$d);
    };
    function validate$w(obj, path = 'ManagedContentSpaceBaseTypeRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        let obj_apiName_union0 = null;
        const obj_apiName_union0_error = (() => {
          if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
          }
        })();
        if (obj_apiName_union0_error != null) {
          obj_apiName_union0 = obj_apiName_union0_error.message;
        }
        let obj_apiName_union1 = null;
        const obj_apiName_union1_error = (() => {
          if (obj_apiName !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
          }
        })();
        if (obj_apiName_union1_error != null) {
          obj_apiName_union1 = obj_apiName_union1_error.message;
        }
        if (obj_apiName_union0 && obj_apiName_union1) {
          let message = 'Object doesn\'t match union (at "' + path_apiName + '")';
          message += '\n' + obj_apiName_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_apiName_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$h = 100;
    const VERSION$h = "1158bab6c830f40913e54e5f647ead28";
    function validate$v(obj, path = 'ManagedContentSpaceRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.baseType !== undefined) {
          const obj_baseType = obj.baseType;
          const path_baseType = path + '.baseType';
          let obj_baseType_union0 = null;
          const obj_baseType_union0_error = (() => {
            const referencepath_baseTypeValidationError = validate$w(obj_baseType, path_baseType);
            if (referencepath_baseTypeValidationError !== null) {
              let message = 'Object doesn\'t match ManagedContentSpaceBaseTypeRepresentation (at "' + path_baseType + '")\n';
              message += referencepath_baseTypeValidationError.message.split('\n').map(line => '\t' + line).join('\n');
              return new TypeError(message);
            }
          })();
          if (obj_baseType_union0_error != null) {
            obj_baseType_union0 = obj_baseType_union0_error.message;
          }
          let obj_baseType_union1 = null;
          const obj_baseType_union1_error = (() => {
            if (obj_baseType !== null) {
              return new TypeError('Expected "null" but received "' + typeof obj_baseType + '" (at "' + path_baseType + '")');
            }
          })();
          if (obj_baseType_union1_error != null) {
            obj_baseType_union1 = obj_baseType_union1_error.message;
          }
          if (obj_baseType_union0 && obj_baseType_union1) {
            let message = 'Object doesn\'t match union (at "' + path_baseType + '")';
            message += '\n' + obj_baseType_union0.split('\n').map(line => '\t' + line).join('\n');
            message += '\n' + obj_baseType_union1.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        if (typeof obj_createdBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdBy + '" (at "' + path_createdBy + '")');
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        const obj_defaultLanguage = obj.defaultLanguage;
        const path_defaultLanguage = path + '.defaultLanguage';
        if (typeof obj_defaultLanguage !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_defaultLanguage + '" (at "' + path_defaultLanguage + '")');
        }
        const obj_description = obj.description;
        const path_description = path + '.description';
        let obj_description_union0 = null;
        const obj_description_union0_error = (() => {
          if (typeof obj_description !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_description + '" (at "' + path_description + '")');
          }
        })();
        if (obj_description_union0_error != null) {
          obj_description_union0 = obj_description_union0_error.message;
        }
        let obj_description_union1 = null;
        const obj_description_union1_error = (() => {
          if (obj_description !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_description + '" (at "' + path_description + '")');
          }
        })();
        if (obj_description_union1_error != null) {
          obj_description_union1 = obj_description_union1_error.message;
        }
        if (obj_description_union0 && obj_description_union1) {
          let message = 'Object doesn\'t match union (at "' + path_description + '")';
          message += '\n' + obj_description_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_description_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_isFlowOrchestrationEnabled = obj.isFlowOrchestrationEnabled;
        const path_isFlowOrchestrationEnabled = path + '.isFlowOrchestrationEnabled';
        let obj_isFlowOrchestrationEnabled_union0 = null;
        const obj_isFlowOrchestrationEnabled_union0_error = (() => {
          if (typeof obj_isFlowOrchestrationEnabled !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_isFlowOrchestrationEnabled + '" (at "' + path_isFlowOrchestrationEnabled + '")');
          }
        })();
        if (obj_isFlowOrchestrationEnabled_union0_error != null) {
          obj_isFlowOrchestrationEnabled_union0 = obj_isFlowOrchestrationEnabled_union0_error.message;
        }
        let obj_isFlowOrchestrationEnabled_union1 = null;
        const obj_isFlowOrchestrationEnabled_union1_error = (() => {
          if (obj_isFlowOrchestrationEnabled !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_isFlowOrchestrationEnabled + '" (at "' + path_isFlowOrchestrationEnabled + '")');
          }
        })();
        if (obj_isFlowOrchestrationEnabled_union1_error != null) {
          obj_isFlowOrchestrationEnabled_union1 = obj_isFlowOrchestrationEnabled_union1_error.message;
        }
        if (obj_isFlowOrchestrationEnabled_union0 && obj_isFlowOrchestrationEnabled_union1) {
          let message = 'Object doesn\'t match union (at "' + path_isFlowOrchestrationEnabled + '")';
          message += '\n' + obj_isFlowOrchestrationEnabled_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_isFlowOrchestrationEnabled_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        if (obj.isSpaceV2 !== undefined) {
          const obj_isSpaceV2 = obj.isSpaceV2;
          const path_isSpaceV2 = path + '.isSpaceV2';
          if (typeof obj_isSpaceV2 !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_isSpaceV2 + '" (at "' + path_isSpaceV2 + '")');
          }
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        if (typeof obj_lastModifiedBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedBy + '" (at "' + path_lastModifiedBy + '")');
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_rootFolderId = obj.rootFolderId;
        const path_rootFolderId = path + '.rootFolderId';
        if (typeof obj_rootFolderId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_rootFolderId + '" (at "' + path_rootFolderId + '")');
        }
        if (obj.supportedLanguages !== undefined) {
          const obj_supportedLanguages = obj.supportedLanguages;
          const path_supportedLanguages = path + '.supportedLanguages';
          if (!ArrayIsArray(obj_supportedLanguages)) {
            return new TypeError('Expected "array" but received "' + typeof obj_supportedLanguages + '" (at "' + path_supportedLanguages + '")');
          }
          for (let i = 0; i < obj_supportedLanguages.length; i++) {
            const obj_supportedLanguages_item = obj_supportedLanguages[i];
            const path_supportedLanguages_item = path_supportedLanguages + '[' + i + ']';
            if (typeof obj_supportedLanguages_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_supportedLanguages_item + '" (at "' + path_supportedLanguages_item + '")');
            }
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$h = 'ManagedContentSpaceRepresentation';
    function keyBuilder$y(luvio, config) {
      return keyPrefix + '::' + RepresentationType$h + ':' + config.id;
    }
    function keyBuilderFromType$8(luvio, object) {
      const keyParams = {
        id: object.id
      };
      return keyBuilder$y(luvio, keyParams);
    }
    function normalize$h(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$E = function ManagedContentSpaceRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$h,
        private: [],
        opaque: true
      };
    };
    function equals$h(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$h = function ManagedContentSpaceRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$v(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$8(luvio, input);
      const ttlToUse = TTL$h;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$h, "CMSAuthoring", VERSION$h, RepresentationType$h, equals$h);
      return createLink(key);
    };
    function getTypeCacheKeys$h(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$8(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$h,
        mergeable: false
      });
    }
    function select$D(luvio, params) {
      return select$E();
    }
    function keyBuilder$x(luvio, params) {
      return keyBuilder$y(luvio, {
        id: params.urlParams.contentSpaceId
      });
    }
    function getResponseCacheKeys$m(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$h(storeKeyMap, luvio, response);
    }
    function ingestSuccess$m(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$x(luvio, resourceParams);
      luvio.storeIngest(key, ingest$h, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$D(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$c(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$x(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$h,
        namespace: keyPrefix,
        version: VERSION$h,
        representationName: RepresentationType$h
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$m(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/spaces/' + config.urlParams.contentSpaceId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function createResourceRequestFromRepresentation$3(representation) {
      const config = {
        urlParams: {}
      };
      config.urlParams.contentSpaceId = representation.id;
      return createResourceRequest$m(config);
    }
    const adapterName$m = 'getManagedContentSpace';
    const getManagedContentSpace_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */)];
    const getManagedContentSpace_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$m, getManagedContentSpace_ConfigPropertyMetadata);
    const createResourceParams$m = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentSpace_ConfigPropertyMetadata);
    function keyBuilder$w(luvio, config) {
      const resourceParams = createResourceParams$m(config);
      return keyBuilder$x(luvio, resourceParams);
    }
    function typeCheckConfig$m(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentSpace_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$m(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$m(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$c(luvio, config) {
      createResourceParams$m(config);
      return select$D();
    }
    function onFetchResponseSuccess$c(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$m(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$m(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$c(luvio, config, resourceParams, response) {
      const snapshot = ingestError$c(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$m(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$m(luvio, config, options) {
      const resourceParams = createResourceParams$m(config);
      const request = createResourceRequest$m(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$c(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$m(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$c(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$c(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$m, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$c(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$w(luvio, config),
        node: adapterFragment$c(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$m(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentSpaceAdapterFactory = luvio => function CMSAuthoring__getManagedContentSpace(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$m(untrustedConfig, getManagedContentSpace_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$c, buildNetworkSnapshotCachePolicy$c);
    };
    const notifyChangeFactory$3 = (luvio, options) => {
      return function getConnectCmsSpacesByContentSpaceIdNotifyChange(configs) {
        const keys = configs.map(c => keyBuilder$y(luvio, c));
        luvio.getNotifyChangeStoreEntries(keys).then(entries => {
          for (let i = 0, len = entries.length; i < len; i++) {
            const {
              key,
              record: val
            } = entries[i];
            const refreshRequest = createResourceRequestFromRepresentation$3(val);
            luvio.dispatchResourceRequest(refreshRequest, options).then(response => {
              return luvio.handleSuccessResponse(() => {
                const {
                  body
                } = response;
                luvio.storeIngest(key, ingest$h, body);
                return luvio.storeBroadcast();
              }, () => {
                const cache = new luvioEngine.StoreKeyMap();
                getTypeCacheKeys$h(cache, luvio, response.body);
                return cache;
              });
            }, error => {
              return luvio.handleErrorResponse(() => {
                const errorSnapshot = luvio.errorSnapshot(error);
                luvio.storeIngestError(key, errorSnapshot, {
                  ttl: TTL$h,
                  namespace: keyPrefix,
                  version: VERSION$h,
                  representationName: RepresentationType$h
                });
                return luvio.storeBroadcast().then(() => errorSnapshot);
              });
            });
          }
        });
      };
    };
    const TTL$g = 100;
    const VERSION$g = "6cb5e79d281317772f97d55182ce890e";
    function validate$u(obj, path = 'ManagedContentSpaceFolderRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_parentFolderId = obj.parentFolderId;
        const path_parentFolderId = path + '.parentFolderId';
        let obj_parentFolderId_union0 = null;
        const obj_parentFolderId_union0_error = (() => {
          if (typeof obj_parentFolderId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_parentFolderId + '" (at "' + path_parentFolderId + '")');
          }
        })();
        if (obj_parentFolderId_union0_error != null) {
          obj_parentFolderId_union0 = obj_parentFolderId_union0_error.message;
        }
        let obj_parentFolderId_union1 = null;
        const obj_parentFolderId_union1_error = (() => {
          if (obj_parentFolderId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_parentFolderId + '" (at "' + path_parentFolderId + '")');
          }
        })();
        if (obj_parentFolderId_union1_error != null) {
          obj_parentFolderId_union1 = obj_parentFolderId_union1_error.message;
        }
        if (obj_parentFolderId_union0 && obj_parentFolderId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_parentFolderId + '")';
          message += '\n' + obj_parentFolderId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_parentFolderId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$g = 'ManagedContentSpaceFolderRepresentation';
    function keyBuilder$v(luvio, config) {
      return keyPrefix + '::' + RepresentationType$g + ':' + config.id;
    }
    function keyBuilderFromType$7(luvio, object) {
      const keyParams = {
        id: object.id
      };
      return keyBuilder$v(luvio, keyParams);
    }
    function normalize$g(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$C = function ManagedContentSpaceFolderRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$g,
        private: [],
        opaque: true
      };
    };
    function equals$g(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$g = function ManagedContentSpaceFolderRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$u(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$7(luvio, input);
      const ttlToUse = TTL$g;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$g, "CMSAuthoring", VERSION$g, RepresentationType$g, equals$g);
      return createLink(key);
    };
    function getTypeCacheKeys$g(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$7(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$g,
        mergeable: false
      });
    }
    const TTL$f = 30000;
    const VERSION$f = "19a2e59df42998b6d30d4dee5c5a293b";
    function validate$t(obj, path = 'ManagedContentSpaceFolderDetailRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        if (typeof obj_createdBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdBy + '" (at "' + path_createdBy + '")');
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        const obj_folderHierarchy = obj.folderHierarchy;
        const path_folderHierarchy = path + '.folderHierarchy';
        if (!ArrayIsArray(obj_folderHierarchy)) {
          return new TypeError('Expected "array" but received "' + typeof obj_folderHierarchy + '" (at "' + path_folderHierarchy + '")');
        }
        for (let i = 0; i < obj_folderHierarchy.length; i++) {
          const obj_folderHierarchy_item = obj_folderHierarchy[i];
          const path_folderHierarchy_item = path_folderHierarchy + '[' + i + ']';
          const referencepath_folderHierarchy_itemValidationError = validate$u(obj_folderHierarchy_item, path_folderHierarchy_item);
          if (referencepath_folderHierarchy_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentSpaceFolderRepresentation (at "' + path_folderHierarchy_item + '")\n';
            message += referencepath_folderHierarchy_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_isShared = obj.isShared;
        const path_isShared = path + '.isShared';
        if (typeof obj_isShared !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isShared + '" (at "' + path_isShared + '")');
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        if (typeof obj_lastModifiedBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedBy + '" (at "' + path_lastModifiedBy + '")');
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$f = 'ManagedContentSpaceFolderDetailRepresentation';
    function normalize$f(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$B = function ManagedContentSpaceFolderDetailRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$f,
        private: [],
        opaque: true
      };
    };
    function equals$f(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$f = function ManagedContentSpaceFolderDetailRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$t(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$f;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$f, "CMSAuthoring", VERSION$f, RepresentationType$f, equals$f);
      return createLink(key);
    };
    function getTypeCacheKeys$f(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$f,
        mergeable: false
      });
    }
    function select$A(luvio, params) {
      return select$B();
    }
    function keyBuilder$u(luvio, params) {
      return keyPrefix + '::ManagedContentSpaceFolderDetailRepresentation:(' + 'contextContentSpaceId:' + params.queryParams.contextContentSpaceId + ',' + 'folderId:' + params.urlParams.folderId + ')';
    }
    function getResponseCacheKeys$l(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$f(storeKeyMap, luvio, response, () => keyBuilder$u(luvio, resourceParams));
    }
    function ingestSuccess$l(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$u(luvio, resourceParams);
      luvio.storeIngest(key, ingest$f, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$A(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$b(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$u(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$f,
        namespace: keyPrefix,
        version: VERSION$f,
        representationName: RepresentationType$f
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$l(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/folders/' + config.urlParams.folderId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$l = 'getManagedContentSpaceFolder';
    const getManagedContentSpaceFolder_ConfigPropertyMetadata = [generateParamConfigMetadata('folderId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('contextContentSpaceId', false, 1 /* QueryParameter */, 0 /* String */)];
    const getManagedContentSpaceFolder_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$l, getManagedContentSpaceFolder_ConfigPropertyMetadata);
    const createResourceParams$l = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentSpaceFolder_ConfigPropertyMetadata);
    function keyBuilder$t(luvio, config) {
      const resourceParams = createResourceParams$l(config);
      return keyBuilder$u(luvio, resourceParams);
    }
    function typeCheckConfig$l(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentSpaceFolder_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$l(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$l(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$b(luvio, config) {
      createResourceParams$l(config);
      return select$A();
    }
    function onFetchResponseSuccess$b(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$l(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$l(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$b(luvio, config, resourceParams, response) {
      const snapshot = ingestError$b(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$l(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$l(luvio, config, options) {
      const resourceParams = createResourceParams$l(config);
      const request = createResourceRequest$l(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$b(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$l(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$b(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$b(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$l, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$b(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$t(luvio, config),
        node: adapterFragment$b(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$l(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentSpaceFolderAdapterFactory = luvio => function CMSAuthoring__getManagedContentSpaceFolder(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$l(untrustedConfig, getManagedContentSpaceFolder_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$b, buildNetworkSnapshotCachePolicy$b);
    };
    function validate$s(obj, path = 'ManagedContentSpaceFolderItemV1Representation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.contentKey !== undefined) {
          const obj_contentKey = obj.contentKey;
          const path_contentKey = path + '.contentKey';
          if (typeof obj_contentKey !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_contentKey + '" (at "' + path_contentKey + '")');
          }
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        if (typeof obj_createdBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdBy + '" (at "' + path_createdBy + '")');
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        if (obj.hasChildFolders !== undefined) {
          const obj_hasChildFolders = obj.hasChildFolders;
          const path_hasChildFolders = path + '.hasChildFolders';
          if (typeof obj_hasChildFolders !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_hasChildFolders + '" (at "' + path_hasChildFolders + '")');
          }
        }
        if (obj.id !== undefined) {
          const obj_id = obj.id;
          const path_id = path + '.id';
          if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
          }
        }
        const obj_isFolder = obj.isFolder;
        const path_isFolder = path + '.isFolder';
        if (typeof obj_isFolder !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isFolder + '" (at "' + path_isFolder + '")');
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        if (typeof obj_lastModifiedBy !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedBy + '" (at "' + path_lastModifiedBy + '")');
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
        if (obj.managedContentType !== undefined) {
          const obj_managedContentType = obj.managedContentType;
          const path_managedContentType = path + '.managedContentType';
          if (typeof obj_managedContentType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_managedContentType + '" (at "' + path_managedContentType + '")');
          }
        }
        if (obj.managedContentVersionId !== undefined) {
          const obj_managedContentVersionId = obj.managedContentVersionId;
          const path_managedContentVersionId = path + '.managedContentVersionId';
          if (typeof obj_managedContentVersionId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_managedContentVersionId + '" (at "' + path_managedContentVersionId + '")');
          }
        }
        if (obj.publishedDate !== undefined) {
          const obj_publishedDate = obj.publishedDate;
          const path_publishedDate = path + '.publishedDate';
          if (typeof obj_publishedDate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_publishedDate + '" (at "' + path_publishedDate + '")');
          }
        }
        if (obj.status !== undefined) {
          const obj_status = obj.status;
          const path_status = path + '.status';
          if (typeof obj_status !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_status + '" (at "' + path_status + '")');
          }
        }
        const obj_title = obj.title;
        const path_title = path + '.title';
        if (typeof obj_title !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$e = 100;
    const VERSION$e = "df1370994ae2e57cdebc5f5125930e2d";
    function validate$r(obj, path = 'ManagedContentSpaceFolderItemV1CollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_folderId = obj.folderId;
        const path_folderId = path + '.folderId';
        if (typeof obj_folderId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_folderId + '" (at "' + path_folderId + '")');
        }
        const obj_folderItems = obj.folderItems;
        const path_folderItems = path + '.folderItems';
        if (!ArrayIsArray(obj_folderItems)) {
          return new TypeError('Expected "array" but received "' + typeof obj_folderItems + '" (at "' + path_folderItems + '")');
        }
        for (let i = 0; i < obj_folderItems.length; i++) {
          const obj_folderItems_item = obj_folderItems[i];
          const path_folderItems_item = path_folderItems + '[' + i + ']';
          const referencepath_folderItems_itemValidationError = validate$s(obj_folderItems_item, path_folderItems_item);
          if (referencepath_folderItems_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentSpaceFolderItemV1Representation (at "' + path_folderItems_item + '")\n';
            message += referencepath_folderItems_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_parentFolderId = obj.parentFolderId;
        const path_parentFolderId = path + '.parentFolderId';
        let obj_parentFolderId_union0 = null;
        const obj_parentFolderId_union0_error = (() => {
          if (typeof obj_parentFolderId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_parentFolderId + '" (at "' + path_parentFolderId + '")');
          }
        })();
        if (obj_parentFolderId_union0_error != null) {
          obj_parentFolderId_union0 = obj_parentFolderId_union0_error.message;
        }
        let obj_parentFolderId_union1 = null;
        const obj_parentFolderId_union1_error = (() => {
          if (obj_parentFolderId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_parentFolderId + '" (at "' + path_parentFolderId + '")');
          }
        })();
        if (obj_parentFolderId_union1_error != null) {
          obj_parentFolderId_union1 = obj_parentFolderId_union1_error.message;
        }
        if (obj_parentFolderId_union0 && obj_parentFolderId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_parentFolderId + '")';
          message += '\n' + obj_parentFolderId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_parentFolderId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$e = 'ManagedContentSpaceFolderItemV1CollectionRepresentation';
    function normalize$e(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$z = function ManagedContentSpaceFolderItemV1CollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$e,
        private: [],
        opaque: true
      };
    };
    function equals$e(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$e = function ManagedContentSpaceFolderItemV1CollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$r(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$e;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$e, "CMSAuthoring", VERSION$e, RepresentationType$e, equals$e);
      return createLink(key);
    };
    function getTypeCacheKeys$e(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$e,
        mergeable: false
      });
    }
    function select$y(luvio, params) {
      return select$z();
    }
    function keyBuilder$s(luvio, params) {
      return keyPrefix + '::ManagedContentSpaceFolderItemV1CollectionRepresentation:(' + 'contentTypeFilter:' + params.queryParams.contentTypeFilter + ',' + 'contentTypes:' + params.queryParams.contentTypes + ',' + 'filter:' + params.queryParams.filter + ',' + 'managedContentType:' + params.queryParams.managedContentType + ',' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'queryTerm:' + params.queryParams.queryTerm + ',' + 'showPublishedOnly:' + params.queryParams.showPublishedOnly + ',' + 'sortBy:' + params.queryParams.sortBy + ',' + 'sortOrder:' + params.queryParams.sortOrder + ',' + 'folderId:' + params.urlParams.folderId + ')';
    }
    function getResponseCacheKeys$k(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$e(storeKeyMap, luvio, response, () => keyBuilder$s(luvio, resourceParams));
    }
    function ingestSuccess$k(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$s(luvio, resourceParams);
      luvio.storeIngest(key, ingest$e, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$y(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$a(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$s(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$e,
        namespace: keyPrefix,
        version: VERSION$e,
        representationName: RepresentationType$e
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$k(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/cms/folders/' + config.urlParams.folderId + '/items',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$k = 'getManagedContentSpaceFolderItemsV1';
    const getManagedContentSpaceFolderItemsV1_ConfigPropertyMetadata = [generateParamConfigMetadata('folderId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('contentTypeFilter', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('contentTypes', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('filter', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('managedContentType', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('page', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('queryTerm', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('showPublishedOnly', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('sortBy', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('sortOrder', false, 1 /* QueryParameter */, 0 /* String */)];
    const getManagedContentSpaceFolderItemsV1_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$k, getManagedContentSpaceFolderItemsV1_ConfigPropertyMetadata);
    const createResourceParams$k = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentSpaceFolderItemsV1_ConfigPropertyMetadata);
    function keyBuilder$r(luvio, config) {
      const resourceParams = createResourceParams$k(config);
      return keyBuilder$s(luvio, resourceParams);
    }
    function typeCheckConfig$k(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentSpaceFolderItemsV1_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$k(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$k(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$a(luvio, config) {
      createResourceParams$k(config);
      return select$y();
    }
    function onFetchResponseSuccess$a(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$k(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$k(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$a(luvio, config, resourceParams, response) {
      const snapshot = ingestError$a(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$k(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$k(luvio, config, options) {
      const resourceParams = createResourceParams$k(config);
      const request = createResourceRequest$k(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$a(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$k(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$a(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$a(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$k, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$a(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$r(luvio, config),
        node: adapterFragment$a(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$k(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentSpaceFolderItemsV1AdapterFactory = luvio => function CMSAuthoring__getManagedContentSpaceFolderItemsV1(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$k(untrustedConfig, getManagedContentSpaceFolderItemsV1_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$a, buildNetworkSnapshotCachePolicy$a);
    };
    function validate$q(obj, path = 'ManagedContentWorkflowConfigRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentTypeFqnOrIds = obj.contentTypeFqnOrIds;
        const path_contentTypeFqnOrIds = path + '.contentTypeFqnOrIds';
        if (!ArrayIsArray(obj_contentTypeFqnOrIds)) {
          return new TypeError('Expected "array" but received "' + typeof obj_contentTypeFqnOrIds + '" (at "' + path_contentTypeFqnOrIds + '")');
        }
        for (let i = 0; i < obj_contentTypeFqnOrIds.length; i++) {
          const obj_contentTypeFqnOrIds_item = obj_contentTypeFqnOrIds[i];
          const path_contentTypeFqnOrIds_item = path_contentTypeFqnOrIds + '[' + i + ']';
          if (typeof obj_contentTypeFqnOrIds_item !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_contentTypeFqnOrIds_item + '" (at "' + path_contentTypeFqnOrIds_item + '")');
          }
        }
        const obj_fqnOrId = obj.fqnOrId;
        const path_fqnOrId = path + '.fqnOrId';
        if (typeof obj_fqnOrId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_fqnOrId + '" (at "' + path_fqnOrId + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$d = 100;
    const VERSION$d = "18ff6463be2b1f8640ca93cf1ecb6f43";
    function validate$p(obj, path = 'ManagedContentOrchestratorConfigRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentSpaceId = obj.contentSpaceId;
        const path_contentSpaceId = path + '.contentSpaceId';
        if (typeof obj_contentSpaceId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentSpaceId + '" (at "' + path_contentSpaceId + '")');
        }
        const obj_isModuleInstalled = obj.isModuleInstalled;
        const path_isModuleInstalled = path + '.isModuleInstalled';
        if (typeof obj_isModuleInstalled !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isModuleInstalled + '" (at "' + path_isModuleInstalled + '")');
        }
        const obj_moduleFqn = obj.moduleFqn;
        const path_moduleFqn = path + '.moduleFqn';
        if (typeof obj_moduleFqn !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_moduleFqn + '" (at "' + path_moduleFqn + '")');
        }
        const obj_workflowConfigs = obj.workflowConfigs;
        const path_workflowConfigs = path + '.workflowConfigs';
        if (!ArrayIsArray(obj_workflowConfigs)) {
          return new TypeError('Expected "array" but received "' + typeof obj_workflowConfigs + '" (at "' + path_workflowConfigs + '")');
        }
        for (let i = 0; i < obj_workflowConfigs.length; i++) {
          const obj_workflowConfigs_item = obj_workflowConfigs[i];
          const path_workflowConfigs_item = path_workflowConfigs + '[' + i + ']';
          const referencepath_workflowConfigs_itemValidationError = validate$q(obj_workflowConfigs_item, path_workflowConfigs_item);
          if (referencepath_workflowConfigs_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentWorkflowConfigRepresentation (at "' + path_workflowConfigs_item + '")\n';
            message += referencepath_workflowConfigs_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$d = 'ManagedContentOrchestratorConfigRepresentation';
    function keyBuilder$q(luvio, config) {
      return keyPrefix + '::' + RepresentationType$d + ':' + config.id;
    }
    function keyBuilderFromType$6(luvio, object) {
      const keyParams = {
        id: object.contentSpaceId
      };
      return keyBuilder$q(luvio, keyParams);
    }
    function normalize$d(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$x = function ManagedContentOrchestratorConfigRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$d,
        private: [],
        opaque: true
      };
    };
    function equals$d(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$d = function ManagedContentOrchestratorConfigRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$p(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$6(luvio, input);
      const ttlToUse = TTL$d;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$d, "CMSAuthoring", VERSION$d, RepresentationType$d, equals$d);
      return createLink(key);
    };
    function getTypeCacheKeys$d(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$6(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$d,
        mergeable: false
      });
    }
    function select$w(luvio, params) {
      return select$x();
    }
    function keyBuilder$p(luvio, params) {
      return keyBuilder$q(luvio, {
        id: params.urlParams.contentSpaceId
      });
    }
    function getResponseCacheKeys$j(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$d(storeKeyMap, luvio, response);
    }
    function ingestSuccess$j(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$p(luvio, resourceParams);
      luvio.storeIngest(key, ingest$d, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$w(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$9(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$p(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$d,
        namespace: keyPrefix,
        version: VERSION$d,
        representationName: RepresentationType$d
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$j(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/spaces/' + config.urlParams.contentSpaceId + '/orchestrator-config',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function createResourceRequestFromRepresentation$2(representation) {
      const config = {
        urlParams: {}
      };
      config.urlParams.contentSpaceId = representation.contentSpaceId;
      return createResourceRequest$j(config);
    }
    const adapterName$j = 'getManagedContentSpaceOrchestratorConfig';
    const getManagedContentSpaceOrchestratorConfig_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */)];
    const getManagedContentSpaceOrchestratorConfig_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$j, getManagedContentSpaceOrchestratorConfig_ConfigPropertyMetadata);
    const createResourceParams$j = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentSpaceOrchestratorConfig_ConfigPropertyMetadata);
    function keyBuilder$o(luvio, config) {
      const resourceParams = createResourceParams$j(config);
      return keyBuilder$p(luvio, resourceParams);
    }
    function typeCheckConfig$j(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentSpaceOrchestratorConfig_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$j(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$j(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$9(luvio, config) {
      createResourceParams$j(config);
      return select$w();
    }
    function onFetchResponseSuccess$9(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$j(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$j(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$9(luvio, config, resourceParams, response) {
      const snapshot = ingestError$9(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$j(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$j(luvio, config, options) {
      const resourceParams = createResourceParams$j(config);
      const request = createResourceRequest$j(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$9(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$j(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$9(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$9(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$j, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$9(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$o(luvio, config),
        node: adapterFragment$9(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$j(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentSpaceOrchestratorConfigAdapterFactory = luvio => function CMSAuthoring__getManagedContentSpaceOrchestratorConfig(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$j(untrustedConfig, getManagedContentSpaceOrchestratorConfig_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$9, buildNetworkSnapshotCachePolicy$9);
    };
    const notifyChangeFactory$2 = (luvio, options) => {
      return function getConnectCmsSpacesOrchestratorConfigByContentSpaceIdNotifyChange(configs) {
        const keys = configs.map(c => keyBuilder$q(luvio, c));
        luvio.getNotifyChangeStoreEntries(keys).then(entries => {
          for (let i = 0, len = entries.length; i < len; i++) {
            const {
              key,
              record: val
            } = entries[i];
            const refreshRequest = createResourceRequestFromRepresentation$2(val);
            luvio.dispatchResourceRequest(refreshRequest, options).then(response => {
              return luvio.handleSuccessResponse(() => {
                const {
                  body
                } = response;
                luvio.storeIngest(key, ingest$d, body);
                return luvio.storeBroadcast();
              }, () => {
                const cache = new luvioEngine.StoreKeyMap();
                getTypeCacheKeys$d(cache, luvio, response.body);
                return cache;
              });
            }, error => {
              return luvio.handleErrorResponse(() => {
                const errorSnapshot = luvio.errorSnapshot(error);
                luvio.storeIngestError(key, errorSnapshot, {
                  ttl: TTL$d,
                  namespace: keyPrefix,
                  version: VERSION$d,
                  representationName: RepresentationType$d
                });
                return luvio.storeBroadcast().then(() => errorSnapshot);
              });
            });
          }
        });
      };
    };
    const TTL$c = 100;
    const VERSION$c = "292efba3a426b62d2af39a38fd3464b0";
    function validate$o(obj, path = 'ManagedContentSpaceCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_spaces = obj.spaces;
        const path_spaces = path + '.spaces';
        if (!ArrayIsArray(obj_spaces)) {
          return new TypeError('Expected "array" but received "' + typeof obj_spaces + '" (at "' + path_spaces + '")');
        }
        for (let i = 0; i < obj_spaces.length; i++) {
          const obj_spaces_item = obj_spaces[i];
          const path_spaces_item = path_spaces + '[' + i + ']';
          const referencepath_spaces_itemValidationError = validate$v(obj_spaces_item, path_spaces_item);
          if (referencepath_spaces_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentSpaceRepresentation (at "' + path_spaces_item + '")\n';
            message += referencepath_spaces_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$c = 'ManagedContentSpaceCollectionRepresentation';
    function normalize$c(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$v = function ManagedContentSpaceCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$c,
        private: [],
        opaque: true
      };
    };
    function equals$c(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$c = function ManagedContentSpaceCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$o(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$c;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$c, "CMSAuthoring", VERSION$c, RepresentationType$c, equals$c);
      return createLink(key);
    };
    function getTypeCacheKeys$c(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$c,
        mergeable: false
      });
    }
    function select$u(luvio, params) {
      return select$v();
    }
    function keyBuilder$n(luvio, params) {
      return keyPrefix + '::ManagedContentSpaceCollectionRepresentation:(' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'nameFragment:' + params.queryParams.nameFragment + ')';
    }
    function getResponseCacheKeys$i(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$c(storeKeyMap, luvio, response, () => keyBuilder$n(luvio, resourceParams));
    }
    function ingestSuccess$i(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$n(luvio, resourceParams);
      luvio.storeIngest(key, ingest$c, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$u(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$8(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$n(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$c,
        namespace: keyPrefix,
        version: VERSION$c,
        representationName: RepresentationType$c
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$i(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/spaces',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$i = 'getManagedContentSpaces';
    const getManagedContentSpaces_ConfigPropertyMetadata = [generateParamConfigMetadata('page', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('nameFragment', false, 1 /* QueryParameter */, 0 /* String */)];
    const getManagedContentSpaces_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$i, getManagedContentSpaces_ConfigPropertyMetadata);
    const createResourceParams$i = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentSpaces_ConfigPropertyMetadata);
    function keyBuilder$m(luvio, config) {
      const resourceParams = createResourceParams$i(config);
      return keyBuilder$n(luvio, resourceParams);
    }
    function typeCheckConfig$i(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentSpaces_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$i(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$i(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$8(luvio, config) {
      createResourceParams$i(config);
      return select$u();
    }
    function onFetchResponseSuccess$8(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$i(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$i(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$8(luvio, config, resourceParams, response) {
      const snapshot = ingestError$8(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$i(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$i(luvio, config, options) {
      const resourceParams = createResourceParams$i(config);
      const request = createResourceRequest$i(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$8(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$i(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$8(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$8(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$i, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$8(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$m(luvio, config),
        node: adapterFragment$8(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$i(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentSpacesAdapterFactory = luvio => function CMSAuthoring__getManagedContentSpaces(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$i(untrustedConfig, getManagedContentSpaces_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$8, buildNetworkSnapshotCachePolicy$8);
    };
    function validate$n(obj, path = 'ManagedContentTaxonomyPathFragmentRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$b = 100;
    const VERSION$b = "861a01549e9c8877564cf9109fe8af72";
    function validate$m(obj, path = 'ManagedContentTaxonomyPathRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_taxonomyFragment = obj.taxonomyFragment;
        const path_taxonomyFragment = path + '.taxonomyFragment';
        const referencepath_taxonomyFragmentValidationError = validate$n(obj_taxonomyFragment, path_taxonomyFragment);
        if (referencepath_taxonomyFragmentValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentTaxonomyPathFragmentRepresentation (at "' + path_taxonomyFragment + '")\n';
          message += referencepath_taxonomyFragmentValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_termFragments = obj.termFragments;
        const path_termFragments = path + '.termFragments';
        if (!ArrayIsArray(obj_termFragments)) {
          return new TypeError('Expected "array" but received "' + typeof obj_termFragments + '" (at "' + path_termFragments + '")');
        }
        for (let i = 0; i < obj_termFragments.length; i++) {
          const obj_termFragments_item = obj_termFragments[i];
          const path_termFragments_item = path_termFragments + '[' + i + ']';
          const referencepath_termFragments_itemValidationError = validate$n(obj_termFragments_item, path_termFragments_item);
          if (referencepath_termFragments_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentTaxonomyPathFragmentRepresentation (at "' + path_termFragments_item + '")\n';
            message += referencepath_termFragments_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$b = 'ManagedContentTaxonomyPathRepresentation';
    function normalize$b(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$t = function ManagedContentTaxonomyPathRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$b,
        private: [],
        opaque: true
      };
    };
    function equals$b(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$b = function ManagedContentTaxonomyPathRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$m(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$b;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$b, "CMSAuthoring", VERSION$b, RepresentationType$b, equals$b);
      return createLink(key);
    };
    function getTypeCacheKeys$b(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$b,
        mergeable: false
      });
    }
    const TTL$a = 100;
    const VERSION$a = "ac799a7cee04dda27b43cff95ee1aee5";
    function validate$l(obj, path = 'ManagedContentTaxonomyTermRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_pathsFromRoot = obj.pathsFromRoot;
        const path_pathsFromRoot = path + '.pathsFromRoot';
        if (!ArrayIsArray(obj_pathsFromRoot)) {
          return new TypeError('Expected "array" but received "' + typeof obj_pathsFromRoot + '" (at "' + path_pathsFromRoot + '")');
        }
        for (let i = 0; i < obj_pathsFromRoot.length; i++) {
          const obj_pathsFromRoot_item = obj_pathsFromRoot[i];
          const path_pathsFromRoot_item = path_pathsFromRoot + '[' + i + ']';
          if (typeof obj_pathsFromRoot_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_pathsFromRoot_item + '" (at "' + path_pathsFromRoot_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$a = 'ManagedContentTaxonomyTermRepresentation';
    function keyBuilder$l(luvio, config) {
      return keyPrefix + '::' + RepresentationType$a + ':' + config.id;
    }
    function keyBuilderFromType$5(luvio, object) {
      const keyParams = {
        id: object.id
      };
      return keyBuilder$l(luvio, keyParams);
    }
    function normalize$a(input, existing, path, luvio, store, timestamp) {
      const input_pathsFromRoot = input.pathsFromRoot;
      const input_pathsFromRoot_id = path.fullPath + '__pathsFromRoot';
      for (let i = 0; i < input_pathsFromRoot.length; i++) {
        const input_pathsFromRoot_item = input_pathsFromRoot[i];
        let input_pathsFromRoot_item_id = input_pathsFromRoot_id + '__' + i;
        input_pathsFromRoot[i] = ingest$b(input_pathsFromRoot_item, {
          fullPath: input_pathsFromRoot_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$s = function ManagedContentTaxonomyTermRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$a,
        private: [],
        selections: [{
          name: 'id',
          kind: 'Scalar'
        }, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'pathsFromRoot',
          kind: 'Link',
          plural: true,
          fragment: select$t()
        }]
      };
    };
    function equals$a(existing, incoming) {
      const existing_id = existing.id;
      const incoming_id = incoming.id;
      if (!(existing_id === incoming_id)) {
        return false;
      }
      const existing_label = existing.label;
      const incoming_label = incoming.label;
      if (!(existing_label === incoming_label)) {
        return false;
      }
      const existing_pathsFromRoot = existing.pathsFromRoot;
      const incoming_pathsFromRoot = incoming.pathsFromRoot;
      const equals_pathsFromRoot_items = equalsArray(existing_pathsFromRoot, incoming_pathsFromRoot, (existing_pathsFromRoot_item, incoming_pathsFromRoot_item) => {
        if (!(existing_pathsFromRoot_item.__ref === incoming_pathsFromRoot_item.__ref)) {
          return false;
        }
      });
      if (equals_pathsFromRoot_items === false) {
        return false;
      }
      return true;
    }
    const ingest$a = function ManagedContentTaxonomyTermRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$l(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$5(luvio, input);
      const ttlToUse = TTL$a;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$a, "CMSAuthoring", VERSION$a, RepresentationType$a, equals$a);
      return createLink(key);
    };
    function getTypeCacheKeys$a(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$5(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$a,
        mergeable: false
      });
      const input_pathsFromRoot_length = input.pathsFromRoot.length;
      for (let i = 0; i < input_pathsFromRoot_length; i++) {
        getTypeCacheKeys$b(rootKeySet, luvio, input.pathsFromRoot[i], () => '');
      }
    }
    const TTL$9 = 100;
    const VERSION$9 = "8ab64b2a71caa7cbdb25a65e8081196c";
    function validate$k(obj, path = 'ManagedContentTaxonomyTermCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentKey = obj.contentKey;
        const path_contentKey = path + '.contentKey';
        let obj_contentKey_union0 = null;
        const obj_contentKey_union0_error = (() => {
          if (typeof obj_contentKey !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_contentKey + '" (at "' + path_contentKey + '")');
          }
        })();
        if (obj_contentKey_union0_error != null) {
          obj_contentKey_union0 = obj_contentKey_union0_error.message;
        }
        let obj_contentKey_union1 = null;
        const obj_contentKey_union1_error = (() => {
          if (obj_contentKey !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_contentKey + '" (at "' + path_contentKey + '")');
          }
        })();
        if (obj_contentKey_union1_error != null) {
          obj_contentKey_union1 = obj_contentKey_union1_error.message;
        }
        if (obj_contentKey_union0 && obj_contentKey_union1) {
          let message = 'Object doesn\'t match union (at "' + path_contentKey + '")';
          message += '\n' + obj_contentKey_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_contentKey_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_managedContentId = obj.managedContentId;
        const path_managedContentId = path + '.managedContentId';
        let obj_managedContentId_union0 = null;
        const obj_managedContentId_union0_error = (() => {
          if (typeof obj_managedContentId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_managedContentId + '" (at "' + path_managedContentId + '")');
          }
        })();
        if (obj_managedContentId_union0_error != null) {
          obj_managedContentId_union0 = obj_managedContentId_union0_error.message;
        }
        let obj_managedContentId_union1 = null;
        const obj_managedContentId_union1_error = (() => {
          if (obj_managedContentId !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_managedContentId + '" (at "' + path_managedContentId + '")');
          }
        })();
        if (obj_managedContentId_union1_error != null) {
          obj_managedContentId_union1 = obj_managedContentId_union1_error.message;
        }
        if (obj_managedContentId_union0 && obj_managedContentId_union1) {
          let message = 'Object doesn\'t match union (at "' + path_managedContentId + '")';
          message += '\n' + obj_managedContentId_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_managedContentId_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_taxonomyTerms = obj.taxonomyTerms;
        const path_taxonomyTerms = path + '.taxonomyTerms';
        if (!ArrayIsArray(obj_taxonomyTerms)) {
          return new TypeError('Expected "array" but received "' + typeof obj_taxonomyTerms + '" (at "' + path_taxonomyTerms + '")');
        }
        for (let i = 0; i < obj_taxonomyTerms.length; i++) {
          const obj_taxonomyTerms_item = obj_taxonomyTerms[i];
          const path_taxonomyTerms_item = path_taxonomyTerms + '[' + i + ']';
          if (typeof obj_taxonomyTerms_item !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_taxonomyTerms_item + '" (at "' + path_taxonomyTerms_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$9 = 'ManagedContentTaxonomyTermCollectionRepresentation';
    function keyBuilder$k(luvio, config) {
      return keyPrefix + '::' + RepresentationType$9 + ':' + (config.id === null ? '' : config.id);
    }
    function keyBuilderFromType$4(luvio, object) {
      const keyParams = {
        id: object.managedContentId
      };
      return keyBuilder$k(luvio, keyParams);
    }
    function normalize$9(input, existing, path, luvio, store, timestamp) {
      const input_taxonomyTerms = input.taxonomyTerms;
      const input_taxonomyTerms_id = path.fullPath + '__taxonomyTerms';
      for (let i = 0; i < input_taxonomyTerms.length; i++) {
        const input_taxonomyTerms_item = input_taxonomyTerms[i];
        let input_taxonomyTerms_item_id = input_taxonomyTerms_id + '__' + i;
        input_taxonomyTerms[i] = ingest$a(input_taxonomyTerms_item, {
          fullPath: input_taxonomyTerms_item_id,
          propertyName: i,
          parent: {
            data: input,
            key: path.fullPath,
            existing: existing
          },
          ttl: path.ttl
        }, luvio, store, timestamp);
      }
      return input;
    }
    const select$r = function ManagedContentTaxonomyTermCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$9,
        private: [],
        selections: [{
          name: 'contentKey',
          kind: 'Scalar'
        }, {
          name: 'managedContentId',
          kind: 'Scalar'
        }, {
          name: 'taxonomyTerms',
          kind: 'Link',
          plural: true,
          fragment: select$s()
        }]
      };
    };
    function equals$9(existing, incoming) {
      const existing_contentKey = existing.contentKey;
      const incoming_contentKey = incoming.contentKey;
      if (!(existing_contentKey === incoming_contentKey)) {
        return false;
      }
      const existing_managedContentId = existing.managedContentId;
      const incoming_managedContentId = incoming.managedContentId;
      if (!(existing_managedContentId === incoming_managedContentId)) {
        return false;
      }
      const existing_taxonomyTerms = existing.taxonomyTerms;
      const incoming_taxonomyTerms = incoming.taxonomyTerms;
      const equals_taxonomyTerms_items = equalsArray(existing_taxonomyTerms, incoming_taxonomyTerms, (existing_taxonomyTerms_item, incoming_taxonomyTerms_item) => {
        if (!(existing_taxonomyTerms_item.__ref === incoming_taxonomyTerms_item.__ref)) {
          return false;
        }
      });
      if (equals_taxonomyTerms_items === false) {
        return false;
      }
      return true;
    }
    const ingest$9 = function ManagedContentTaxonomyTermCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$k(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$4(luvio, input);
      const ttlToUse = TTL$9;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$9, "CMSAuthoring", VERSION$9, RepresentationType$9, equals$9);
      return createLink(key);
    };
    function getTypeCacheKeys$9(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$4(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$9,
        mergeable: false
      });
      const input_taxonomyTerms_length = input.taxonomyTerms.length;
      for (let i = 0; i < input_taxonomyTerms_length; i++) {
        getTypeCacheKeys$a(rootKeySet, luvio, input.taxonomyTerms[i]);
      }
    }
    function select$q(luvio, params) {
      return select$r();
    }
    function keyBuilder$j(luvio, params) {
      return keyBuilder$k(luvio, {
        id: params.urlParams.contentKeyOrId
      });
    }
    function getResponseCacheKeys$h(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$9(storeKeyMap, luvio, response);
    }
    function ingestSuccess$h(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$j(luvio, resourceParams);
      luvio.storeIngest(key, ingest$9, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$q(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$7(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$j(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$9,
        namespace: keyPrefix,
        version: VERSION$9,
        representationName: RepresentationType$9
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$h(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/' + config.urlParams.contentKeyOrId + '/taxonomy-terms',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$h = 'getManagedContentTaxonomyTerms';
    const getManagedContentTaxonomyTerms_ConfigPropertyMetadata = [generateParamConfigMetadata('contentKeyOrId', true, 0 /* UrlParameter */, 0 /* String */)];
    const getManagedContentTaxonomyTerms_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$h, getManagedContentTaxonomyTerms_ConfigPropertyMetadata);
    const createResourceParams$h = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentTaxonomyTerms_ConfigPropertyMetadata);
    function keyBuilder$i(luvio, config) {
      const resourceParams = createResourceParams$h(config);
      return keyBuilder$j(luvio, resourceParams);
    }
    function typeCheckConfig$h(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentTaxonomyTerms_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$h(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$h(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$7(luvio, config) {
      createResourceParams$h(config);
      return select$q();
    }
    function onFetchResponseSuccess$7(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$h(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$h(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$7(luvio, config, resourceParams, response) {
      const snapshot = ingestError$7(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$h(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$h(luvio, config, options) {
      const resourceParams = createResourceParams$h(config);
      const request = createResourceRequest$h(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$7(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$h(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$7(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$7(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$h, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$7(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$i(luvio, config),
        node: adapterFragment$7(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$h(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentTaxonomyTermsAdapterFactory = luvio => function CMSAuthoring__getManagedContentTaxonomyTerms(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$h(untrustedConfig, getManagedContentTaxonomyTerms_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$7, buildNetworkSnapshotCachePolicy$7);
    };
    const TTL$8 = 120000;
    const VERSION$8 = "a722ea476134ec8addd2229742816b17";
    function validate$j(obj, path = 'ManagedContentTypeSummaryCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentTypes = obj.contentTypes;
        const path_contentTypes = path + '.contentTypes';
        if (!ArrayIsArray(obj_contentTypes)) {
          return new TypeError('Expected "array" but received "' + typeof obj_contentTypes + '" (at "' + path_contentTypes + '")');
        }
        for (let i = 0; i < obj_contentTypes.length; i++) {
          const obj_contentTypes_item = obj_contentTypes[i];
          const path_contentTypes_item = path_contentTypes + '[' + i + ']';
          const referencepath_contentTypes_itemValidationError = validate$17(obj_contentTypes_item, path_contentTypes_item);
          if (referencepath_contentTypes_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentTypeSummaryRepresentation (at "' + path_contentTypes_item + '")\n';
            message += referencepath_contentTypes_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_totalItems = obj.totalItems;
        const path_totalItems = path + '.totalItems';
        if (typeof obj_totalItems !== 'number' || typeof obj_totalItems === 'number' && Math.floor(obj_totalItems) !== obj_totalItems) {
          return new TypeError('Expected "integer" but received "' + typeof obj_totalItems + '" (at "' + path_totalItems + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$8 = 'ManagedContentTypeSummaryCollectionRepresentation';
    function normalize$8(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$p = function ManagedContentTypeSummaryCollectionRepresentationSelect() {
      const {
        selections: ManagedContentTypeSummaryRepresentation__selections,
        opaque: ManagedContentTypeSummaryRepresentation__opaque
      } = select$1m();
      return {
        kind: 'Fragment',
        version: VERSION$8,
        private: [],
        selections: [{
          name: 'contentTypes',
          kind: 'Object',
          plural: true,
          selections: ManagedContentTypeSummaryRepresentation__selections
        }, {
          name: 'totalItems',
          kind: 'Scalar'
        }]
      };
    };
    function equals$8(existing, incoming) {
      const existing_totalItems = existing.totalItems;
      const incoming_totalItems = incoming.totalItems;
      if (!(existing_totalItems === incoming_totalItems)) {
        return false;
      }
      const existing_contentTypes = existing.contentTypes;
      const incoming_contentTypes = incoming.contentTypes;
      const equals_contentTypes_items = equalsArray(existing_contentTypes, incoming_contentTypes, (existing_contentTypes_item, incoming_contentTypes_item) => {
        if (!equals$G(existing_contentTypes_item, incoming_contentTypes_item)) {
          return false;
        }
      });
      if (equals_contentTypes_items === false) {
        return false;
      }
      return true;
    }
    const ingest$8 = function ManagedContentTypeSummaryCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$j(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$8;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$8, "CMSAuthoring", VERSION$8, RepresentationType$8, equals$8);
      return createLink(key);
    };
    function getTypeCacheKeys$8(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$8,
        mergeable: false
      });
    }
    function select$o(luvio, params) {
      return select$p();
    }
    function keyBuilder$h(luvio, params) {
      return keyPrefix + '::ManagedContentTypeSummaryCollectionRepresentation:(' + 'mixinFQN:' + params.queryParams.mixinFQN + ',' + 'contentSpaceId:' + params.urlParams.contentSpaceId + ')';
    }
    function getResponseCacheKeys$g(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$8(storeKeyMap, luvio, response, () => keyBuilder$h(luvio, resourceParams));
    }
    function ingestSuccess$g(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$h(luvio, resourceParams);
      luvio.storeIngest(key, ingest$8, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$o(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$6(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$h(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$8,
        namespace: keyPrefix,
        version: VERSION$8,
        representationName: RepresentationType$8
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$g(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/spaces/' + config.urlParams.contentSpaceId + '/content-types',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$g = 'getManagedContentTypesForMixin';
    const getManagedContentTypesForMixin_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('mixinFQN', false, 1 /* QueryParameter */, 0 /* String */)];
    const getManagedContentTypesForMixin_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$g, getManagedContentTypesForMixin_ConfigPropertyMetadata);
    const createResourceParams$g = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentTypesForMixin_ConfigPropertyMetadata);
    function keyBuilder$g(luvio, config) {
      const resourceParams = createResourceParams$g(config);
      return keyBuilder$h(luvio, resourceParams);
    }
    function typeCheckConfig$g(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentTypesForMixin_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$g(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$g(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$6(luvio, config) {
      createResourceParams$g(config);
      return select$o();
    }
    function onFetchResponseSuccess$6(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$g(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$g(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$6(luvio, config, resourceParams, response) {
      const snapshot = ingestError$6(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$g(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$g(luvio, config, options) {
      const resourceParams = createResourceParams$g(config);
      const request = createResourceRequest$g(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$6(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$g(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$6(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$6(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$g, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$6(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$g(luvio, config),
        node: adapterFragment$6(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$g(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentTypesForMixinAdapterFactory = luvio => function CMSAuthoring__getManagedContentTypesForMixin(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$g(untrustedConfig, getManagedContentTypesForMixin_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$6, buildNetworkSnapshotCachePolicy$6);
    };
    function select$n(luvio, params) {
      return select$1b();
    }
    function keyBuilder$f(luvio, params) {
      return keyBuilder$13(luvio, {
        id: params.urlParams.variantId
      });
    }
    function getResponseCacheKeys$f(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$v(storeKeyMap, luvio, response);
    }
    function ingestSuccess$f(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$f(luvio, resourceParams);
      luvio.storeIngest(key, ingest$v, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$n(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$5(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$f(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$v,
        namespace: keyPrefix,
        version: VERSION$z,
        representationName: RepresentationType$v
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$f(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/variants/' + config.urlParams.variantId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function createResourceRequestFromRepresentation$1(representation) {
      const config = {
        urlParams: {}
      };
      config.urlParams.variantId = representation.managedContentVariantId;
      return createResourceRequest$f(config);
    }
    const adapterName$f = 'getManagedContentVariant';
    const getManagedContentVariant_ConfigPropertyMetadata = [generateParamConfigMetadata('variantId', true, 0 /* UrlParameter */, 0 /* String */)];
    const getManagedContentVariant_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$f, getManagedContentVariant_ConfigPropertyMetadata);
    const createResourceParams$f = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentVariant_ConfigPropertyMetadata);
    function keyBuilder$e(luvio, config) {
      const resourceParams = createResourceParams$f(config);
      return keyBuilder$f(luvio, resourceParams);
    }
    function typeCheckConfig$f(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentVariant_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$f(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$f(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$5(luvio, config) {
      createResourceParams$f(config);
      return select$n();
    }
    function onFetchResponseSuccess$5(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$f(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$f(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$5(luvio, config, resourceParams, response) {
      const snapshot = ingestError$5(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$f(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$f(luvio, config, options) {
      const resourceParams = createResourceParams$f(config);
      const request = createResourceRequest$f(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$5(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$f(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$5(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$5(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$f, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$5(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$e(luvio, config),
        node: adapterFragment$5(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$f(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentVariantAdapterFactory = luvio => function CMSAuthoring__getManagedContentVariant(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$f(untrustedConfig, getManagedContentVariant_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$5, buildNetworkSnapshotCachePolicy$5);
    };
    const notifyChangeFactory$1 = (luvio, options) => {
      return function getConnectCmsContentsVariantsByVariantIdNotifyChange(configs) {
        const keys = configs.map(c => keyBuilder$13(luvio, c));
        luvio.getNotifyChangeStoreEntries(keys).then(entries => {
          for (let i = 0, len = entries.length; i < len; i++) {
            const {
              key,
              record: val
            } = entries[i];
            const refreshRequest = createResourceRequestFromRepresentation$1(val);
            luvio.dispatchResourceRequest(refreshRequest, options).then(response => {
              return luvio.handleSuccessResponse(() => {
                const {
                  body
                } = response;
                luvio.storeIngest(key, ingest$v, body);
                return luvio.storeBroadcast();
              }, () => {
                const cache = new luvioEngine.StoreKeyMap();
                getTypeCacheKeys$v(cache, luvio, response.body);
                return cache;
              });
            }, error => {
              return luvio.handleErrorResponse(() => {
                const errorSnapshot = luvio.errorSnapshot(error);
                luvio.storeIngestError(key, errorSnapshot, {
                  ttl: TTL$v,
                  namespace: keyPrefix,
                  version: VERSION$z,
                  representationName: RepresentationType$v
                });
                return luvio.storeBroadcast().then(() => errorSnapshot);
              });
            });
          }
        });
      };
    };
    function validate$i(obj, path = 'ManagedContentVariantReferenceDetailsRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_canPublish = obj.canPublish;
        const path_canPublish = path + '.canPublish';
        if (typeof obj_canPublish !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_canPublish + '" (at "' + path_canPublish + '")');
        }
        const obj_contentKey = obj.contentKey;
        const path_contentKey = path + '.contentKey';
        if (typeof obj_contentKey !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentKey + '" (at "' + path_contentKey + '")');
        }
        const obj_contentType = obj.contentType;
        const path_contentType = path + '.contentType';
        const referencepath_contentTypeValidationError = validate$17(obj_contentType, path_contentType);
        if (referencepath_contentTypeValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentTypeSummaryRepresentation (at "' + path_contentType + '")\n';
          message += referencepath_contentTypeValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        const referencepath_createdByValidationError = validate$14(obj_createdBy, path_createdBy);
        if (referencepath_createdByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_createdBy + '")\n';
          message += referencepath_createdByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        const obj_isReady = obj.isReady;
        const path_isReady = path + '.isReady';
        if (typeof obj_isReady !== 'boolean') {
          return new TypeError('Expected "boolean" but received "' + typeof obj_isReady + '" (at "' + path_isReady + '")');
        }
        const obj_language = obj.language;
        const path_language = path + '.language';
        const referencepath_languageValidationError = validate$G(obj_language, path_language);
        if (referencepath_languageValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentLanguageSummaryRepresentation (at "' + path_language + '")\n';
          message += referencepath_languageValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        const referencepath_lastModifiedByValidationError = validate$14(obj_lastModifiedBy, path_lastModifiedBy);
        if (referencepath_lastModifiedByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_lastModifiedBy + '")\n';
          message += referencepath_lastModifiedByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
        const obj_managedContentId = obj.managedContentId;
        const path_managedContentId = path + '.managedContentId';
        if (typeof obj_managedContentId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentId + '" (at "' + path_managedContentId + '")');
        }
        const obj_managedContentSpaceId = obj.managedContentSpaceId;
        const path_managedContentSpaceId = path + '.managedContentSpaceId';
        if (typeof obj_managedContentSpaceId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentSpaceId + '" (at "' + path_managedContentSpaceId + '")');
        }
        const obj_managedContentVariantId = obj.managedContentVariantId;
        const path_managedContentVariantId = path + '.managedContentVariantId';
        if (typeof obj_managedContentVariantId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentVariantId + '" (at "' + path_managedContentVariantId + '")');
        }
        const obj_referenceType = obj.referenceType;
        const path_referenceType = path + '.referenceType';
        if (typeof obj_referenceType !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_referenceType + '" (at "' + path_referenceType + '")');
        }
        const obj_status = obj.status;
        const path_status = path + '.status';
        const referencepath_statusValidationError = validate$10(obj_status, path_status);
        if (referencepath_statusValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentVariantStatusRepresentation (at "' + path_status + '")\n';
          message += referencepath_statusValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_title = obj.title;
        const path_title = path + '.title';
        if (typeof obj_title !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$7 = 100;
    const VERSION$7 = "944ebf1d8e72c74b2d0a208b3dfa8326";
    function validate$h(obj, path = 'ManagedContentVariantReferencesCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_referenceVariants = obj.referenceVariants;
        const path_referenceVariants = path + '.referenceVariants';
        if (typeof obj_referenceVariants !== 'object' || ArrayIsArray(obj_referenceVariants) || obj_referenceVariants === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_referenceVariants + '" (at "' + path_referenceVariants + '")');
        }
        const obj_referenceVariants_keys = ObjectKeys(obj_referenceVariants);
        for (let i = 0; i < obj_referenceVariants_keys.length; i++) {
          const key = obj_referenceVariants_keys[i];
          const obj_referenceVariants_prop = obj_referenceVariants[key];
          const path_referenceVariants_prop = path_referenceVariants + '["' + key + '"]';
          if (!ArrayIsArray(obj_referenceVariants_prop)) {
            return new TypeError('Expected "array" but received "' + typeof obj_referenceVariants_prop + '" (at "' + path_referenceVariants_prop + '")');
          }
          for (let i = 0; i < obj_referenceVariants_prop.length; i++) {
            const obj_referenceVariants_prop_item = obj_referenceVariants_prop[i];
            const path_referenceVariants_prop_item = path_referenceVariants_prop + '[' + i + ']';
            const referencepath_referenceVariants_prop_itemValidationError = validate$i(obj_referenceVariants_prop_item, path_referenceVariants_prop_item);
            if (referencepath_referenceVariants_prop_itemValidationError !== null) {
              let message = 'Object doesn\'t match ManagedContentVariantReferenceDetailsRepresentation (at "' + path_referenceVariants_prop_item + '")\n';
              message += referencepath_referenceVariants_prop_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
              return new TypeError(message);
            }
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$7 = 'ManagedContentVariantReferencesCollectionRepresentation';
    function normalize$7(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$m = function ManagedContentVariantReferencesCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$7,
        private: [],
        opaque: true
      };
    };
    function equals$7(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$7 = function ManagedContentVariantReferencesCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$h(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$7;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$7, "CMSAuthoring", VERSION$7, RepresentationType$7, equals$7);
      return createLink(key);
    };
    function getTypeCacheKeys$7(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$7,
        mergeable: false
      });
    }
    function select$l(luvio, params) {
      return select$m();
    }
    function keyBuilder$d(luvio, params) {
      return keyPrefix + '::ManagedContentVariantReferencesCollectionRepresentation:(' + 'variantIds:' + params.queryParams.variantIds + ',' + 'contentKeyOrId:' + params.urlParams.contentKeyOrId + ')';
    }
    function getResponseCacheKeys$e(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$7(storeKeyMap, luvio, response, () => keyBuilder$d(luvio, resourceParams));
    }
    function ingestSuccess$e(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$d(luvio, resourceParams);
      luvio.storeIngest(key, ingest$7, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$l(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$4(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$d(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$7,
        namespace: keyPrefix,
        version: VERSION$7,
        representationName: RepresentationType$7
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$e(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/' + config.urlParams.contentKeyOrId + '/variants/references',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$e = 'getManagedContentVariantReferences';
    const getManagedContentVariantReferences_ConfigPropertyMetadata = [generateParamConfigMetadata('contentKeyOrId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('variantIds', false, 1 /* QueryParameter */, 0 /* String */, true)];
    const getManagedContentVariantReferences_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$e, getManagedContentVariantReferences_ConfigPropertyMetadata);
    const createResourceParams$e = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentVariantReferences_ConfigPropertyMetadata);
    function keyBuilder$c(luvio, config) {
      const resourceParams = createResourceParams$e(config);
      return keyBuilder$d(luvio, resourceParams);
    }
    function typeCheckConfig$e(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentVariantReferences_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$e(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$e(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$4(luvio, config) {
      createResourceParams$e(config);
      return select$l();
    }
    function onFetchResponseSuccess$4(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$e(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$e(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$4(luvio, config, resourceParams, response) {
      const snapshot = ingestError$4(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$e(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$e(luvio, config, options) {
      const resourceParams = createResourceParams$e(config);
      const request = createResourceRequest$e(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$4(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$e(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$4(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$4(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$e, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$4(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$c(luvio, config),
        node: adapterFragment$4(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$e(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentVariantReferencesAdapterFactory = luvio => function CMSAuthoring__getManagedContentVariantReferences(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$e(untrustedConfig, getManagedContentVariantReferences_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$4, buildNetworkSnapshotCachePolicy$4);
    };
    const TTL$6 = 1000;
    const VERSION$6 = "98edee4f058ced93570a7b0ce2293672";
    function validate$g(obj, path = 'ManagedContentRenditionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentKey = obj.contentKey;
        const path_contentKey = path + '.contentKey';
        if (typeof obj_contentKey !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentKey + '" (at "' + path_contentKey + '")');
        }
        const obj_language = obj.language;
        const path_language = path + '.language';
        if (typeof obj_language !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_language + '" (at "' + path_language + '")');
        }
        const obj_managedContentId = obj.managedContentId;
        const path_managedContentId = path + '.managedContentId';
        if (typeof obj_managedContentId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentId + '" (at "' + path_managedContentId + '")');
        }
        const obj_renditionBody = obj.renditionBody;
        const path_renditionBody = path + '.renditionBody';
        if (typeof obj_renditionBody !== 'object' || ArrayIsArray(obj_renditionBody) || obj_renditionBody === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_renditionBody + '" (at "' + path_renditionBody + '")');
        }
        const obj_renditionBody_keys = ObjectKeys(obj_renditionBody);
        for (let i = 0; i < obj_renditionBody_keys.length; i++) {
          const key = obj_renditionBody_keys[i];
          const obj_renditionBody_prop = obj_renditionBody[key];
          const path_renditionBody_prop = path_renditionBody + '["' + key + '"]';
          if (obj_renditionBody_prop === undefined) {
            return new TypeError('Expected "defined" but received "' + typeof obj_renditionBody_prop + '" (at "' + path_renditionBody_prop + '")');
          }
        }
        const obj_renditionSchema = obj.renditionSchema;
        const path_renditionSchema = path + '.renditionSchema';
        if (typeof obj_renditionSchema !== 'object' || ArrayIsArray(obj_renditionSchema) || obj_renditionSchema === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_renditionSchema + '" (at "' + path_renditionSchema + '")');
        }
        const obj_renditionSchema_keys = ObjectKeys(obj_renditionSchema);
        for (let i = 0; i < obj_renditionSchema_keys.length; i++) {
          const key = obj_renditionSchema_keys[i];
          const obj_renditionSchema_prop = obj_renditionSchema[key];
          const path_renditionSchema_prop = path_renditionSchema + '["' + key + '"]';
          if (obj_renditionSchema_prop === undefined) {
            return new TypeError('Expected "defined" but received "' + typeof obj_renditionSchema_prop + '" (at "' + path_renditionSchema_prop + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$6 = 'ManagedContentRenditionRepresentation';
    function normalize$6(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$k = function ManagedContentRenditionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$6,
        private: [],
        opaque: true
      };
    };
    function equals$6(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$6 = function ManagedContentRenditionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$g(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$6;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$6, "CMSAuthoring", VERSION$6, RepresentationType$6, equals$6);
      return createLink(key);
    };
    function getTypeCacheKeys$6(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$6,
        mergeable: false
      });
    }
    function select$j(luvio, params) {
      return select$k();
    }
    function keyBuilder$b(luvio, params) {
      return keyPrefix + '::ManagedContentRenditionRepresentation:(' + 'channelIdOrApiName:' + params.queryParams.channelIdOrApiName + ',' + 'language:' + params.queryParams.language + ',' + 'version:' + params.queryParams.version + ',' + 'contentKeyOrId:' + params.urlParams.contentKeyOrId + ',' + 'renditionType:' + params.urlParams.renditionType + ')';
    }
    function getResponseCacheKeys$d(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$6(storeKeyMap, luvio, response, () => keyBuilder$b(luvio, resourceParams));
    }
    function ingestSuccess$d(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$b(luvio, resourceParams);
      luvio.storeIngest(key, ingest$6, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$j(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$3(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$b(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$6,
        namespace: keyPrefix,
        version: VERSION$6,
        representationName: RepresentationType$6
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$d(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/' + config.urlParams.contentKeyOrId + '/renditions/' + config.urlParams.renditionType + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$d = 'getManagedContentVariantRendition';
    const getManagedContentVariantRendition_ConfigPropertyMetadata = [generateParamConfigMetadata('contentKeyOrId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('renditionType', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('channelIdOrApiName', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('language', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('version', false, 1 /* QueryParameter */, 0 /* String */)];
    const getManagedContentVariantRendition_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$d, getManagedContentVariantRendition_ConfigPropertyMetadata);
    const createResourceParams$d = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentVariantRendition_ConfigPropertyMetadata);
    function keyBuilder$a(luvio, config) {
      const resourceParams = createResourceParams$d(config);
      return keyBuilder$b(luvio, resourceParams);
    }
    function typeCheckConfig$d(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentVariantRendition_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$d(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$d(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$3(luvio, config) {
      createResourceParams$d(config);
      return select$j();
    }
    function onFetchResponseSuccess$3(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$d(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$d(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$3(luvio, config, resourceParams, response) {
      const snapshot = ingestError$3(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$d(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$d(luvio, config, options) {
      const resourceParams = createResourceParams$d(config);
      const request = createResourceRequest$d(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$3(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$d(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$3(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$3(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$d, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$3(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$a(luvio, config),
        node: adapterFragment$3(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$d(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentVariantRenditionAdapterFactory = luvio => function CMSAuthoring__getManagedContentVariantRendition(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$d(untrustedConfig, getManagedContentVariantRendition_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$3, buildNetworkSnapshotCachePolicy$3);
    };
    function validate$f(obj, path = 'ManagedContentVariantVersionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        const referencepath_createdByValidationError = validate$14(obj_createdBy, path_createdBy);
        if (referencepath_createdByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_createdBy + '")\n';
          message += referencepath_createdByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        const referencepath_lastModifiedByValidationError = validate$14(obj_lastModifiedBy, path_lastModifiedBy);
        if (referencepath_lastModifiedByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_lastModifiedBy + '")\n';
          message += referencepath_lastModifiedByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
        const obj_resourceUrl = obj.resourceUrl;
        const path_resourceUrl = path + '.resourceUrl';
        if (typeof obj_resourceUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_resourceUrl + '" (at "' + path_resourceUrl + '")');
        }
        const obj_status = obj.status;
        const path_status = path + '.status';
        const referencepath_statusValidationError = validate$10(obj_status, path_status);
        if (referencepath_statusValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentVariantStatusRepresentation (at "' + path_status + '")\n';
          message += referencepath_statusValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_title = obj.title;
        const path_title = path + '.title';
        if (typeof obj_title !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
        }
        const obj_versionNumber = obj.versionNumber;
        const path_versionNumber = path + '.versionNumber';
        if (typeof obj_versionNumber !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_versionNumber + '" (at "' + path_versionNumber + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$5 = 100;
    const VERSION$5 = "993f4fe3a5b12699f037079dbe30610b";
    function validate$e(obj, path = 'ManagedContentVariantVersionCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_managedContentVariantId = obj.managedContentVariantId;
        const path_managedContentVariantId = path + '.managedContentVariantId';
        if (typeof obj_managedContentVariantId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentVariantId + '" (at "' + path_managedContentVariantId + '")');
        }
        if (obj.nextPageUrl !== undefined) {
          const obj_nextPageUrl = obj.nextPageUrl;
          const path_nextPageUrl = path + '.nextPageUrl';
          if (typeof obj_nextPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
          }
        }
        const obj_versions = obj.versions;
        const path_versions = path + '.versions';
        if (!ArrayIsArray(obj_versions)) {
          return new TypeError('Expected "array" but received "' + typeof obj_versions + '" (at "' + path_versions + '")');
        }
        for (let i = 0; i < obj_versions.length; i++) {
          const obj_versions_item = obj_versions[i];
          const path_versions_item = path_versions + '[' + i + ']';
          const referencepath_versions_itemValidationError = validate$f(obj_versions_item, path_versions_item);
          if (referencepath_versions_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentVariantVersionRepresentation (at "' + path_versions_item + '")\n';
            message += referencepath_versions_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$5 = 'ManagedContentVariantVersionCollectionRepresentation';
    function keyBuilder$9(luvio, config) {
      return keyPrefix + '::' + RepresentationType$5 + ':' + config.variantId;
    }
    function keyBuilderFromType$3(luvio, object) {
      const keyParams = {
        variantId: object.managedContentVariantId
      };
      return keyBuilder$9(luvio, keyParams);
    }
    function normalize$5(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$i = function ManagedContentVariantVersionCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$5,
        private: [],
        opaque: true
      };
    };
    function equals$5(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$5 = function ManagedContentVariantVersionCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$e(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$3(luvio, input);
      const ttlToUse = TTL$5;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$5, "CMSAuthoring", VERSION$5, RepresentationType$5, equals$5);
      return createLink(key);
    };
    function getTypeCacheKeys$5(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$3(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$5,
        mergeable: false
      });
    }
    function select$h(luvio, params) {
      return select$i();
    }
    function keyBuilder$8(luvio, params) {
      return keyBuilder$9(luvio, {
        variantId: params.urlParams.variantId
      });
    }
    function getResponseCacheKeys$c(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$5(storeKeyMap, luvio, response);
    }
    function ingestSuccess$c(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$8(luvio, resourceParams);
      luvio.storeIngest(key, ingest$5, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$h(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$2(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$8(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$5,
        namespace: keyPrefix,
        version: VERSION$5,
        representationName: RepresentationType$5
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$c(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/variants/' + config.urlParams.variantId + '/versions',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    function createResourceRequestFromRepresentation(representation) {
      const config = {
        urlParams: {},
        queryParams: {}
      };
      config.urlParams.variantId = representation.managedContentVariantId;
      return createResourceRequest$c(config);
    }
    const adapterName$c = 'getManagedContentVariantVersions';
    const getManagedContentVariantVersions_ConfigPropertyMetadata = [generateParamConfigMetadata('variantId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('page', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('status', false, 1 /* QueryParameter */, 0 /* String */, true)];
    const getManagedContentVariantVersions_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$c, getManagedContentVariantVersions_ConfigPropertyMetadata);
    const createResourceParams$c = /*#__PURE__*/luvioEngine.createResourceParams(getManagedContentVariantVersions_ConfigPropertyMetadata);
    function keyBuilder$7(luvio, config) {
      const resourceParams = createResourceParams$c(config);
      return keyBuilder$8(luvio, resourceParams);
    }
    function typeCheckConfig$c(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getManagedContentVariantVersions_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$c(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$c(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$2(luvio, config) {
      createResourceParams$c(config);
      return select$h();
    }
    function onFetchResponseSuccess$2(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$c(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$c(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$2(luvio, config, resourceParams, response) {
      const snapshot = ingestError$2(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$c(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$c(luvio, config, options) {
      const resourceParams = createResourceParams$c(config);
      const request = createResourceRequest$c(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$2(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$c(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$2(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$2(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$c, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$2(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$7(luvio, config),
        node: adapterFragment$2(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$c(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getManagedContentVariantVersionsAdapterFactory = luvio => function CMSAuthoring__getManagedContentVariantVersions(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$c(untrustedConfig, getManagedContentVariantVersions_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$2, buildNetworkSnapshotCachePolicy$2);
    };
    const notifyChangeFactory = (luvio, options) => {
      return function getConnectCmsContentsVariantsVersionsByVariantIdNotifyChange(configs) {
        const keys = configs.map(c => keyBuilder$9(luvio, c));
        luvio.getNotifyChangeStoreEntries(keys).then(entries => {
          for (let i = 0, len = entries.length; i < len; i++) {
            const {
              key,
              record: val
            } = entries[i];
            const refreshRequest = createResourceRequestFromRepresentation(val);
            luvio.dispatchResourceRequest(refreshRequest, options).then(response => {
              return luvio.handleSuccessResponse(() => {
                const {
                  body
                } = response;
                luvio.storeIngest(key, ingest$5, body);
                return luvio.storeBroadcast();
              }, () => {
                const cache = new luvioEngine.StoreKeyMap();
                getTypeCacheKeys$5(cache, luvio, response.body);
                return cache;
              });
            }, error => {
              return luvio.handleErrorResponse(() => {
                const errorSnapshot = luvio.errorSnapshot(error);
                luvio.storeIngestError(key, errorSnapshot, {
                  ttl: TTL$5,
                  namespace: keyPrefix,
                  version: VERSION$5,
                  representationName: RepresentationType$5
                });
                return luvio.storeBroadcast().then(() => errorSnapshot);
              });
            });
          }
        });
      };
    };
    function validate$d(obj, path = 'AbstractManagedContentSearchResultRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_createdBy = obj.createdBy;
        const path_createdBy = path + '.createdBy';
        const referencepath_createdByValidationError = validate$14(obj_createdBy, path_createdBy);
        if (referencepath_createdByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_createdBy + '")\n';
          message += referencepath_createdByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_createdDate = obj.createdDate;
        const path_createdDate = path + '.createdDate';
        if (typeof obj_createdDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_createdDate + '" (at "' + path_createdDate + '")');
        }
        const obj_folder = obj.folder;
        const path_folder = path + '.folder';
        const referencepath_folderValidationError = validate$1b(obj_folder, path_folder);
        if (referencepath_folderValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentFolderSummaryRepresentation (at "' + path_folder + '")\n';
          message += referencepath_folderValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_lastModifiedBy = obj.lastModifiedBy;
        const path_lastModifiedBy = path + '.lastModifiedBy';
        const referencepath_lastModifiedByValidationError = validate$14(obj_lastModifiedBy, path_lastModifiedBy);
        if (referencepath_lastModifiedByValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentUserSummaryRepresentation (at "' + path_lastModifiedBy + '")\n';
          message += referencepath_lastModifiedByValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        if (typeof obj_lastModifiedDate !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
        }
        const obj_managedContentSpaceId = obj.managedContentSpaceId;
        const path_managedContentSpaceId = path + '.managedContentSpaceId';
        if (typeof obj_managedContentSpaceId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_managedContentSpaceId + '" (at "' + path_managedContentSpaceId + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$4 = 100;
    const VERSION$4 = "bbcdc04e5d094f6f8048bc2863d86527";
    function validate$c(obj, path = 'ManagedContentSearchResultItemsCollectionRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count) {
          return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageUri = obj.currentPageUri;
        const path_currentPageUri = path + '.currentPageUri';
        if (typeof obj_currentPageUri !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_currentPageUri + '" (at "' + path_currentPageUri + '")');
        }
        const obj_items = obj.items;
        const path_items = path + '.items';
        if (!ArrayIsArray(obj_items)) {
          return new TypeError('Expected "array" but received "' + typeof obj_items + '" (at "' + path_items + '")');
        }
        for (let i = 0; i < obj_items.length; i++) {
          const obj_items_item = obj_items[i];
          const path_items_item = path_items + '[' + i + ']';
          const referencepath_items_itemValidationError = validate$d(obj_items_item, path_items_item);
          if (referencepath_items_itemValidationError !== null) {
            let message = 'Object doesn\'t match AbstractManagedContentSearchResultRepresentation (at "' + path_items_item + '")\n';
            message += referencepath_items_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_nextPageUri = obj.nextPageUri;
        const path_nextPageUri = path + '.nextPageUri';
        if (typeof obj_nextPageUri !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_nextPageUri + '" (at "' + path_nextPageUri + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$4 = 'ManagedContentSearchResultItemsCollectionRepresentation';
    function normalize$4(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$g = function ManagedContentSearchResultItemsCollectionRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$4,
        private: [],
        opaque: true
      };
    };
    function equals$4(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$4 = function ManagedContentSearchResultItemsCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$c(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$4;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$4, "CMSAuthoring", VERSION$4, RepresentationType$4, equals$4);
      return createLink(key);
    };
    function getTypeCacheKeys$4(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$4,
        mergeable: false
      });
    }
    function select$f(luvio, params) {
      return select$g();
    }
    function keyBuilder$6(luvio, params) {
      return keyPrefix + '::ManagedContentSearchResultItemsCollectionRepresentation:(' + 'contentSpaceOrFolderIds:' + params.queryParams.contentSpaceOrFolderIds + ',' + 'contentTypeFQN:' + params.queryParams.contentTypeFQN + ',' + 'languages:' + params.queryParams.languages + ',' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'queryTerm:' + params.queryParams.queryTerm + ',' + 'scope:' + params.queryParams.scope + ')';
    }
    function getResponseCacheKeys$b(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$4(storeKeyMap, luvio, response, () => keyBuilder$6(luvio, resourceParams));
    }
    function ingestSuccess$b(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$6(luvio, resourceParams);
      luvio.storeIngest(key, ingest$4, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$f(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError$1(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$6(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$4,
        namespace: keyPrefix,
        version: VERSION$4,
        representationName: RepresentationType$4
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$b(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/items/search',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$b = 'getSearchResults';
    const getSearchResults_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceOrFolderIds', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('contentTypeFQN', false, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('languages', false, 1 /* QueryParameter */, 0 /* String */, true), generateParamConfigMetadata('page', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('queryTerm', true, 1 /* QueryParameter */, 0 /* String */), generateParamConfigMetadata('scope', false, 1 /* QueryParameter */, 0 /* String */)];
    const getSearchResults_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$b, getSearchResults_ConfigPropertyMetadata);
    const createResourceParams$b = /*#__PURE__*/luvioEngine.createResourceParams(getSearchResults_ConfigPropertyMetadata);
    function keyBuilder$5(luvio, config) {
      const resourceParams = createResourceParams$b(config);
      return keyBuilder$6(luvio, resourceParams);
    }
    function typeCheckConfig$b(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getSearchResults_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$b(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$b(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment$1(luvio, config) {
      createResourceParams$b(config);
      return select$f();
    }
    function onFetchResponseSuccess$1(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$b(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$b(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError$1(luvio, config, resourceParams, response) {
      const snapshot = ingestError$1(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$b(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$b(luvio, config, options) {
      const resourceParams = createResourceParams$b(config);
      const request = createResourceRequest$b(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$1(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$b(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$1(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$1(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$b, undefined, false);
    }
    function buildCachedSnapshotCachePolicy$1(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$5(luvio, config),
        node: adapterFragment$1(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$b(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getSearchResultsAdapterFactory = luvio => function CMSAuthoring__getSearchResults(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$b(untrustedConfig, getSearchResults_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy$1, buildNetworkSnapshotCachePolicy$1);
    };
    function validate$b(obj, path = 'ManagedContentWebUrlRedirectInfoOutputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_redirectUrl = obj.redirectUrl;
        const path_redirectUrl = path + '.redirectUrl';
        let obj_redirectUrl_union0 = null;
        const obj_redirectUrl_union0_error = (() => {
          if (typeof obj_redirectUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_redirectUrl + '" (at "' + path_redirectUrl + '")');
          }
        })();
        if (obj_redirectUrl_union0_error != null) {
          obj_redirectUrl_union0 = obj_redirectUrl_union0_error.message;
        }
        let obj_redirectUrl_union1 = null;
        const obj_redirectUrl_union1_error = (() => {
          if (obj_redirectUrl !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_redirectUrl + '" (at "' + path_redirectUrl + '")');
          }
        })();
        if (obj_redirectUrl_union1_error != null) {
          obj_redirectUrl_union1 = obj_redirectUrl_union1_error.message;
        }
        if (obj_redirectUrl_union0 && obj_redirectUrl_union1) {
          let message = 'Object doesn\'t match union (at "' + path_redirectUrl + '")';
          message += '\n' + obj_redirectUrl_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_redirectUrl_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$a(obj, path = 'ManagedContentSiteInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_domainId = obj.domainId;
        const path_domainId = path + '.domainId';
        if (typeof obj_domainId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_domainId + '" (at "' + path_domainId + '")');
        }
        const obj_siteId = obj.siteId;
        const path_siteId = path + '.siteId';
        if (typeof obj_siteId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_siteId + '" (at "' + path_siteId + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function validate$9(obj, path = 'ManagedContentWebUrlInfoRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.siteInfo !== undefined) {
          const obj_siteInfo = obj.siteInfo;
          const path_siteInfo = path + '.siteInfo';
          const referencepath_siteInfoValidationError = validate$a(obj_siteInfo, path_siteInfo);
          if (referencepath_siteInfoValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentSiteInfoRepresentation (at "' + path_siteInfo + '")\n';
            message += referencepath_siteInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const TTL$3 = 100;
    const VERSION$3 = "e55a316362ca4e75b43fa6c9c1b8a065";
    function validate$8(obj, path = 'ManagedContentWebUrlRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentKey = obj.contentKey;
        const path_contentKey = path + '.contentKey';
        if (typeof obj_contentKey !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_contentKey + '" (at "' + path_contentKey + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_redirectInfo = obj.redirectInfo;
        const path_redirectInfo = path + '.redirectInfo';
        const referencepath_redirectInfoValidationError = validate$b(obj_redirectInfo, path_redirectInfo);
        if (referencepath_redirectInfoValidationError !== null) {
          let message = 'Object doesn\'t match ManagedContentWebUrlRedirectInfoOutputRepresentation (at "' + path_redirectInfo + '")\n';
          message += referencepath_redirectInfoValidationError.message.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_status = obj.status;
        const path_status = path + '.status';
        if (typeof obj_status !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_status + '" (at "' + path_status + '")');
        }
        const obj_urlAlias = obj.urlAlias;
        const path_urlAlias = path + '.urlAlias';
        if (typeof obj_urlAlias !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_urlAlias + '" (at "' + path_urlAlias + '")');
        }
        const obj_urls = obj.urls;
        const path_urls = path + '.urls';
        if (!ArrayIsArray(obj_urls)) {
          return new TypeError('Expected "array" but received "' + typeof obj_urls + '" (at "' + path_urls + '")');
        }
        for (let i = 0; i < obj_urls.length; i++) {
          const obj_urls_item = obj_urls[i];
          const path_urls_item = path_urls + '[' + i + ']';
          const referencepath_urls_itemValidationError = validate$9(obj_urls_item, path_urls_item);
          if (referencepath_urls_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentWebUrlInfoRepresentation (at "' + path_urls_item + '")\n';
            message += referencepath_urls_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$3 = 'ManagedContentWebUrlRepresentation';
    function keyBuilder$4(luvio, config) {
      return keyPrefix + '::' + RepresentationType$3 + ':' + config.managedContentWebUrlId;
    }
    function keyBuilderFromType$2(luvio, object) {
      const keyParams = {
        managedContentWebUrlId: object.id
      };
      return keyBuilder$4(luvio, keyParams);
    }
    function normalize$3(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$e = function ManagedContentWebUrlRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$3,
        private: [],
        opaque: true
      };
    };
    function equals$3(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$3 = function ManagedContentWebUrlRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$8(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$2(luvio, input);
      const ttlToUse = TTL$3;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$3, "CMSAuthoring", VERSION$3, RepresentationType$3, equals$3);
      return createLink(key);
    };
    function getTypeCacheKeys$3(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$2(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$3,
        mergeable: false
      });
    }
    const TTL$2 = 100;
    const VERSION$2 = "361f66b21b2d3b6832c42c67fac4f448";
    function validate$7(obj, path = 'ManagedContentWebUrlsRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_urlAliases = obj.urlAliases;
        const path_urlAliases = path + '.urlAliases';
        if (!ArrayIsArray(obj_urlAliases)) {
          return new TypeError('Expected "array" but received "' + typeof obj_urlAliases + '" (at "' + path_urlAliases + '")');
        }
        for (let i = 0; i < obj_urlAliases.length; i++) {
          const obj_urlAliases_item = obj_urlAliases[i];
          const path_urlAliases_item = path_urlAliases + '[' + i + ']';
          const referencepath_urlAliases_itemValidationError = validate$8(obj_urlAliases_item, path_urlAliases_item);
          if (referencepath_urlAliases_itemValidationError !== null) {
            let message = 'Object doesn\'t match ManagedContentWebUrlRepresentation (at "' + path_urlAliases_item + '")\n';
            message += referencepath_urlAliases_itemValidationError.message.split('\n').map(line => '\t' + line).join('\n');
            return new TypeError(message);
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$2 = 'ManagedContentWebUrlsRepresentation';
    function normalize$2(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$d = function ManagedContentWebUrlsRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$2,
        private: [],
        opaque: true
      };
    };
    function equals$2(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$2 = function ManagedContentWebUrlsRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$7(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = path.fullPath;
      const ttlToUse = TTL$2;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$2, "CMSAuthoring", VERSION$2, RepresentationType$2, equals$2);
      return createLink(key);
    };
    function getTypeCacheKeys$2(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = fullPathFactory();
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$2,
        mergeable: false
      });
    }
    function select$c(luvio, params) {
      return select$d();
    }
    function keyBuilder$3(luvio, params) {
      return keyPrefix + '::ManagedContentWebUrlsRepresentation:(' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'contentKeyOrId:' + params.urlParams.contentKeyOrId + ')';
    }
    function getResponseCacheKeys$a(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$2(storeKeyMap, luvio, response, () => keyBuilder$3(luvio, resourceParams));
    }
    function ingestSuccess$a(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const key = keyBuilder$3(luvio, resourceParams);
      luvio.storeIngest(key, ingest$2, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$c(),
        variables: {}
      }, snapshotRefresh);
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function ingestError(luvio, params, error, snapshotRefresh) {
      const key = keyBuilder$3(luvio, params);
      const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
      const storeMetadataParams = {
        ttl: TTL$2,
        namespace: keyPrefix,
        version: VERSION$2,
        representationName: RepresentationType$2
      };
      luvio.storeIngestError(key, errorSnapshot, storeMetadataParams);
      return errorSnapshot;
    }
    function createResourceRequest$a(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/' + config.urlParams.contentKeyOrId + '/web-urls',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$a = 'getWebUrls';
    const getWebUrls_ConfigPropertyMetadata = [generateParamConfigMetadata('contentKeyOrId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('page', false, 1 /* QueryParameter */, 3 /* Integer */), generateParamConfigMetadata('pageSize', false, 1 /* QueryParameter */, 3 /* Integer */)];
    const getWebUrls_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$a, getWebUrls_ConfigPropertyMetadata);
    const createResourceParams$a = /*#__PURE__*/luvioEngine.createResourceParams(getWebUrls_ConfigPropertyMetadata);
    function keyBuilder$2(luvio, config) {
      const resourceParams = createResourceParams$a(config);
      return keyBuilder$3(luvio, resourceParams);
    }
    function typeCheckConfig$a(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, getWebUrls_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$a(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$a(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function adapterFragment(luvio, config) {
      createResourceParams$a(config);
      return select$c();
    }
    function onFetchResponseSuccess(luvio, config, resourceParams, response) {
      const snapshot = ingestSuccess$a(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$a(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function onFetchResponseError(luvio, config, resourceParams, response) {
      const snapshot = ingestError(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$a(luvio, config, snapshotRefreshOptions)
      });
      return luvio.storeBroadcast().then(() => snapshot);
    }
    function buildNetworkSnapshot$a(luvio, config, options) {
      const resourceParams = createResourceParams$a(config);
      const request = createResourceRequest$a(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess(luvio, config, resourceParams, response), () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$a(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext) {
      return luvioEngine.buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshot$a, undefined, false);
    }
    function buildCachedSnapshotCachePolicy(context, storeLookup) {
      const {
        luvio,
        config
      } = context;
      const selector = {
        recordId: keyBuilder$2(luvio, config),
        node: adapterFragment(luvio, config),
        variables: {}
      };
      const cacheSnapshot = storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$a(luvio, config, snapshotRefreshOptions)
      });
      return cacheSnapshot;
    }
    const getWebUrlsAdapterFactory = luvio => function CMSAuthoring__getWebUrls(untrustedConfig, requestContext) {
      const config = validateAdapterConfig$a(untrustedConfig, getWebUrls_ConfigPropertyNames);
      // Invalid or incomplete config
      if (config === null) {
        return null;
      }
      return luvio.applyCachePolicy(requestContext || {}, {
        config,
        luvio
      },
      // BuildSnapshotContext
      buildCachedSnapshotCachePolicy, buildNetworkSnapshotCachePolicy);
    };
    function validate$6(obj, path = 'ManagedContentSpaceInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        if (obj.channels !== undefined) {
          const obj_channels = obj.channels;
          const path_channels = path + '.channels';
          if (!ArrayIsArray(obj_channels)) {
            return new TypeError('Expected "array" but received "' + typeof obj_channels + '" (at "' + path_channels + '")');
          }
          for (let i = 0; i < obj_channels.length; i++) {
            const obj_channels_item = obj_channels[i];
            const path_channels_item = path_channels + '[' + i + ']';
            if (typeof obj_channels_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_channels_item + '" (at "' + path_channels_item + '")');
            }
          }
        }
        if (obj.collaborators !== undefined) {
          const obj_collaborators = obj.collaborators;
          const path_collaborators = path + '.collaborators';
          if (!ArrayIsArray(obj_collaborators)) {
            return new TypeError('Expected "array" but received "' + typeof obj_collaborators + '" (at "' + path_collaborators + '")');
          }
          for (let i = 0; i < obj_collaborators.length; i++) {
            const obj_collaborators_item = obj_collaborators[i];
            const path_collaborators_item = path_collaborators + '[' + i + ']';
            if (typeof obj_collaborators_item !== 'object' || ArrayIsArray(obj_collaborators_item) || obj_collaborators_item === null) {
              return new TypeError('Expected "object" but received "' + typeof obj_collaborators_item + '" (at "' + path_collaborators_item + '")');
            }
          }
        }
        if (obj.defaultLanguage !== undefined) {
          const obj_defaultLanguage = obj.defaultLanguage;
          const path_defaultLanguage = path + '.defaultLanguage';
          if (typeof obj_defaultLanguage !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_defaultLanguage + '" (at "' + path_defaultLanguage + '")');
          }
        }
        if (obj.description !== undefined) {
          const obj_description = obj.description;
          const path_description = path + '.description';
          if (typeof obj_description !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_description + '" (at "' + path_description + '")');
          }
        }
        if (obj.isFlowOrchestrationEnabled !== undefined) {
          const obj_isFlowOrchestrationEnabled = obj.isFlowOrchestrationEnabled;
          const path_isFlowOrchestrationEnabled = path + '.isFlowOrchestrationEnabled';
          if (typeof obj_isFlowOrchestrationEnabled !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_isFlowOrchestrationEnabled + '" (at "' + path_isFlowOrchestrationEnabled + '")');
          }
        }
        if (obj.isSpaceV2 !== undefined) {
          const obj_isSpaceV2 = obj.isSpaceV2;
          const path_isSpaceV2 = path + '.isSpaceV2';
          if (typeof obj_isSpaceV2 !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_isSpaceV2 + '" (at "' + path_isSpaceV2 + '")');
          }
        }
        if (obj.isUndeletable !== undefined) {
          const obj_isUndeletable = obj.isUndeletable;
          const path_isUndeletable = path + '.isUndeletable';
          if (typeof obj_isUndeletable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_isUndeletable + '" (at "' + path_isUndeletable + '")');
          }
        }
        if (obj.name !== undefined) {
          const obj_name = obj.name;
          const path_name = path + '.name';
          if (typeof obj_name !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
          }
        }
        if (obj.supportedLanguages !== undefined) {
          const obj_supportedLanguages = obj.supportedLanguages;
          const path_supportedLanguages = path + '.supportedLanguages';
          if (!ArrayIsArray(obj_supportedLanguages)) {
            return new TypeError('Expected "array" but received "' + typeof obj_supportedLanguages + '" (at "' + path_supportedLanguages + '")');
          }
          for (let i = 0; i < obj_supportedLanguages.length; i++) {
            const obj_supportedLanguages_item = obj_supportedLanguages[i];
            const path_supportedLanguages_item = path_supportedLanguages + '[' + i + ']';
            if (typeof obj_supportedLanguages_item !== 'string') {
              return new TypeError('Expected "string" but received "' + typeof obj_supportedLanguages_item + '" (at "' + path_supportedLanguages_item + '")');
            }
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function select$b(luvio, params) {
      return select$E();
    }
    function getResponseCacheKeys$9(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$h(storeKeyMap, luvio, response);
    }
    function ingestSuccess$9(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$8(luvio, body);
      luvio.storeIngest(key, ingest$h, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$b(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$9(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/spaces/' + config.urlParams.contentSpaceId + '',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$9 = 'patchManagedContentSpace';
    const patchManagedContentSpace_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('ManagedContentSpaceInput', true, 2 /* Body */, 4 /* Unsupported */)];
    const patchManagedContentSpace_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$9, patchManagedContentSpace_ConfigPropertyMetadata);
    const createResourceParams$9 = /*#__PURE__*/luvioEngine.createResourceParams(patchManagedContentSpace_ConfigPropertyMetadata);
    function typeCheckConfig$9(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, patchManagedContentSpace_ConfigPropertyMetadata);
      const untrustedConfig_ManagedContentSpaceInput = untrustedConfig.ManagedContentSpaceInput;
      const referenceManagedContentSpaceInputRepresentationValidationError = validate$6(untrustedConfig_ManagedContentSpaceInput);
      if (referenceManagedContentSpaceInputRepresentationValidationError === null) {
        config.ManagedContentSpaceInput = untrustedConfig_ManagedContentSpaceInput;
      }
      return config;
    }
    function validateAdapterConfig$9(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$9(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$9(luvio, config, options) {
      const resourceParams = createResourceParams$9(config);
      const request = createResourceRequest$9(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$9(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$9(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const patchManagedContentSpaceAdapterFactory = luvio => {
      return function patchManagedContentSpace(untrustedConfig) {
        const config = validateAdapterConfig$9(untrustedConfig, patchManagedContentSpace_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "patchManagedContentSpace"');
        }
        return buildNetworkSnapshot$9(luvio, config);
      };
    };
    function select$a(luvio, params) {
      return select$C();
    }
    function getResponseCacheKeys$8(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$g(storeKeyMap, luvio, response);
    }
    function ingestSuccess$8(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$7(luvio, body);
      luvio.storeIngest(key, ingest$g, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$a(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$8(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/folders',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$8 = 'postManagedContentSpaceFolder';
    const postManagedContentSpaceFolder_ConfigPropertyMetadata = [generateParamConfigMetadata('name', true, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('parentFolderId', true, 2 /* Body */, 0 /* String */)];
    const postManagedContentSpaceFolder_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$8, postManagedContentSpaceFolder_ConfigPropertyMetadata);
    const createResourceParams$8 = /*#__PURE__*/luvioEngine.createResourceParams(postManagedContentSpaceFolder_ConfigPropertyMetadata);
    function typeCheckConfig$8(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, postManagedContentSpaceFolder_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$8(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$8(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$8(luvio, config, options) {
      const resourceParams = createResourceParams$8(config);
      const request = createResourceRequest$8(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$8(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$8(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const postManagedContentSpaceFolderAdapterFactory = luvio => {
      return function postManagedContentSpaceFolder(untrustedConfig) {
        const config = validateAdapterConfig$8(untrustedConfig, postManagedContentSpaceFolder_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "postManagedContentSpaceFolder"');
        }
        return buildNetworkSnapshot$8(luvio, config);
      };
    };
    const TTL$1 = 100;
    const VERSION$1 = "789bce2e581ff7969982fbf2ffbfd9a5";
    function validate$5(obj, path = 'ManagedContentPublishOutputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_deploymentId = obj.deploymentId;
        const path_deploymentId = path + '.deploymentId';
        if (typeof obj_deploymentId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_deploymentId + '" (at "' + path_deploymentId + '")');
        }
        const obj_description = obj.description;
        const path_description = path + '.description';
        let obj_description_union0 = null;
        const obj_description_union0_error = (() => {
          if (typeof obj_description !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_description + '" (at "' + path_description + '")');
          }
        })();
        if (obj_description_union0_error != null) {
          obj_description_union0 = obj_description_union0_error.message;
        }
        let obj_description_union1 = null;
        const obj_description_union1_error = (() => {
          if (obj_description !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_description + '" (at "' + path_description + '")');
          }
        })();
        if (obj_description_union1_error != null) {
          obj_description_union1 = obj_description_union1_error.message;
        }
        if (obj_description_union0 && obj_description_union1) {
          let message = 'Object doesn\'t match union (at "' + path_description + '")';
          message += '\n' + obj_description_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_description_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_publishDate = obj.publishDate;
        const path_publishDate = path + '.publishDate';
        let obj_publishDate_union0 = null;
        const obj_publishDate_union0_error = (() => {
          if (typeof obj_publishDate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_publishDate + '" (at "' + path_publishDate + '")');
          }
        })();
        if (obj_publishDate_union0_error != null) {
          obj_publishDate_union0 = obj_publishDate_union0_error.message;
        }
        let obj_publishDate_union1 = null;
        const obj_publishDate_union1_error = (() => {
          if (obj_publishDate !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_publishDate + '" (at "' + path_publishDate + '")');
          }
        })();
        if (obj_publishDate_union1_error != null) {
          obj_publishDate_union1 = obj_publishDate_union1_error.message;
        }
        if (obj_publishDate_union0 && obj_publishDate_union1) {
          let message = 'Object doesn\'t match union (at "' + path_publishDate + '")';
          message += '\n' + obj_publishDate_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_publishDate_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType$1 = 'ManagedContentPublishOutputRepresentation';
    function keyBuilder$1(luvio, config) {
      return keyPrefix + '::' + RepresentationType$1 + ':' + config.id;
    }
    function keyBuilderFromType$1(luvio, object) {
      const keyParams = {
        id: object.deploymentId
      };
      return keyBuilder$1(luvio, keyParams);
    }
    function normalize$1(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$9 = function ManagedContentPublishOutputRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION$1,
        private: [],
        opaque: true
      };
    };
    function equals$1(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest$1 = function ManagedContentPublishOutputRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$5(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType$1(luvio, input);
      const ttlToUse = TTL$1;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize$1, "CMSAuthoring", VERSION$1, RepresentationType$1, equals$1);
      return createLink(key);
    };
    function getTypeCacheKeys$1(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType$1(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType$1,
        mergeable: false
      });
    }
    function select$8(luvio, params) {
      return select$9();
    }
    function getResponseCacheKeys$7(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$1(storeKeyMap, luvio, response);
    }
    function ingestSuccess$7(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$1(luvio, body);
      luvio.storeIngest(key, ingest$1, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$8(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$7(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/publish',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$7 = 'publishManagedContent';
    const publishManagedContent_ConfigPropertyMetadata = [generateParamConfigMetadata('contentIds', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('description', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('includeContentReferences', false, 2 /* Body */, 1 /* Boolean */), generateParamConfigMetadata('variantIds', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('contextContentSpaceId', false, 2 /* Body */, 0 /* String */)];
    const publishManagedContent_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$7, publishManagedContent_ConfigPropertyMetadata);
    const createResourceParams$7 = /*#__PURE__*/luvioEngine.createResourceParams(publishManagedContent_ConfigPropertyMetadata);
    function typeCheckConfig$7(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, publishManagedContent_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$7(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$7(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$7(luvio, config, options) {
      const resourceParams = createResourceParams$7(config);
      const request = createResourceRequest$7(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$7(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$7(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const publishManagedContentAdapterFactory = luvio => {
      return function publishManagedContent(untrustedConfig) {
        const config = validateAdapterConfig$7(untrustedConfig, publishManagedContent_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "publishManagedContent"');
        }
        return buildNetworkSnapshot$7(luvio, config);
      };
    };
    function validate$4(obj, path = 'ManagedContentOrchestratorConfigInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_workflowConfigs = obj.workflowConfigs;
        const path_workflowConfigs = path + '.workflowConfigs';
        if (!ArrayIsArray(obj_workflowConfigs)) {
          return new TypeError('Expected "array" but received "' + typeof obj_workflowConfigs + '" (at "' + path_workflowConfigs + '")');
        }
        for (let i = 0; i < obj_workflowConfigs.length; i++) {
          const obj_workflowConfigs_item = obj_workflowConfigs[i];
          const path_workflowConfigs_item = path_workflowConfigs + '[' + i + ']';
          if (typeof obj_workflowConfigs_item !== 'object' || ArrayIsArray(obj_workflowConfigs_item) || obj_workflowConfigs_item === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_workflowConfigs_item + '" (at "' + path_workflowConfigs_item + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function select$7(luvio, params) {
      return select$x();
    }
    function getResponseCacheKeys$6(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$d(storeKeyMap, luvio, response);
    }
    function ingestSuccess$6(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$6(luvio, body);
      luvio.storeIngest(key, ingest$d, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$7(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$6(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/spaces/' + config.urlParams.contentSpaceId + '/orchestrator-config',
        method: 'put',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$6 = 'putManagedContentSpaceOrchestratorConfig';
    const putManagedContentSpaceOrchestratorConfig_ConfigPropertyMetadata = [generateParamConfigMetadata('contentSpaceId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('mContentOrchConfigInput', true, 2 /* Body */, 4 /* Unsupported */)];
    const putManagedContentSpaceOrchestratorConfig_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$6, putManagedContentSpaceOrchestratorConfig_ConfigPropertyMetadata);
    const createResourceParams$6 = /*#__PURE__*/luvioEngine.createResourceParams(putManagedContentSpaceOrchestratorConfig_ConfigPropertyMetadata);
    function typeCheckConfig$6(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, putManagedContentSpaceOrchestratorConfig_ConfigPropertyMetadata);
      const untrustedConfig_mContentOrchConfigInput = untrustedConfig.mContentOrchConfigInput;
      const referenceManagedContentOrchestratorConfigInputRepresentationValidationError = validate$4(untrustedConfig_mContentOrchConfigInput);
      if (referenceManagedContentOrchestratorConfigInputRepresentationValidationError === null) {
        config.mContentOrchConfigInput = untrustedConfig_mContentOrchConfigInput;
      }
      return config;
    }
    function validateAdapterConfig$6(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$6(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$6(luvio, config, options) {
      const resourceParams = createResourceParams$6(config);
      const request = createResourceRequest$6(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$6(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$6(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const putManagedContentSpaceOrchestratorConfigAdapterFactory = luvio => {
      return function putManagedContentSpaceOrchestratorConfig(untrustedConfig) {
        const config = validateAdapterConfig$6(untrustedConfig, putManagedContentSpaceOrchestratorConfig_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "putManagedContentSpaceOrchestratorConfig"');
        }
        return buildNetworkSnapshot$6(luvio, config);
      };
    };
    function validate$3(obj, path = 'ManagedContentVariantUpdateInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_contentBody = obj.contentBody;
        const path_contentBody = path + '.contentBody';
        if (typeof obj_contentBody !== 'object' || ArrayIsArray(obj_contentBody) || obj_contentBody === null) {
          return new TypeError('Expected "object" but received "' + typeof obj_contentBody + '" (at "' + path_contentBody + '")');
        }
        const obj_contentBody_keys = ObjectKeys(obj_contentBody);
        for (let i = 0; i < obj_contentBody_keys.length; i++) {
          const key = obj_contentBody_keys[i];
          const obj_contentBody_prop = obj_contentBody[key];
          const path_contentBody_prop = path_contentBody + '["' + key + '"]';
          if (obj_contentBody_prop === undefined) {
            return new TypeError('Expected "defined" but received "' + typeof obj_contentBody_prop + '" (at "' + path_contentBody_prop + '")');
          }
        }
        if (obj.title !== undefined) {
          const obj_title = obj.title;
          const path_title = path + '.title';
          if (typeof obj_title !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_title + '" (at "' + path_title + '")');
          }
        }
        if (obj.urlName !== undefined) {
          const obj_urlName = obj.urlName;
          const path_urlName = path + '.urlName';
          if (typeof obj_urlName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_urlName + '" (at "' + path_urlName + '")');
          }
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function select$6(luvio, params) {
      return select$1b();
    }
    function getResponseCacheKeys$5(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$v(storeKeyMap, luvio, response);
    }
    function ingestSuccess$5(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$e(luvio, body);
      luvio.storeIngest(key, ingest$v, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$6(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$5(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/variants/' + config.urlParams.variantId + '',
        method: 'put',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$5 = 'replaceManagedContentVariant';
    const replaceManagedContentVariant_ConfigPropertyMetadata = [generateParamConfigMetadata('variantId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('ManagedContentVariantInputParam', true, 2 /* Body */, 4 /* Unsupported */)];
    const replaceManagedContentVariant_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$5, replaceManagedContentVariant_ConfigPropertyMetadata);
    const createResourceParams$5 = /*#__PURE__*/luvioEngine.createResourceParams(replaceManagedContentVariant_ConfigPropertyMetadata);
    function typeCheckConfig$5(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, replaceManagedContentVariant_ConfigPropertyMetadata);
      const untrustedConfig_ManagedContentVariantInputParam = untrustedConfig.ManagedContentVariantInputParam;
      const referenceManagedContentVariantUpdateInputRepresentationValidationError = validate$3(untrustedConfig_ManagedContentVariantInputParam);
      if (referenceManagedContentVariantUpdateInputRepresentationValidationError === null) {
        config.ManagedContentVariantInputParam = untrustedConfig_ManagedContentVariantInputParam;
      }
      return config;
    }
    function validateAdapterConfig$5(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$5(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$5(luvio, config, options) {
      const resourceParams = createResourceParams$5(config);
      const request = createResourceRequest$5(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$5(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$5(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const replaceManagedContentVariantAdapterFactory = luvio => {
      return function replaceManagedContentVariant(untrustedConfig) {
        const config = validateAdapterConfig$5(untrustedConfig, replaceManagedContentVariant_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "replaceManagedContentVariant"');
        }
        return buildNetworkSnapshot$5(luvio, config);
      };
    };
    const TTL = 100;
    const VERSION = "2f473ff12e87a4fc2336695104ab8567";
    function validate$2(obj, path = 'ManagedContentUnpublishOutputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_deploymentId = obj.deploymentId;
        const path_deploymentId = path + '.deploymentId';
        if (typeof obj_deploymentId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_deploymentId + '" (at "' + path_deploymentId + '")');
        }
        const obj_description = obj.description;
        const path_description = path + '.description';
        let obj_description_union0 = null;
        const obj_description_union0_error = (() => {
          if (typeof obj_description !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_description + '" (at "' + path_description + '")');
          }
        })();
        if (obj_description_union0_error != null) {
          obj_description_union0 = obj_description_union0_error.message;
        }
        let obj_description_union1 = null;
        const obj_description_union1_error = (() => {
          if (obj_description !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_description + '" (at "' + path_description + '")');
          }
        })();
        if (obj_description_union1_error != null) {
          obj_description_union1 = obj_description_union1_error.message;
        }
        if (obj_description_union0 && obj_description_union1) {
          let message = 'Object doesn\'t match union (at "' + path_description + '")';
          message += '\n' + obj_description_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_description_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
        const obj_unpublishDate = obj.unpublishDate;
        const path_unpublishDate = path + '.unpublishDate';
        let obj_unpublishDate_union0 = null;
        const obj_unpublishDate_union0_error = (() => {
          if (typeof obj_unpublishDate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_unpublishDate + '" (at "' + path_unpublishDate + '")');
          }
        })();
        if (obj_unpublishDate_union0_error != null) {
          obj_unpublishDate_union0 = obj_unpublishDate_union0_error.message;
        }
        let obj_unpublishDate_union1 = null;
        const obj_unpublishDate_union1_error = (() => {
          if (obj_unpublishDate !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_unpublishDate + '" (at "' + path_unpublishDate + '")');
          }
        })();
        if (obj_unpublishDate_union1_error != null) {
          obj_unpublishDate_union1 = obj_unpublishDate_union1_error.message;
        }
        if (obj_unpublishDate_union0 && obj_unpublishDate_union1) {
          let message = 'Object doesn\'t match union (at "' + path_unpublishDate + '")';
          message += '\n' + obj_unpublishDate_union0.split('\n').map(line => '\t' + line).join('\n');
          message += '\n' + obj_unpublishDate_union1.split('\n').map(line => '\t' + line).join('\n');
          return new TypeError(message);
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    const RepresentationType = 'ManagedContentUnpublishOutputRepresentation';
    function keyBuilder(luvio, config) {
      return keyPrefix + '::' + RepresentationType + ':' + config.id;
    }
    function keyBuilderFromType(luvio, object) {
      const keyParams = {
        id: object.deploymentId
      };
      return keyBuilder(luvio, keyParams);
    }
    function normalize(input, existing, path, luvio, store, timestamp) {
      return input;
    }
    const select$5 = function ManagedContentUnpublishOutputRepresentationSelect() {
      return {
        kind: 'Fragment',
        version: VERSION,
        private: [],
        opaque: true
      };
    };
    function equals(existing, incoming) {
      if (JSONStringify(incoming) !== JSONStringify(existing)) {
        return false;
      }
      return true;
    }
    const ingest = function ManagedContentUnpublishOutputRepresentationIngest(input, path, luvio, store, timestamp) {
      {
        const validateError = validate$2(input);
        if (validateError !== null) {
          throw validateError;
        }
      }
      const key = keyBuilderFromType(luvio, input);
      const ttlToUse = TTL;
      luvioEngine.ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize, "CMSAuthoring", VERSION, RepresentationType, equals);
      return createLink(key);
    };
    function getTypeCacheKeys(rootKeySet, luvio, input, fullPathFactory) {
      // root cache key (uses fullPathFactory if keyBuilderFromType isn't defined)
      const rootKey = keyBuilderFromType(luvio, input);
      rootKeySet.set(rootKey, {
        namespace: keyPrefix,
        representationName: RepresentationType,
        mergeable: false
      });
    }
    function select$4(luvio, params) {
      return select$5();
    }
    function getResponseCacheKeys$4(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys(storeKeyMap, luvio, response);
    }
    function ingestSuccess$4(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType(luvio, body);
      luvio.storeIngest(key, ingest, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$4(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$4(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/unpublish',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$4 = 'unpublishManagedContent';
    const unpublishManagedContent_ConfigPropertyMetadata = [generateParamConfigMetadata('contentIds', false, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('description', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('variantIds', false, 2 /* Body */, 0 /* String */, true)];
    const unpublishManagedContent_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$4, unpublishManagedContent_ConfigPropertyMetadata);
    const createResourceParams$4 = /*#__PURE__*/luvioEngine.createResourceParams(unpublishManagedContent_ConfigPropertyMetadata);
    function typeCheckConfig$4(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, unpublishManagedContent_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$4(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$4(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$4(luvio, config, options) {
      const resourceParams = createResourceParams$4(config);
      const request = createResourceRequest$4(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$4(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$4(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const unpublishManagedContentAdapterFactory = luvio => {
      return function unpublishManagedContent(untrustedConfig) {
        const config = validateAdapterConfig$4(untrustedConfig, unpublishManagedContent_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "unpublishManagedContent"');
        }
        return buildNetworkSnapshot$4(luvio, config);
      };
    };
    function select$3(luvio, params) {
      return select$1i();
    }
    function getResponseCacheKeys$3(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$y(storeKeyMap, luvio, response);
    }
    function ingestSuccess$3(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$h(luvio, body);
      luvio.storeIngest(key, ingest$y, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$3(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$3(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/schedules/' + config.urlParams.deploymentId + '',
        method: 'patch',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$3 = 'updateDeployment';
    const updateDeployment_ConfigPropertyMetadata = [generateParamConfigMetadata('deploymentId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('isCancelled', false, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('scheduleDate', false, 1 /* QueryParameter */, 0 /* String */)];
    const updateDeployment_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$3, updateDeployment_ConfigPropertyMetadata);
    const createResourceParams$3 = /*#__PURE__*/luvioEngine.createResourceParams(updateDeployment_ConfigPropertyMetadata);
    function typeCheckConfig$3(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, updateDeployment_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$3(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$3(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$3(luvio, config, options) {
      const resourceParams = createResourceParams$3(config);
      const request = createResourceRequest$3(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$3(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$3(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const updateDeploymentAdapterFactory = luvio => {
      return function updateDeployment(untrustedConfig) {
        const config = validateAdapterConfig$3(untrustedConfig, updateDeployment_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "updateDeployment"');
        }
        return buildNetworkSnapshot$3(luvio, config);
      };
    };
    function validate$1(obj, path = 'MCSFolderShareInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_targetId = obj.targetId;
        const path_targetId = path + '.targetId';
        if (typeof obj_targetId !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_targetId + '" (at "' + path_targetId + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function select$2(luvio, params) {
      return select$U();
    }
    function getResponseCacheKeys$2(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$n(storeKeyMap, luvio, response);
    }
    function ingestSuccess$2(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$9(luvio, body);
      luvio.storeIngest(key, ingest$n, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$2(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$2(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/folders/' + config.urlParams.folderId + '/shares',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName$2 = 'updateMCSFolderShares';
    const updateMCSFolderShares_ConfigPropertyMetadata = [generateParamConfigMetadata('folderId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('shareWith', true, 2 /* Body */, 4 /* Unsupported */, true), generateParamConfigMetadata('unshareWith', true, 2 /* Body */, 0 /* String */, true)];
    const updateMCSFolderShares_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$2, updateMCSFolderShares_ConfigPropertyMetadata);
    const createResourceParams$2 = /*#__PURE__*/luvioEngine.createResourceParams(updateMCSFolderShares_ConfigPropertyMetadata);
    function typeCheckConfig$2(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, updateMCSFolderShares_ConfigPropertyMetadata);
      const untrustedConfig_shareWith = untrustedConfig.shareWith;
      if (ArrayIsArray$1(untrustedConfig_shareWith)) {
        const untrustedConfig_shareWith_array = [];
        for (let i = 0, arrayLength = untrustedConfig_shareWith.length; i < arrayLength; i++) {
          const untrustedConfig_shareWith_item = untrustedConfig_shareWith[i];
          const referenceMCSFolderShareInputRepresentationValidationError = validate$1(untrustedConfig_shareWith_item);
          if (referenceMCSFolderShareInputRepresentationValidationError === null) {
            untrustedConfig_shareWith_array.push(untrustedConfig_shareWith_item);
          }
        }
        config.shareWith = untrustedConfig_shareWith_array;
      }
      return config;
    }
    function validateAdapterConfig$2(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$2(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$2(luvio, config, options) {
      const resourceParams = createResourceParams$2(config);
      const request = createResourceRequest$2(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$2(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$2(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const updateMCSFolderSharesAdapterFactory = luvio => {
      return function updateMCSFolderShares(untrustedConfig) {
        const config = validateAdapterConfig$2(untrustedConfig, updateMCSFolderShares_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "updateMCSFolderShares"');
        }
        return buildNetworkSnapshot$2(luvio, config);
      };
    };
    function select$1(luvio, params) {
      return select$r();
    }
    function getResponseCacheKeys$1(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$9(storeKeyMap, luvio, response);
    }
    function ingestSuccess$1(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$4(luvio, body);
      luvio.storeIngest(key, ingest$9, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$1(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest$1(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/' + config.urlParams.contentKeyOrId + '/taxonomy-terms',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const adapterName$1 = 'updateManagedContentTaxonomyTerms';
    const updateManagedContentTaxonomyTerms_ConfigPropertyMetadata = [generateParamConfigMetadata('contentKeyOrId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('publish', true, 1 /* QueryParameter */, 1 /* Boolean */), generateParamConfigMetadata('termsToAdd', true, 2 /* Body */, 0 /* String */, true), generateParamConfigMetadata('termsToRemove', true, 2 /* Body */, 0 /* String */, true)];
    const updateManagedContentTaxonomyTerms_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName$1, updateManagedContentTaxonomyTerms_ConfigPropertyMetadata);
    const createResourceParams$1 = /*#__PURE__*/luvioEngine.createResourceParams(updateManagedContentTaxonomyTerms_ConfigPropertyMetadata);
    function typeCheckConfig$1(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, updateManagedContentTaxonomyTerms_ConfigPropertyMetadata);
      return config;
    }
    function validateAdapterConfig$1(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig$1(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot$1(luvio, config, options) {
      const resourceParams = createResourceParams$1(config);
      const request = createResourceRequest$1(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess$1(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys$1(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const updateManagedContentTaxonomyTermsAdapterFactory = luvio => {
      return function updateManagedContentTaxonomyTerms(untrustedConfig) {
        const config = validateAdapterConfig$1(untrustedConfig, updateManagedContentTaxonomyTerms_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "updateManagedContentTaxonomyTerms"');
        }
        return buildNetworkSnapshot$1(luvio, config);
      };
    };
    function validate(obj, path = 'ManagedContentWebUrlRedirectInfoInputRepresentation') {
      const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray(obj) || obj === null) {
          return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_redirectUrl = obj.redirectUrl;
        const path_redirectUrl = path + '.redirectUrl';
        if (typeof obj_redirectUrl !== 'string') {
          return new TypeError('Expected "string" but received "' + typeof obj_redirectUrl + '" (at "' + path_redirectUrl + '")');
        }
      })();
      return v_error === undefined ? null : v_error;
    }
    function select(luvio, params) {
      return select$e();
    }
    function getResponseCacheKeys(storeKeyMap, luvio, resourceParams, response) {
      getTypeCacheKeys$3(storeKeyMap, luvio, response);
    }
    function ingestSuccess(luvio, resourceParams, response) {
      const {
        body
      } = response;
      const key = keyBuilderFromType$2(luvio, body);
      luvio.storeIngest(key, ingest$3, body);
      const snapshot = luvio.storeLookup({
        recordId: key,
        node: select(),
        variables: {}
      });
      {
        if (snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
      }
      luvioEngine.deepFreeze(snapshot.data);
      return snapshot;
    }
    function createResourceRequest(config) {
      const headers = {};
      return {
        baseUri: '/services/data/v62.0',
        basePath: '/connect/cms/contents/web-urls/' + config.urlParams.managedContentWebUrlId + '',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    const adapterName = 'updateManagedContentWebUrl';
    const updateManagedContentWebUrl_ConfigPropertyMetadata = [generateParamConfigMetadata('managedContentWebUrlId', true, 0 /* UrlParameter */, 0 /* String */), generateParamConfigMetadata('redirectInfo', false, 2 /* Body */, 4 /* Unsupported */), generateParamConfigMetadata('status', false, 2 /* Body */, 0 /* String */), generateParamConfigMetadata('urlAlias', false, 2 /* Body */, 0 /* String */)];
    const updateManagedContentWebUrl_ConfigPropertyNames = /*#__PURE__*/buildAdapterValidationConfig(adapterName, updateManagedContentWebUrl_ConfigPropertyMetadata);
    const createResourceParams = /*#__PURE__*/luvioEngine.createResourceParams(updateManagedContentWebUrl_ConfigPropertyMetadata);
    function typeCheckConfig(untrustedConfig) {
      const config = {};
      luvioEngine.typeCheckConfig(untrustedConfig, config, updateManagedContentWebUrl_ConfigPropertyMetadata);
      const untrustedConfig_redirectInfo = untrustedConfig.redirectInfo;
      const referenceManagedContentWebUrlRedirectInfoInputRepresentationValidationError = validate(untrustedConfig_redirectInfo);
      if (referenceManagedContentWebUrlRedirectInfoInputRepresentationValidationError === null) {
        config.redirectInfo = untrustedConfig_redirectInfo;
      }
      return config;
    }
    function validateAdapterConfig(untrustedConfig, configPropertyNames) {
      if (!untrustedIsObject(untrustedConfig)) {
        return null;
      }
      {
        validateConfig(untrustedConfig, configPropertyNames);
      }
      const config = typeCheckConfig(untrustedConfig);
      if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
      }
      return config;
    }
    function buildNetworkSnapshot(luvio, config, options) {
      const resourceParams = createResourceParams(config);
      const request = createResourceRequest(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => {
          const snapshot = ingestSuccess(luvio, resourceParams, response);
          return luvio.storeBroadcast().then(() => snapshot);
        }, () => {
          const cache = new luvioEngine.StoreKeyMap();
          getResponseCacheKeys(cache, luvio, resourceParams, response.body);
          return cache;
        });
      }, response => {
        luvioEngine.deepFreeze(response);
        throw response;
      });
    }
    const updateManagedContentWebUrlAdapterFactory = luvio => {
      return function updateManagedContentWebUrl(untrustedConfig) {
        const config = validateAdapterConfig(untrustedConfig, updateManagedContentWebUrl_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
          throw new Error('Invalid config for "updateManagedContentWebUrl"');
        }
        return buildNetworkSnapshot(luvio, config);
      };
    };
    exports.cloneManagedContentDocument = void 0;
    exports.createDeployment = void 0;
    exports.createManagedContent = void 0;
    exports.createManagedContentExportV2Job = void 0;
    exports.createManagedContentImportV2Job = void 0;
    exports.createManagedContentTranslationVariants = void 0;
    exports.createManagedContentVariant = void 0;
    exports.createSchedule = void 0;
    exports.createTranslationV2Job = void 0;
    exports.deleteManagedContentVariant = void 0;
    exports.getAllCMSJobsForSpace = void 0;
    exports.getCMSJobForSpace = void 0;
    exports.getCMSJobForSpaceNotifyChange = void 0;
    exports.getCollectionItems = void 0;
    exports.getDeployments = void 0;
    exports.getMCSFolderShareTargets = void 0;
    exports.getMCSFolderShares = void 0;
    exports.getMCSFolderSharesNotifyChange = void 0;
    exports.getManagedContent = void 0;
    exports.getManagedContentByFolderId = void 0;
    exports.getManagedContentForSite = void 0;
    exports.getManagedContentPreviews = void 0;
    exports.getManagedContentProviders = void 0;
    exports.getManagedContentReferencedBy = void 0;
    exports.getManagedContentSingleItem = void 0;
    exports.getManagedContentSpace = void 0;
    exports.getManagedContentSpaceFolder = void 0;
    exports.getManagedContentSpaceFolderItemsV1 = void 0;
    exports.getManagedContentSpaceNotifyChange = void 0;
    exports.getManagedContentSpaceOrchestratorConfig = void 0;
    exports.getManagedContentSpaceOrchestratorConfigNotifyChange = void 0;
    exports.getManagedContentSpaces = void 0;
    exports.getManagedContentTaxonomyTerms = void 0;
    exports.getManagedContentTypesForMixin = void 0;
    exports.getManagedContentVariant = void 0;
    exports.getManagedContentVariantNotifyChange = void 0;
    exports.getManagedContentVariantReferences = void 0;
    exports.getManagedContentVariantRendition = void 0;
    exports.getManagedContentVariantVersions = void 0;
    exports.getManagedContentVariantVersionsNotifyChange = void 0;
    exports.getSearchResults = void 0;
    exports.getWebUrls = void 0;
    exports.patchManagedContentSpace = void 0;
    exports.postManagedContentSpaceFolder = void 0;
    exports.publishManagedContent = void 0;
    exports.putManagedContentSpaceOrchestratorConfig = void 0;
    exports.replaceManagedContentVariant = void 0;
    exports.unpublishManagedContent = void 0;
    exports.updateDeployment = void 0;
    exports.updateMCSFolderShares = void 0;
    exports.updateManagedContentTaxonomyTerms = void 0;
    exports.updateManagedContentWebUrl = void 0;
    // Imperative GET Adapters
    exports.getAllCMSJobsForSpace_imperative = void 0;
    exports.getCMSJobForSpace_imperative = void 0;
    exports.getCollectionItems_imperative = void 0;
    exports.getDeployments_imperative = void 0;
    exports.getMCSFolderShareTargets_imperative = void 0;
    exports.getMCSFolderShares_imperative = void 0;
    exports.getManagedContent_imperative = void 0;
    exports.getManagedContentByFolderId_imperative = void 0;
    exports.getManagedContentForSite_imperative = void 0;
    exports.getManagedContentPreviews_imperative = void 0;
    exports.getManagedContentProviders_imperative = void 0;
    exports.getManagedContentReferencedBy_imperative = void 0;
    exports.getManagedContentSingleItem_imperative = void 0;
    exports.getManagedContentSpace_imperative = void 0;
    exports.getManagedContentSpaceFolder_imperative = void 0;
    exports.getManagedContentSpaceFolderItemsV1_imperative = void 0;
    exports.getManagedContentSpaceOrchestratorConfig_imperative = void 0;
    exports.getManagedContentSpaces_imperative = void 0;
    exports.getManagedContentTaxonomyTerms_imperative = void 0;
    exports.getManagedContentTypesForMixin_imperative = void 0;
    exports.getManagedContentVariant_imperative = void 0;
    exports.getManagedContentVariantReferences_imperative = void 0;
    exports.getManagedContentVariantRendition_imperative = void 0;
    exports.getManagedContentVariantVersions_imperative = void 0;
    exports.getSearchResults_imperative = void 0;
    exports.getWebUrls_imperative = void 0;
    const getAllCMSJobsForSpaceMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getAllCMSJobsForSpace',
      ttl: 100
    };
    const getCMSJobForSpaceMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getCMSJobForSpace',
      ttl: 100
    };
    const getCollectionItemsMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getCollectionItems',
      ttl: 100
    };
    const getDeploymentsMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getDeployments',
      ttl: 100
    };
    const getMCSFolderShareTargetsMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getMCSFolderShareTargets',
      ttl: 1000
    };
    const getMCSFolderSharesMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getMCSFolderShares',
      ttl: 1000
    };
    const getManagedContentMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContent',
      ttl: 100
    };
    const getManagedContentByFolderIdMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentByFolderId',
      ttl: 100
    };
    const getManagedContentForSiteMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentForSite',
      ttl: 100
    };
    const getManagedContentPreviewsMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentPreviews',
      ttl: 1000
    };
    const getManagedContentProvidersMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentProviders',
      ttl: 120000
    };
    const getManagedContentReferencedByMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentReferencedBy',
      ttl: 100
    };
    const getManagedContentSingleItemMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentSingleItem',
      ttl: 100
    };
    const getManagedContentSpaceMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentSpace',
      ttl: 100
    };
    const getManagedContentSpaceFolderMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentSpaceFolder',
      ttl: 30000
    };
    const getManagedContentSpaceFolderItemsV1Metadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentSpaceFolderItemsV1',
      ttl: 100
    };
    const getManagedContentSpaceOrchestratorConfigMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentSpaceOrchestratorConfig',
      ttl: 100
    };
    const getManagedContentSpacesMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentSpaces',
      ttl: 100
    };
    const getManagedContentTaxonomyTermsMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentTaxonomyTerms',
      ttl: 100
    };
    const getManagedContentTypesForMixinMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentTypesForMixin',
      ttl: 120000
    };
    const getManagedContentVariantMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentVariant',
      ttl: 3600000
    };
    const getManagedContentVariantReferencesMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentVariantReferences',
      ttl: 100
    };
    const getManagedContentVariantRenditionMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentVariantRendition',
      ttl: 1000
    };
    const getManagedContentVariantVersionsMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getManagedContentVariantVersions',
      ttl: 100
    };
    const getSearchResultsMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getSearchResults',
      ttl: 100
    };
    const getWebUrlsMetadata = {
      apiFamily: 'CMSAuthoring',
      name: 'getWebUrls',
      ttl: 100
    };
    // Notify Update Available
    function bindExportsTo(luvio) {
      // LDS Adapters
      const getAllCMSJobsForSpace_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getAllCMSJobsForSpace', getAllCMSJobsForSpaceAdapterFactory), getAllCMSJobsForSpaceMetadata);
      const getCMSJobForSpace_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getCMSJobForSpace', getCMSJobForSpaceAdapterFactory), getCMSJobForSpaceMetadata);
      const getCollectionItems_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getCollectionItems', getCollectionItemsAdapterFactory), getCollectionItemsMetadata);
      const getDeployments_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getDeployments', getDeploymentsAdapterFactory), getDeploymentsMetadata);
      const getMCSFolderShareTargets_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getMCSFolderShareTargets', getMCSFolderShareTargetsAdapterFactory), getMCSFolderShareTargetsMetadata);
      const getMCSFolderShares_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getMCSFolderShares', getMCSFolderSharesAdapterFactory), getMCSFolderSharesMetadata);
      const getManagedContent_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContent', getManagedContentAdapterFactory), getManagedContentMetadata);
      const getManagedContentByFolderId_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentByFolderId', getManagedContentByFolderIdAdapterFactory), getManagedContentByFolderIdMetadata);
      const getManagedContentForSite_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentForSite', getManagedContentForSiteAdapterFactory), getManagedContentForSiteMetadata);
      const getManagedContentPreviews_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentPreviews', getManagedContentPreviewsAdapterFactory), getManagedContentPreviewsMetadata);
      const getManagedContentProviders_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentProviders', getManagedContentProvidersAdapterFactory), getManagedContentProvidersMetadata);
      const getManagedContentReferencedBy_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentReferencedBy', getManagedContentReferencedByAdapterFactory), getManagedContentReferencedByMetadata);
      const getManagedContentSingleItem_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentSingleItem', getManagedContentSingleItemAdapterFactory), getManagedContentSingleItemMetadata);
      const getManagedContentSpace_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentSpace', getManagedContentSpaceAdapterFactory), getManagedContentSpaceMetadata);
      const getManagedContentSpaceFolder_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentSpaceFolder', getManagedContentSpaceFolderAdapterFactory), getManagedContentSpaceFolderMetadata);
      const getManagedContentSpaceFolderItemsV1_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentSpaceFolderItemsV1', getManagedContentSpaceFolderItemsV1AdapterFactory), getManagedContentSpaceFolderItemsV1Metadata);
      const getManagedContentSpaceOrchestratorConfig_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentSpaceOrchestratorConfig', getManagedContentSpaceOrchestratorConfigAdapterFactory), getManagedContentSpaceOrchestratorConfigMetadata);
      const getManagedContentSpaces_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentSpaces', getManagedContentSpacesAdapterFactory), getManagedContentSpacesMetadata);
      const getManagedContentTaxonomyTerms_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentTaxonomyTerms', getManagedContentTaxonomyTermsAdapterFactory), getManagedContentTaxonomyTermsMetadata);
      const getManagedContentTypesForMixin_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentTypesForMixin', getManagedContentTypesForMixinAdapterFactory), getManagedContentTypesForMixinMetadata);
      const getManagedContentVariant_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentVariant', getManagedContentVariantAdapterFactory), getManagedContentVariantMetadata);
      const getManagedContentVariantReferences_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentVariantReferences', getManagedContentVariantReferencesAdapterFactory), getManagedContentVariantReferencesMetadata);
      const getManagedContentVariantRendition_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentVariantRendition', getManagedContentVariantRenditionAdapterFactory), getManagedContentVariantRenditionMetadata);
      const getManagedContentVariantVersions_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getManagedContentVariantVersions', getManagedContentVariantVersionsAdapterFactory), getManagedContentVariantVersionsMetadata);
      const getSearchResults_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getSearchResults', getSearchResultsAdapterFactory), getSearchResultsMetadata);
      const getWebUrls_ldsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, 'getWebUrls', getWebUrlsAdapterFactory), getWebUrlsMetadata);
      function unwrapSnapshotData(factory) {
        const adapter = factory(luvio);
        return config => adapter(config).then(snapshot => snapshot.data);
      }
      return {
        cloneManagedContentDocument: unwrapSnapshotData(cloneManagedContentDocumentAdapterFactory),
        createDeployment: unwrapSnapshotData(createDeploymentAdapterFactory),
        createManagedContent: unwrapSnapshotData(createManagedContentAdapterFactory),
        createManagedContentExportV2Job: unwrapSnapshotData(createManagedContentExportV2JobAdapterFactory),
        createManagedContentImportV2Job: unwrapSnapshotData(createManagedContentImportV2JobAdapterFactory),
        createManagedContentTranslationVariants: unwrapSnapshotData(createManagedContentTranslationVariantsAdapterFactory),
        createManagedContentVariant: unwrapSnapshotData(createManagedContentVariantAdapterFactory),
        createSchedule: unwrapSnapshotData(createScheduleAdapterFactory),
        createTranslationV2Job: unwrapSnapshotData(createTranslationV2JobAdapterFactory),
        deleteManagedContentVariant: ldsBindings.createLDSAdapter(luvio, adapterName$A, deleteManagedContentVariantAdapterFactory),
        getAllCMSJobsForSpace: ldsBindings.createWireAdapterConstructor(luvio, getAllCMSJobsForSpace_ldsAdapter, getAllCMSJobsForSpaceMetadata),
        getCMSJobForSpace: ldsBindings.createWireAdapterConstructor(luvio, getCMSJobForSpace_ldsAdapter, getCMSJobForSpaceMetadata),
        getCMSJobForSpaceNotifyChange: ldsBindings.createLDSAdapter(luvio, 'getCMSJobForSpaceNotifyChange', notifyChangeFactory$5),
        getCollectionItems: ldsBindings.createWireAdapterConstructor(luvio, getCollectionItems_ldsAdapter, getCollectionItemsMetadata),
        getDeployments: ldsBindings.createWireAdapterConstructor(luvio, getDeployments_ldsAdapter, getDeploymentsMetadata),
        getMCSFolderShareTargets: ldsBindings.createWireAdapterConstructor(luvio, getMCSFolderShareTargets_ldsAdapter, getMCSFolderShareTargetsMetadata),
        getMCSFolderShares: ldsBindings.createWireAdapterConstructor(luvio, getMCSFolderShares_ldsAdapter, getMCSFolderSharesMetadata),
        getMCSFolderSharesNotifyChange: ldsBindings.createLDSAdapter(luvio, 'getMCSFolderSharesNotifyChange', notifyChangeFactory$4),
        getManagedContent: ldsBindings.createWireAdapterConstructor(luvio, getManagedContent_ldsAdapter, getManagedContentMetadata),
        getManagedContentByFolderId: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentByFolderId_ldsAdapter, getManagedContentByFolderIdMetadata),
        getManagedContentForSite: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentForSite_ldsAdapter, getManagedContentForSiteMetadata),
        getManagedContentPreviews: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentPreviews_ldsAdapter, getManagedContentPreviewsMetadata),
        getManagedContentProviders: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentProviders_ldsAdapter, getManagedContentProvidersMetadata),
        getManagedContentReferencedBy: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentReferencedBy_ldsAdapter, getManagedContentReferencedByMetadata),
        getManagedContentSingleItem: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentSingleItem_ldsAdapter, getManagedContentSingleItemMetadata),
        getManagedContentSpace: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentSpace_ldsAdapter, getManagedContentSpaceMetadata),
        getManagedContentSpaceFolder: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentSpaceFolder_ldsAdapter, getManagedContentSpaceFolderMetadata),
        getManagedContentSpaceFolderItemsV1: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentSpaceFolderItemsV1_ldsAdapter, getManagedContentSpaceFolderItemsV1Metadata),
        getManagedContentSpaceNotifyChange: ldsBindings.createLDSAdapter(luvio, 'getManagedContentSpaceNotifyChange', notifyChangeFactory$3),
        getManagedContentSpaceOrchestratorConfig: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentSpaceOrchestratorConfig_ldsAdapter, getManagedContentSpaceOrchestratorConfigMetadata),
        getManagedContentSpaceOrchestratorConfigNotifyChange: ldsBindings.createLDSAdapter(luvio, 'getManagedContentSpaceOrchestratorConfigNotifyChange', notifyChangeFactory$2),
        getManagedContentSpaces: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentSpaces_ldsAdapter, getManagedContentSpacesMetadata),
        getManagedContentTaxonomyTerms: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentTaxonomyTerms_ldsAdapter, getManagedContentTaxonomyTermsMetadata),
        getManagedContentTypesForMixin: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentTypesForMixin_ldsAdapter, getManagedContentTypesForMixinMetadata),
        getManagedContentVariant: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentVariant_ldsAdapter, getManagedContentVariantMetadata),
        getManagedContentVariantNotifyChange: ldsBindings.createLDSAdapter(luvio, 'getManagedContentVariantNotifyChange', notifyChangeFactory$1),
        getManagedContentVariantReferences: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentVariantReferences_ldsAdapter, getManagedContentVariantReferencesMetadata),
        getManagedContentVariantRendition: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentVariantRendition_ldsAdapter, getManagedContentVariantRenditionMetadata),
        getManagedContentVariantVersions: ldsBindings.createWireAdapterConstructor(luvio, getManagedContentVariantVersions_ldsAdapter, getManagedContentVariantVersionsMetadata),
        getManagedContentVariantVersionsNotifyChange: ldsBindings.createLDSAdapter(luvio, 'getManagedContentVariantVersionsNotifyChange', notifyChangeFactory),
        getSearchResults: ldsBindings.createWireAdapterConstructor(luvio, getSearchResults_ldsAdapter, getSearchResultsMetadata),
        getWebUrls: ldsBindings.createWireAdapterConstructor(luvio, getWebUrls_ldsAdapter, getWebUrlsMetadata),
        patchManagedContentSpace: unwrapSnapshotData(patchManagedContentSpaceAdapterFactory),
        postManagedContentSpaceFolder: unwrapSnapshotData(postManagedContentSpaceFolderAdapterFactory),
        publishManagedContent: unwrapSnapshotData(publishManagedContentAdapterFactory),
        putManagedContentSpaceOrchestratorConfig: unwrapSnapshotData(putManagedContentSpaceOrchestratorConfigAdapterFactory),
        replaceManagedContentVariant: unwrapSnapshotData(replaceManagedContentVariantAdapterFactory),
        unpublishManagedContent: unwrapSnapshotData(unpublishManagedContentAdapterFactory),
        updateDeployment: unwrapSnapshotData(updateDeploymentAdapterFactory),
        updateMCSFolderShares: unwrapSnapshotData(updateMCSFolderSharesAdapterFactory),
        updateManagedContentTaxonomyTerms: unwrapSnapshotData(updateManagedContentTaxonomyTermsAdapterFactory),
        updateManagedContentWebUrl: unwrapSnapshotData(updateManagedContentWebUrlAdapterFactory),
        // Imperative GET Adapters
        getAllCMSJobsForSpace_imperative: ldsBindings.createImperativeAdapter(luvio, getAllCMSJobsForSpace_ldsAdapter, getAllCMSJobsForSpaceMetadata),
        getCMSJobForSpace_imperative: ldsBindings.createImperativeAdapter(luvio, getCMSJobForSpace_ldsAdapter, getCMSJobForSpaceMetadata),
        getCollectionItems_imperative: ldsBindings.createImperativeAdapter(luvio, getCollectionItems_ldsAdapter, getCollectionItemsMetadata),
        getDeployments_imperative: ldsBindings.createImperativeAdapter(luvio, getDeployments_ldsAdapter, getDeploymentsMetadata),
        getMCSFolderShareTargets_imperative: ldsBindings.createImperativeAdapter(luvio, getMCSFolderShareTargets_ldsAdapter, getMCSFolderShareTargetsMetadata),
        getMCSFolderShares_imperative: ldsBindings.createImperativeAdapter(luvio, getMCSFolderShares_ldsAdapter, getMCSFolderSharesMetadata),
        getManagedContent_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContent_ldsAdapter, getManagedContentMetadata),
        getManagedContentByFolderId_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentByFolderId_ldsAdapter, getManagedContentByFolderIdMetadata),
        getManagedContentForSite_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentForSite_ldsAdapter, getManagedContentForSiteMetadata),
        getManagedContentPreviews_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentPreviews_ldsAdapter, getManagedContentPreviewsMetadata),
        getManagedContentProviders_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentProviders_ldsAdapter, getManagedContentProvidersMetadata),
        getManagedContentReferencedBy_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentReferencedBy_ldsAdapter, getManagedContentReferencedByMetadata),
        getManagedContentSingleItem_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentSingleItem_ldsAdapter, getManagedContentSingleItemMetadata),
        getManagedContentSpace_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentSpace_ldsAdapter, getManagedContentSpaceMetadata),
        getManagedContentSpaceFolder_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentSpaceFolder_ldsAdapter, getManagedContentSpaceFolderMetadata),
        getManagedContentSpaceFolderItemsV1_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentSpaceFolderItemsV1_ldsAdapter, getManagedContentSpaceFolderItemsV1Metadata),
        getManagedContentSpaceOrchestratorConfig_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentSpaceOrchestratorConfig_ldsAdapter, getManagedContentSpaceOrchestratorConfigMetadata),
        getManagedContentSpaces_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentSpaces_ldsAdapter, getManagedContentSpacesMetadata),
        getManagedContentTaxonomyTerms_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentTaxonomyTerms_ldsAdapter, getManagedContentTaxonomyTermsMetadata),
        getManagedContentTypesForMixin_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentTypesForMixin_ldsAdapter, getManagedContentTypesForMixinMetadata),
        getManagedContentVariant_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentVariant_ldsAdapter, getManagedContentVariantMetadata),
        getManagedContentVariantReferences_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentVariantReferences_ldsAdapter, getManagedContentVariantReferencesMetadata),
        getManagedContentVariantRendition_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentVariantRendition_ldsAdapter, getManagedContentVariantRenditionMetadata),
        getManagedContentVariantVersions_imperative: ldsBindings.createImperativeAdapter(luvio, getManagedContentVariantVersions_ldsAdapter, getManagedContentVariantVersionsMetadata),
        getSearchResults_imperative: ldsBindings.createImperativeAdapter(luvio, getSearchResults_ldsAdapter, getSearchResultsMetadata),
        getWebUrls_imperative: ldsBindings.createImperativeAdapter(luvio, getWebUrls_ldsAdapter, getWebUrlsMetadata)
        // Notify Update Availables
      };
    }
    ldsEngine.withDefaultLuvio(luvio => {
      ({
        cloneManagedContentDocument: exports.cloneManagedContentDocument,
        createDeployment: exports.createDeployment,
        createManagedContent: exports.createManagedContent,
        createManagedContentExportV2Job: exports.createManagedContentExportV2Job,
        createManagedContentImportV2Job: exports.createManagedContentImportV2Job,
        createManagedContentTranslationVariants: exports.createManagedContentTranslationVariants,
        createManagedContentVariant: exports.createManagedContentVariant,
        createSchedule: exports.createSchedule,
        createTranslationV2Job: exports.createTranslationV2Job,
        deleteManagedContentVariant: exports.deleteManagedContentVariant,
        getAllCMSJobsForSpace: exports.getAllCMSJobsForSpace,
        getCMSJobForSpace: exports.getCMSJobForSpace,
        getCMSJobForSpaceNotifyChange: exports.getCMSJobForSpaceNotifyChange,
        getCollectionItems: exports.getCollectionItems,
        getDeployments: exports.getDeployments,
        getMCSFolderShareTargets: exports.getMCSFolderShareTargets,
        getMCSFolderShares: exports.getMCSFolderShares,
        getMCSFolderSharesNotifyChange: exports.getMCSFolderSharesNotifyChange,
        getManagedContent: exports.getManagedContent,
        getManagedContentByFolderId: exports.getManagedContentByFolderId,
        getManagedContentForSite: exports.getManagedContentForSite,
        getManagedContentPreviews: exports.getManagedContentPreviews,
        getManagedContentProviders: exports.getManagedContentProviders,
        getManagedContentReferencedBy: exports.getManagedContentReferencedBy,
        getManagedContentSingleItem: exports.getManagedContentSingleItem,
        getManagedContentSpace: exports.getManagedContentSpace,
        getManagedContentSpaceFolder: exports.getManagedContentSpaceFolder,
        getManagedContentSpaceFolderItemsV1: exports.getManagedContentSpaceFolderItemsV1,
        getManagedContentSpaceNotifyChange: exports.getManagedContentSpaceNotifyChange,
        getManagedContentSpaceOrchestratorConfig: exports.getManagedContentSpaceOrchestratorConfig,
        getManagedContentSpaceOrchestratorConfigNotifyChange: exports.getManagedContentSpaceOrchestratorConfigNotifyChange,
        getManagedContentSpaces: exports.getManagedContentSpaces,
        getManagedContentTaxonomyTerms: exports.getManagedContentTaxonomyTerms,
        getManagedContentTypesForMixin: exports.getManagedContentTypesForMixin,
        getManagedContentVariant: exports.getManagedContentVariant,
        getManagedContentVariantNotifyChange: exports.getManagedContentVariantNotifyChange,
        getManagedContentVariantReferences: exports.getManagedContentVariantReferences,
        getManagedContentVariantRendition: exports.getManagedContentVariantRendition,
        getManagedContentVariantVersions: exports.getManagedContentVariantVersions,
        getManagedContentVariantVersionsNotifyChange: exports.getManagedContentVariantVersionsNotifyChange,
        getSearchResults: exports.getSearchResults,
        getWebUrls: exports.getWebUrls,
        patchManagedContentSpace: exports.patchManagedContentSpace,
        postManagedContentSpaceFolder: exports.postManagedContentSpaceFolder,
        publishManagedContent: exports.publishManagedContent,
        putManagedContentSpaceOrchestratorConfig: exports.putManagedContentSpaceOrchestratorConfig,
        replaceManagedContentVariant: exports.replaceManagedContentVariant,
        unpublishManagedContent: exports.unpublishManagedContent,
        updateDeployment: exports.updateDeployment,
        updateMCSFolderShares: exports.updateMCSFolderShares,
        updateManagedContentTaxonomyTerms: exports.updateManagedContentTaxonomyTerms,
        updateManagedContentWebUrl: exports.updateManagedContentWebUrl,
        getAllCMSJobsForSpace_imperative: exports.getAllCMSJobsForSpace_imperative,
        getCMSJobForSpace_imperative: exports.getCMSJobForSpace_imperative,
        getCollectionItems_imperative: exports.getCollectionItems_imperative,
        getDeployments_imperative: exports.getDeployments_imperative,
        getMCSFolderShareTargets_imperative: exports.getMCSFolderShareTargets_imperative,
        getMCSFolderShares_imperative: exports.getMCSFolderShares_imperative,
        getManagedContent_imperative: exports.getManagedContent_imperative,
        getManagedContentByFolderId_imperative: exports.getManagedContentByFolderId_imperative,
        getManagedContentForSite_imperative: exports.getManagedContentForSite_imperative,
        getManagedContentPreviews_imperative: exports.getManagedContentPreviews_imperative,
        getManagedContentProviders_imperative: exports.getManagedContentProviders_imperative,
        getManagedContentReferencedBy_imperative: exports.getManagedContentReferencedBy_imperative,
        getManagedContentSingleItem_imperative: exports.getManagedContentSingleItem_imperative,
        getManagedContentSpace_imperative: exports.getManagedContentSpace_imperative,
        getManagedContentSpaceFolder_imperative: exports.getManagedContentSpaceFolder_imperative,
        getManagedContentSpaceFolderItemsV1_imperative: exports.getManagedContentSpaceFolderItemsV1_imperative,
        getManagedContentSpaceOrchestratorConfig_imperative: exports.getManagedContentSpaceOrchestratorConfig_imperative,
        getManagedContentSpaces_imperative: exports.getManagedContentSpaces_imperative,
        getManagedContentTaxonomyTerms_imperative: exports.getManagedContentTaxonomyTerms_imperative,
        getManagedContentTypesForMixin_imperative: exports.getManagedContentTypesForMixin_imperative,
        getManagedContentVariant_imperative: exports.getManagedContentVariant_imperative,
        getManagedContentVariantReferences_imperative: exports.getManagedContentVariantReferences_imperative,
        getManagedContentVariantRendition_imperative: exports.getManagedContentVariantRendition_imperative,
        getManagedContentVariantVersions_imperative: exports.getManagedContentVariantVersions_imperative,
        getSearchResults_imperative: exports.getSearchResults_imperative,
        getWebUrls_imperative: exports.getWebUrls_imperative
      } = bindExportsTo(luvio));
    });
    // version: 1.309.0-dev21-4baf03ecaf
    const __lwc_hmr_context = { moduleHash : 'e81e8f55483783f2bb3a08b887c70d6d' };
    if (lwc.hot) {
        lwc.hot.register('force/ldsAdaptersCmsAuthoring/ldsAdaptersCmsAuthoring.js', 'e81e8f55483783f2bb3a08b887c70d6d', {"name":"ldsAdaptersCmsAuthoring","namespace":"force","enableLightningWebSecurityTransforms":false,"experimentalDynamicComponent":{"loader":"@salesforce/loader","strictSpecifier":false},"experimentalDynamicDirective":false,"enableDynamicComponents":true,"enableStaticContentOptimization":true,"outputConfig":{"sourcemap":false}});
    }

    exports.__lwc_hmr_context = __lwc_hmr_context;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('interop/cmsAuthoringApi', ['exports', 'force/ldsAdaptersCmsAuthoring'], (function (exports, ldsAdaptersCmsAuthoring) {



    Object.defineProperty(exports, 'cloneManagedContentDocument', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.cloneManagedContentDocument; }
    });
    Object.defineProperty(exports, 'createDeployment', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.createDeployment; }
    });
    Object.defineProperty(exports, 'createManagedContent', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.createManagedContent; }
    });
    Object.defineProperty(exports, 'createManagedContentExportV2Job', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.createManagedContentExportV2Job; }
    });
    Object.defineProperty(exports, 'createManagedContentImportV2Job', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.createManagedContentImportV2Job; }
    });
    Object.defineProperty(exports, 'createManagedContentVariant', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.createManagedContentVariant; }
    });
    Object.defineProperty(exports, 'createSchedule', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.createSchedule; }
    });
    Object.defineProperty(exports, 'createTranslationV2Job', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.createTranslationV2Job; }
    });
    Object.defineProperty(exports, 'deleteManagedContentVariant', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.deleteManagedContentVariant; }
    });
    Object.defineProperty(exports, 'getAllCMSJobsForSpace', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getAllCMSJobsForSpace; }
    });
    Object.defineProperty(exports, 'getCMSJobForSpace', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getCMSJobForSpace; }
    });
    Object.defineProperty(exports, 'getCollectionItems', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getCollectionItems; }
    });
    Object.defineProperty(exports, 'getDeployments', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getDeployments; }
    });
    Object.defineProperty(exports, 'getMCSFolderShareTargets', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getMCSFolderShareTargets; }
    });
    Object.defineProperty(exports, 'getMCSFolderShares', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getMCSFolderShares; }
    });
    Object.defineProperty(exports, 'getManagedContent', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContent; }
    });
    Object.defineProperty(exports, 'getManagedContentByFolderId', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentByFolderId; }
    });
    Object.defineProperty(exports, 'getManagedContentForSite', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentForSite; }
    });
    Object.defineProperty(exports, 'getManagedContentPreviews', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentPreviews; }
    });
    Object.defineProperty(exports, 'getManagedContentProviders', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentProviders; }
    });
    Object.defineProperty(exports, 'getManagedContentReferencedBy', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentReferencedBy; }
    });
    Object.defineProperty(exports, 'getManagedContentSingleItem', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentSingleItem; }
    });
    Object.defineProperty(exports, 'getManagedContentSpace', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentSpace; }
    });
    Object.defineProperty(exports, 'getManagedContentSpaceFolder', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentSpaceFolder; }
    });
    Object.defineProperty(exports, 'getManagedContentSpaceFolderItemsV1', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentSpaceFolderItemsV1; }
    });
    Object.defineProperty(exports, 'getManagedContentSpaceOrchestratorConfig', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentSpaceOrchestratorConfig; }
    });
    Object.defineProperty(exports, 'getManagedContentSpaces', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentSpaces; }
    });
    Object.defineProperty(exports, 'getManagedContentTaxonomyTerms', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentTaxonomyTerms; }
    });
    Object.defineProperty(exports, 'getManagedContentTypesForMixin', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentTypesForMixin; }
    });
    Object.defineProperty(exports, 'getManagedContentVariant', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentVariant; }
    });
    Object.defineProperty(exports, 'getManagedContentVariantReferences', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentVariantReferences; }
    });
    Object.defineProperty(exports, 'getManagedContentVariantRendition', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentVariantRendition; }
    });
    Object.defineProperty(exports, 'getManagedContentVariantVersions', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getManagedContentVariantVersions; }
    });
    Object.defineProperty(exports, 'getSearchResults', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getSearchResults; }
    });
    Object.defineProperty(exports, 'getWebUrls', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.getWebUrls; }
    });
    Object.defineProperty(exports, 'patchManagedContentSpace', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.patchManagedContentSpace; }
    });
    Object.defineProperty(exports, 'postManagedContentSpaceFolder', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.postManagedContentSpaceFolder; }
    });
    Object.defineProperty(exports, 'publishManagedContent', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.publishManagedContent; }
    });
    Object.defineProperty(exports, 'putManagedContentSpaceOrchestratorConfig', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.putManagedContentSpaceOrchestratorConfig; }
    });
    Object.defineProperty(exports, 'replaceManagedContentVariant', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.replaceManagedContentVariant; }
    });
    Object.defineProperty(exports, 'unpublishManagedContent', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.unpublishManagedContent; }
    });
    Object.defineProperty(exports, 'updateDeployment', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.updateDeployment; }
    });
    Object.defineProperty(exports, 'updateMCSFolderShares', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.updateMCSFolderShares; }
    });
    Object.defineProperty(exports, 'updateManagedContentTaxonomyTerms', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.updateManagedContentTaxonomyTerms; }
    });
    Object.defineProperty(exports, 'updateManagedContentWebUrl', {
        enumerable: true,
        get: function () { return ldsAdaptersCmsAuthoring.updateManagedContentWebUrl; }
    });

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('lightning/cmsAuthoringApi', ['interop/cmsAuthoringApi'], function(m) { return m && typeof m === 'object' && 'default' in m ? m.default : m; });
(function() { LWR.define('dxp_util/eventBuilder', ['exports', 'dxp_util/common'], (function (exports, common) {

    const DXP_EVENT_NAME = Object.freeze({
      PRIVATE_DESIGN_TIME: "privatedesigntime",
      OPEN_SECTION: "opensection",
      CLOSE_SECTION: "closesection",
      VIEWPORT_CHANGE: "viewportchange",
      CHANGE: "change",
      COLUMN_ACTION: "columnaction",
      PILL_REMOVE: "pillremove",
      PILL_ADD: "pilladd",
      SEARCH: "search",
      NEXT_PAGE: "nextpage",
      PREVIOUS_PAGE: "previouspage",
      REPEATER_SORT: "repeatersort",
      RECORD_LIST_SORT: "recordlistsort"
    });
    const PAGINATION_ACTION = Object.freeze({
      APPEND: "append",
      REPLACE: "replace"
    });
    const buildEvent = common.curry((options, name, detail) => {
      return new CustomEvent(name, {
        ...options,
        detail
      });
    });
    const buildApiEvent = buildEvent({
      composed: true,
      bubbles: true
    });
    const buildShadowEvent = buildEvent({});

    /**
     * Cancel given event
     *
     * @param {Event} event event to cancel
     */
    function cancelEvent(event) {
      event?.preventDefault();
      event?.stopPropagation();
    }

    /**
     * Create a private design time event
     *
     * @param {object} detail Pass to event.detail
     * @returns {CustomEvent} Private design event Event
     *
     */
    function buildPrivateDesignTimeEvent(detail) {
      return buildApiEvent(DXP_EVENT_NAME.PRIVATE_DESIGN_TIME, detail);
    }
    /**
     * Create a close section event
     *
     * @param {object} detail Pass to event.detail
     * @returns {CustomEvent} Close section event
     */
    function buildCloseSectionEvent(detail) {
      return buildApiEvent(DXP_EVENT_NAME.CLOSE_SECTION, detail);
    }

    /**
     * Create a open section event
     *
     * @param {object} detail Pass to event.detail
     * @returns {CustomEvent} Open section event
     */
    function buildOpenSectionEvent(detail) {
      return buildApiEvent(DXP_EVENT_NAME.OPEN_SECTION, detail);
    }

    /**
     * Create a viewport change event
     *
     * @param {object} viewport The viewport
     * @returns {CustomEvent} Viewport change event
     */
    function buildViewportChangeEvent(viewport) {
      return buildShadowEvent(DXP_EVENT_NAME.VIEWPORT_CHANGE, {
        viewport
      });
    }

    /**
     * Create a standard change event
     *
     * @param {object} detail event detail
     * @returns {CustomEvent} Viewport change event
     */
    function buildChangeEvent(detail) {
      return buildApiEvent(DXP_EVENT_NAME.CHANGE, detail);
    }

    /**
     * Create a column action event used by tree grid components
     *
     * @param {object} detail event detail
     * @returns {CustomEvent} Tree grid column action event
     */
    function buildColumnActionEvent(detail) {
      return buildShadowEvent(DXP_EVENT_NAME.COLUMN_ACTION, detail);
    }

    /**
     * Create a pill remove event used by autocomplete
     *
     * @param {object} detail event detail
     * @returns {CustomEvent} Pill Remove Event
     */
    function buildPillRemoveEvent(detail) {
      return buildShadowEvent(DXP_EVENT_NAME.PILL_REMOVE, detail);
    }

    /**
     * Create a pill add event used by autocomplete
     *
     * @param {object} detail event detail
     * @returns {CustomEvent} Pill Add Event
     */
    function buildPillAddEvent(detail) {
      return buildShadowEvent(DXP_EVENT_NAME.PILL_ADD, detail);
    }

    /**
     * Create a search event used by link selector
     *
     * @param {object} detail event detail
     * @returns {CustomEvent} Search Custom Event
     */
    function buildSearchEvent(detail) {
      return buildApiEvent(DXP_EVENT_NAME.SEARCH, detail);
    }

    /**
     * Create a next page event used by paginators
     *
     * @param {object} detail event detail
     * @returns {CustomEvent} Search Custom Event
     */
    function buildNextPageEvent(detail) {
      return buildApiEvent(DXP_EVENT_NAME.NEXT_PAGE, detail);
    }

    /**
     * Create a previous page event used by paginators
     *
     * @param {object} detail event detail
     * @returns {CustomEvent} Search Custom Event
     */
    function buildPreviousPageEvent(detail) {
      return buildApiEvent(DXP_EVENT_NAME.PREVIOUS_PAGE, detail);
    }

    /**
     * Create a repeater sort event
     *
     * @param {object} detail event detail
     * The detail object for sort must be of the format
     * detail : {
     *      sortBy: 'fieldName',
     *      sortOrder: 'asc' or 'desc'
     * }
     * @returns {CustomEvent} Search Custom Event
     * @description Specifically to talk to data provider
     */
    function buildRepeaterSortEvent(detail) {
      return buildApiEvent(DXP_EVENT_NAME.REPEATER_SORT, detail);
    }

    /**
     * Create a record list sort event
     *
     * @param {object} detail event detail
     * The detail object contain objectApiName, listViewApiName, sortBy data
     * @returns {CustomEvent} Search Custom Event
     * @description Specifically to talk to data provider
     */
    function buildRecordListSortEvent(detail) {
      return buildApiEvent(DXP_EVENT_NAME.RECORD_LIST_SORT, detail);
    }

    exports.DXP_EVENT_NAME = DXP_EVENT_NAME;
    exports.PAGINATION_ACTION = PAGINATION_ACTION;
    exports.buildChangeEvent = buildChangeEvent;
    exports.buildCloseSectionEvent = buildCloseSectionEvent;
    exports.buildColumnActionEvent = buildColumnActionEvent;
    exports.buildNextPageEvent = buildNextPageEvent;
    exports.buildOpenSectionEvent = buildOpenSectionEvent;
    exports.buildPillAddEvent = buildPillAddEvent;
    exports.buildPillRemoveEvent = buildPillRemoveEvent;
    exports.buildPreviousPageEvent = buildPreviousPageEvent;
    exports.buildPrivateDesignTimeEvent = buildPrivateDesignTimeEvent;
    exports.buildRecordListSortEvent = buildRecordListSortEvent;
    exports.buildRepeaterSortEvent = buildRepeaterSortEvent;
    exports.buildSearchEvent = buildSearchEvent;
    exports.buildViewportChangeEvent = buildViewportChangeEvent;
    exports.cancelEvent = cancelEvent;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/config', ['exports'], (function (exports) {

  const currentRelease = {
    currentRelease: '252',
    apiVersion: 'v62.0'
  };

  exports.currentRelease = currentRelease;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/cmsDeliveryApi', ['exports', 'experience/store', 'experience/config', 'experience/data', 'experience/utils'], (function (exports, store, config, data, utils) {

  const API_VERSION$1 = config.currentRelease.apiVersion;
  function getEndPointUrl$1(channelOrSiteId, contentKeyOrId) {
    if (channelOrSiteId.startsWith('0DM')) {
      return `/services/data/${API_VERSION$1}/connect/sites/${channelOrSiteId}/cms/delivery/contents/${contentKeyOrId}`;
    } else if (channelOrSiteId.startsWith('0ap')) {
      return `/services/data/${API_VERSION$1}/connect/cms/delivery/channels/${channelOrSiteId}/contents/${contentKeyOrId}`;
    }
    throw new TypeError("The 'channelOrSiteId' parameter is invalid");
  }
  async function getContent$1(options) {
    if (!utils.isPlainObject(options)) {
      throw new TypeError(`Options are required to successfully be able to execute this request.`);
    }
    if (typeof options.channelOrSiteId !== 'string' || options.channelOrSiteId.trim().length === 0) {
      throw new TypeError("The 'channelOrSiteId' parameter is required to successfully execute this request.");
    }
    if (typeof options.contentKeyOrId !== 'string' || options.contentKeyOrId.trim().length === 0) {
      throw new TypeError("The 'contentKeyOrId' parameter is required to successfully execute this request.");
    }
    const channelOrSiteId = encodeURIComponent(options.channelOrSiteId);
    const contentKeyOrId = encodeURIComponent(options.contentKeyOrId);
    const endPointUrl = getEndPointUrl$1(channelOrSiteId, contentKeyOrId);
    return data.fetchService(endPointUrl).catch(response => {
      throw new Error(response.statusText);
    });
  }
  const cmsStore = new store.Store('@@CmsDeliveryApi');
  function getContentLoader(action) {
    return getContent$1(action.payload);
  }

  const API_VERSION = config.currentRelease.apiVersion;
  const PATH_PARAM = ['channelOrSiteId'];
  const VALID_TYPES = {
    channelOrSiteId: 'string',
    contentKeys: 'array',
    managedContentIds: 'array',
    contentTypeFQN: 'string',
    page: 'number',
    pageSize: 'number',
    referenceDepth: 'number',
    includeContentBody: 'boolean'
  };
  const VALID_TYPE_VALUES = Object.values(VALID_TYPES).filter((type, index, self) => {
    return self.indexOf(type) === index;
  });
  function getEndPointUrl(channelOrSiteId, queryParams) {
    if (channelOrSiteId.startsWith('0DM')) {
      return data.composeUri(`/services/data/${API_VERSION}/connect/sites/${channelOrSiteId}/cms/delivery/contents`, queryParams);
    } else if (channelOrSiteId.startsWith('0ap')) {
      return data.composeUri(`/services/data/${API_VERSION}/connect/cms/delivery/channels/${channelOrSiteId}/contents`, queryParams);
    }
    throw new TypeError('Enter a valid prefix for channelOrSiteId.');
  }
  function isPathParam(param) {
    return PATH_PARAM.includes(param);
  }
  function isTypeValid(paramValue) {
    return VALID_TYPE_VALUES.includes(paramValue);
  }
  function isListType(type) {
    return type === 'array';
  }
  function isTypeMatch(value, type) {
    if (isListType(type)) {
      return Array.isArray(value);
    }
    return isTypeValid(type) && typeof value === type;
  }
  function isNotEmptyString(value) {
    return typeof value === 'string' && value.trim().length > 0;
  }
  function isBoolean(value) {
    return typeof value === 'boolean';
  }
  function getQueryParams(options) {
    const queryParams = {};
    for (const [optionKey, optionValue] of Object.entries(options)) {
      const optionType = VALID_TYPES[optionKey];
      if (isPathParam(optionKey) || utils.isNil(optionValue) || utils.isNil(optionType)) {
        continue;
      }
      if (!isTypeMatch(optionValue, optionType)) {
        if (optionType === 'array') {
          throw new TypeError(`The type entered for ${optionKey} isn’t valid. Enter the value as an ${optionType}.`);
        } else {
          throw new TypeError(`The type entered for ${optionKey} isn’t valid. Enter the value as a ${optionType}.`);
        }
      }
      if (isListType(optionType)) {
        const listOptionValue = optionValue.join(',');
        if (isNotEmptyString(listOptionValue)) {
          queryParams[optionKey] = listOptionValue;
        }
      }
      if (isNotEmptyString(optionValue) || utils.isInteger(optionValue) || isBoolean(optionValue)) {
        queryParams[optionKey] = optionValue.toString();
      }
    }
    return queryParams;
  }
  async function getContents$1(options) {
    if (!utils.isPlainObject(options)) {
      throw new TypeError(`Enter input parameters to execute the request.`);
    }
    if (!isNotEmptyString(options.channelOrSiteId)) {
      throw new TypeError('Enter a value for channelOrSiteId.');
    }
    const channelOrSiteId = encodeURIComponent(options.channelOrSiteId);
    const queryParams = getQueryParams(options);
    const endPointUrl = getEndPointUrl(channelOrSiteId, queryParams);
    return data.fetchService(endPointUrl).catch(response => {
      throw new Error(response.statusText);
    });
  }
  const cmsDeliveryListStore = new store.Store('@@CmsDeliveryListApi');
  function getContentsLoader(action) {
    return getContents$1(action.payload);
  }

  class getContent extends store.StoreAdapter {
    constructor(dataCallback) {
      super(dataCallback, cmsStore, 'content', {
        loader: getContentLoader
      });
    }
    /*LWC compiler v7.1.5*/
  }
  class getContents extends store.StoreAdapter {
    constructor(dataCallback) {
      super(dataCallback, cmsDeliveryListStore, 'contents', {
        loader: getContentsLoader
      });
    }
    /*LWC compiler v7.1.5*/
  }

  exports.getContent = getContent;
  exports.getContents = getContents;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_data_provider/cmsV2SingleItemDataProvider', ['exports', 'lwc', 'dxp_data_provider/dataProviderUtils', 'dxp_util/eventBuilder', 'dxp_data_provider/navigableDataProvider', 'experience/cmsDeliveryApi', 'lightning/cmsAuthoringApi', 'dxp_util/siteInfo', 'dxp_util/common', 'experience/store'], (function (exports, lwc, dataProviderUtils, eventBuilder, NavigableDataProvider, cmsDeliveryApi, cmsAuthoringApi, siteInfo, common, store) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var NavigableDataProvider__default = /*#__PURE__*/_interopDefaultCompat(NavigableDataProvider);

    var _tmpl = void 0;

    /**
     * Data provider to fetch 2.0 content from CMS
     *
     * We have mock data for now, as wire adaptor to fetch 2.0 content is not in yet
     *
     * @class CMSV2SingleItemDataProvider
     * @extends NavigableDataProvider
     */
    class CMSV2SingleItemDataProvider extends NavigableDataProvider__default.default {
      constructor() {
        super();
        // default is 'shadow'
        /**
         *  Internal data binding expression key
         *
         * @type {string}
         * @memberof CMSV2SingleItemDataProvider
         */
        this.sfdcExpressionKey = void 0;
        this.fieldDataEventHandler = this.handleFieldDataEvent.bind(this);
        this.elementsAskingForDataViaEvents = [];
        /**
         * Content version number.
         * The decision to call delivery or authoring service depends on this being available
         */
        this.contentVersion = void 0;
        /**
         * Get content key for delivery API
         */
        this.contentKeyForDeliveryApi = void 0;
        /**
         * Get content key for Authoring API
         */
        this.contentKeyForAuthoringApi = void 0;
        this.addEventListener(dataProviderUtils.DATA_PROVIDER_GET_FIELD_DATA_EVENT_NAME, this.fieldDataEventHandler);
      }

      /**
       * Currently CMS wire adapter accepts only a list of keys, thus we need to transform
       * the one content key into a array of a single content key.
       *
       * @type {string} - can either be a single contentKey or be a urlAlias, where the content key is
       *                  the last item in the url (ex. we-still-meeting-today-MCKABCDYJW4ZCE5IECPBVBBLQY5I)
       */
      get contentKey() {
        return this._contentKey;
      }
      set contentKey(key) {
        if (!key) {
          return;
        }
        this._contentKey = dataProviderUtils.normalizeContentKey(key);
        if (this.currentPageReference && this._contentKey) {
          if (this.shouldCallGetManagedContentApi()) {
            this.contentVersion = this.currentPageReference?.state?.mcVersionId;
            this.contentKeyForAuthoringApi = this.contentKey;
          } else {
            this.contentKeyForDeliveryApi = this.contentKey;
          }
        }
      }
      get detailPageUrl() {
        return this._detailPageUrl || "";
      }
      set detailPageUrl(url) {
        this._detailPageUrl = url;

        // Update any elements asking for data via events (ex. richTextEditor in design time does this)
        // Only update if cmsData is loaded also - otherwise when data is loaded it will update
        if (common.notEmpty(this._sfdcData)) {
          this.synchronizeData();
        }
      }
      /**
       * Get the siteId for delivery API
       */
      get siteId() {
        return siteInfo.SiteInfo.SiteId;
      }
      updateData(data) {
        this._sfdcData = this.toCmsData(data);
        this.handleContextChange();
      }

      /**
       * Wire method to get managed content from cmsDeliveryApi
       *
       * @param {string} channelOrSiteId channel or site Id.
       * @param {string} contentKeyOrId contentKey or id of the cms content.
       */
      wiredCMSDeliveryContent({
        data
      }) {
        if (data) {
          // Here we allow users to bind to entire payload of the Cms v2 Delivery Api response,
          // as opposed to just rendition for Cms v1 Data Provider
          this.sfdcType = data?.contentType?.fullyQualifiedName;
          this.updateData(data);
        }
      }

      /**
       * Wire method to get managed content from cmsAuthoringApi
       *
       * @param {string} contentKeyOrId contentKey or id of the cms content.
       * @param {string} siteId site Id.
       * @param {string} version content version number
       */
      wiredCMSAuthoringContent({
        data
      }) {
        if (data) {
          this.sfdcType = data?.contentType?.fullyQualifiedName;
          this.updateData(data);
        }
      }

      /**
       * Synchronize the data with child component when detailUrl is changed
       */
      handleContextChange() {
        // Update any elements asking for data via events (ex. richTextEditor in design time does this)
        // Only update if detail url is loaded also - otherwise when detail url is loaded it will update
        if (this._detailPageUrlLoaded) {
          this.synchronizeData();
        }
      }

      /**
       * Synchronize data with child component
       */
      synchronizeData() {
        this.elementsAskingForDataViaEvents.forEach(([element, fields]) => this.setDataForElementAsking(element, fields));
        this.elementsAskingForDataViaEvents = [];
      }

      /**
       * Handles a custom event that gets fired from components that
       * need data so they can resolve the expressions themselves
       *
       * @param {Event} event - Custom event: { detail: fields }
       */
      handleFieldDataEvent(event) {
        eventBuilder.cancelEvent(event);
        if (common.empty(this._sfdcData) || !this._detailPageUrlLoaded) {
          this.elementsAskingForDataViaEvents.push([event.target, event.detail]);
        } else {
          this.setDataForElementAsking(event.target, event.detail);
        }
      }

      /**
       * Sets the data for the element asking for it
       *
       * @param {HTMLElement} element - element to set data for
       * @param {Array} fields - list of fields to get data for
       */
      setDataForElementAsking(element, fields) {
        const result = {};
        fields?.forEach?.call(fields, fieldAndMetadata => {
          const [field, metadata] = dataProviderUtils.getFieldAndMetadata(fieldAndMetadata);
          if (field) {
            result[fieldAndMetadata] = this.getField(field, metadata);
          } else {
            result[fieldAndMetadata] = this.getData(metadata);
          }
        });

        // Please read last test case in cmsV2SingleItemDataProvider.test.js to understand why this check is here
        if (typeof element.setDataExpressions === "function") {
          element.setDataExpressions(result);
        } else {
          console.log("Element does not have setDataExpressions!");
        }
      }

      /**
       * Only call the get managed content authoring api when previewing authoring content in the CMS app.
       * in the CMS app.
       */
      shouldCallGetManagedContentApi() {
        return this.sfdcIsPreviewMode &&
        // page level data provider is needed so that a single binded component on a detail page doesn't call getManagedContentForSite
        this.sfdcIsViewLevelDataProvider && this.currentPageReference.type === NavigableDataProvider.CMS_CONTENT_PAGE_TYPE && this.currentPageReference.state && this.currentPageReference.state.mcVersionId;
      }

      /**
       * Event fired when CurrentPageReference is changed
       *
       * @param {object} currentPageReference - CurrentPageReference
       */
      handleCurrentPageReferenceChange(currentPageReference) {
        if (this.shouldCallGetManagedContentApi()) {
          this.contentVersion = currentPageReference?.state?.mcVersionId;
          this.contentKeyForAuthoringApi = this.contentKey;
        } else {
          this.contentKeyForDeliveryApi = this.contentKey;
        }
      }

      /**
       * Method to be used for preloading data to support SSR
       *
       * @param {object} preloadRequestContext - Request context to preload the data
       */
      static async preloadData(preloadRequestContext) {
        let rejects = [];
        await Promise.allSettled(
        // eslint-disable-next-line @locker/locker/distorted-element-attributes-getter
        preloadRequestContext.attributes.map(attribute => {
          // eslint-disable-next-line @lwc/lwc/no-unexpected-wire-adapter-usages
          return store.getStoreAdapterValue(cmsDeliveryApi.getContent, {
            channelOrSiteId: siteInfo.SiteInfo.SiteId,
            contentKeyOrId: attribute?.contentKey
          });
        })).then(results => {
          results.forEach((result, index) => {
            if (result.status === "rejected") {
              rejects.push({
                provider: "cmsV2SingleItemDataProvider",
                url: `/connect/sites/${siteInfo.SiteInfo.SiteId}/cms/delivery/contents/${preloadRequestContext.attributes[index].contentKey}`,
                reason: result.reason?.toString()
              });
            }
          });
        });
        return rejects.length ? Promise.reject(new Error(JSON.stringify(rejects))) : Promise.resolve();
      }
      /*LWC compiler v7.1.5*/
    }
    /**
     * Enable the component to render as lightDOM
     *
     * @static
     */
    CMSV2SingleItemDataProvider.renderMode = "light";
    lwc.registerDecorators(CMSV2SingleItemDataProvider, {
      publicProps: {
        sfdcExpressionKey: {
          config: 0
        },
        contentKey: {
          config: 3
        }
      },
      wire: {
        wiredCMSDeliveryContent: {
          adapter: cmsDeliveryApi.getContent,
          dynamic: ["channelOrSiteId", "contentKeyOrId"],
          method: 1,
          config: function ($cmp) {
            return {
              channelOrSiteId: $cmp.siteId,
              contentKeyOrId: $cmp.contentKeyForDeliveryApi
            };
          }
        },
        wiredCMSAuthoringContent: {
          adapter: cmsAuthoringApi.getManagedContentForSite,
          dynamic: ["contentKeyOrId", "siteId", "version"],
          method: 1,
          config: function ($cmp) {
            return {
              contentKeyOrId: $cmp.contentKeyForAuthoringApi,
              siteId: $cmp.siteId,
              version: $cmp.contentVersion
            };
          }
        }
      },
      fields: ["fieldDataEventHandler", "elementsAskingForDataViaEvents", "contentVersion", "contentKeyForDeliveryApi", "contentKeyForAuthoringApi"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(CMSV2SingleItemDataProvider, {
      tmpl: _tmpl,
      sel: "dxp_data_provider-cms-v2single-item-data-provider",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
