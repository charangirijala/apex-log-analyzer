LWR.define('@view/forgotPassword/labels', [], function() { return ["Logo","Forget your password?","To reset your password, enter your username. We\u0027ll send a reset-password link to the email address associated with your account.","Username","Reset","Cancel","Choose a color. Current color: ","Active","Inactive","required","Clear","Loading","Increase number","Decrease number","{0} Help Info","Date","Value must be {0} or earlier.","Value must be {0} or later.","Time","Complete this field with format {0}.","{0} (Use format {1})","Help","Enter a valid value.","Enter a valid numeric value.","$Label.LightningErrorMessage.validityBadEmailInput does not exist.","Invalid Format","The number is too high.","The number is too low.","Your entry isn\u0027t a valid increment.","Your entry is too long.","Your entry is too short.","You have entered an invalid format.","Complete this field.","You must select at least one choice from this set.","Your entry does not match the allowed format {0}.","Select a date after {0}","Select a date before {0}","Select a date between {0} and {1}","Select a date for {0}","Date picker: ","Next Month","Previous Month","Today","Pick a Year","Selected Options:","Press delete or backspace to remove","Loading","Clear Selection","Select an Option","None Selected","Cancel","Custom","Default","Done","B","Blue","Use arrow keys to select a saturation and brightness, on an x and y axis.","Enter a valid hexadecimal value.","G","Green","Hex","Select Hue","R","Red","Or drop files","Upload Files"]; });
(function() { LWR.define('community_layout/sldsFlexibleLayout', ['exports', 'lwc'], (function (exports, lwc) {

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("." + token) : "";
      return ".content-container" + shadowSelector + " {display: flex;flex-direction: column;}";
      /*LWC compiler v7.1.5*/
    }
    stylesheet.$scoped$ = true;
    var _implicitScopedStylesheets = [stylesheet];

    const stc0 = {
      classMap: {
        "content-container": true
      },
      key: 0
    };
    const stc1 = {
      attrs: {
        "name": "content"
      },
      key: 1
    };
    const stc2 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {s: api_slot, h: api_element} = $api;
      return [api_element("div", stc0, [api_slot("content", stc1, stc2, $slotset)])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = ["content"];
    tmpl.renderMode = "light";
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-2b5a72ratvd";
    tmpl.legacyStylesheetToken = "community_layout-sldsFlexibleLayout_sldsFlexibleLayout";
    if (_implicitScopedStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitScopedStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    /**
     * This comment is important, if it doesn't exist the slot will not be accessible in the ModuleDef,
     * see https://gus.lightning.force.com/lightning/r/0D5B000000moNnZ/view
     * @slot content a place for the content
     */
    class SldsFlexibleColLayout extends lwc.LightningElement {
      /*LWC compiler v7.1.5*/
    }
    SldsFlexibleColLayout.renderMode = 'light';
    const __lwc_component_class_internal = lwc.registerComponent(SldsFlexibleColLayout, {
      tmpl: _tmpl,
      sel: "community_layout-slds-flexible-layout",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/label/LwcComponent:dxp_content_layout:header.section_name_logo', ['@view/forgotPassword/labels'], m => m[0]);
(function() { LWR.define('dxp_util/browserProperties', ['exports', 'lwc', '@salesforce/client/formFactor'], (function (exports, lwc, formFactor) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var formFactor__default = /*#__PURE__*/_interopDefaultCompat(formFactor);

    var _tmpl = void 0;

    /**
     * BrowserProperties
     *
     * Define browser related functionality.
     *
     */
    class BrowserProperties {
      static get screenViewport() {
        return {
          top: 0,
          left: 0,
          bottom: window.innerHeight,
          right: window.innerWidth
        };
      }
    }
    const __lwc_component_class_internal = lwc.registerComponent(BrowserProperties, {
      tmpl: _tmpl,
      sel: "dxp_util-browser-properties",
      apiVersion: 62
    });
    /**
     * Whether run on mobile device
     *
     * @returns {boolean} true if formFactor is Small
     */
    function isMobile() {
      return formFactor__default.default === "Small";
    }

    /**
     * Whether run on tablet device
     *
     * @returns {boolean} true if formFactor is Medium
     */
    function isTablet() {
      return formFactor__default.default === "Medium";
    }

    /**
     * Whether run on desktop device
     *
     * @returns {boolean} true if formFactor is Large
     */
    function isDesktop() {
      return formFactor__default.default === "Large";
    }

    exports.default = __lwc_component_class_internal;
    exports.isDesktop = isDesktop;
    exports.isMobile = isMobile;
    exports.isTablet = isTablet;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/community/basePath', ['@app/basePath'], function(m) { return m && typeof m === 'object' && 'default' in m ? m.default : m; });
(function() { LWR.define('experience/uri', ['exports'], (function (exports) {

  function encode(str) {
    return encodeURIComponent(str).replace(/[!'()~]/g, match => '%' + match.charCodeAt(0).toString(16).toUpperCase());
  }
  function composeQueryString(params) {
    const args = typeof params === 'object' && params != null ? params : {};
    if ('URLSearchParams' in globalThis) {
      return new URLSearchParams(args).toString();
    }
    return Object.keys(args).map(k => encode(k) + '=' + encode(args[k])).join('&');
  }

  function composeUri(uri, args) {
    const u = typeof uri === 'string' ? uri : '';
    const q = composeQueryString(args);
    if (q) {
      const ch = u.indexOf('?') !== -1 ? '&' : '?';
      return `${u}${ch}${q}`;
    }
    return u;
  }

  exports.composeQueryString = composeQueryString;
  exports.composeUri = composeUri;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/resourceResolver', ['exports', '@salesforce/community/basePath', 'experience/uri', '@app/imageOpt'], (function (exports, basePath, uri, imageOptimiserType) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var basePath__default = /*#__PURE__*/_interopDefaultCompat(basePath);
  var imageOptimiserType__default = /*#__PURE__*/_interopDefaultCompat(imageOptimiserType);

  const cloudflareTransformUrl = '/cdn-cgi/image/';

  const defaultCdnProvider = 'Cloudflare';
  const cmsResourceUrlPattern = /^\/cms\//;
  const staticImageResourcePattern = /^\/img\//;
  const staticCmsAssetPattern = /^\/?assets\//;
  const platformPath = '/sfsites/c';
  const dataResourcePattern = /^data:/;
  const isCloudflareEnabled = () => imageOptimiserType__default.default === defaultCdnProvider;
  function isCmsResource(url) {
    if (url && url.includes('/cms') && url.includes('/media')) {
      url = url.substring(url.indexOf('/cms'));
    }
    return cmsResourceUrlPattern.test(url);
  }
  function composeCloudflareUri(uri, resourceOptions) {
    let cdnOptions = ['fit=scale-down'];
    if (uri.includes(cloudflareTransformUrl)) {
      const endIndexOfCloudflareUrl = uri.indexOf('/', cloudflareTransformUrl.length);
      uri = uri.substring(endIndexOfCloudflareUrl);
    }
    uri = uri.startsWith('/') ? uri.substring(1) : uri;
    if (resourceOptions && !uri.toLowerCase().includes('.svg')) {
      const dimensionsOptions = Object.entries(resourceOptions).map(([key, value]) => {
        return `${key}=${value}`;
      });
      cdnOptions = [...cdnOptions, ...dimensionsOptions];
    }
    return `${cloudflareTransformUrl}${cdnOptions}/${uri}`;
  }
  function extendUrl(url, absoluteUrl, resourceOptions) {
    absoluteUrl = absoluteUrl || false;
    const normalizedCmsResourceOptions = Object.entries(resourceOptions || {}).reduce((result, [key, value]) => {
      value = Math.max(value, 100);
      result[key] = `${value}`;
      return result;
    }, Object.create(null));
    if (url && absoluteUrl && url.includes('/cms') && url.includes('/media')) {
      url = url.substring(url.indexOf('/cms'));
    }
    let extendedUrl = url;
    if (cmsResourceUrlPattern.test(url)) {
      extendedUrl = `${basePath__default.default}${platformPath}${url}`;
      if (!isCloudflareEnabled()) {
        return uri.composeUri(extendedUrl, normalizedCmsResourceOptions);
      }
    } else if (staticImageResourcePattern.test(url)) {
      extendedUrl = `${basePath__default.default}${platformPath}${url}`;
    } else if (staticCmsAssetPattern.test(url)) {
      extendedUrl = url.startsWith('/') ? `${basePath__default.default}${url}` : `${basePath__default.default}/${url}`;
    }
    return extendedUrl;
  }
  function resolve(url, absoluteUrl, resourceOptions) {
    if (!url || dataResourcePattern.test(url)) {
      return url;
    }
    const extendedUrl = extendUrl(url, absoluteUrl, resourceOptions);
    if (isCloudflareEnabled()) {
      return composeCloudflareUri(extendedUrl, resourceOptions);
    }
    return extendedUrl;
  }
  function resolveWithoutImageOpt(url, absoluteUrl, resourceOptions) {
    if (!url || dataResourcePattern.test(url)) {
      return url;
    }
    return extendUrl(url, absoluteUrl, resourceOptions);
  }

  exports.isCmsResource = isCmsResource;
  exports.resolve = resolve;
  exports.resolveWithoutImageOpt = resolveWithoutImageOpt;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_util/common', ['exports'], (function (exports) {

    /**
     * Creates a debounced function that delays invoking `func` until after
     * `delay` milliseconds have elapsed since the last time the debounced function was invoked.
     *
     * @function debounce
     * @param {Function} func - The function to debounce
     * @param {number} delay - The number of milliseconds to delay
     * @param {object} options - The options object
     * @param {boolean} options.leading - Specify invoking on the leading edge of the timeout
     * @returns {Function} - debounced function
     */
    function debounce(func, delay, options) {
      const _options = options || {};
      let invokeLeading = _options.leading;
      let timer;
      return function debounced() {
        const args = Array.prototype.slice.apply(arguments);
        if (invokeLeading) {
          func.apply(this, args);
          invokeLeading = false;
        }
        clearTimeout(timer);
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        timer = setTimeout(function () {
          func.apply(this, args);
          invokeLeading = _options.leading; // reset for next debounce sequence
        }, delay);
      };
    }

    const KeyCodes = {
      tab: 9,
      backspace: 8,
      enter: 13,
      escape: 27,
      space: 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      delete: 46,
      shift: 16
    };

    /**
     * Functional Try/Catch handler
     *
     * @param {Function} tryFunc function may throw exception
     * @param {Function} catchFunc function to handle exception
     * @returns {object} result
     */
    function tryCatch(tryFunc, catchFunc) {
      return function fpTryCatch() {
        try {
          return tryFunc.apply(this, arguments);
        } catch (error) {
          return catchFunc?.apply(this, [error].concat(arguments));
        }
      };
    }

    /**
     * Safe parse a json string
     * JSON.parse => https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
     *
     * @param {string} json The string to parse as JSON. See the JSON object for a description of JSON syntax.
     * @param {boolean} fallBackInput if fallBackInput is true, then return the input.
     * @param {Function} reviver If a function, this prescribes how the value originally produced by parsing is transformed, before being returned.
     * @returns {object} The Object, Array, string, number, boolean, or null value corresponding to the given JSON text.
     */
    function safeParseJson(json, reviver) {
      if (typeof json !== "string") {
        return json ?? {};
      }
      return tryCatch(JSON.parse, reviver)(json) ?? {};
    }

    /**
     * Stringify object and remove empty values
     *
     * @param {object} obj object to stringify
     * @returns {string} stringified object
     */
    function stringify(obj) {
      return JSON.stringify(obj, (key, value) => value ? value : undefined);
    }

    /**
     * Create a deep copy of an object or array (borrow from base components)
     *
     * @param {object|Array} obj - item to be copied
     * @returns {object|Array} copy of the item
     */
    function deepCopy(obj) {
      if (Object(obj) !== obj) {
        // primitives
        return obj;
      }
      if (obj instanceof Set) {
        return new Set(obj);
      }
      if (obj instanceof Date) {
        return new Date(obj);
      }
      if (typeof obj === "function") {
        return obj.bind({});
      }
      if (Array.isArray(obj)) {
        const obj2 = [];
        const len = obj.length;
        for (let i = 0; i < len; i++) {
          obj2.push(deepCopy(obj[i]));
        }
        return obj2;
      }
      const result = Object.create({});
      let keys = Object.keys(obj);
      if (obj instanceof Error) {
        // Error properties are non-enumerable
        keys = Object.getOwnPropertyNames(obj);
      }
      const len = keys.length;
      for (let i = 0; i < len; i++) {
        const key = keys[i];
        result[key] = deepCopy(obj[key]);
      }
      return result;
    }

    /**
     * Deep merge two objects
     *
     * e.g. deepMerge({a: {a: 1}}, {a: {b: 2}}
     * should return {a: {a: 1, b: 2}}
     *
     * Object.assign does not do deep merge
     * and returns {a: {b: 2}}
     *
     * We could have use lodash merge method but
     * security locker is not allowing it to be
     *
     * @param {object} target target object where merge needed
     * @param {object} sources objects that need to be merged
     * @returns {object} deep merged object
     */
    function deepMerge(target, ...sources) {
      if (!sources.length) {
        return target;
      }
      const source = sources.shift();
      if (isObject(target) && isObject(source)) {
        for (const key in source) {
          if (isObject(source[key])) {
            if (!target[key]) {
              Object.assign(target, {
                [key]: {}
              });
            }
            deepMerge(target[key], source[key]);
          } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
            target[key] = [...target[key], ...source[key]];
          } else {
            Object.assign(target, {
              [key]: source[key]
            });
          }
        }
      }
      return deepMerge(target, ...sources);
    }

    /**
     * Returns if passed value is an object or not
     *
     * @param {object} key
     * @returns true/false
     */
    function isObject(key) {
      return key && typeof key === "object" && !Array.isArray(key);
    }

    /**
     * Simple pipe functional operator
     *
     * @example
     *      pipe(f, g)(v) ===  g(f(v))
     *
     * @param  {...Function} functions functions to be connected
     * @returns {Function} piped function sequence
     */
    const pipe = (...functions) => value => {
      return functions.filter(func => typeof func === "function") // filter out non function
      .reduce((currentValue, currentFunction) => {
        return currentFunction(currentValue);
      }, value);
    };

    /**
     * Simple compose functional operator
     *
     * @example
     *      compose(f, g)(v) ===  f(g(v))
     *
     * @param  {...Function} functions functions to be connected
     * @returns {Function} composed function sequence
     */
    const compose = (...functions) => value => functions.filter(func => typeof func === "function") // filter out non function
    .reduceRight((currentValue, currentFunction) => currentFunction(currentValue), value);

    /**
     * Build forEach functional operator with given function for array
     *
     * @param {Function} action action to be executed in forEach
     * @returns {Function} forEach operator tied to given action
     */
    const forEach = action => items => items.forEach(action);

    /**
     * Build find functional operator with given function for array
     *
     * @param {Function} action action to be executed in find
     * @returns {Function} find operator tied to given action
     */
    const find = action => items => items.find(action);

    /**
     * Build filter functional operator with given function for array
     *
     * @param {Function} action action to be executed in filter
     * @returns {Function} filter operator tied to given action
     */
    const filter = action => items => items.filter(action);

    /**
     * Build map functional operator with given function for array
     *
     * @param {Function} action action to be executed in map
     * @returns {Function} map operator tied to given action
     */
    const map = action => items => items.map(action);

    /**
     * Build every functional operator with given function for array
     *
     * @param {Function} action action to be executed in map
     * @returns {Function} every operator tied to given action
     */
    const every = action => items => items.every(action);

    /**
     * Enumerate all keys of given object
     *
     * @param {Function} action action to be executed
     * @returns {Function} forEachKey operator tied to given action
     */
    const forEachKey = action => items => Object.keys(items).forEach(action);

    /**
     * Every key of given object
     *
     * @param {Function} action action to be executed
     * @returns {Function} everyKey operator tied to given action
     */
    const everyKey = action => items => compose(every(action), Object.keys)(items);

    /**
     * Merge two records and return the merged record with unique items
     *
     * @param {object[]} firstRecord First record
     * @param {object[]} secondRecord Second record
     * @param {string} identifier key based on which the records uniqueness is determined
     * @returns {object[]} Array of merged records
     */
    function mergeUniqueRecords(firstRecord, secondRecord, identifier) {
      const left = Array.isArray(firstRecord) ? firstRecord : [];
      const right = Array.isArray(secondRecord) ? secondRecord : [];
      const nonDups = right.filter(record => {
        const duplicateIndex = left.findIndex(item => item[identifier] === record[identifier]);
        if (duplicateIndex >= 0) {
          left[duplicateIndex] = record;
        }
        return duplicateIndex < 0;
      });
      return left.concat(nonDups);
    }

    /**
     * Takes a function with n arguments and transforms it into n functions that each take a single argument aka curried function.
     *
     * @param {Function} func with n arguments
     * @returns {Function}the result of applied function or a function that accepts remaining arguments
     */
    const curry = func => {
      return function curried(...args) {
        if (args.length >= func.length) {
          return func.apply(this, args);
        }
        return (...args2) => {
          return curried.apply(this, args.concat(args2));
        };
      };
    };

    /**
     * Check if given statement is a function
     *
     * @param {string} statement statement to be checked
     * @returns {boolean} whether given value is a function
     */
    function isFunction(statement) {
      return typeof statement === "function";
    }

    /**
     * Call statement if it is a function, or return the statement
     *
     * @param {Function|boolean} statement statement to be called
     * @returns {any} result of the statement
     */
    const callOrReturn = statement => {
      return isFunction(statement) ? statement() : statement;
    };

    /**
     * Execute then function or else function based on value of the condition
     *
     * @param {Function|boolean} fnCondition condition to be checked
     * @param {Function|any} fnThen then function to be executed
     * @param {Function|any} fnElse else function to be executed
     * @returns {any}
     */
    const ifElse = curry((fnCondition, fnThen, fnElse) => {
      return callOrReturn(fnCondition) ? callOrReturn(fnThen) : callOrReturn(fnElse);
    });

    /**
     * Execute given function if given statement is a function
     *
     * @param {Function|boolean} fnCondition condition to be checked
     * @param {Function|object} fnThen statement to be executed if condition is true
     * @returns {any} statement or function result
     */
    const ifVal = curry((fnCondition, fnThen) => {
      return ifElse(fnCondition, fnThen, null);
    });
    const apply$1 = value => func => func(value);

    /**
     * Execute functions return true if one of them is passed
     *
     * @param {...Function} funcs funcs to be applied
     * @returns {boolean} true one function is passed
     */
    const or = (...funcs) => value => funcs?.filter(isFunction).some(apply$1(value));

    /**
     * Execute functions return true if all are passed
     *
     * @param {Function[]} funcs funcs to be applied
     * @returns {boolean} true when all  are passed
     */
    const and = (...funcs) => value => funcs?.filter(isFunction).every(apply$1(value));

    /**
     * Detects the Data Type and returns if its Primitive Type or not
     * https://developer.mozilla.org/en-US/docs/Glossary/Primitive
     *
     * @param {*} data input Data
     * @returns {boolean} returns true if Primitive Data Type else false
     */
    function isPrimitive(data) {
      return data !== Object(data);
    }

    /**
     * Custom Typeof method to determine the data type of an array rather an object.
     *
     * @param {*} data input Data
     * @returns {string} the type of the data
     */
    function typeOf(data) {
      return Array.isArray(data) ? "array" : typeof data;
    }

    /**
     * Get value of given key from given object
     *
     * @param {object} obj object to be searched
     * @param {string} path path to be searched
     * @returns {any} value of given key
     */
    const get = curry((obj, path) => {
      if (empty(path)) {
        return obj;
      }
      const steps = path.split(".");
      let current = obj ?? {};
      let i = 0;
      for (i = 0; i < steps.length - 1; i++) {
        if (empty(current[steps[i]])) {
          return null;
        }
        current = current[steps[i]];
      }
      return current[steps[i]];
    });

    /**
     * Set value of given key in given object
     *
     * @param {object} obj object to be searched
     * @param {string} path path to be searched
     * @param {any} value value of given key
     */
    const set = curry((obj, path, value) => {
      if (empty(path)) {
        return;
      }
      const steps = path.split(".");
      let current = obj;
      let i = 0;
      for (i = 0; i < steps.length - 1; i++) {
        current[steps[i]] = current[steps[i]] || {};
        current = current[steps[i]];
      }
      current[steps[i]] = value;
    });

    /**
     * Set value of given key in src object to value of given key in dest object
     *
     * @param {object} src source object
     * @param {object} dest destination object
     * @param {string} srcKey source key
     * @param {string} destKey destination key
     */
    const mapping = curry((src, dest, srcKey, destKey) => {
      const value = get(src, srcKey);
      set(dest, destKey, value);
    });

    /**
     * Merge src object's path value to dest object's path value
     *
     * @param {object} src source object
     * @param {object} dest destination object
     * @param {object} mapper mapper of attribtues
     * @param {boolean}  reverseMapper whether to use value/key instead of key/value
     * @returns {object} updated dest object
     */
    function mapObject(src, dest, mapper, reverseMapper) {
      forEachKey(key => {
        if (reverseMapper) {
          mapping(src, dest, mapper[key], key);
        } else {
          mapping(src, dest, key, mapper[key]);
        }
      })(mapper ?? {});
      return dest;
    }

    /**
     * Invoke a method on given object
     *
     * @param  {...any} args arguments to be passed to the method
     * @returns {object} returned from method or null
     */
    function apply(...args) {
      const [obj, method, ...rest] = args;
      return obj?.[method]?.apply(obj, rest);
    }

    /**
     * Create index array from given count
     *
     * @param {number} count how many index
     * @returns {number[]} [1, 2, 3, ... count]
     */
    const toIndexes = count => [...Array(count).keys()];
    const notEmpty = value => !empty(value);

    /**
     * Check if given value is empty
     *  "", [], null, undefined, {} is treated as empty
     *
     * @param {any} value value to check
     * @returns {boolean} whether value is empty
     */
    function empty(value) {
      if (Array.isArray(value)) {
        return value.length === 0;
      }
      const type = typeof value;
      switch (type) {
        case "string":
          return value === "";
        case "boolean":
        case "number":
        case "function":
          return false;
        case "object":
          return Object.keys(value ?? {}).length === 0;
        default:
          return value == null;
      }
    }

    /**
     * Check if given property is defined in given object
     *
     * @param {object} object object to evaluate
     * @param {string} property property name
     * @returns {boolean} whether property is defined on object
     */
    function hasOwnProperty(object, property = "") {
      return Object.prototype.hasOwnProperty.call(object ?? {}, property);
    }
    const SFDC_DEFAULT = "__sfdc_default__";
    /**
     * Path given resolve, to avoid empty function
     *
     * @param {object} resolver give resolver
     * @returns {object} patched resolver
     */
    function patchResolver(resolver) {
      return {
        patchRecord: true,
        getter: (target, key) => () => get(target, key),
        ...resolver
      };
    }
    /**
     * Check if given field is spanning field
     *
     * @param {object} field field to check
     * @returns {boolean} true if field is spanning field
     */
    function isSpanningField(field) {
      return notEmpty(field?.value?.fields);
    }

    /**
     * Return field displayValue or value or field itself
     *
     * @param {object} field field to get value
     * @returns {any} field displayValue or value or field itself
     */
    function fieldToValue(field) {
      return field?.displayValue || field?.value || field;
    }

    /**
     * Return field value or empty string
     *
     * @param {object} field target field to get value
     * @param {any} value field's value
     * @returns {any} when field's displayValue and value are both null return empty string
     *                otherwise return value
     */
    function safeFieldValue(field, value) {
      if (isField(field)) {
        return value ?? "";
      }
      return value;
    }

    /**
     * Check if field has null value
     *
     * @param {object} propertyValue field value
     * @returns {boolean} whether it's a null value of field
     */
    function isField(propertyValue) {
      return typeof propertyValue === "object" && !Array.isArray(propertyValue) && hasOwnProperty(propertyValue, "value") && hasOwnProperty(propertyValue, "displayValue");
    }

    /**
     * Convert a plain object to getify
     *
     * @param {object} object to be getified
     * @param {object} resolver getter/setter resolver
     * @param {object} parent parent object to apply property
     * @returns {object} getified object
     */
    function getify(object, resolver, parent = {}) {
      if (empty(object) || isPrimitive(object) || isFunction(object)) {
        return object;
      }
      resolver = patchResolver(resolver);
      if (Array.isArray(object)) {
        return object.map(item => getify(item, resolver));
      }
      return Object.entries(object).reduce((initial, entry) => {
        const [key, value] = entry;
        const type = typeof value;
        if (isPrimitive(value)) {
          Object.defineProperty(initial, key, {
            get() {
              return resolver.getter(object, key)();
            },
            enumerable: true
          });
        } else if (Array.isArray(value)) {
          initial[key] = value.map(item => getify(item, resolver));
        } else if (isFunction(value)) {
          initial[key] = value;
        }
        // istanbul ignore else
        else if (type === "object") {
          const obj = {};
          if (resolver.patchRecord) {
            Object.defineProperties(obj, {
              [SFDC_DEFAULT]: {
                get() {
                  return safeFieldValue(value, resolver.getter(object, key)());
                },
                enumerable: true
              },
              _rawValue: {
                get() {
                  return resolver.getter(obj, "value")();
                },
                enumerable: true
              },
              _displayValue: {
                get() {
                  return resolver.getter(obj, "displayValue")();
                },
                enumerable: true
              }
            });
          }
          getify(value, resolver, obj);
          if (isSpanningField(obj)) {
            const fields = obj.value.fields;
            Object.entries(fields).forEach(field => {
              const [fieldName, fieldInfo] = field;

              // Don't override existing property
              if (!hasOwnProperty(obj, fieldName)) {
                Object.defineProperty(obj, fieldName, {
                  get() {
                    // if field is spanning field, return itself
                    if (isSpanningField(fieldInfo)) {
                      return fieldInfo;
                    }

                    // if field is not spanning field, return displayValue or value or itself
                    return fieldToValue(fieldInfo);
                  },
                  enumerable: true
                });
              }
            });
          }
          // Lock will block defineProperties from return value. Or it's proxied, can use defineProperties at all
          // But for argument locker didn't touch it, so we can still use defineProperties on it.
          initial[key] = obj;
        }
        return initial;
      }, parent);
    }

    /**
     * Returns the number in the range of the min and the max value
     * If the input value is less than min, returns the min
     * If the input value is greater than max, returns the max.
     *
     * @function range
     * @param {number} value - The input value to range
     * @param {number} min -  The minimum number
     * @param {number} max - The maximum number
     * @returns {number} - returns the number in the range
     */
    function range(value, min, max) {
      const number = Number.parseInt(value, 10);
      if (number < min) {
        return min;
      }
      if (number > max) {
        return max;
      }
      return number;
    }

    /**
     * Validates if the given value is a number
     * The function supports the validation of
     * decimal, binary and hexadecimal numbers
     *
     * @param {any} value The value to be validated
     * @returns {boolean} True if the value is a number, otherwise False
     */
    function isNumber(value) {
      return value !== "" && !isNaN(Number(value)) && /^-?[0-9a-fA-Fx.]*$/.exec(value);
    }

    const VALID_UNITS = ["%", "cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh"];

    /**
     * The value and unit of a unit value [number][px|%|rem|...]
     * E.g.: { value: "100", unit: "px" }
     *
     * @typedef {object} UnitValue
     * @property {number} value - The unit value
     * @property {string} unit - The unit
     */

    /**
     * Parse the given size in its numeric and unit parts
     * Expected pattern [number][px|%|rem|...]
     *
     * @param {string} unitValue The size value to be parsed
     * @param {string[]} acceptedUnits The list of accepted units.
     * @returns {UnitValue} An object with the numeric value and unit
     */
    function parseUnit(unitValue, acceptedUnits = VALID_UNITS) {
      const parsedValues = /^([^a-z%]*)(.*)/.exec(unitValue);
      let value = parsedValues[1];
      let unit = parsedValues[2];
      if (!isNumber(value) || !acceptedUnits.includes(unit)) {
        value = "";
        unit = "";
      }
      return {
        value,
        unit
      };
    }

    const propertyNamesHash = properties => {
      return typeof properties === "object" ? properties : {};
    };
    const proto = {
      toString() {
        return Object.keys(this).map(key => {
          const [name, unit] = key.split(":");
          const parsedValue = parseUnit(this[key]);
          let value;
          if (notEmpty(parsedValue.unit)) {
            value = this[key];
          } else {
            value = notEmpty(this[key]) ? `${this[key]}${unit ?? ""}` : "initial";
          }
          return `${name}: ${value};`;
        }).join(" ");
      }
    };

    /**
     * A CSS Custom Property Utility
     *
     * @example
     *   const styles = propertySet({
     *       "--dxp-c-card-content-width:%": this.contentWidth,
     *       "--dxp-c-card-content-height:px": this.contentHeight,
     *   }).toString();
     *
     *   When value is undefined/null/“”, the property is ignored. Such as contentWidth is undefined
     *   contentHeight is 0.
     *      "--dxp-c-card-content-height: 0px"
     *
     *   When contentWidth is 100, contentHeight is 100
     *
     *      "--dxp-c-card-content-width: 100%;--dxp-c-card-content-height: 0px;"
     *
     * @param {object} config a plain configuration, use as shallow copy.
     * @returns {object} A PropertySet object
     */
    function propertySet(config) {
      return Object.assign(Object.create(proto), propertyNamesHash(config));
    }

    /**
     * Static Content for placeholder datauri
     */
    const PLACEHOLDER_DATA_URI = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQwNiIgaGVpZ2h0PSI0NDEiIHZpZXdCb3g9IjAgMCAxNDA2IDQ0MSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgb3BhY2l0eT0iMC4yODMxNTgiIHk9IjAuMzMwMDc4IiB3aWR0aD0iMTQwNiIgaGVpZ2h0PSI0NDAiIGZpbGw9IiNGM0YzRjMiLz4KPHBhdGggZD0iTTY3OCAyNTJDNjcxLjkyIDI1MiA2NjcgMjQ3LjA4IDY2NyAyNDFWMTk5QzY2NyAxOTIuOTIgNjcxLjkyIDE4OCA2NzggMTg4SDcyOEM3MzQuMDggMTg4IDczOSAxOTIuOTIgNzM5IDE5OVYyNDFDNzM5IDI0Ny4wOCA3MzQuMDggMjUyIDcyOCAyNTJINjc4VjI1MlpNNjczIDIzMS43Nkw2ODEuODggMjI0LjhDNjgyLjU2IDIyNC4yOCA2ODMuMjggMjI0IDY4NC4wNCAyMjRDNjg0LjggMjI0IDY4NS41NiAyMjQuMjggNjg2LjIgMjI0LjhMNjk2LjY0IDIzMy4yNEw3MTQuMDggMjE4LjhDNzE0Ljc2IDIxOC4yNCA3MTUuNDggMjE4IDcxNi4yNCAyMThDNzE3IDIxOCA3MTcuNzYgMjE4LjI4IDcxOC40IDIxOC44TDczMyAyMzAuNDhWMTk5QzczMyAxOTYuMjQgNzMwLjc2IDE5NCA3MjggMTk0SDY3OEM2NzUuMjQgMTk0IDY3MyAxOTYuMjQgNjczIDE5OVYyMzEuNzZWMjMxLjc2Wk02OTUgMjIwQzY4OS40OCAyMjAgNjg1IDIxNS41MiA2ODUgMjEwQzY4NSAyMDQuNDggNjg5LjQ4IDIwMCA2OTUgMjAwQzcwMC41MiAyMDAgNzA1IDIwNC40OCA3MDUgMjEwQzcwNSAyMTUuNTIgNzAwLjUyIDIyMCA2OTUgMjIwWk02OTUgMjE0QzY5Ny4yIDIxNCA2OTkgMjEyLjIgNjk5IDIxMEM2OTkgMjA3LjggNjk3LjIgMjA2IDY5NSAyMDZDNjkyLjggMjA2IDY5MSAyMDcuOCA2OTEgMjEwQzY5MSAyMTIuMiA2OTIuOCAyMTQgNjk1IDIxNFpNNjc4IDI0Nkg3MjhDNzMwLjc2IDI0NiA3MzMgMjQzLjc2IDczMyAyNDFWMjM5LjY0QzczMyAyMzguNjggNzMyLjYgMjM3Ljg0IDczMS44NCAyMzcuMjRMNzE2LjI0IDIyNC43Nkw2OTguOCAyMzkuMjRDNjk4LjE2IDIzOS43NiA2OTcuNCAyNDAgNjk2LjY0IDI0MEM2OTUuODggMjQwIDY5NS4xNiAyMzkuOCA2OTQuNDggMjM5LjI0TDY4NC4wNCAyMzAuNzZMNjc0LjE2IDIzOC41MkM2NzMuNCAyMzkuMTIgNjczIDIzOS45NiA2NzMgMjQwLjkyVjI0MUM2NzMgMjQzLjc2IDY3NS4yNCAyNDYgNjc4IDI0NlYyNDZaIiBmaWxsPSIjQUJBQ0FEIi8+Cjwvc3ZnPg==";

    /**
     * Static Content for video placeholder datauri
     */
    const VIDEO_PLACEHOLDER_DATA_URI = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMxMiIgaGVpZ2h0PSI0NDAiIHZpZXdCb3g9IjAgMCAxMzEyIDQ0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgb3BhY2l0eT0iMC4yODMxNTgiIHdpZHRoPSIxMzEyIiBoZWlnaHQ9IjQ0MCIgZmlsbD0iI0YzRjNGMyIvPgo8cGF0aCBkPSJNNjM5LjA4IDE5MkM2NDAuNzYgMTkyIDY0Mi42OCAxOTIuNTYgNjQ0LjY4IDE5My42OEw2NzguNzYgMjEyLjg0QzY4Mi4yOCAyMTQuOCA2ODQgMjE3LjQgNjg0IDIyMEM2ODQgMjIyLjYgNjgyLjMyIDIyNS4xNiA2NzguNzYgMjI3LjE2TDY0NC42OCAyNDYuMzJDNjQyLjY4IDI0Ny40NCA2NDAuNzYgMjQ4IDYzOS4wOCAyNDhDNjM0Ljg4IDI0OCA2MzIgMjQ0LjY0IDYzMiAyMzguOTJWMjAxLjA4QzYzMiAxOTUuMzYgNjM0Ljg4IDE5MiA2MzkuMDggMTkyVjE5MloiIGZpbGw9IiNBQkFDQUQiLz4KPC9zdmc+";
    const LOGO_PLACEHOLDER_DATA_URI = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUwIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgMTUwIDUwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSIyNSIgY3k9IjI1IiByPSIyNSIgZmlsbD0iIzc3NzU3QSIvPgo8cGF0aCBkPSJNNjUuNTI4NyAzOS41VjEyLjAzMkg3MC40MDA3VjM1LjM4NEg4MS44MjQ3VjM5LjVINjUuNTI4N1pNOTQuMDk5NSA0MC4wMDRDOTIuMzkxNSA0MC4wMDQgOTAuNzk1NSAzOS41ODQgODkuMzExNSAzOC43NDRDODcuODI3NSAzNy44NzYgODYuNjIzNSAzNi42NDQgODUuNjk5NSAzNS4wNDhDODQuNzc1NSAzMy40MjQgODQuMzEzNSAzMS40NzggODQuMzEzNSAyOS4yMUM4NC4zMTM1IDI2LjkxNCA4NC43NzU1IDI0Ljk2OCA4NS42OTk1IDIzLjM3MkM4Ni42MjM1IDIxLjc0OCA4Ny44Mjc1IDIwLjUxNiA4OS4zMTE1IDE5LjY3NkM5MC43OTU1IDE4LjgwOCA5Mi4zOTE1IDE4LjM3NCA5NC4wOTk1IDE4LjM3NEM5NS44MzU1IDE4LjM3NCA5Ny40NDU1IDE4LjgwOCA5OC45Mjk1IDE5LjY3NkMxMDAuNDE0IDIwLjUxNiAxMDEuNjE4IDIxLjc0OCAxMDIuNTQyIDIzLjM3MkMxMDMuNDY2IDI0Ljk2OCAxMDMuOTI4IDI2LjkxNCAxMDMuOTI4IDI5LjIxQzEwMy45MjggMzEuNDc4IDEwMy40NjYgMzMuNDI0IDEwMi41NDIgMzUuMDQ4QzEwMS42MTggMzYuNjQ0IDEwMC40MTQgMzcuODc2IDk4LjkyOTUgMzguNzQ0Qzk3LjQ0NTUgMzkuNTg0IDk1LjgzNTUgNDAuMDA0IDk0LjA5OTUgNDAuMDA0Wk05NC4wOTk1IDM2LjA1NkM5NS42MTE1IDM2LjA1NiA5Ni44MDE1IDM1LjQyNiA5Ny42Njk1IDM0LjE2NkM5OC41Mzc1IDMyLjkwNiA5OC45NzE1IDMxLjI1NCA5OC45NzE1IDI5LjIxQzk4Ljk3MTUgMjcuMTM4IDk4LjUzNzUgMjUuNDcyIDk3LjY2OTUgMjQuMjEyQzk2LjgwMTUgMjIuOTUyIDk1LjYxMTUgMjIuMzIyIDk0LjA5OTUgMjIuMzIyQzkyLjU4NzUgMjIuMzIyIDkxLjM5NzUgMjIuOTUyIDkwLjUyOTUgMjQuMjEyQzg5LjY4OTUgMjUuNDcyIDg5LjI2OTUgMjcuMTM4IDg5LjI2OTUgMjkuMjFDODkuMjY5NSAzMS4yNTQgODkuNjg5NSAzMi45MDYgOTAuNTI5NSAzNC4xNjZDOTEuMzk3NSAzNS40MjYgOTIuNTg3NSAzNi4wNTYgOTQuMDk5NSAzNi4wNTZaTTExNS44OSA0OC42MTRDMTE0LjI2NiA0OC42MTQgMTEyLjc5NiA0OC40MTggMTExLjQ4IDQ4LjAyNkMxMTAuMTkyIDQ3LjYzNCAxMDkuMTcgNDcuMDMyIDEwOC40MTQgNDYuMjJDMTA3LjY4NiA0NS40MzYgMTA3LjMyMiA0NC40NDIgMTA3LjMyMiA0My4yMzhDMTA3LjMyMiA0MS41MyAxMDguMzAyIDQwLjA2IDExMC4yNjIgMzguODI4VjM4LjY2QzEwOS43MyAzOC4zMjQgMTA5LjI4MiAzNy44NzYgMTA4LjkxOCAzNy4zMTZDMTA4LjU4MiAzNi43NTYgMTA4LjQxNCAzNi4wNTYgMTA4LjQxNCAzNS4yMTZDMTA4LjQxNCAzNC40MDQgMTA4LjYzOCAzMy42NzYgMTA5LjA4NiAzMy4wMzJDMTA5LjU2MiAzMi4zNiAxMTAuMDk0IDMxLjgxNCAxMTAuNjgyIDMxLjM5NFYzMS4yMjZDMTA5Ljk4MiAzMC42OTQgMTA5LjM1MiAyOS45NTIgMTA4Ljc5MiAyOUMxMDguMjYgMjguMDQ4IDEwNy45OTQgMjYuOTcgMTA3Ljk5NCAyNS43NjZDMTA3Ljk5NCAyNC4xNyAxMDguMzcyIDIyLjgyNiAxMDkuMTI4IDIxLjczNEMxMDkuODg0IDIwLjY0MiAxMTAuODc4IDE5LjgxNiAxMTIuMTEgMTkuMjU2QzExMy4zNyAxOC42NjggMTE0LjcxNCAxOC4zNzQgMTE2LjE0MiAxOC4zNzRDMTE2LjcwMiAxOC4zNzQgMTE3LjIzNCAxOC40MyAxMTcuNzM4IDE4LjU0MkMxMTguMjcgMTguNjI2IDExOC43NDYgMTguNzM4IDExOS4xNjYgMTguODc4SDEyNi41NThWMjIuNDQ4SDEyMi43NzhDMTIzLjExNCAyMi44NCAxMjMuMzk0IDIzLjM0NCAxMjMuNjE4IDIzLjk2QzEyMy44NDIgMjQuNTQ4IDEyMy45NTQgMjUuMjA2IDEyMy45NTQgMjUuOTM0QzEyMy45NTQgMjcuNDQ2IDEyMy42MDQgMjguNzM0IDEyMi45MDQgMjkuNzk4QzEyMi4yMDQgMzAuODM0IDEyMS4yNjYgMzEuNjE4IDEyMC4wOSAzMi4xNUMxMTguOTE0IDMyLjY4MiAxMTcuNTk4IDMyLjk0OCAxMTYuMTQyIDMyLjk0OEMxMTUuNjk0IDMyLjk0OCAxMTUuMjMyIDMyLjkwNiAxMTQuNzU2IDMyLjgyMkMxMTQuMjggMzIuNzM4IDExMy44MDQgMzIuNTk4IDExMy4zMjggMzIuNDAyQzExMy4wMiAzMi42ODIgMTEyLjc2OCAzMi45NjIgMTEyLjU3MiAzMy4yNDJDMTEyLjQwNCAzMy41MjIgMTEyLjMyIDMzLjkgMTEyLjMyIDM0LjM3NkMxMTIuMzIgMzQuOTY0IDExMi41NTggMzUuNDI2IDExMy4wMzQgMzUuNzYyQzExMy41MzggMzYuMDk4IDExNC40MiAzNi4yNjYgMTE1LjY4IDM2LjI2NkgxMTkuMzM0QzEyMS44MjYgMzYuMjY2IDEyMy43MDIgMzYuNjcyIDEyNC45NjIgMzcuNDg0QzEyNi4yNSAzOC4yNjggMTI2Ljg5NCAzOS41NTYgMTI2Ljg5NCA0MS4zNDhDMTI2Ljg5NCA0Mi42OTIgMTI2LjQ0NiA0My45MSAxMjUuNTUgNDUuMDAyQzEyNC42NTQgNDYuMTIyIDEyMy4zOCA0Ny4wMDQgMTIxLjcyOCA0Ny42NDhDMTIwLjA3NiA0OC4yOTIgMTE4LjEzIDQ4LjYxNCAxMTUuODkgNDguNjE0Wk0xMTYuMTQyIDI5LjkyNEMxMTcuMTIyIDI5LjkyNCAxMTcuOTYyIDI5LjU2IDExOC42NjIgMjguODMyQzExOS4zNjIgMjguMTA0IDExOS43MTIgMjcuMDgyIDExOS43MTIgMjUuNzY2QzExOS43MTIgMjQuNDc4IDExOS4zNjIgMjMuNDg0IDExOC42NjIgMjIuNzg0QzExNy45OSAyMi4wNTYgMTE3LjE1IDIxLjY5MiAxMTYuMTQyIDIxLjY5MkMxMTUuMTM0IDIxLjY5MiAxMTQuMjggMjIuMDQyIDExMy41OCAyMi43NDJDMTEyLjg4IDIzLjQ0MiAxMTIuNTMgMjQuNDUgMTEyLjUzIDI1Ljc2NkMxMTIuNTMgMjcuMDgyIDExMi44OCAyOC4xMDQgMTEzLjU4IDI4LjgzMkMxMTQuMjggMjkuNTYgMTE1LjEzNCAyOS45MjQgMTE2LjE0MiAyOS45MjRaTTExNi42NDYgNDUuNDY0QzExOC4yOTggNDUuNDY0IDExOS42NDIgNDUuMTI4IDEyMC42NzggNDQuNDU2QzEyMS43MTQgNDMuNzg0IDEyMi4yMzIgNDMuMDE0IDEyMi4yMzIgNDIuMTQ2QzEyMi4yMzIgNDEuMzM0IDEyMS45MSA0MC43ODggMTIxLjI2NiA0MC41MDhDMTIwLjY1IDQwLjIyOCAxMTkuNzU0IDQwLjA4OCAxMTguNTc4IDQwLjA4OEgxMTUuNzY0QzExNC42NDQgNDAuMDg4IDExMy43MDYgMzkuOTkgMTEyLjk1IDM5Ljc5NEMxMTEuODg2IDQwLjYwNiAxMTEuMzU0IDQxLjUxNiAxMTEuMzU0IDQyLjUyNEMxMTEuMzU0IDQzLjQ0OCAxMTEuODMgNDQuMTYyIDExMi43ODIgNDQuNjY2QzExMy43MzQgNDUuMTk4IDExNS4wMjIgNDUuNDY0IDExNi42NDYgNDUuNDY0Wk0xMzguMzE0IDQwLjAwNEMxMzYuNjA2IDQwLjAwNCAxMzUuMDEgMzkuNTg0IDEzMy41MjYgMzguNzQ0QzEzMi4wNDIgMzcuODc2IDEzMC44MzggMzYuNjQ0IDEyOS45MTQgMzUuMDQ4QzEyOC45OSAzMy40MjQgMTI4LjUyOCAzMS40NzggMTI4LjUyOCAyOS4yMUMxMjguNTI4IDI2LjkxNCAxMjguOTkgMjQuOTY4IDEyOS45MTQgMjMuMzcyQzEzMC44MzggMjEuNzQ4IDEzMi4wNDIgMjAuNTE2IDEzMy41MjYgMTkuNjc2QzEzNS4wMSAxOC44MDggMTM2LjYwNiAxOC4zNzQgMTM4LjMxNCAxOC4zNzRDMTQwLjA1IDE4LjM3NCAxNDEuNjYgMTguODA4IDE0My4xNDQgMTkuNjc2QzE0NC42MjggMjAuNTE2IDE0NS44MzIgMjEuNzQ4IDE0Ni43NTYgMjMuMzcyQzE0Ny42OCAyNC45NjggMTQ4LjE0MiAyNi45MTQgMTQ4LjE0MiAyOS4yMUMxNDguMTQyIDMxLjQ3OCAxNDcuNjggMzMuNDI0IDE0Ni43NTYgMzUuMDQ4QzE0NS44MzIgMzYuNjQ0IDE0NC42MjggMzcuODc2IDE0My4xNDQgMzguNzQ0QzE0MS42NiAzOS41ODQgMTQwLjA1IDQwLjAwNCAxMzguMzE0IDQwLjAwNFpNMTM4LjMxNCAzNi4wNTZDMTM5LjgyNiAzNi4wNTYgMTQxLjAxNiAzNS40MjYgMTQxLjg4NCAzNC4xNjZDMTQyLjc1MiAzMi45MDYgMTQzLjE4NiAzMS4yNTQgMTQzLjE4NiAyOS4yMUMxNDMuMTg2IDI3LjEzOCAxNDIuNzUyIDI1LjQ3MiAxNDEuODg0IDI0LjIxMkMxNDEuMDE2IDIyLjk1MiAxMzkuODI2IDIyLjMyMiAxMzguMzE0IDIyLjMyMkMxMzYuODAyIDIyLjMyMiAxMzUuNjEyIDIyLjk1MiAxMzQuNzQ0IDI0LjIxMkMxMzMuOTA0IDI1LjQ3MiAxMzMuNDg0IDI3LjEzOCAxMzMuNDg0IDI5LjIxQzEzMy40ODQgMzEuMjU0IDEzMy45MDQgMzIuOTA2IDEzNC43NDQgMzQuMTY2QzEzNS42MTIgMzUuNDI2IDEzNi44MDIgMzYuMDU2IDEzOC4zMTQgMzYuMDU2WiIgZmlsbD0iIzcwNkU2QiIvPgo8L3N2Zz4K";

    /**
     * Whether uri has content.
     *
     * @param {string} uri uri to check
     * @returns {boolean} true if uri has content, instead of nullish or empty string
     */
    function hasUri(uri) {
      return uri && uri !== "";
    }

    /**
     * Transform uri to css url('uri')
     *
     * @example
     *      toCssUrl("https://example") => url('https://example')
     *
     * @param {string} uri source uri
     * @returns {string} css url string
     */
    function toCssUrl(uri) {
      return hasUri(uri) ? `url("${uri}")` : "";
    }

    /**
     * Normalize url, if url is empty, return fallback placeholder url
     *
     * @param {string} url image url
     * @returns {string} url value
     */
    function safeCssUrl(url) {
      return pipe(safeImageSrc, toCssUrl)(url);
    }

    /**
     * Return normalized image uri
     *
     * @param {string} uri image uri
     * @returns {string} if empty return default placeholder data uri.
     */
    function safeImageSrc(uri) {
      return hasUri(uri) ? uri : PLACEHOLDER_DATA_URI;
    }

    /**
     * Build a querySelectorAll functional operator with given selector
     *
     * @param {string} selector A css selector
     * @returns {Function} querySelectorAll operator tied to selector
     */
    const querySelectorAll = selector => element => Array.from(element?.querySelectorAll(selector));
    const focusableElementsSelector = "a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]";

    /**
     * Returns the first focusable element inside the given element.
     * NOTE: Only works for elements that have open shadow root!
     *
     * @param {Element} element - element to search inside
     * @returns {Element|null}  - first focusable element inside the given element
     */
    const findFirstFocusable = element => {
      if (!element) {
        return null;
      }
      if (element.matches && element.matches(focusableElementsSelector)) {
        return element;
      }

      // eslint-disable-next-line @locker/locker/distorted-element-shadow-root-getter
      const shadowRoot = element.shadowRoot;
      if (shadowRoot) {
        // if element is in shadow dom
        return findFirstFocusable(shadowRoot);
      } else if (element.assignedElements) {
        // if the element is a slot with assigned elements
        for (const assignedElement of element.assignedElements()) {
          const focusableInAssigned = findFirstFocusable(assignedElement);
          if (focusableInAssigned) {
            return focusableInAssigned;
          }
        }
      } else {
        // if element is in light dom
        for (const child of element.children) {
          const focusableChild = findFirstFocusable(child);
          if (focusableChild) {
            return focusableChild;
          }
        }
      }
      return null;
    };

    /**
     * Split string into array of words and remove empty words
     *
     * @param {string} separator
     * @param {string} string
     * @returns
     */
    const split = curry((separator, string) => {
      return string?.toString().split(separator) ?? [];
    });

    /**
     * Capitalize given string, such as from hello to Hello
     *
     * @param {string} string String to be capitalized
     * @returns {string} capitalized string
     */
    function toCapitalized(string = "") {
      string = string?.toString();
      return isNonEmptyString(string) ? `${string.charAt(0).toUpperCase()}${string.slice(1)}` : "";
    }

    /**
     * Check if given value is a string
     *
     * @param {*} str value to be checked
     * @returns {boolean} flag indicating if the value is string type
     */
    function isString(str) {
      return typeof str === "string";
    }

    /**
     * Check if given string is non empty
     *
     * @param {string} str string to be checked
     * @returns {boolean} whether string is non empty
     */
    function isNonEmptyString(str) {
      return isString(str) && notEmpty(str);
    }

    /**
     * Split url into array of words and remove empty words
     *
     * @param {*} url url to be split
     * @returns {string[]} array of words
     */
    function splitUrl(url) {
      return compose(filter(item => item?.length > 0), split("/"))(url);
    }

    /**
     * Return a promise resolved when time is out.
     *
     * @param {number} interval timeout value
     * @returns {object} A promise
     */
    function timeout(interval = 0) {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(resolve, interval);
      });
    }

    /**
     * Return a promise resolved when requestAnimationFrame is called.
     *
     * @returns {object} A promise
     */
    function nextFrame() {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(resolve);
      });
    }

    const LARGE_FORMFACTOR = "l";
    const MEDIUM_FORMFACTOR = "m";
    const SMALL_FORMFACTOR = "s";
    const FORMFACTOR_ARRAY = [LARGE_FORMFACTOR, MEDIUM_FORMFACTOR, SMALL_FORMFACTOR];

    // Content position value to flexbox alignment property mapping
    const AlignmentMap = {
      top: "flex-start",
      left: "flex-start",
      bottom: "flex-end",
      right: "flex-end",
      center: "center"
    };

    /**
     * Create attributes for all the form factors to be fed to the propertySet
     *
     * @param {object} attributeMap
     * @param {string} keyPrefix
     * @param {object} attributeValues
     * @returns {object} { "key:unit" : "value" }
     * @example {name: "height", unit: "px"},'--dxp-c', {"--dxp-c-l-height": "10", "--dxp-c-m-height": "20", "--dxp-c-s-height": "30" } =>
     *  {"--dxp-c-l-height:px": "10", "--dxp-c-m-height:px": "20", "--dxp-c-s-height:px": "30" }
     */
    function prependFormFactor(attributeMap, keyPrefix, attributeValues) {
      const response = {};
      FORMFACTOR_ARRAY.forEach(formFactor => {
        attributeMap.forEach(prop => {
          const propKeyWithCustomTitle = `${keyPrefix}-${formFactor}-${prop.customTitle || prop.name}`;
          const propKey = `${keyPrefix}-${formFactor}-${prop.name}`;
          response[`${propKeyWithCustomTitle}:${prop.unit}`] = prop.name.match(/alignment/gi) && Object.keys(attributeValues).includes(propKey) ? AlignmentMap[attributeValues[propKey]] : attributeValues[propKey];
        });
      });
      return response;
    }

    /**
     * Convert `class` attribute value to a selector
     *
     * @param {string} classAttributeValue value passed in class attribute of the element
     * @returns {string} selector which could be passed to query selector to select that element
     */
    function convertClassAttributeToSelector(classAttributeValue) {
      return ifElse(!classAttributeValue || typeof classAttributeValue !== "string", null, () => `.${classAttributeValue.split(" ").join(".")}`);
    }

    /**
     * Split string into object of key value pairs
     * ex: "--dxp-c-l-width: 30; --dxp-c-l-height: 30;"
     * response : { --dxp-c-l-width: 30, --dxp-c-l-height: 30};
     * here attributeSeparator is ;, and keyValSeparator is :
     *
     * @param {string} attributeSeparator
     * @param {string} keyValSeparator
     * @param {string} string
     * @returns {object}
     */
    function splitStringToObj(attributeSeparator, keyValSeparator, string) {
      const response = {};
      if (!string || !attributeSeparator || !keyValSeparator) {
        return {};
      }
      const stringArray = string.split(attributeSeparator);
      stringArray.filter(keyValue => {
        const kvm = keyValue.match(new RegExp(keyValSeparator, "g")) || [];
        return keyValue && kvm.length === 1 && kvm[0] === keyValSeparator;
      }).forEach(keyValue => {
        const [key, value] = keyValue.split(keyValSeparator);
        response[key.trim()] = value.trim();
      });
      return response;
    }

    /**
     * Define the debounce timeout
     * Why choose 150ms for debounce delay, below link has some good explanation.
     * https://www.nngroup.com/articles/response-times-3-important-limits/
     * https://icons8.com/articles/ui-design-user-interface-illustrations/
     */
    const DEBOUNCE_TIMEOUT = 150;

    /**
     * Define a empty client rect.
     */
    const EMPTY_RECT = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };

    /**
     * Parses strings that use dynamic values
     * Strings should follow this format: "Hello {0}, welcome to {1}"
     * Use for interally supplied text and values only
     *
     * @param {string} text The string to be parsed
     * @param {...string} values the strings to be inserted
     * @returns {string} The original string with the values inserted
     */
    function formatString(text, ...values) {
      return values.reduce((t, value, index) => t?.replaceAll(`{${index}}`, value), text);
    }

    exports.AlignmentMap = AlignmentMap;
    exports.DEBOUNCE_TIMEOUT = DEBOUNCE_TIMEOUT;
    exports.EMPTY_RECT = EMPTY_RECT;
    exports.KeyCodes = KeyCodes;
    exports.LOGO_PLACEHOLDER_DATA_URI = LOGO_PLACEHOLDER_DATA_URI;
    exports.PLACEHOLDER_DATA_URI = PLACEHOLDER_DATA_URI;
    exports.SFDC_DEFAULT = SFDC_DEFAULT;
    exports.VIDEO_PLACEHOLDER_DATA_URI = VIDEO_PLACEHOLDER_DATA_URI;
    exports.and = and;
    exports.apply = apply;
    exports.compose = compose;
    exports.convertClassAttributeToSelector = convertClassAttributeToSelector;
    exports.curry = curry;
    exports.debounce = debounce;
    exports.deepCopy = deepCopy;
    exports.deepMerge = deepMerge;
    exports.empty = empty;
    exports.every = every;
    exports.everyKey = everyKey;
    exports.fieldToValue = fieldToValue;
    exports.filter = filter;
    exports.find = find;
    exports.findFirstFocusable = findFirstFocusable;
    exports.forEach = forEach;
    exports.forEachKey = forEachKey;
    exports.formatString = formatString;
    exports.get = get;
    exports.getify = getify;
    exports.hasOwnProperty = hasOwnProperty;
    exports.hasUri = hasUri;
    exports.ifElse = ifElse;
    exports.ifVal = ifVal;
    exports.isField = isField;
    exports.isFunction = isFunction;
    exports.isNonEmptyString = isNonEmptyString;
    exports.isNumber = isNumber;
    exports.isPrimitive = isPrimitive;
    exports.isString = isString;
    exports.map = map;
    exports.mapObject = mapObject;
    exports.mapping = mapping;
    exports.mergeUniqueRecords = mergeUniqueRecords;
    exports.nextFrame = nextFrame;
    exports.notEmpty = notEmpty;
    exports.or = or;
    exports.parseUnit = parseUnit;
    exports.pipe = pipe;
    exports.prependFormFactor = prependFormFactor;
    exports.propertySet = propertySet;
    exports.querySelectorAll = querySelectorAll;
    exports.range = range;
    exports.safeCssUrl = safeCssUrl;
    exports.safeFieldValue = safeFieldValue;
    exports.safeImageSrc = safeImageSrc;
    exports.safeParseJson = safeParseJson;
    exports.set = set;
    exports.split = split;
    exports.splitStringToObj = splitStringToObj;
    exports.splitUrl = splitUrl;
    exports.stringify = stringify;
    exports.timeout = timeout;
    exports.toCapitalized = toCapitalized;
    exports.toCssUrl = toCssUrl;
    exports.toIndexes = toIndexes;
    exports.tryCatch = tryCatch;
    exports.typeOf = typeOf;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/utilsInternal', ['exports'], (function (exports) {

  const objToString = Object.prototype.toString;
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const funcToString = Function.prototype.toString;
  const objectCtorString = funcToString.call(Object);
  const isInteger = value => {
    return Number.isInteger ? Number.isInteger(value) : typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
  };
  function isFunction(val) {
    return typeof val === 'function';
  }
  function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
  }
  function isPromiseLike(val) {
    return isObjectLike(val) && typeof val.then === 'function';
  }
  function isObject(value) {
    return isFunction(value) || isObjectLike(value);
  }
  function getObjectTag(v) {
    return objToString.call(v);
  }
  function isObjectByTag(v) {
    return getObjectTag(v) === '[object Object]';
  }
  function isPlainObject(value) {
    if (!isObjectLike(value) || !isObjectByTag(value)) {
      return false;
    }
    const proto = Object.getPrototypeOf(Object(value));
    if (proto === null) {
      return true;
    }
    const ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return isFunction(ctor) && ctor instanceof ctor && funcToString.call(ctor) === objectCtorString;
  }
  function isNil(value) {
    return value == null;
  }
  function isBlank(value) {
    return isNil(value) || typeof value !== 'string' || value.trim().length === 0;
  }
  function empty(value) {
    if (Array.isArray(value)) {
      return value.length === 0;
    }
    const type = typeof value;
    switch (type) {
      case 'string':
        return value.toString() === '';
      case 'boolean':
      case 'number':
      case 'function':
        return false;
      case 'object':
        return Object.keys(value ?? {}).length === 0;
      default:
        return value == null;
    }
  }

  const rootRef$1 = '#REF:$';
  function defaultCompareFn(a, b) {
    return a.localeCompare(b);
  }
  function baseDeepSort(value, compareFn, stack, errors, path = rootRef$1) {
    if (!isObjectLike(value)) {
      return value;
    }
    const obj = value;
    if (stack.has(obj)) {
      return value;
    }
    stack.set(obj, path);
    if (Array.isArray(obj)) {
      return obj.map((item, idx) => {
        const childPath = `${path}[${String(idx)}]`;
        return baseDeepSort(item, compareFn, stack, errors, childPath);
      });
    }
    if (isPlainObject(value)) {
      return Object.keys(value).sort(compareFn).reduce((acc, key) => {
        const childPath = `${path}.${key}`;
        acc[key] = baseDeepSort(value[key], compareFn, stack, errors, childPath);
        return acc;
      }, {});
    }
    {
      const message = `unsupported type '${getObjectTag(obj)}' found at '${path}'`;
      errors.push(new Error(message));
    }
    return value;
  }
  function deepSort(value, comparator) {
    const stack = new WeakMap();
    const errors = [];
    const sortedValue = baseDeepSort(value, isFunction(comparator) ? comparator : defaultCompareFn, stack, errors);
    const result = Object.create(null);
    Object.defineProperty(result, 'value', {
      enumerable: true,
      value: sortedValue
    });
    Object.defineProperty(result, 'errors', {
      enumerable: true,
      value: errors
    });
    return result;
  }

  function baseDeepFreeze(value, errors = [], ref = '#REF:$') {
    if (isObjectLike(value) && !Object.isFrozen(value)) {
      const obj = value;
      if ((typeof window === 'undefined' || "development" !== 'production') && !isPlainObject(obj) && !Array.isArray(obj)) {
        const message = `unsupported type '${getObjectTag(obj)}' found at '${ref}'`;
        errors.push(new Error(message));
      }
      Object.freeze(obj);
      for (const key of Object.keys(obj)) {
        baseDeepFreeze(obj[key], errors, `${ref}.${key}`);
      }
    }
    const result = Object.create(null);
    Object.defineProperty(result, 'value', {
      enumerable: true,
      value
    });
    Object.defineProperty(result, 'errors', {
      enumerable: true,
      value: errors
    });
    return result;
  }
  function deepFreeze(value) {
    return baseDeepFreeze(value);
  }

  const cache = new WeakSet();
  function redefineProperty(target, key) {
    try {
      const value = Reflect.get(target, key);
      Reflect.defineProperty(target, key, {
        enumerable: true,
        get() {
          return typeof value === 'object' && value !== null ? readonly(value) : value;
        }
      });
    } catch {
      // Intentionally empty
    }
  }
  function readonly(target) {
    if (typeof target !== 'object' || target === null || cache.has(target)) {
      return target;
    }
    cache.add(target);
    if (Object.isFrozen(target)) {
      const shallowClone = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
      for (const [key, value] of Object.entries(target)) {
        Reflect.set(shallowClone, key, typeof value === 'object' && value !== null ? readonly(value) : value);
      }
      return Object.freeze(shallowClone);
    }
    for (const key of Object.keys(target)) {
      redefineProperty(target, key);
    }
    return Object.freeze(target);
  }

  function get(obj, path, defaultValue) {
    const travel = regexp => String.prototype.split.call(path, regexp).filter(Boolean).reduce((res, key) => res !== null && res !== undefined ? res[key] : res, obj);
    const result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/);
    return result === undefined || result === obj ? defaultValue : result;
  }

  function circularRefReplacer() {
    const errors = [];
    const pathsUndefined = [];
    const stack = new WeakMap();
    const rootRef = '#REF:$';
    const undefRef = '#REF:undefined';
    function replacer(key, value) {
      const keyString = String(key);
      const parentPath = stack.get(this);
      const path = parentPath ? parentPath + (Array.isArray(this) ? `[${keyString}]` : '.' + keyString) : Array.isArray(this) ? `[${keyString}]` : keyString;
      if (!isObjectLike(value) || value !== Object(value)) {
        if (typeof value === 'undefined') {
          pathsUndefined.push(path);
          return undefRef;
        }
        return value;
      }
      const obj = value;
      if (stack.has(obj)) {
        const ref = stack.get(obj);
        return ref ? `${rootRef}${ref[0] === '[' ? '' : '.'}${ref}` : rootRef;
      }
      {
        if (!isPlainObject(obj) && !Array.isArray(obj)) {
          const currentRef = path ? `${rootRef}${path[0] === '[' ? '' : '.'}${path}` : rootRef;
          const message = `unsupported type '${getObjectTag(obj)}' found at '${currentRef}'`;
          errors.push(new Error(message));
        }
      }
      stack.set(obj, path);
      return obj;
    }
    replacer.errors = () => errors;
    replacer.pathsUndefined = () => pathsUndefined;
    return replacer;
  }
  function circularRefReviver() {
    const circular = new Map();
    const rootRef = '#REF:$';
    const undefRef = '#REF:undefined';
    function decycle(cyclicRef, rootValue) {
      const matches = circular.get(cyclicRef);
      let ref = cyclicRef.substring(rootRef.length);
      ref.indexOf('.') === 0 && (ref = ref.substring(1));
      const cyclicValue = ref ? get(rootValue, ref) : rootValue;
      for (const match of matches) {
        match.value[match.key] = cyclicValue;
      }
      circular.delete(cyclicRef);
    }
    return function reviver(key, value) {
      if (typeof value === 'string' && value.indexOf(rootRef) === 0) {
        if (!circular.has(value)) {
          circular.set(value, []);
        }
        circular.get(value).push({
          value: this,
          key
        });
        return value;
      }
      if (!isObjectLike(value) || value !== Object(value)) {
        return typeof value === 'string' && value === undefRef ? undefined : value;
      }
      if (key === '') {
        const rootValue = this[''];
        for (const k of circular.keys()) {
          decycle(k, rootValue);
        }
      }
      return value;
    };
  }
  function deepClone(value) {
    const respond = (v, errors) => {
      const result = Object.create(null);
      Object.defineProperty(result, 'value', {
        enumerable: true,
        value: v
      });
      Object.defineProperty(result, 'errors', {
        enumerable: true,
        value: errors
      });
      return result;
    };
    if (!isObject(value)) {
      return respond(typeof value === 'symbol' ? Symbol.prototype.valueOf.call(value) : value, []);
    }
    const replacer = circularRefReplacer();
    const clone = JSON.parse(JSON.stringify(value, replacer), circularRefReviver());
    const pathsUndefined = replacer.pathsUndefined();
    for (const pathUndefined of pathsUndefined) {
      const tokens = pathUndefined.split('.');
      tokens.reduce((prev, curr) => {
        if (isPlainObject(prev)) {
          !Object.prototype.hasOwnProperty.call(prev, curr) && (prev[curr] = undefined);
          return prev[curr];
        }
        return undefined;
      }, clone);
    }
    return respond(clone, replacer.errors());
  }

  const rootRef = '#REF:$';
  function baseDeepEqual(a, b, stack, errors, path = rootRef) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null || typeof a !== 'object' || typeof b !== 'object') {
      return a !== a && b !== b;
    }
    if (stack.has(a)) {
      return stack.get(a) === b;
    }
    stack.set(a, b);
    if (Array.isArray(a)) {
      const length = a.length;
      if (!Array.isArray(b) || length !== b.length) {
        return false;
      }
      for (let i = length; i-- !== 0;) {
        const childPath = `${path}[${String(i)}]`;
        if (!baseDeepEqual(a.at(i), b.at(i), stack, errors, childPath)) {
          return false;
        }
      }
      return true;
    } else if (isPlainObject(a)) {
      const keys = Reflect.ownKeys(a);
      const length = keys.length;
      if (!isPlainObject(b) || length !== Reflect.ownKeys(b).length) {
        return false;
      }
      for (let i = length; i-- !== 0;) {
        const key = keys.at(i);
        const childPath = `${path}.${String(key)}`;
        if (!Reflect.has(b, key) || !baseDeepEqual(Reflect.get(a, key), Reflect.get(b, key), stack, errors, childPath)) {
          return false;
        }
      }
      return true;
    }
    {
      const message = `unsupported type '${getObjectTag(a)}' found at '${path}'`;
      errors.push(new Error(message));
    }
    return false;
  }
  function deepEqual(value1, value2) {
    const stack = new WeakMap();
    const errors = [];
    const value = baseDeepEqual(value1, value2, stack, errors);
    const result = Object.create(null);
    Object.defineProperty(result, 'value', {
      enumerable: true,
      value
    });
    Object.defineProperty(result, 'errors', {
      enumerable: true,
      value: errors
    });
    return result;
  }

  function uuidv4Factory() {
    let lastId = 0;
    return () => {
      if (isFunction(crypto?.randomUUID)) {
        return crypto.randomUUID();
      } else if (isFunction(crypto?.getRandomValues)) {
        return [1e7, 1e3, 4e3, 8e3, 1e11].join('-').replace(/[018]/g, c => (Number(c) ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> Number(c) / 4).toString(16));
      }
      return String(++lastId);
    };
  }
  const uuidv4 = uuidv4Factory();
  function uuidValidate(uuid) {
    return typeof uuid === 'string' && /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(uuid);
  }

  const TIMEOUTS = new WeakMap();
  const TIMEOUTS_CHILDREN = new WeakMap();
  const QUEUE_TIMEOUT_EXTENSIONS = new WeakMap();
  function defer() {
    const deferred = {};
    deferred.promise = new Promise((resolve, reject) => {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    return deferred;
  }
  function clearDebounceTimeout(promise) {
    if (TIMEOUTS.has(promise)) {
      clearTimeout(TIMEOUTS.get(promise));
      TIMEOUTS_CHILDREN.has(promise) && clearTimeout(TIMEOUTS_CHILDREN.get(promise));
      TIMEOUTS.delete(promise);
      TIMEOUTS_CHILDREN.delete(promise);
      QUEUE_TIMEOUT_EXTENSIONS.delete(promise);
      return true;
    }
    return false;
  }
  function extendDebouncedTimeout(promise, wait = 0) {
    if (TIMEOUTS.has(promise)) {
      QUEUE_TIMEOUT_EXTENSIONS.set(promise, wait);
      return true;
    }
    return false;
  }
  function debounce(fn, wait = 0) {
    let deferred;
    let timeoutId;
    let pendingArgs = [];
    function flush() {
      const {
        promise,
        resolve,
        reject
      } = deferred;
      if (QUEUE_TIMEOUT_EXTENSIONS.has(promise)) {
        const childTimeoutId = setTimeout(flush.bind(this), QUEUE_TIMEOUT_EXTENSIONS.get(promise));
        TIMEOUTS_CHILDREN.set(promise, childTimeoutId);
        QUEUE_TIMEOUT_EXTENSIONS.delete(promise);
        return;
      }
      const currentArgs = pendingArgs;
      timeoutId = undefined;
      pendingArgs = [];
      try {
        const result = fn.apply(this, currentArgs[currentArgs.length - 1]);
        Promise.resolve(result).then(resolve, reject).finally(() => {
          deferred = undefined;
          TIMEOUTS.delete(promise);
          TIMEOUTS_CHILDREN.delete(promise);
          QUEUE_TIMEOUT_EXTENSIONS.delete(promise);
        });
      } catch (e) {
        reject(e);
      }
    }
    function debounced(...args) {
      if (deferred) {
        clearDebounceTimeout(deferred.promise);
      } else {
        deferred = defer();
      }
      pendingArgs.push(args);
      timeoutId = setTimeout(flush.bind(this), wait);
      const {
        promise
      } = deferred;
      TIMEOUTS.set(promise, timeoutId);
      return promise;
    }
    return debounced;
  }

  const CONDITION = Symbol();
  const PROPERTY_CONTEXT_VALUE = 'value';
  const TRAPS_FORBIDDEN = ['connect', 'disconnect', 'update'];
  function extractCallback(data, property) {
    const value = Reflect.get(data, property);
    const d = {
      ...data
    };
    Reflect.deleteProperty(d, property);
    const cb = typeof value === 'function' || typeof value === 'undefined' ? value : () => Boolean(value);
    return [cb, d];
  }
  function createConditionalAdapter(superclass, trapsOrCallback, callback) {
    const argsLength = arguments.length;
    let effectiveTraps;
    let defaultCallback;
    if (argsLength > 2) {
      if (typeof trapsOrCallback !== 'undefined' && !Array.isArray(trapsOrCallback)) {
        throw new TypeError(`[utils] traps need to be an array; '${typeof trapsOrCallback}' given`);
      }
      if (typeof callback !== 'undefined' && !isFunction(callback)) {
        throw new TypeError(`[utils] callback needs to be a function; '${typeof callback}' given`);
      }
      effectiveTraps = trapsOrCallback;
      defaultCallback = callback;
    } else if (argsLength > 1) {
      const isArray = Array.isArray(trapsOrCallback);
      const isFunc = isFunction(trapsOrCallback);
      if (typeof trapsOrCallback !== 'undefined' && !isArray && !isFunc) {
        throw new TypeError(`[utils] second parameter either needs to define traps via an array, or a callback function; '${typeof trapsOrCallback}' given`);
      }
      effectiveTraps = isArray ? trapsOrCallback : undefined;
      defaultCallback = isFunc ? trapsOrCallback : undefined;
    }
    const callbackSymbol = Symbol();
    const executeCallbackSymbol = Symbol();
    class ConditionalAdapter extends superclass {
      [executeCallbackSymbol](trap) {
        const effectiveCallback = this[callbackSymbol].last ?? this[callbackSymbol].default;
        return effectiveCallback?.(trap, this) ?? true;
      }
      constructor(...args) {
        super(...args);
        this[callbackSymbol] = {
          default: defaultCallback,
          last: defaultCallback
        };
        const instance = this;
        const customTraps = new Set(Array.isArray(effectiveTraps) && effectiveTraps.length > 0 ? effectiveTraps.filter(trap => !TRAPS_FORBIDDEN.includes(trap)) : []);
        for (const trap of customTraps) {
          const originalMethod = Reflect.get(this, trap);
          if (isFunction(originalMethod)) {
            Reflect.defineProperty(this, trap, {
              enumerable: true,
              writable: false,
              configurable: false,
              value: function (..._args) {
                if (instance[executeCallbackSymbol](trap)) {
                  return originalMethod?.apply(this, _args);
                }
              }
            });
          }
        }
      }
      update(config, context) {
        let effectiveConfig;
        let effectiveContext;
        if (Reflect.has(config, CONDITION)) {
          const [cb, effectiveConf] = extractCallback(config, CONDITION);
          effectiveConfig = effectiveConf;
          effectiveContext = context;
          this[callbackSymbol].last = cb;
        } else if (context && Reflect.has(context, PROPERTY_CONTEXT_VALUE)) {
          const [cb, ctx] = extractCallback(context.value, CONDITION);
          effectiveContext = {
            ...context,
            value: ctx
          };
          effectiveConfig = config;
          this[callbackSymbol].last = cb;
        } else {
          this[callbackSymbol].last = undefined;
          effectiveConfig = config;
          effectiveContext = context;
        }
        if (!Array.isArray(effectiveTraps) || Array.isArray(effectiveTraps) && (effectiveTraps.length === 0 || effectiveTraps.includes('update'))) {
          if (this[executeCallbackSymbol]('update')) {
            super.update(effectiveConfig, effectiveContext);
          }
        } else {
          super.update(effectiveConfig, effectiveContext);
        }
      }
      /*LWC compiler v7.1.5*/
    }
    ConditionalAdapter.contextSchema = {
      value: 'required'
    };
    return ConditionalAdapter;
  }

  function baseConvert(digits, sourceBase, destinationBase) {
    let start = 0;
    const result = [];
    const digitsCopy = [...digits];
    while (true) {
      let carry = 0,
        done = true;
      for (let i = start; i < digitsCopy.length; i++) {
        const p = sourceBase * carry + digitsCopy[i];
        digitsCopy[i] = Math.floor(p / destinationBase);
        carry = p % destinationBase;
        if (done) {
          if (!digitsCopy[i]) {
            start = i;
          } else {
            done = false;
          }
        }
      }
      result.unshift(carry);
      if (done) {
        return result;
      }
    }
  }

  const CHAR_TO_VALUE = '0123456789abcdefghijklmnopqrstuvwxyz';
  const VALUE_TO_CHAR = [...CHAR_TO_VALUE].reduce((acc, value, index) => {
    acc[value] = index;
    return acc;
  }, {});
  function base36Encode(str) {
    if (!str) {
      return str;
    }
    return baseConvert(new TextEncoder().encode(str), 256, 36).map(digit => CHAR_TO_VALUE[digit]).join('');
  }
  function base36Decode(str) {
    if (!str) {
      return str;
    }
    const base36Digits = [...str].map(char => {
      const digit = VALUE_TO_CHAR[char];
      if (digit === undefined) {
        throw new TypeError(`Invalid base 36 digit: ${char}`);
      }
      return digit;
    });
    const base256Digits = baseConvert(base36Digits, 36, 256);
    return new TextDecoder().decode(new Uint8Array(base256Digits));
  }

  function getCookie(cookieName) {
    return globalThis.document?.cookie.split(';').map(s => s.trim().split('=')).filter(([name]) => name.startsWith(cookieName)).map(([, value]) => value)[0];
  }

  function dateAdd(date, duration) {
    if (date instanceof Date) {
      const newdate = new Date(date);
      typeof duration?.years === 'number' && newdate.setFullYear(newdate.getFullYear() + duration.years);
      typeof duration?.months === 'number' && newdate.setMonth(newdate.getMonth() + duration.months);
      typeof duration?.days === 'number' && newdate.setDate(newdate.getDate() + duration.days);
      return newdate;
    }
    return undefined;
  }
  function dateSubtract(date, duration) {
    if (date instanceof Date) {
      const newdate = new Date(date);
      typeof duration?.years === 'number' && newdate.setFullYear(newdate.getFullYear() - duration.years);
      typeof duration?.months === 'number' && newdate.setMonth(newdate.getMonth() - duration.months);
      typeof duration?.days === 'number' && newdate.setDate(newdate.getDate() - duration.days);
      return newdate;
    }
    return undefined;
  }

  exports.CONDITION = CONDITION;
  exports.base36Decode = base36Decode;
  exports.base36Encode = base36Encode;
  exports.baseConvert = baseConvert;
  exports.circularRefReplacer = circularRefReplacer;
  exports.circularRefReviver = circularRefReviver;
  exports.clearDebounceTimeout = clearDebounceTimeout;
  exports.createConditionalAdapter = createConditionalAdapter;
  exports.dateAdd = dateAdd;
  exports.dateSubtract = dateSubtract;
  exports.debounce = debounce;
  exports.deepClone = deepClone;
  exports.deepEqual = deepEqual;
  exports.deepFreeze = deepFreeze;
  exports.deepSort = deepSort;
  exports.empty = empty;
  exports.extendDebouncedTimeout = extendDebouncedTimeout;
  exports.get = get;
  exports.getCookie = getCookie;
  exports.getObjectTag = getObjectTag;
  exports.isBlank = isBlank;
  exports.isFunction = isFunction;
  exports.isInteger = isInteger;
  exports.isNil = isNil;
  exports.isObject = isObject;
  exports.isObjectLike = isObjectLike;
  exports.isPlainObject = isPlainObject;
  exports.isPromiseLike = isPromiseLike;
  exports.readonly = readonly;
  exports.uuidValidate = uuidValidate;
  exports.uuidv4 = uuidv4;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/util', ['exports', 'experience/utilsInternal'], (function (exports, utilsInternal) {



	Object.defineProperty(exports, 'CONDITION', {
		enumerable: true,
		get: function () { return utilsInternal.CONDITION; }
	});
	Object.defineProperty(exports, 'base36Decode', {
		enumerable: true,
		get: function () { return utilsInternal.base36Decode; }
	});
	Object.defineProperty(exports, 'base36Encode', {
		enumerable: true,
		get: function () { return utilsInternal.base36Encode; }
	});
	Object.defineProperty(exports, 'baseConvert', {
		enumerable: true,
		get: function () { return utilsInternal.baseConvert; }
	});
	Object.defineProperty(exports, 'circularRefReplacer', {
		enumerable: true,
		get: function () { return utilsInternal.circularRefReplacer; }
	});
	Object.defineProperty(exports, 'circularRefReviver', {
		enumerable: true,
		get: function () { return utilsInternal.circularRefReviver; }
	});
	Object.defineProperty(exports, 'clearDebounceTimeout', {
		enumerable: true,
		get: function () { return utilsInternal.clearDebounceTimeout; }
	});
	Object.defineProperty(exports, 'createConditionalAdapter', {
		enumerable: true,
		get: function () { return utilsInternal.createConditionalAdapter; }
	});
	Object.defineProperty(exports, 'debounce', {
		enumerable: true,
		get: function () { return utilsInternal.debounce; }
	});
	Object.defineProperty(exports, 'deepClone', {
		enumerable: true,
		get: function () { return utilsInternal.deepClone; }
	});
	Object.defineProperty(exports, 'deepEqual', {
		enumerable: true,
		get: function () { return utilsInternal.deepEqual; }
	});
	Object.defineProperty(exports, 'deepFreeze', {
		enumerable: true,
		get: function () { return utilsInternal.deepFreeze; }
	});
	Object.defineProperty(exports, 'deepSort', {
		enumerable: true,
		get: function () { return utilsInternal.deepSort; }
	});
	Object.defineProperty(exports, 'extendDebouncedTimeout', {
		enumerable: true,
		get: function () { return utilsInternal.extendDebouncedTimeout; }
	});
	Object.defineProperty(exports, 'get', {
		enumerable: true,
		get: function () { return utilsInternal.get; }
	});
	Object.defineProperty(exports, 'getObjectTag', {
		enumerable: true,
		get: function () { return utilsInternal.getObjectTag; }
	});
	Object.defineProperty(exports, 'isBlank', {
		enumerable: true,
		get: function () { return utilsInternal.isBlank; }
	});
	Object.defineProperty(exports, 'isFunction', {
		enumerable: true,
		get: function () { return utilsInternal.isFunction; }
	});
	Object.defineProperty(exports, 'isInteger', {
		enumerable: true,
		get: function () { return utilsInternal.isInteger; }
	});
	Object.defineProperty(exports, 'isNil', {
		enumerable: true,
		get: function () { return utilsInternal.isNil; }
	});
	Object.defineProperty(exports, 'isObject', {
		enumerable: true,
		get: function () { return utilsInternal.isObject; }
	});
	Object.defineProperty(exports, 'isObjectLike', {
		enumerable: true,
		get: function () { return utilsInternal.isObjectLike; }
	});
	Object.defineProperty(exports, 'isPlainObject', {
		enumerable: true,
		get: function () { return utilsInternal.isPlainObject; }
	});
	Object.defineProperty(exports, 'isPromiseLike', {
		enumerable: true,
		get: function () { return utilsInternal.isPromiseLike; }
	});
	Object.defineProperty(exports, 'uuidValidate', {
		enumerable: true,
		get: function () { return utilsInternal.uuidValidate; }
	});
	Object.defineProperty(exports, 'uuidv4', {
		enumerable: true,
		get: function () { return utilsInternal.uuidv4; }
	});

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_util/validator', ['exports'], (function (exports) {

    /**
     * This is a more strict validator which could be used to validate
     * if the input is a "resource" link like Image/Video.
     * An input is a valid URL if it matches ANY of these rules:
     * 1. Starts with "https://"
     * 2. Starts with "/" followed by at least one character
     *
     * @param {string} url the input url
     * @returns {boolean} whether the url is valid
     */
    function isValidURL(url) {
      const regex = /(^([hH][tT][tT][pP][sS]):\/\/.*)|(^\/.+)/;
      return regex.test(url);
    }

    /**
     * This validator is more relaxed and could be used for any validating any link.
     * Eg you could use this for validating button links
     * An input is a valid link if it matches ANY of these rules:
     * 1. Starts with "https://"
     * 2. Starts with "/"
     * 3. Starts with "#"
     *
     * @param {string} link the input link
     * @returns {boolean} whether the link is valid
     */
    function isValidLink(link) {
      const regex = /(^([hH][tT][tT][pP][sS]):\/\/.*)|(^\/.*)|(^[#].*)/;
      return regex.test(link);
    }

    /**
     * Determines if a url is relative or not
     *
     * @param {string} url the url to determine if it is relative or not
     * @returns {boolean} true if the url is relative; false otherwise
     */
    function isRelativeURL(url) {
      const regex = /^\/(?!\/)/;
      return regex.test(url);
    }

    /**
     * Check if given string is data uri prefixed.
     *
     * @param {string} url source url
     * @returns {boolean} whether url is data uir prefixed
     */
    function isDataUri(url) {
      return url?.startsWith("data:image");
    }

    /**
     * Check if given string is shortcut uri (mailto: or tel:)
     *
     * @param {string} uri source url
     * @returns {boolean} whether url is absolute
     * @example
     *      isShortcutUri('mailto:help@example.com'); // true
     *      isShortcutUri('tel://EXAMPLE.COM'); // true
     */
    function isShortcutUri(uri) {
      const regex = new RegExp("^(mailto|tel):", "i");
      return regex.test(uri);
    }

    exports.isDataUri = isDataUri;
    exports.isRelativeURL = isRelativeURL;
    exports.isShortcutUri = isShortcutUri;
    exports.isValidLink = isValidLink;
    exports.isValidURL = isValidURL;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_util/normalizer', ['exports'], (function (exports) {

    /**
     * A boolean normalization utility for attributes.
     *
     * @param {object} value - The value to normalize.
     * @returns {boolean} - The normalized value.
     */
    function normalizeBoolean(value) {
      return typeof value === "string" || !!value;
    }

    /**
     * A string normalization utility for attributes.
     *
     * @param {string} value - The value to normalize.
     * @param {object} config - The optional configuration object.
     * @param {string} [config.fallbackValue] - The optional fallback value to use if the given value is not provided or invalid. Defaults to an empty string.
     * @param {Array} [config.caseSensitive] - Whether it's caseSensitive comparing.
     * @param {Array} [config.validValues] - An optional array of valid values. Assumes all input is valid if not provided.
     * @returns {string} - The normalized value.
     */
    function normalizeString(value, config = {}) {
      const {
        fallbackValue = "",
        validValues,
        caseSensitive = false
      } = config;
      let normalized = typeof value === "string" && value.trim() || "";
      if (!caseSensitive) {
        normalized = normalized.toLowerCase();
      }
      if (validValues && validValues.indexOf(normalized) === -1) {
        normalized = fallbackValue;
      }
      return normalized;
    }

    /**
     * Normalize given string to size option
     *
     * @param {string} value string value
     * @returns {string} normalized size value
     */
    function normalizeSize(value) {
      return normalizeString(value, {
        fallbackValue: "small",
        validValues: ["small", "medium", "large"]
      });
    }

    /**
     * Normalize given string to alignment option
     *
     * @param {string} value string value
     * @returns {string} normalized alignment value
     */
    function normalizeAlignment(value) {
      return normalizeString(value, {
        fallbackValue: "left",
        validValues: ["left", "center", "right"]
      });
    }

    /**
     * Normalize given string to order (ltr or rtl)
     *
     * @param {string} value string value
     * @returns {string} normalized alignment value
     */
    function normalizeDirection(value) {
      return normalizeString(value, {
        fallbackValue: "left",
        validValues: ["left", "right"]
      });
    }
    const ACTION_TYPE = {
      SHOW_INLINE_MESSAGE: "inline",
      REDIRECT_TO_EXISTING_PAGE: "redirect"
    };

    /**
     * Normalize given string to action option
     *
     * @param {string} value string value
     * @returns {string} normalized action value
     */
    function normalizeAction(value) {
      return normalizeString(value, {
        caseSensitive: true,
        fallbackValue: ACTION_TYPE.SHOW_INLINE_MESSAGE,
        validValues: [ACTION_TYPE.SHOW_INLINE_MESSAGE, ACTION_TYPE.REDIRECT_TO_EXISTING_PAGE]
      });
    }

    const COLUMN_PORTION_MAP = Object.freeze({
      "50%": {
        left: 1,
        right: 1
      },
      "16.67%": {
        left: 1,
        right: 5
      },
      "33.33%": {
        left: 1,
        right: 2
      },
      "66.67%": {
        left: 2,
        right: 1
      }
    });
    const COLUMN_PORTION_OPTIONS = Object.keys(COLUMN_PORTION_MAP);
    const DEFAULT_COLUMN_PORTION = COLUMN_PORTION_OPTIONS[0];

    /**
     * Normalize portion options
     *
     * @param {string} value value to normalize
     * @returns {string} accepted value
     */
    function normalizePortion(value) {
      return normalizeString(value, {
        fallbackValue: DEFAULT_COLUMN_PORTION,
        validValues: COLUMN_PORTION_OPTIONS
      });
    }

    exports.ACTION_TYPE = ACTION_TYPE;
    exports.COLUMN_PORTION_MAP = COLUMN_PORTION_MAP;
    exports.COLUMN_PORTION_OPTIONS = COLUMN_PORTION_OPTIONS;
    exports.DEFAULT_COLUMN_PORTION = DEFAULT_COLUMN_PORTION;
    exports.normalizeAction = normalizeAction;
    exports.normalizeAlignment = normalizeAlignment;
    exports.normalizeBoolean = normalizeBoolean;
    exports.normalizeDirection = normalizeDirection;
    exports.normalizePortion = normalizePortion;
    exports.normalizeSize = normalizeSize;
    exports.normalizeString = normalizeString;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_util/linkInfo', ['exports', 'dxp_util/common', 'dxp_util/normalizer', 'dxp_util/validator'], (function (exports, common, normalizer, validator) {

    const LinkType = Object.freeze({
      WEB_PAGE: "standard__webPage",
      CMS_PAGE: "standard__managedContentPage",
      RECORD_PAGE: "standard__recordPage",
      NAMED_PAGE: "comm__namedPage",
      RELATION_PAGE: "standard__recordRelationshipPage",
      OBJECT_PAGE: "standard__objectPage",
      SEARCH_PAGE: "standard__search"
    });
    const Knowledge_OBJECT_PREFIX = "__kav";
    const NetworkDataCategory_OBJECT_API_NAME = "NetworkDataCategory";

    /**
     * Check if given value is a valid link
     *
     * @param {string} value uri to check
     * @returns {boolean} true if valid
     */
    const isValidURL = common.or(validator.isValidLink, validator.isShortcutUri);

    /**
     * A Validator Map Data Representation
     *
     * @typedef {object} PageReferenceValidatorMap
     *
     * @property {object} valid ke/value defintion, key is target attribute, value is a array of  validator functions
     */

    const PageReferenceValidatorMap = Object.freeze({
      [LinkType.NAMED_PAGE]: {
        valid: {
          "attributes.name": [common.notEmpty]
        }
      },
      [LinkType.OBJECT_PAGE]: {
        valid: {
          "attributes.objectApiName": [common.notEmpty],
          "state.filterName": [common.notEmpty]
        }
      },
      [LinkType.RECORD_PAGE]: {
        // Record Route only require objectApiName and recordId, recordName is optional
        valid: {
          "attributes.objectApiName": [common.notEmpty],
          "attributes.recordId": [common.notEmpty]
        },
        validKnowledge: {
          "attributes.objectApiName": [common.notEmpty],
          "attributes.urlName": [common.notEmpty]
        },
        validNetworkDataCategory: {
          "attributes.objectApiName": [common.notEmpty],
          "attributes.urlPath": [common.notEmpty]
        }
      },
      [LinkType.RELATION_PAGE]: {
        valid: {
          "attributes.objectApiName": [common.notEmpty],
          "attributes.recordId": [common.notEmpty],
          "attributes.relationshipApiName": [common.notEmpty]
        },
        validKnowledge: {
          "attributes.urlName": [common.notEmpty],
          "attributes.relationshipApiName": [common.notEmpty]
        }
      },
      [LinkType.CMS_PAGE]: {
        valid: {
          "attributes.contentTypeName": [common.notEmpty],
          "attributes.contentKey": [common.notEmpty]
        }
      },
      [LinkType.SEARCH_PAGE]: {},
      [LinkType.WEB_PAGE]: {
        valid: {
          "attributes.url": [isValidURL]
        }
      }
    });

    const DEFAULT_LINK_TYPE = LinkType.WEB_PAGE;

    /**
     * Fixed version for linkinfo
     */
    const VERSION_TAG = "linkInfo";

    /**
     * A Link Info representation
     *
     * @typedef {object} LinkInfo
     * @property {string} pageReference a standard page reference object
     *
     *      Refer to https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.reference_page_reference_type
     *
     * @example
     *    {
     *        pageReference: {
     *          type: "standard_web_page"
     *          ...
     *        }
     *    }
     */

    /**
     * Versioned Link Info representation
     *
     * @typedef {object} VersionedLinkInfo
     * @property {LinkInfo} linkInfo link info
     */

    const DEFAULT_LINKINFO = {
      pageReference: {
        type: LinkType.WEB_PAGE
      }
    };

    /**
     * Convert to versioned link info
     *
     * @param {LinkInfo} linkInfo link info
     * @returns {VersionedLinkInfo} versioned link info
     */
    function toVersioned(linkInfo) {
      return {
        [VERSION_TAG]: linkInfo ?? {}
      };
    }

    /**
     * Convert url to LinkInfo
     *
     * @param {string} url url to be converted
     * @returns {LinkInfo} link info
     */
    function toLinkInfo(url) {
      return {
        pageReference: {
          type: LinkType.WEB_PAGE,
          attributes: {
            url
          }
        }
      };
    }

    /**
     * Normalize link info
     *
     * @param {LinkInfo} linkInfo link info
     * @returns {LinkInfo} normalized link info
     */
    function normalizeLinkInfo(linkInfo) {
      const normalizedLinkInfo = {
        ...DEFAULT_LINKINFO,
        ...linkInfo
      };
      return normalizedLinkInfo;
    }

    /**
     * Safely parse versioned link info to link info
     *
     * @param {string} data versioned link info json string
     * @returns {LinkInfo} link info
     */
    function safeToLinkInfo(data) {
      const versioned = common.safeParseJson(data);
      const linkInfo = versioned[VERSION_TAG] ?? versioned;
      return common.notEmpty(linkInfo) ? linkInfo : toLinkInfo(data);
    }
    /**
     * Parse json into link info
     *
     * @param {string} data json data string
     * @returns {LinkInfo} link info
     */
    function parseLinkInfo(data) {
      const linkInfo = safeToLinkInfo(data);
      return normalizeLinkInfo(linkInfo[VERSION_TAG] ?? linkInfo);
    }

    /**
     * Verifies if the given object belongs to Knowledge category or not
     *
     * @param {string} objectApiName objectApiName
     * @param {string} pageType record/object/related
     * @returns {boolean} returns true/false
     */
    function isKnowledgeObject(objectApiName, pageType) {
      if (objectApiName?.includes(Knowledge_OBJECT_PREFIX) && (pageType === LinkType.RECORD_PAGE || pageType === LinkType.RELATION_PAGE)) {
        return true;
      }
      return false;
    }

    /**
     * Verifies if the given object belongs to NetworkDataCategory category or not
     *
     * @param {string} objectApiName objectApiName
     * @param {string} pageType record/object/related
     * @returns {boolean} returns true/false
     */
    function isNetworkDataCategoryObject(objectApiName, pageType) {
      return objectApiName === NetworkDataCategory_OBJECT_API_NAME && pageType === LinkType.RECORD_PAGE;
    }

    const NavigationType = Object.freeze(Object.values(LinkType));
    const toPageReferenceMap = common.compose(normalized => PageReferenceValidatorMap[normalized], normalizePageReferenceType);

    /**
     * Check if given page reference is valid
     *
     * @param {object} pageReference page reference
     * @returns {boolean} true if contain valid url
     */
    function isValidPageReference(pageReference) {
      if (common.empty(pageReference)) {
        return false;
      }
      let validType;
      const objectApiName = pageReference.attributes?.objectApiName;
      const referenceMap = toPageReferenceMap(pageReference.type);

      // Fetch validator map per page reference type, default to web page
      // Also checks if knowledge based object then maps to a different validator.
      if (isKnowledgeObject(objectApiName, pageReference.type)) {
        validType = referenceMap?.validKnowledge;
      } else if (isNetworkDataCategoryObject(objectApiName, pageReference.type)) {
        validType = referenceMap?.validNetworkDataCategory;
      } else {
        validType = referenceMap.valid;
      }

      // Enumerate key from valid object, each key is a attribute path of the pageReference
      // value is a array of validator functions.
      // Return true if all validator functions are passed against the value of
      // the attribute path from pageReference
      const keyIsValidWhenValueIsValid = key => common.compose(common.and.apply(this, validType?.[key]), common.get(pageReference))(key);
      return common.everyKey(key => {
        return keyIsValidWhenValueIsValid(key);
      })(validType ?? {});
    }

    /**
     * Normalize page reference type
     *
     * @param {string} type page reference type
     * @returns {string} normalized type
     */
    function normalizePageReferenceType(type) {
      return normalizer.normalizeString(type, {
        fallbackValue: LinkType.WEB_PAGE,
        validValues: NavigationType,
        caseSensitive: true
      });
    }

    exports.DEFAULT_LINK_TYPE = DEFAULT_LINK_TYPE;
    exports.Knowledge_OBJECT_PREFIX = Knowledge_OBJECT_PREFIX;
    exports.LinkType = LinkType;
    exports.NavigationType = NavigationType;
    exports.NetworkDataCategory_OBJECT_API_NAME = NetworkDataCategory_OBJECT_API_NAME;
    exports.isKnowledgeObject = isKnowledgeObject;
    exports.isNetworkDataCategoryObject = isNetworkDataCategoryObject;
    exports.isValidPageReference = isValidPageReference;
    exports.normalizeLinkInfo = normalizeLinkInfo;
    exports.normalizePageReferenceType = normalizePageReferenceType;
    exports.parseLinkInfo = parseLinkInfo;
    exports.toLinkInfo = toLinkInfo;
    exports.toVersioned = toVersioned;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_base/baseNavigation', ['exports', 'lwc', 'lightning/navigation', 'dxp_util/common', 'dxp_util/linkInfo', 'dxp_util/validator'], (function (exports, lwc, navigation, common, linkInfo, validator) {

    var _tmpl = void 0;

    /**
     * Normalize given url
     *
     * @param {string} url url to be normalized
     * @param {string} fallback fallback url
     * @returns {string} normalized url
     */
    function normalizeLink(url, fallback) {
      return validator.isValidLink(url) ? url : fallback;
    }

    /**
     * Normalize given page reference with type
     *
     * @param {object} pageReference page reference
     * @param {string} type type to be normalized
     * @returns {object} normalized page reference
     */
    function normalizePageReference(pageReference, type) {
      return type !== pageReference?.type ? {
        ...pageReference,
        type
      } : pageReference;
    }

    /**
     * Open url if given url is shortcut url (mailto: or tel:)
     *
     * @param {string} url url to be opened
     * @returns {boolean} true if url is shortcut url
     */
    function openShortcutUri(url) {
      if (validator.isShortcutUri(url)) {
        window.open(url);
        return true;
      }
      return false;
    }

    const Uri = Symbol("uri");
    const Type = Symbol("type");
    const LinkInfo = Symbol("linkInfo");

    /**
     * Base Navigation Component that consume lightning/navigation
     *
     * @class BaseNavigation
     */
    class BaseNavigation extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this[Type] = linkInfo.LinkType.WEB_PAGE;
        this[Uri] = "";
        this._linkInfo = {};
        this.pendingPageReference = void 0;
        this.navContext = void 0;
        this._generatedUrl = void 0;
        this[LinkInfo] = linkInfo.toLinkInfo("");
      }
      /**
       * Type of navigation
       *
       *  @type {string}
       * @memberof BaseNavigation
       */
      get type() {
        return this[Type];
      }
      set type(value) {
        this[Type] = linkInfo.normalizePageReferenceType(value, {
          fallbackValue: linkInfo.DEFAULT_LINK_TYPE,
          validValues: linkInfo.NavigationType
        });
        this.synchronizeLinkInfoWithUrl();
      }

      /**
       * Navigation URI
       *
       * @type {string}
       * @memberof BaseNavigation
       */
      get uri() {
        return this[Uri];
      }
      set uri(value) {
        // Check if we can parse the uri to LinkInfo
        this[LinkInfo] = linkInfo.parseLinkInfo(value);
        // linkInfo has pageReference built-in
        this[Type] = this[LinkInfo]?.pageReference?.type;

        // Store original raw value
        this[Uri] = value;
        this.synchronizeLinkInfoWithUrl();
      }
      /**
       * Gets the navigation context.
       *
       * @param {object} context wired nav context
       */
      wireNavConext(context) {
        this.navContext = context;

        // Navigation maybe requested before the context is wired
        // Check if we need to navigate if a navigation is requested
        if (this.navContext && this.pendingPageReference) {
          // A navigation request is set, so perform the navigation
          const pageReference = this.pendingPageReference;
          this.pendingPageReference = null;
          this.navigateWithPageReference(pageReference);
        }
        this.synchronizeLinkInfoWithUrl();
      }

      /**
       * Navigate to internal uri
       *
       * @param {string} url url for navigation, if not provided, will fallback to this.uri
       */
      navigateTo(url) {
        const {
          pageReference
        } = url ? linkInfo.toLinkInfo(url) : this[LinkInfo];

        // If navigation context is not wired, set the navigation request
        if (!this.navContext) {
          this.pendingPageReference = pageReference;
          return;
        }
        this.navigateWithPageReference(pageReference);
      }

      /**
       * Navigate to pageReference
       *
       * @param {object} pageReference page reference
       */
      navigateWithPageReference(pageReference) {
        // If a link type is provided, override the type
        const newReference = normalizePageReference(pageReference, this[Type]);
        common.ifVal(linkInfo.isValidPageReference(newReference) && !openShortcutUri(newReference.attributes?.url), () => {
          navigation.navigate(this.navContext, newReference);
        });
      }

      /**
       * Synchronize linkInfo with generateUrl method
       */
      async synchronizeLinkInfoWithUrl() {
        const {
          attributes,
          type
        } = this[LinkInfo].pageReference;
        const route = attributes?.url ?? "";
        if (type === linkInfo.LinkType.WEB_PAGE && validator.isShortcutUri(route)) {
          // mailto: or tel: is not supported by generateUrl, can be used directly
          this._generatedUrl = route;
        } else if (this.navContext && linkInfo.isValidPageReference(this[LinkInfo]?.pageReference)) {
          // Generate a URL with given pageReference
          const url = await navigation.generateUrl(this.navContext, common.deepCopy(this[LinkInfo].pageReference));
          this._generatedUrl = normalizeLink(url, "");
        } else {
          this._generatedUrl = normalizeLink(route, "");
        }
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(BaseNavigation, {
      track: {
        _linkInfo: 1
      },
      wire: {
        wireNavConext: {
          adapter: navigation.NavigationContext,
          method: 1,
          config: function ($cmp) {
            return {};
          }
        }
      },
      fields: ["pendingPageReference", "navContext", "_generatedUrl"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(BaseNavigation, {
      tmpl: _tmpl,
      sel: "dxp_base-base-navigation",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lwr/environment', ['exports'], (function (exports) {

	const environment = globalThis?.LWR?.env || {};
	const isServer = environment && (environment.SSR === 'true' || environment.SSR === true);
	// The baseBath from the config or set from the request (e.g. /shop)
	const basePath = environment && environment.basePath;
	// The locale set from the request or the defaultLocale from the config (e.g. en-US)
	const locale = environment && environment.locale;
	// Root base path for static assets (e.g. /shop/mobify/bundle/1234/site)
	const assetBasePath = environment && environment.assetBasePath;
	// Base path for UI routing (e.g. /shop/en-US)
	const uiBasePath = environment && environment.uiBasePath;

	exports.assetBasePath = assetBasePath;
	exports.basePath = basePath;
	exports.isServer = isServer;
	exports.locale = locale;
	exports.uiBasePath = uiBasePath;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/picture', ['exports', 'lwc', 'experience/resourceResolver'], (function (exports, lwc, resourceResolver) {

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("." + token) : "";
      var hostSelector = token ? ("." + token + "-host") : "";
      return ((useActualHostSelector ? ":host {" : hostSelector + " {")) + "display: contents;all: inherit;}picture" + shadowSelector + " {all: inherit;}img" + shadowSelector + " {max-height: inherit;width: inherit;object-fit: inherit;}";
      /*LWC compiler v7.1.5*/
    }
    stylesheet.$scoped$ = true;
    var _implicitScopedStylesheets = [stylesheet];

    const $fragment1 = lwc.parseFragment`<source${"a0:media"}${"a0:srcset"}${"a0:sizes"}${3}>`;
    const $fragment2 = lwc.parseFragment`<img${"a0:src"}${"a0:alt"}${"a0:loading"}${"a0:draggable"}${3}>`;
    const stc0 = {
      key: 0
    };
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {k: api_key, sp: api_static_part, st: api_static_fragment, i: api_iterator, f: api_flatten, h: api_element} = $api;
      return [api_element("picture", stc0, api_flatten([api_iterator($cmp.normalizedImages, function (image) {
        return api_static_fragment($fragment1, api_key(2, image.media), [api_static_part(0, {
          attrs: {
            "media": image.media,
            "srcset": image.srcSet,
            "sizes": image.sizes
          }
        }, null)]);
      }), api_static_fragment($fragment2, 4, [api_static_part(0, {
        attrs: {
          "src": $cmp.normalizedUrl,
          "alt": $cmp.alternativeText,
          "loading": $cmp.normalizedLoading,
          "draggable": $cmp.draggable
        }
      }, null)])]))];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.renderMode = "light";
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-6d0jmdgc6e8";
    tmpl.legacyStylesheetToken = "experience-picture_picture";
    if (_implicitScopedStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitScopedStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    function hasMultipleImageUrls(imageUrls, key) {
      return Object.prototype.hasOwnProperty.call(imageUrls, key);
    }
    function getImageSizesFromCss(el, cssHookName) {
      const styles = el && getComputedStyle(el);
      const hook = cssHookName ?? '--dxp-c-image-width';
      const mobile = Number(styles?.getPropertyValue(`${hook}-mobile`));
      const tablet = Number(styles?.getPropertyValue(`${hook}-tablet`));
      const desktop = Number(styles?.getPropertyValue(`${hook}-desktop`));
      return {
        mobile: mobile && !Number.isNaN(mobile) ? mobile : 0,
        tablet: tablet && !Number.isNaN(tablet) ? tablet : 0,
        desktop: desktop && !Number.isNaN(desktop) ? desktop : 0
      };
    }
    function imageSizesDefined(imageSizes) {
      return imageSizes && Object.values(imageSizes).every(size => size && size !== 0);
    }
    function createImageDataMap(imageUrl, overrides, dpr = [1, 2]) {
      if (!imageUrl || !overrides || !imageSizesDefined(overrides)) {
        return [];
      }
      return Object.entries(overrides).reduce((acc, [key, imageSize]) => {
        const url = hasMultipleImageUrls(imageUrl, key) ? imageUrl[key] : imageUrl;
        acc.push({
          formFactor: key,
          srcSet: dpr.map(value => `${resourceResolver.resolve(url, true, {
        width: imageSize * value
      })} ${value}x`).join(', ')
        });
        return acc;
      }, []);
    }
    const MEDIA_QUERIES = {
      mobile: '(max-width: 47.9375em)',
      tablet: '(max-width: 64em)',
      desktop: '(min-width: 64.0625em)'
    };

    class Picture extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.alternativeText = void 0;
        this.loading = void 0;
        this.url = void 0;
        this.images = void 0;
        this.disableDrag = false;
      }
      get draggable() {
        return !this.disableDrag;
      }
      get normalizedImages() {
        return this.mapImageData(this.images || []);
      }
      get normalizedUrl() {
        return resourceResolver.resolve(this.url || '', true);
      }
      get normalizedLoading() {
        return this.loading ?? 'eager';
      }
      mapImageData(images) {
        return images.map(image => ({
          ...image,
          media: 'formFactor' in image ? MEDIA_QUERIES[image.formFactor] : image.media
        }));
      }
      /*LWC compiler v7.1.5*/
    }
    Picture.renderMode = 'light';
    lwc.registerDecorators(Picture, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        loading: {
          config: 0
        },
        url: {
          config: 0
        },
        images: {
          config: 0
        },
        disableDrag: {
          config: 0
        }
      }
    });
    const __lwc_component_class_internal = lwc.registerComponent(Picture, {
      tmpl: _tmpl,
      sel: "experience-picture",
      apiVersion: 62
    });

    exports.MEDIA_QUERIES = MEDIA_QUERIES;
    exports.createImageDataMap = createImageDataMap;
    exports.default = __lwc_component_class_internal;
    exports.getImageSizesFromCss = getImageSizesFromCss;
    exports.imageSizesDefined = imageSizesDefined;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_content_layout/siteLogo', ['exports', 'lwc', 'experience/picture', 'lwr/environment', 'dxp_base/baseNavigation', 'dxp_util/linkInfo', 'dxp_util/browserProperties', 'experience/util', '@salesforce/label/LwcComponent:dxp_content_layout:header.section_name_logo', 'experience/resourceResolver', 'dxp_util/common'], (function (exports, lwc, _experiencePicture, environment, BaseNavigation, linkInfo, browserProperties, util, ImageAlternativeText, resourceResolver, common) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var _experiencePicture__default = /*#__PURE__*/_interopDefaultCompat(_experiencePicture);
    var BaseNavigation__default = /*#__PURE__*/_interopDefaultCompat(BaseNavigation);
    var ImageAlternativeText__default = /*#__PURE__*/_interopDefaultCompat(ImageAlternativeText);

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("." + token) : "";
      return ".logo-anchor" + shadowSelector + " {display: flex;justify-content: var(--dxp-c-l-alignment, left);}.dxp-content-layout-site-logo" + shadowSelector + " {background-repeat: no-repeat;background-size: contain;width: calc((var(--dxp-c-l-logo-width, 100) * 1px));max-height: 75px;height: auto;max-width: 100%;background-position-y: var(--dxp-c-site-logo-background-position-y);}experience-picture" + shadowSelector + " {height: auto;object-fit: contain;}@media only screen and (min-width: 48em) and (max-width: 64em) {.logo-anchor" + shadowSelector + " {justify-content: var(--dxp-c-m-alignment, left);}.dxp-content-layout-site-logo" + shadowSelector + " {max-height: 45px;width: calc((var(--dxp-c-m-logo-width, 100) * 1px));}}@media only screen and (max-width: 47.9375em) {.logo-anchor" + shadowSelector + " {justify-content: var(--dxp-c-s-alignment, left);}.dxp-content-layout-site-logo" + shadowSelector + " {max-height: 25px;width: calc((var(--dxp-c-s-logo-width, 100) * 1px));}}";
      /*LWC compiler v7.1.5*/
    }
    stylesheet.$scoped$ = true;
    var _implicitScopedStylesheets = [stylesheet];

    const stc0 = {
      "logo-anchor": true
    };
    const stc1 = {
      "dxp-content-layout-site-logo": true
    };
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {b: api_bind, c: api_custom_element, h: api_element} = $api;
      const {_m0} = $ctx;
      return [api_element("a", {
        classMap: stc0,
        attrs: {
          "href": $cmp.url
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.onClick))
        }
      }, [api_element("div", {
        classMap: stc1,
        attrs: {
          "role": "img",
          "aria-label": $cmp.resolvedAltText
        },
        ref: "logo",
        key: 1
      }, [api_custom_element("experience-picture", _experiencePicture__default.default, {
        props: {
          "alternativeText": "",
          "url": $cmp._resolvedImageUrl,
          "images": $cmp.image.images
        },
        key: 2
      })])])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.renderMode = "light";
    tmpl.hasRefs = true;
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-440ckkrho00";
    tmpl.legacyStylesheetToken = "dxp_content_layout-siteLogo_siteLogo";
    if (_implicitScopedStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitScopedStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    /**
     * @typedef {object} ImageSizes
     * @property {number} mobile The image width on mobile phone devices
     * @property {number} tablet The image width on tablet devices
     * @property {number} desktop The image width on desktop-size devices
     */

    /**
     * @param {(HTMLElement | null)} el A container that holds the image element to extract the sizes from
     * @returns {ImageSizes} An object holding the image sizes for various screen sizes
     */
    function getImageSizes(el) {
      const styles = el && getComputedStyle(el);
      const mobile = Number(styles?.getPropertyValue(CSS_WIDTH_SMALL_VAR));
      const tablet = Number(styles?.getPropertyValue(CSS_WIDTH_MEDIUM_VAR));
      const desktop = Number(styles?.getPropertyValue(CSS_WIDTH_LARGE_VAR));
      return {
        mobile: mobile && !Number.isNaN(mobile) ? mobile : 0,
        tablet: tablet && !Number.isNaN(tablet) ? tablet : 0,
        desktop: desktop && !Number.isNaN(desktop) ? desktop : 0
      };
    }

    /**
     * @param {(HTMLElement | null)} el A container that holds the image element to extract the sizes from
     * @param {ImageSizes} imageSizes An object holding the image sizes for various screen sizes
     */
    function calculateImageSizes(el, imageSizes) {
      if (!_experiencePicture.imageSizesDefined(imageSizes)) {
        const sizes = getImageSizes(el);
        Object.assign(imageSizes, sizes);
      }
    }

    const CSS_LOGO_PATH_VAR = "--dxp-s-site-logo-path";
    const CSS_LOGO_URL_VAR = "--dxp-s-site-logo-url";
    const CSS_MOBILE_LOGO_URL_VAR = "--dxp-s-site-logo-mobile-url";
    const CSS_WIDTH_SMALL_VAR = "--dxp-c-s-logo-width";
    const CSS_WIDTH_MEDIUM_VAR = "--dxp-c-m-logo-width";
    const CSS_WIDTH_LARGE_VAR = "--dxp-c-l-logo-width";

    /**
     * @typedef {object} MouseEvent
     * @property {Function} preventDefault Prevents default event behavior
     */

    /**
     * @typedef {object} ImageInfo
     * @property {string} url The url of the image (external or internal)
     * @property {string} altText The alt text of the image
     */

    /**
     * Generic component for displaying a logo of a site.
     * Clicking on the logo navigates to the home page.
     */
    class SiteLogo extends BaseNavigation__default.default {
      /**
       * Serialized JSON of the image info.
       * `imageUrl` and `altText` properties take precedence over `imageInfo`.
       * This is for backwards compatibility.
       *
       * @type {ImageInfo}
       */
      get imageInfo() {
        return this._imageInfo;
      }
      set imageInfo(value) {
        this._imageInfo = value;
      }

      /**
       * Serialized JSON of the image info for mobile.
       * `imageUrl` and `altText` properties take precedence over `imageInfoMobile`.
       *   This is for backwards compatibility.
       *
       * @type {ImageInfo}
       */
      get imageInfoMobile() {
        return this._imageInfoMobile;
      }
      set imageInfoMobile(value) {
        this._imageInfoMobile = value;
      }

      /**
       * The url of the logo image.
       * If no url is provided the CSS variable `--dxp-s-side-logo-path`
       * will be used instead.
       * This takes priority over `imageInfo`.
       *
       * @type {string}
       */

      get resolvedAltText() {
        const imagInfoAltText = browserProperties.isMobile() ? this._imageInfoMobile?.AltText : this._imageInfo?.AltText;
        return this.altText || imagInfoAltText || ImageAlternativeText__default.default;
      }
      get url() {
        return this._generatedUrl;
      }
      get image() {
        const desktopImageUrl = this._resolvedImageUrl || this._getResolvedImageUrl();
        const imgUrl = {
          desktop: desktopImageUrl,
          tablet: desktopImageUrl,
          mobile: this._imageInfoMobile?.Url || desktopImageUrl
        };
        return {
          url: desktopImageUrl,
          images: _experiencePicture.createImageDataMap(imgUrl, this._imageSizes, [1, 2])
        };
      }
      constructor() {
        super();
        /**
         * A tuple representing image width and height.
         *
         * @typedef {number[]} Cache
         * @property {number} 0 - The width of the image.
         * @property {number} 1 - The height of the image.
         */
        /**
         * Cache for computing image ratios.
         *
         * @type {Map<string, Cache>}
         */
        this._imageDimensionCache = new Map();
        /**
         * @type {ImageInfo | undefined}
         */
        this._imageInfo = void 0;
        /**
         * @type {ImageInfo | undefined}
         */
        this._imageInfoMobile = void 0;
        this._imageSizes = {
          mobile: 0,
          tablet: 0,
          desktop: 0
        };
        /**
         * Site Logo info defined in Branding Set. TODO - This should replace CSS variable CSS_LOGO_PATH_VAR but currently there's a mismatch in the 2 URLs
         * as the page path is not appended to this URL unlike CSS_LOGO_PATH_VAR and logoInfo is wrapped in url() but CSS_LOGO_PATH_VAR is not,
         * e.g. logoInfo = url(/assets/images/logo-alpine-group.svg), CSS_LOGO_PATH_VAR = /b2blwr/assets/images/logo-alpine-group.svg
         * Adding the property here for future. Once there is parity between the URLs or somehow convert logoInfo to CSS_LOGO_PATH_VAR's format,
         * CSS_LOGO_PATH_VAR can be removed. TD - https://gus.lightning.force.com/lightning/r/ADM_Team_Dependency__c/a0nEE000000XlrNYAS/view
         *
         * @type {ImageInfo}
         */
        this.logoInfo = void 0;
        this.imageUrl = void 0;
        /**
         * The alt text of the logo image.
         * This takes priority over `imageInfo`.
         *
         * @type {string}
         */
        this.altText = void 0;
        /**
         * The width of the logo in pixels.
         *
         * @type {number}
         */
        this.logoWidth = void 0;
        /**
         * Whether to use the CSS variable --dxp-s-site-logo-url
         * for the background-image.
         *
         * @type {boolean}
         */
        this.useCssImageUrl = false;
        /**
         * Where the element is aligned in it's container. Possible values are:
         * - left
         * - right
         * - center
         *
         * @type {string}
         */
        this.alignment = void 0;
        /**
         * Whether the component is being rendered in design time or runtime. Used
         * to show placeholder site logo when no valid image URL is specified.
         *
         * @type {boolean}
         */
        this.isBuilderMode = false;
        /**
         * @private
         * @type {number}
         */
        this._imageHeight = void 0;
        /**
         * @private
         * @type {number}
         */
        this._imageWidth = void 0;
        /**
         * @private
         * @type {?string}
         */
        this._resolvedImageUrl = void 0;
        this.uri = JSON.stringify(SiteLogo.HOME_PAGE_REF);
      }
      renderedCallback() {
        /**
         * We have to calculate the image sizes after the component is rendered because the
         * image sizes are defined in CSS variables, and they are not available before.
         * This will add up 1 more render cycle, but will only be calculated once.
         * We should be careful with changing the behavior here.
         */
        calculateImageSizes(this.querySelector(".dxp-content-layout-site-logo"), this._imageSizes);
        this._resolvedImageUrl = this._getResolvedImageUrl();
      }

      /**
       * @param {MouseEvent} event The click event
       * @returns {void}
       */
      onClick(event) {
        event.preventDefault();
        this.navigateTo();
      }
      _getResolvedImageUrl() {
        let imageUrl = "";
        if (environment.isServer) {
          imageUrl = this.imageUrl || this._imageInfo?.Url;
          return resourceResolver.resolve(imageUrl, true);
        }
        if (this.useCssImageUrl) {
          imageUrl = this._getStyleProperty(CSS_LOGO_URL_VAR).replace(/url\("?([^")]+)"?\)/, "$1");
        } else {
          imageUrl = this.imageUrl || this._imageInfo?.Url || this._getStyleProperty(CSS_LOGO_PATH_VAR) || this._getPlaceholderImageUrl();
        }
        return resourceResolver.resolve(imageUrl, true);
      }
      _getPlaceholderImageUrl() {
        return this.isBuilderMode ? common.LOGO_PLACEHOLDER_DATA_URI : "";
      }
      _getStyleProperty(prop, customEl) {
        const element = customEl || this.querySelector(".dxp-content-layout-site-logo");
        if (element) {
          const styles = window.getComputedStyle(element);
          return styles.getPropertyValue(prop);
        }
        return "";
      }
      /*LWC compiler v7.1.5*/
    }
    /**
     * @static
     * @type {object}
     * @readonly
     */
    SiteLogo.HOME_PAGE_REF = util.deepFreeze({
      pageReference: {
        type: linkInfo.LinkType.NAMED_PAGE,
        attributes: {
          name: "Home"
        }
      }
    }).value;
    SiteLogo.renderMode = "light";
    lwc.registerDecorators(SiteLogo, {
      publicProps: {
        logoInfo: {
          config: 0
        },
        imageInfo: {
          config: 3
        },
        imageInfoMobile: {
          config: 3
        },
        imageUrl: {
          config: 0
        },
        altText: {
          config: 0
        },
        logoWidth: {
          config: 0
        },
        useCssImageUrl: {
          config: 0
        },
        alignment: {
          config: 0
        },
        isBuilderMode: {
          config: 0
        }
      },
      track: {
        _imageSizes: 1,
        _imageHeight: 1,
        _imageWidth: 1
      },
      fields: ["_imageDimensionCache", "_imageInfo", "_imageInfoMobile", "_resolvedImageUrl"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(SiteLogo, {
      tmpl: _tmpl,
      sel: "dxp_content_layout-site-logo",
      apiVersion: 62
    });

    exports.CSS_LOGO_PATH_VAR = CSS_LOGO_PATH_VAR;
    exports.CSS_LOGO_URL_VAR = CSS_LOGO_URL_VAR;
    exports.CSS_MOBILE_LOGO_URL_VAR = CSS_MOBILE_LOGO_URL_VAR;
    exports.CSS_WIDTH_LARGE_VAR = CSS_WIDTH_LARGE_VAR;
    exports.CSS_WIDTH_MEDIUM_VAR = CSS_WIDTH_MEDIUM_VAR;
    exports.CSS_WIDTH_SMALL_VAR = CSS_WIDTH_SMALL_VAR;
    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/community/Id', [], function() { return "0DBHy0000005ZrLOAU"; });
(function() { LWR.define('dxp_util/siteInfo', ['exports', '@salesforce/community/basePath', 'dxp_util/common', '@salesforce/i18n/lang', '@salesforce/community/Id', '@salesforce/site/Id'], (function (exports, basePath, common, CurrentLocale, CommunityId, SiteId) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var basePath__default = /*#__PURE__*/_interopDefaultCompat(basePath);
    var CurrentLocale__default = /*#__PURE__*/_interopDefaultCompat(CurrentLocale);
    var CommunityId__default = /*#__PURE__*/_interopDefaultCompat(CommunityId);
    var SiteId__default = /*#__PURE__*/_interopDefaultCompat(SiteId);

    const CMS_PATH_PREFIX = "/sfsites/c";
    const SITE_CMS_PATH_PREFIX = `${basePath__default.default}${CMS_PATH_PREFIX}`;
    const constructUrlPath = common.curry((prefix, isExternal, url) => {
      return isExternal ? url : `${basePath__default.default}${prefix ?? ""}${prefixWithLeadingSlash(url)}`;
    });
    const constructCmsPath = constructUrlPath(CMS_PATH_PREFIX);
    const constructSitePath = constructUrlPath("");
    const SiteInfo = {
      // curr locale is sometimes not formated to the correct syntax for locale, needs to be en_US, not en-US
      CurrentLanguage: CurrentLocale__default.default.replace("-", "_"),
      CommunityId: CommunityId__default.default,
      CurrentLocale: CurrentLocale__default.default,
      SiteId: SiteId__default.default
    };

    /**
     * Return cms path prefix.
     *
     * @returns {string} path prefix
     */
    function getPathPrefix() {
      return SITE_CMS_PATH_PREFIX;
    }

    /**
     * Construct url with site path
     *
     * @param {string} url relative url
     * @param {boolean} isExternal whether isExternal url.
     * @returns {string} content url
     */
    function buildSitePath(url, isExternal = false) {
      return constructSitePath(isExternal, url);
    }

    /**
     * Construct url with site path
     *
     * @param {string} url relative url
     * @param {boolean} isExternal whether isExternal url.
     * @returns {string} content url
     */
    function buildSiteCmsPath(url, isExternal = false) {
      return constructCmsPath(isExternal, url);
    }

    /**
     * Check if given url is site url
     *
     * @param {string} url url to check
     * @returns {boolean} whether url is a site url
     */
    function isSitePath(url) {
      return url?.startsWith(basePath__default.default);
    }

    /**
     * Checks if a URL string starts with either "http://", "https://", or "data:image".
     *
     * @param {string} url - The URL string to check.
     * @returns {boolean} Returns true if the URL starts with "http://", "https://", or "data:image"; otherwise, returns false.
     */
    function isValidImageUrl(url) {
      const regex = /^(https?|data:image\/[a-z]+)/i;
      return regex.test(url);
    }

    /**
     * Prefixes a URL segment with a leading slash if needed.
     * If the URL segment starts with a slash, it is returned unchanged.
     * If the URL segment does not start with a slash, a leading slash is added.
     *
     * @param {string} urlSegment - The URL segment to be prefixed.
     * @returns {string} The URL segment with a leading slash if needed.
     */
    function prefixWithLeadingSlash(urlSegment) {
      return urlSegment && !/^\/.*/.test(urlSegment) ? `/${urlSegment}` : urlSegment;
    }

    /**
     * Returns the image URL based on the provided URL.
     *
     * @param {string} url - The input URL.
     * @returns {string} The image URL.
     */
    function getImageUrl(url) {
      return isSitePath(url) ? url : buildSitePath(url, isValidImageUrl(url));
    }

    exports.CMS_PATH_PREFIX = CMS_PATH_PREFIX;
    exports.SiteInfo = SiteInfo;
    exports.buildSiteCmsPath = buildSiteCmsPath;
    exports.buildSitePath = buildSitePath;
    exports.constructUrlPath = constructUrlPath;
    exports.getImageUrl = getImageUrl;
    exports.getPathPrefix = getPathPrefix;
    exports.isSitePath = isSitePath;
    exports.isValidImageUrl = isValidImageUrl;
    exports.prefixWithLeadingSlash = prefixWithLeadingSlash;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_util/contentInfo', ['exports', 'dxp_util/siteInfo', 'dxp_util/normalizer'], (function (exports, siteInfo, normalizer) {

    /**
     * Regular expressions for CMS resources and for static image resources.
     */
    const cmsResourceUrlPattern = /^\/cms\//;
    const staticImageResourcePattern = /^\/img\//; // Static app resources referenced (e.g. the "no image" image")
    const staticCmsAssetPattern = /^\/assets\//; // Static (LWR-specific) app resources referenced

    /**
     * Check if given url is a cms resource url
     *
     * @param {string} url url to check
     * @returns {boolean} true if url contains /cms/ part
     */
    function isCmsResource(url) {
      return cmsResourceUrlPattern.test(url);
    }

    /**
     * Check if given url is a static image resource url
     *
     * @param {string} url url to check
     * @returns {boolean} true if url contains /img/ part
     */
    function isStaticImageResource(url) {
      return staticImageResourcePattern.test(url);
    }

    /**
     * Check if given url is a cms asset url
     *
     * @param {string} url url to check
     * @returns {boolean} true if url contains /assets/ part
     */
    function isCmsAsset(url) {
      return staticCmsAssetPattern.test(url);
    }

    /**
     * Check if given url is a resource url
     *
     * @param {string} url url to check
     * @returns {boolean} true if url is cms or image url
     */
    function isResource(url) {
      return isCmsResource(url) || isStaticImageResource(url);
    }

    /**
     * Resolves a cms assets/resource URL - that may (or may not) be managed by Salesforce CMS - to a canonical, routable URL.
     *
     * @param {string} url
     *  A URL of a resource. This may - or may not - be a Salesforce-hosted CMS resource.
     *
     * @returns {string}
     *  If {@see url} represents a CMS-hosted resource, then a resolved CMS resource URL;
     *  otherwise, the unaltered {@see url}.
     */
    function resolveUrl(url) {
      // If the URL is a CMS URL, transform it; otherwise, leave it alone.
      return isCmsAsset(url) ? siteInfo.buildSitePath(url) : isResource(url) ? siteInfo.buildSiteCmsPath(url) : url;
    }

    const CMS_MEDIA_BASE_PATH = "/cms/delivery/media";

    /**
     * A simple image info representation
     *
     * @typedef {object} ImageInfo
     *
     * @property {string} url image url
     * @property {string} altText alternative text
     */

    /**
     * A simple url info representation
     *
     * @typedef {object} UrlInfo
     *
     * @property {string} url image url
     * @property {boolean} isExternal whether url is external url
     */

    /**
     * Return cms content url *
     *
     * @param {object} config { url, isExternal }
     * @returns {string} content url
     */
    function getCMSContentUrl(config) {
      const {
        url,
        isExternal
      } = config;
      return siteInfo.buildSiteCmsPath(url, isExternal);
    }

    /**
     * Convert a cms item to url info
     *
     * @param {object} item cms content item
     * @returns {UrlInfo} url info
     */
    function toUrlInfo(item) {
      return {
        url: item.contentNodes?.source?.url ?? "",
        isExternal: !!item.contentNodes?.source?.isExternal,
        altText: item.contentNodes?.altText?.value ?? ""
      };
    }
    /**
     * Convert items to key map
     *
     * @param {Array} cmsContentItems Content Items
     * @returns {object} Content Key Map
     */
    function convertItemsToContentKeyMap(cmsContentItems = []) {
      return cmsContentItems.filter(item => item.contentKey && item.contentNodes).reduce((acc, item) => {
        acc.set(item.contentKey, toUrlInfo(item));
        return acc;
      }, new Map());
    }

    /**
     * Extract image info from cms content
     *
     * @param {object} data cms content data
     * @param {string[]} contentKeys a array of content key
     * @returns {ImageInfo} extracted image info
     */
    function extractImageInfo(data, contentKeys) {
      const contentKeyUrlMap = convertItemsToContentKeyMap(data?.items ?? []);
      const [key] = contentKeys;
      const urlInfo = contentKeyUrlMap.get(key);
      const imageInfo = urlInfo ? {
        url: getCMSContentUrl(urlInfo),
        altText: urlInfo.altText
      } : {};
      return imageInfo;
    }

    /**
     * Extract image info from cms v2 content
     *
     * @param {object} data cms content data
     * @returns {ImageInfo} extracted image info
     */
    function extractImageInfoV2(data) {
      const content = data?.contentBody ?? {};
      const media = content["sfdc_cms:media"] ?? {};
      const imageInfo = {
        url: siteInfo.buildSiteCmsPath(media.url ?? "", media.source?.type === "url"),
        altText: content.altText ?? ""
      };
      return imageInfo;
    }

    /**
     * Get Different Form Factors URLs from Image Info
     *
     * @param {object} imageInfo image info object
     * @returns {object} URLs for Mobile, Tablet and Desktop Form Factors
     */
    function getImageSrcSetUrls(imageInfo) {
      const mobileUrl = normalizer.normalizeString(imageInfo?.SrcSet?.[0]?.srcSet?.[0] || imageInfo?.Url, {
        fallbackValue: "initial",
        caseSensitive: true
      });
      const tabletUrl = normalizer.normalizeString(imageInfo?.SrcSet?.[1]?.srcSet?.[0] || imageInfo?.Url, {
        fallbackValue: "initial",
        caseSensitive: true
      });
      const desktopUrl = normalizer.normalizeString(imageInfo?.SrcSet?.[2]?.srcSet?.[0] || imageInfo?.Url, {
        fallbackValue: "initial",
        caseSensitive: true
      });
      return {
        mobileUrl,
        tabletUrl,
        desktopUrl
      };
    }

    /**
     * Extract Content Key from CMS Resource URL
     *
     * @param {string} url raw url
     * @returns {string} content key
     */
    function getContentKey(url) {
      if (!url || !url.includes(CMS_MEDIA_BASE_PATH)) {
        return null;
      }
      const start = url.indexOf(CMS_MEDIA_BASE_PATH) + CMS_MEDIA_BASE_PATH.length + 1;
      return url.substring(start) || null;
    }

    exports.convertItemsToContentKeyMap = convertItemsToContentKeyMap;
    exports.extractImageInfo = extractImageInfo;
    exports.extractImageInfoV2 = extractImageInfoV2;
    exports.getCMSContentUrl = getCMSContentUrl;
    exports.getContentKey = getContentKey;
    exports.getImageSrcSetUrls = getImageSrcSetUrls;
    exports.isCmsAsset = isCmsAsset;
    exports.isCmsResource = isCmsResource;
    exports.isResource = isResource;
    exports.isStaticImageResource = isStaticImageResource;
    exports.resolveUrl = resolveUrl;
    exports.toUrlInfo = toUrlInfo;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('community_layout/section', ['exports', 'lwc', 'lwr/environment', 'dxp_util/common', 'dxp_util/contentInfo'], (function (exports, lwc, environment, common, contentInfo) {

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("." + token) : "";
      var hostSelector = token ? ("." + token + "-host") : "";
      return ((useActualHostSelector ? ":host.comm-section-container {" : hostSelector + ".comm-section-container {")) + "display: block;position: relative;}.columns-content" + shadowSelector + " {display: flex;margin-left: auto;margin-right: auto;position: relative;}.background-image" + shadowSelector + ",.background-image-overlay" + shadowSelector + " {position: absolute;width: 100%;height: 100%;top: 0;left: 0;right: 0;bottom: 0;z-index: 0;}.background-image-overlay" + shadowSelector + " {background-color: var(--dxp-c-section-image-overlay-color);}@media only screen and (min-width: 64.0625em) {" + ((useActualHostSelector ? ":host.comm-section-container {" : hostSelector + ".comm-section-container {")) + "padding: var(\n --dxp-c-section-content-spacing-block-start,\n var(--dxp-style-c-padding-top, var(--dxp-s-section-content-spacing-block-start))\n )\n var(\n --dxp-c-section-content-spacing-inline-end,\n var(--dxp-style-c-padding-right, var(--dxp-s-section-content-spacing-inline-end))\n )\n var(\n --dxp-c-section-content-spacing-block-end,\n var(--dxp-style-c-padding-bottom, var(--dxp-s-section-content-spacing-block-end))\n )\n var(\n --dxp-c-section-content-spacing-inline-start,\n var(--dxp-style-c-padding-left, var(--dxp-s-section-content-spacing-inline-start))\n );min-height: var(--dxp-c-section-min-height-desktop, var(--dxp-c-l-section-min-height));}.columns-content" + shadowSelector + " {--dxp-c-region-wrapper-vertical-align: var(\n --dxp-c-l-section-vertical-align,\n var(--dxp-c-section-vertical-align)\n );flex-direction: row;max-width: var(\n --dxp-c-section-columns-max-width,\n var(\n --dxp-c-l-max-content-width,\n var(--dxp-c-max-content-width, var(--dxp-s-section-columns-max-width))\n )\n );min-height: var(\n --dxp-c-section-columns-min-height-desktop,\n var(--dxp-c-l-section-min-height)\n );}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'] .columns-content" : hostSelector + "[data-layout-direction~='desktop-direction-row'] .columns-content")) + shadowSelector + " {flex-direction: row;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-column'] .columns-content" : hostSelector + "[data-layout-direction~='desktop-direction-column'] .columns-content")) + shadowSelector + " {flex-direction: column;}.background-image" + shadowSelector + ", .background-image-overlay" + shadowSelector + " {min-height: var(--dxp-c-section-min-height-desktop, var(--dxp-c-l-section-min-height));}.background-image" + shadowSelector + " {background: var(--dxp-c-l-section-image-url) var(--dxp-c-section-image-position)\n var(--dxp-c-section-image-size-and-repeat);}}@media only screen and (min-width: 48em) and (max-width: 64em) {" + ((useActualHostSelector ? ":host.comm-section-container {" : hostSelector + ".comm-section-container {")) + "padding: var(\n --dxp-c-section-content-spacing-block-start-tablet,\n var(\n --dxp-style-c-padding-top-m,\n var(--dxp-s-section-content-spacing-block-start-mobile)\n )\n )\n var(\n --dxp-c-section-content-spacing-inline-end-tablet,\n var(\n --dxp-style-c-padding-right-m,\n var(--dxp-s-section-content-spacing-inline-end-mobile)\n )\n )\n var(\n --dxp-c-section-content-spacing-block-end-tablet,\n var(\n --dxp-style-c-padding-bottom-m,\n var(--dxp-s-section-content-spacing-block-end-mobile)\n )\n )\n var(\n --dxp-c-section-content-spacing-inline-start-tablet,\n var(\n --dxp-style-c-padding-left-m,\n var(--dxp-s-section-content-spacing-inline-start-mobile)\n )\n );min-height: var(--dxp-c-section-min-height-tablet, var(--dxp-c-m-section-min-height));}.columns-content" + shadowSelector + " {--dxp-c-region-wrapper-vertical-align: var(\n --dxp-c-m-section-vertical-align,\n var(--dxp-c-section-vertical-align)\n );flex-direction: column;max-width: var(\n --dxp-c-section-columns-max-width-tablet,\n var(\n --dxp-c-m-max-content-width,\n var(--dxp-c-max-content-width, var(--dxp-s-section-columns-max-width-mobile))\n )\n );min-height: var(\n --dxp-c-section-columns-min-height-tablet,\n var(--dxp-c-m-section-min-height)\n );}" + ((useActualHostSelector ? ":host[data-layout-direction~='tablet-direction-row'] .columns-content" : hostSelector + "[data-layout-direction~='tablet-direction-row'] .columns-content")) + shadowSelector + " {flex-direction: row;}" + ((useActualHostSelector ? ":host[data-layout-direction~='tablet-direction-column'] .columns-content" : hostSelector + "[data-layout-direction~='tablet-direction-column'] .columns-content")) + shadowSelector + " {flex-direction: column;}.background-image" + shadowSelector + ", .background-image-overlay" + shadowSelector + " {min-height: var(--dxp-c-section-min-height-tablet, var(--dxp-c-m-section-min-height));}.background-image" + shadowSelector + " {background: var(--dxp-c-m-section-image-url) var(--dxp-c-section-image-position)\n var(--dxp-c-section-image-size-and-repeat);}}@media only screen and (max-width: 47.9375em) {" + ((useActualHostSelector ? ":host.comm-section-container {" : hostSelector + ".comm-section-container {")) + "padding: var(\n --dxp-c-section-content-spacing-block-start-mobile,\n var(\n --dxp-style-c-padding-top-s,\n var(--dxp-s-section-content-spacing-block-start-mobile)\n )\n )\n var(\n --dxp-c-section-content-spacing-inline-end-mobile,\n var(\n --dxp-style-c-padding-right-s,\n var(--dxp-s-section-content-spacing-inline-end-mobile)\n )\n )\n var(\n --dxp-c-section-content-spacing-block-end-mobile,\n var(\n --dxp-style-c-padding-bottom-s,\n var(--dxp-s-section-content-spacing-block-end-mobile)\n )\n )\n var(\n --dxp-c-section-content-spacing-inline-start-mobile,\n var(\n --dxp-style-c-padding-left-s,\n var(--dxp-s-section-content-spacing-inline-start-mobile)\n )\n );min-height: var(--dxp-c-section-min-height-mobile, var(--dxp-c-s-section-min-height));}.columns-content" + shadowSelector + " {--dxp-c-region-wrapper-vertical-align: var(\n --dxp-c-s-section-vertical-align,\n var(--dxp-c-section-vertical-align)\n );flex-direction: column;max-width: var(\n --dxp-c-section-columns-max-width-mobile,\n var(\n --dxp-c-s-max-content-width,\n var(--dxp-c-max-content-width, var(--dxp-s-section-columns-max-width-mobile))\n )\n );min-height: var(\n --dxp-c-section-columns-min-height-mobile,\n var(--dxp-c-s-section-min-height)\n );}" + ((useActualHostSelector ? ":host[data-layout-direction~='mobile-direction-row'] .columns-content" : hostSelector + "[data-layout-direction~='mobile-direction-row'] .columns-content")) + shadowSelector + " {flex-direction: row;}" + ((useActualHostSelector ? ":host[data-layout-direction~='mobile-direction-column'] .columns-content" : hostSelector + "[data-layout-direction~='mobile-direction-column'] .columns-content")) + shadowSelector + " {flex-direction: column;}.background-image" + shadowSelector + ", .background-image-overlay" + shadowSelector + " {min-height: var(--dxp-c-section-min-height-mobile, var(--dxp-c-s-section-min-height));}.background-image" + shadowSelector + " {background: var(--dxp-c-s-section-image-url) var(--dxp-c-section-image-position)\n var(--dxp-c-section-image-size-and-repeat);}}";
      /*LWC compiler v7.1.5*/
    }
    stylesheet.$scoped$ = true;
    var _implicitScopedStylesheets = [stylesheet];

    const $fragment1 = lwc.parseFragment`<div class="background-image${0}"${"a0:aria-label"}${2}></div>`;
    const $fragment2 = lwc.parseFragment`<div class="background-image-overlay${0}"${2}></div>`;
    const stc0 = {
      classMap: {
        "columns-content": true
      },
      key: 4
    };
    const stc1 = {
      attrs: {
        "name": "columns"
      },
      key: 5
    };
    const stc2 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {sp: api_static_part, st: api_static_fragment, s: api_slot, h: api_element} = $api;
      return [api_static_fragment($fragment1, 1, [api_static_part(0, {
        attrs: {
          "aria-label": $cmp.imageAlt
        }
      }, null)]), api_static_fragment($fragment2, 3), api_element("div", stc0, [api_slot("columns", stc1, stc2, $slotset)])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = ["columns"];
    tmpl.renderMode = "light";
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-6j9an5vbrcd";
    tmpl.legacyStylesheetToken = "community_layout-section_section";
    if (_implicitScopedStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitScopedStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    /**
     * This comment is important, if it doesn't exist the slot will not be accessible in the ModuleDef,
     * see https://gus.lightning.force.com/lightning/r/0D5B000000moNnZ/view
     * @slot columns container for community_layout-column components
     */
    class Section extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._imageAltText = '';
        this._desktopBackgroundImageUrl = void 0;
        this._tabletBackgroundImageUrl = void 0;
        this._mobileBackgroundImageUrl = void 0;
        /**
         * sectionConfig is a JSON blob that stores attributes needed for site.com CRUD info (columnKey, Name, columns)
         * AND also attributes that will be passed into the generated column component (columnWidth)
         */
        this.sectionConfig = '{"columns":[{"columnKey":"col1","columnName":"Column 1","columnWidth":"12","seedComponents":[]}]}';
        this.maxContentWidth = void 0;
        this.sectionColumnGutterWidth = void 0;
        this.componentSpacerSize = void 0;
        this.sectionMinHeight = void 0;
        this.layoutDirectionDesktop = void 0;
        this.layoutDirectionTablet = void 0;
        this.layoutDirectionMobile = void 0;
        this.sectionVerticalAlign = void 0;
        this.backgroundImageOverlay = void 0;
      }
      /**
       * Gets the specified image from the CMS picker.
       */
      get backgroundImageConfig() {
        return this._backgroundImage;
      }
      set backgroundImageConfig(value) {
        if (typeof value === 'object' && value !== null) {
          this._backgroundImage = value;
          this._imageAltText = value?.AltText || '';
          const srcSetUrls = contentInfo.getImageSrcSetUrls(value);
          ({
            mobileUrl: this._mobileBackgroundImageUrl,
            tabletUrl: this._tabletBackgroundImageUrl,
            desktopUrl: this._desktopBackgroundImageUrl
          } = srcSetUrls);
        } else {
          this._backgroundImage = {};
        }
      }
      get imageAlt() {
        return this._imageAltText;
      }
      connectedCallback() {
        this.classList?.add('comm-section-container');
        if (typeof window === 'undefined' /* __lwr_isServer__ */) {
          this.setComputedCssVariables();
        }
        this.setResponsivePropertiesFallbackCssVariables();
      }
      renderedCallback() {
        this.setComputedCssVariables();
      }

      /**
       * Set fallback css variables for responsive properties when responsive css variables are unavailable
       * (e.g ExperienceScreenResponsive org perm is disabled)
       */
      setResponsivePropertiesFallbackCssVariables() {
        const styles = [];
        if (this.sectionVerticalAlign) {
          styles.push(`--dxp-c-section-vertical-align: ${this.sectionVerticalAlign};`);
        }
        if (this.maxContentWidth) {
          styles.push(`--dxp-c-max-content-width: ${this.maxContentWidth};`);
        }
        if (styles.length > 0) {
          this.setStyleAttribute(styles.join(' '));
        }
      }
      setComputedCssVariables() {
        if (this.backgroundImageConfig && this._desktopBackgroundImageUrl && this._tabletBackgroundImageUrl && this._mobileBackgroundImageUrl) {
          const {
            bgPosition,
            bgSizeOrRepeat
          } = this.backgroundImageConfig;
          const computedCssVariables = common.propertySet({
            '--dxp-c-l-section-image-url': common.toCssUrl(encodeURI(this._desktopBackgroundImageUrl)),
            '--dxp-c-m-section-image-url': common.toCssUrl(encodeURI(this._tabletBackgroundImageUrl)),
            '--dxp-c-s-section-image-url': common.toCssUrl(encodeURI(this._mobileBackgroundImageUrl)),
            '--dxp-c-section-image-position': bgPosition,
            '--dxp-c-section-image-size-and-repeat': bgSizeOrRepeat,
            '--dxp-c-section-image-overlay-color': this.backgroundImageOverlay
          }).toString();
          this.setStyleAttribute(computedCssVariables);
        }
      }
      setStyleAttribute(style) {
        // the browser may not include the trailing semicolon in the element style
        // attribute value. adding the semicolon when necessary until we can access
        // this.style (https://github.com/salesforce/lwc/issues/3999) and set the
        // individual properties instead.
        const initialStyle = this.getAttribute('style') || '';
        this.setAttribute('style', `${initialStyle}${!initialStyle || initialStyle.endsWith(';') ? '' : ';'}${style}`);
      }
      /*LWC compiler v7.1.5*/
    }
    Section.renderMode = 'light';
    lwc.registerDecorators(Section, {
      publicProps: {
        sectionConfig: {
          config: 0
        },
        maxContentWidth: {
          config: 0
        },
        sectionColumnGutterWidth: {
          config: 0
        },
        componentSpacerSize: {
          config: 0
        },
        sectionMinHeight: {
          config: 0
        },
        layoutDirectionDesktop: {
          config: 0
        },
        layoutDirectionTablet: {
          config: 0
        },
        layoutDirectionMobile: {
          config: 0
        },
        sectionVerticalAlign: {
          config: 0
        },
        backgroundImageConfig: {
          config: 3
        },
        backgroundImageOverlay: {
          config: 0
        }
      },
      fields: ["_imageAltText", "_desktopBackgroundImageUrl", "_tabletBackgroundImageUrl", "_mobileBackgroundImageUrl"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(Section, {
      tmpl: _tmpl,
      sel: "community_layout-section",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('community_layout/column', ['exports', 'lwc'], (function (exports, lwc) {

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("." + token) : "";
      var hostSelector = token ? ("." + token + "-host") : "";
      return ((useActualHostSelector ? ":host {" : hostSelector + " {")) + "display: flex;}.column-content" + shadowSelector + " {display: flex;flex-direction: column;flex: 1;min-width: 0;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'].col-large-size_1-of-12,:host[data-layout-direction~='tablet-direction-row'].col-large-size_1-of-12,:host[data-layout-direction~='mobile-direction-row'].col-large-size_1-of-12 {" : hostSelector + "[data-layout-direction~='desktop-direction-row'].col-large-size_1-of-12," + hostSelector + "[data-layout-direction~='tablet-direction-row'].col-large-size_1-of-12," + hostSelector + "[data-layout-direction~='mobile-direction-row'].col-large-size_1-of-12 {")) + "flex-grow: 1;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'].col-large-size_2-of-12,:host[data-layout-direction~='tablet-direction-row'].col-large-size_2-of-12,:host[data-layout-direction~='mobile-direction-row'].col-large-size_2-of-12 {" : hostSelector + "[data-layout-direction~='desktop-direction-row'].col-large-size_2-of-12," + hostSelector + "[data-layout-direction~='tablet-direction-row'].col-large-size_2-of-12," + hostSelector + "[data-layout-direction~='mobile-direction-row'].col-large-size_2-of-12 {")) + "flex-grow: 2;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'].col-large-size_3-of-12,:host[data-layout-direction~='tablet-direction-row'].col-large-size_3-of-12,:host[data-layout-direction~='mobile-direction-row'].col-large-size_3-of-12 {" : hostSelector + "[data-layout-direction~='desktop-direction-row'].col-large-size_3-of-12," + hostSelector + "[data-layout-direction~='tablet-direction-row'].col-large-size_3-of-12," + hostSelector + "[data-layout-direction~='mobile-direction-row'].col-large-size_3-of-12 {")) + "flex-grow: 3;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'].col-large-size_4-of-12,:host[data-layout-direction~='tablet-direction-row'].col-large-size_4-of-12,:host[data-layout-direction~='mobile-direction-row'].col-large-size_4-of-12 {" : hostSelector + "[data-layout-direction~='desktop-direction-row'].col-large-size_4-of-12," + hostSelector + "[data-layout-direction~='tablet-direction-row'].col-large-size_4-of-12," + hostSelector + "[data-layout-direction~='mobile-direction-row'].col-large-size_4-of-12 {")) + "flex-grow: 4;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'].col-large-size_5-of-12,:host[data-layout-direction~='tablet-direction-row'].col-large-size_5-of-12,:host[data-layout-direction~='mobile-direction-row'].col-large-size_5-of-12 {" : hostSelector + "[data-layout-direction~='desktop-direction-row'].col-large-size_5-of-12," + hostSelector + "[data-layout-direction~='tablet-direction-row'].col-large-size_5-of-12," + hostSelector + "[data-layout-direction~='mobile-direction-row'].col-large-size_5-of-12 {")) + "flex-grow: 5;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'].col-large-size_6-of-12,:host[data-layout-direction~='tablet-direction-row'].col-large-size_6-of-12,:host[data-layout-direction~='mobile-direction-row'].col-large-size_6-of-12 {" : hostSelector + "[data-layout-direction~='desktop-direction-row'].col-large-size_6-of-12," + hostSelector + "[data-layout-direction~='tablet-direction-row'].col-large-size_6-of-12," + hostSelector + "[data-layout-direction~='mobile-direction-row'].col-large-size_6-of-12 {")) + "flex-grow: 6;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'].col-large-size_7-of-12,:host[data-layout-direction~='tablet-direction-row'].col-large-size_7-of-12,:host[data-layout-direction~='mobile-direction-row'].col-large-size_7-of-12 {" : hostSelector + "[data-layout-direction~='desktop-direction-row'].col-large-size_7-of-12," + hostSelector + "[data-layout-direction~='tablet-direction-row'].col-large-size_7-of-12," + hostSelector + "[data-layout-direction~='mobile-direction-row'].col-large-size_7-of-12 {")) + "flex-grow: 7;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'].col-large-size_8-of-12,:host[data-layout-direction~='tablet-direction-row'].col-large-size_8-of-12,:host[data-layout-direction~='mobile-direction-row'].col-large-size_8-of-12 {" : hostSelector + "[data-layout-direction~='desktop-direction-row'].col-large-size_8-of-12," + hostSelector + "[data-layout-direction~='tablet-direction-row'].col-large-size_8-of-12," + hostSelector + "[data-layout-direction~='mobile-direction-row'].col-large-size_8-of-12 {")) + "flex-grow: 8;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'].col-large-size_9-of-12,:host[data-layout-direction~='tablet-direction-row'].col-large-size_9-of-12,:host[data-layout-direction~='mobile-direction-row'].col-large-size_9-of-12 {" : hostSelector + "[data-layout-direction~='desktop-direction-row'].col-large-size_9-of-12," + hostSelector + "[data-layout-direction~='tablet-direction-row'].col-large-size_9-of-12," + hostSelector + "[data-layout-direction~='mobile-direction-row'].col-large-size_9-of-12 {")) + "flex-grow: 9;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'].col-large-size_10-of-12,:host[data-layout-direction~='tablet-direction-row'].col-large-size_10-of-12,:host[data-layout-direction~='mobile-direction-row'].col-large-size_10-of-12 {" : hostSelector + "[data-layout-direction~='desktop-direction-row'].col-large-size_10-of-12," + hostSelector + "[data-layout-direction~='tablet-direction-row'].col-large-size_10-of-12," + hostSelector + "[data-layout-direction~='mobile-direction-row'].col-large-size_10-of-12 {")) + "flex-grow: 10;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'].col-large-size_11-of-12,:host[data-layout-direction~='tablet-direction-row'].col-large-size_11-of-12,:host[data-layout-direction~='mobile-direction-row'].col-large-size_11-of-12 {" : hostSelector + "[data-layout-direction~='desktop-direction-row'].col-large-size_11-of-12," + hostSelector + "[data-layout-direction~='tablet-direction-row'].col-large-size_11-of-12," + hostSelector + "[data-layout-direction~='mobile-direction-row'].col-large-size_11-of-12 {")) + "flex-grow: 11;}@media only screen and (min-width: 64.0625em) {" + ((useActualHostSelector ? ":host {" : hostSelector + " {")) + "padding: var(--dxp-c-column-container-spacing-block-start)\n var(--dxp-c-column-container-spacing-inline-end)\n var(--dxp-c-column-container-spacing-block-end)\n var(--dxp-c-column-container-spacing-inline-start);}.column-content" + shadowSelector + " {padding: var(--dxp-c-column-content-spacing-block-start)\n var(--dxp-c-column-content-spacing-inline-end)\n var(--dxp-c-column-content-spacing-block-end)\n var(--dxp-c-column-content-spacing-inline-start);justify-content: var(--dxp-c-l-section-vertical-align, var(--dxp-c-section-vertical-align));}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-row'] {" : hostSelector + "[data-layout-direction~='desktop-direction-row'] {")) + "--sectionSpacerWidth: var(\n --dxp-c-column-spacer-size,\n var(--dxp-c-l-section-column-gutter-width, var(--dxp-s-column-spacer-size))\n );flex: 1;min-width: 0;}" + ((useActualHostSelector ? ":host[data-layout-direction~='desktop-direction-column'] {" : hostSelector + "[data-layout-direction~='desktop-direction-column'] {")) + "--sectionSpacerHeight: var(\n --dxp-c-column-spacer-size,\n var(--dxp-c-l-section-column-gutter-width, var(--dxp-s-column-spacer-size))\n );flex: 0;min-height: 0;}}@media only screen and (min-width: 48em) and (max-width: 64em) {" + ((useActualHostSelector ? ":host {" : hostSelector + " {")) + "padding: var(--dxp-c-column-container-spacing-block-start-mobile)\n var(--dxp-c-column-container-spacing-inline-end-mobile)\n var(--dxp-c-column-container-spacing-block-end-mobile)\n var(--dxp-c-column-container-spacing-inline-start-mobile);}.column-content" + shadowSelector + " {padding: var(--dxp-c-column-content-spacing-block-start-mobile)\n var(--dxp-c-column-content-spacing-inline-end-mobile)\n var(--dxp-c-column-content-spacing-block-end-mobile)\n var(--dxp-c-column-content-spacing-inline-start-mobile);justify-content: var(--dxp-c-m-section-vertical-align, var(--dxp-c-section-vertical-align));}" + ((useActualHostSelector ? ":host[data-layout-direction~='tablet-direction-row'] {" : hostSelector + "[data-layout-direction~='tablet-direction-row'] {")) + "--sectionSpacerWidth: var(\n --dxp-c-column-spacer-size-tablet,\n var(--dxp-c-m-section-column-gutter-width, var(--dxp-s-column-spacer-size-mobile))\n );flex: 1;min-width: 0;}" + ((useActualHostSelector ? ":host[data-layout-direction~='tablet-direction-column'] {" : hostSelector + "[data-layout-direction~='tablet-direction-column'] {")) + "--sectionSpacerHeight: var(\n --dxp-c-column-spacer-size-tablet,\n var(--dxp-c-m-section-column-gutter-width, var(--dxp-s-column-spacer-size-mobile))\n );flex: 0;min-height: 0;}}@media only screen and (max-width: 47.9375em) {" + ((useActualHostSelector ? ":host {" : hostSelector + " {")) + "padding: var(--dxp-c-column-container-spacing-block-start-mobile)\n var(--dxp-c-column-container-spacing-inline-end-mobile)\n var(--dxp-c-column-container-spacing-block-end-mobile)\n var(--dxp-c-column-container-spacing-inline-start-mobile);}.column-content" + shadowSelector + " {padding: var(--dxp-c-column-content-spacing-block-start-mobile)\n var(--dxp-c-column-content-spacing-inline-end-mobile)\n var(--dxp-c-column-content-spacing-block-end-mobile)\n var(--dxp-c-column-content-spacing-inline-start-mobile);justify-content: var(--dxp-c-s-section-vertical-align, var(--dxp-c-section-vertical-align));}" + ((useActualHostSelector ? ":host[data-layout-direction~='mobile-direction-row'] {" : hostSelector + "[data-layout-direction~='mobile-direction-row'] {")) + "--sectionSpacerWidth: var(\n --dxp-c-column-spacer-size-mobile,\n var(--dxp-c-s-section-column-gutter-width, var(--dxp-s-column-spacer-size-mobile))\n );flex: 1;min-width: 0;}" + ((useActualHostSelector ? ":host[data-layout-direction~='mobile-direction-column'] {" : hostSelector + "[data-layout-direction~='mobile-direction-column'] {")) + "--sectionSpacerHeight: var(\n --dxp-c-column-spacer-size-mobile,\n var(--dxp-c-s-section-column-gutter-width, var(--dxp-s-column-spacer-size-mobile))\n );flex: 0;min-height: 0;}}";
      /*LWC compiler v7.1.5*/
    }
    stylesheet.$scoped$ = true;
    var _implicitScopedStylesheets = [stylesheet];

    const stc0 = {
      classMap: {
        "column-content": true
      },
      key: 0
    };
    const stc1 = {
      attrs: {
        "name": "column"
      },
      key: 1
    };
    const stc2 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {s: api_slot, h: api_element} = $api;
      return [api_element("div", stc0, [api_slot("column", stc1, stc2, $slotset)])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = ["column"];
    tmpl.renderMode = "light";
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-48aostf02bd";
    tmpl.legacyStylesheetToken = "community_layout-column_column";
    if (_implicitScopedStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitScopedStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    /**
     * This comment is important, if it doesn't exist the slot will not be accessible in the ModuleDef,
     * see https://gus.lightning.force.com/lightning/r/0D5B000000moNnZ/view
     * @slot column a place for content within a column slot
     */
    // import { getMinSize, isHorizontalLayout, isVerticalLayout } from './utils';

    const DEFAULT_WIDTH = 12;
    const DEFAULT_COUNT = 1;
    const FULL_WIDTH = 'col-size_12-of-12';
    class Column extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._columnWidth = DEFAULT_WIDTH;
        this._columnCount = DEFAULT_COUNT;
      }
      /**
       * A unit of width ranging from 1 to 12 used to set the appropriate column style.
       */
      get columnWidth() {
        return this._columnWidth;
      }
      set columnWidth(newWidth) {
        this._columnWidth = newWidth;
        this.updateHostCssClasses();
      }

      /**
       * The total number of columns within the same section. This is useful when calculating how much width the spacers
       * in a section are taking up.
       */
      get columnCount() {
        return this._columnCount;
      }
      set columnCount(newCount) {
        this._columnCount = newCount;
      }
      connectedCallback() {
        this.updateHostCssClasses();
      }

      /**
       * Sets the host css. Required at the host level so that it has a width relative to its container (section).
       */
      updateHostCssClasses() {
        // We technically don't need these classes anymore but it seems safer to leave them for now in case site
        // authors are relying on them in their custom css.
        //
        // We previously had css classes that targeted form factors and the row flow-direction before assigning width.
        // The reason we could remove them is that when we use flex-direction column we're not assigning a height or
        // min-height to the container. That means the container only takes up the space needed by the content and
        // there's no room for the columns to grow so our style settings below are a no-op.
        //
        // The nice thing is if we ever start supporting a min-height in flex-direction column mode, everything will
        // distribute as specified in column distribution in the vertical direction!
        //
        // TODO: These classes are required again until we are able to get the host CSSStyleDeclaration during
        // connectedCallback using this.style after https://github.com/salesforce/lwc/issues/3999 is fixed. Currently,
        // this can only be accessed using the getComputedStyle(host.children[0].parentElement, null) workaround
        // after the component has been rendered. So, we're not able to get the correct flex-direction for the
        // current form factor when the component is server-side rendered.
        const updatedClassList = [FULL_WIDTH, this.colWidthClass];
        this.classList?.remove(...Array.from(this.classList).filter(clazz => clazz?.startsWith('col-large-size_')));
        this.classList?.add(...updatedClassList);
      }

      // updateHostStyle() {
      //     // We need to define how much the column can shrink which is needed for narrow screens and for flex to be able
      //     // to distribute space amongst the columns.
      //     const minSize = getMinSize(this.columnWidth, this.columnCount);

      //     const style = [];
      //     if (isHorizontalLayout()) {
      //         // The flex-grow value works well as the column width because we're using the 12 column span layout. If we have
      //         // 5 columns where one of them needs to be double the width of the others that follows naturally from the
      //         // given columnWidth values:
      //         // | 2 | 2 | 4 | 2 | 2 |
      //         //
      //         // The columns with flex-grow 2 will all be sized the same while the column with flex-grow 4 will be double the
      //         // size of the others.
      //         style.push(`flex-grow: ${this.columnWidth}`);
      //         if (minSize) {
      //             style.push(`min-width: ${minSize}`);
      //         }
      //     } else if (isVerticalLayout()) {
      //         // We don't want to apply flex-grow to vertical layouts to match existing behavior to be extra safe. If
      //         // the user specifies a min-height for the section, flex-grow will apply to vertical layouts as well.
      //         if (minSize) {
      //             style.push(`min-height: ${minSize}`);
      //         }
      //     }

      //     if (style.length > 0) {
      //         this.setAttribute('style', style.join('; '));
      //     }
      // }

      get colWidthClass() {
        return this.columnWidth ? `col-large-size_${this.columnWidth}-of-12` : 'col';
      }
      /*LWC compiler v7.1.5*/
    }
    Column.renderMode = 'light';
    Column.validationOptOut = ['class'];
    lwc.registerDecorators(Column, {
      publicProps: {
        columnWidth: {
          config: 3
        },
        columnCount: {
          config: 3
        }
      },
      fields: ["_columnWidth", "_columnCount"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(Column, {
      tmpl: _tmpl,
      sel: "community_layout-column",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@luvio/runtime', ['force/luvioRuntimeWebruntime'], function(m) { return m && typeof m === 'object' && 'default' in m ? m.default : m; });
(function() { LWR.define('force/luvioRegistry', ['exports', 'lwc'], (function (exports, lwc) {

    /**
     * Copyright (c) 2022, Salesforce, Inc.,
     * All rights reserved.
     * For full license text, see the LICENSE.txt file
     */

    /*  *******************************************************************************************
     *  ATTENTION!
     *  THIS IS A GENERATED FILE FROM https://github.com/salesforce-experience-platform-emu/lds-lightning-platform
     *  If you would like to contribute to LDS, please follow the steps outlined in the git repo.
     *  Any changes made to this file in p4 will be automatically overwritten.
     *  *******************************************************************************************
     */
    /* proxy-compat-disable */
    /**
     * Copyright (c) 2022, Salesforce, Inc.,
     * All rights reserved.
     * For full license text, see the LICENSE.txt file
     */

    /**
     * Callbacks to be invoked when registrations happen.
     */
    const callbacks = [];
    /**
     * Registrations that have already occurred.
     *
     * Note that Registrations are maintained as a list rather than a map to allow
     * the same id to be registered multiple times with potentially different
     * data.
     */
    const registrations = [];
    /**
     * Invokes callback for each Registration, both past & future. That is, callback
     * will be invoked exactly as many times as register() is called.
     *
     * Note that Registration ids are not guaranteed to be unique. The meaning of
     * multiple Registrations with the same id is determined by the caller(s) of
     * register().
     */
    function forEachRegistration(callback) {
      callbacks.push(callback);
      registrations.forEach(r => callback(r));
    }
    /**
     * Invokes callback when the specified id is registered.
     *
     * Note that callback may be invoked:
     *
     *    - multiple times if multiple calls to register() specify the id
     *    - never if the specified id is never registered
     */
    function withRegistration(id, callback) {
      forEachRegistration(r => {
        if (r.id === id) {
          callback(r);
        }
      });
    }
    /**
     * Returns all current Registrations that match the specified id. If no matching
     * Registrations are found, [] is returned.
     */
    function findRegistrations(id) {
      return registrations.filter(r => r.id === id);
    }
    /**
     * Register an id and associated data.
     *
     * Callers of register() should make types available that include:
     *
     *    - the id they will register
     *    - definitions for any additional properties on their Registration objects
     *
     * For example:
     *
     *    export type MyRegistration = {
     *        id: 'myRegistrationId',
     *
     *        // some value that others might need
     *        myValue: string,
     *
     *        // some function that others might want to call
     *        myFunction: () => void,
     *    };
     *    register({ id: 'myRegistrationId', myValue: 'foo', myFunction: () => {} } as MyRegistration);
     *
     * The registry itself does not dictate the format of ids nor attempt to coordinate
     * uniqueness of id values.
     *
     * The same id can be registered multiple times with different Registration
     * objects.
     */
    function register(r) {
      registrations.push(r);
      callbacks.forEach(callback => callback(r));
    }
    // version: 1.278.0-a388a38f0
    const __lwc_hmr_context = { moduleHash : '337e2f351c3b3c0bb447df317317ab3e' };
    if (lwc.hot) {
        lwc.hot.register('force/luvioRegistry/luvioRegistry.js', '337e2f351c3b3c0bb447df317317ab3e', {"name":"luvioRegistry","namespace":"force","enableLightningWebSecurityTransforms":false,"experimentalDynamicComponent":{"loader":"@salesforce/loader","strictSpecifier":false},"experimentalDynamicDirective":false,"enableDynamicComponents":true,"enableStaticContentOptimization":true,"outputConfig":{"sourcemap":false}});
    }

    exports.__lwc_hmr_context = __lwc_hmr_context;
    exports.findRegistrations = findRegistrations;
    exports.forEachRegistration = forEachRegistration;
    exports.register = register;
    exports.withRegistration = withRegistration;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@luvio/registry', ['force/luvioRegistry'], function(m) { return m && typeof m === 'object' && 'default' in m ? m.default : m; });
(function() { LWR.define('experience/coercion', ['exports'], (function (exports) {

  function coerceBooleanProperty(value) {
    return value != null && `${value}`.toLowerCase() !== 'false';
  }

  function isNumberValue(value) {
    return !isNaN(parseFloat(String(value))) && !isNaN(Number(value));
  }
  function coerceNumberProperty(value, fallbackValue = 0) {
    return isNumberValue(value) ? Number(value) : fallbackValue;
  }

  function isObjectLike(value) {
    return value != null && typeof value === 'object';
  }
  function isNumber(value) {
    return typeof value === 'number' || isObjectLike(value) && Object.prototype.toString.call(value) === '[object Number]';
  }
  function isNaN$1(value) {
    return isNumber(value) && value !== +value;
  }
  function coerceStringProperty(value, fallbackValue) {
    const stringValue = value == null || isNaN$1(value) ? '' : value.toString();
    return stringValue.length > 0 ? stringValue : fallbackValue;
  }

  exports.coerceBooleanProperty = coerceBooleanProperty;
  exports.coerceNumberProperty = coerceNumberProperty;
  exports.coerceStringProperty = coerceStringProperty;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/serializeError', ['exports', 'lwc'], (function (exports, lwc) {

  var _tmpl = void 0;

  const list = [EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, globalThis.DOMException, globalThis.AssertionError, globalThis.SystemError].filter(Boolean).map(constructor => [constructor.name, constructor]);
  const errorConstructors = new Map(list);
  const __lwc_component_class_internal = lwc.registerComponent(errorConstructors, {
    tmpl: _tmpl,
    sel: "experience-serialize-error",
    apiVersion: 62
  });

  class NonError extends Error {
    constructor(message) {
      super(NonError._prepareSuperMessage(message));
      this.name = 'NonError';
    }
    static _prepareSuperMessage(message) {
      try {
        return JSON.stringify(message);
      } catch {
        return String(message);
      }
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(NonError, {
    fields: ["name"]
  });
  const commonProperties = [{
    property: 'name',
    enumerable: false
  }, {
    property: 'message',
    enumerable: false
  }, {
    property: 'stack',
    enumerable: false
  }, {
    property: 'code',
    enumerable: true
  }, {
    property: 'cause',
    enumerable: false
  }];
  const toJsonWasCalled = Symbol('.toJSON was called');
  const toJSON = from => {
    from[toJsonWasCalled] = true;
    const json = from.toJSON();
    delete from[toJsonWasCalled];
    return json;
  };
  const getErrorConstructor = name => __lwc_component_class_internal.get(name) ?? Error;
  const destroyCircular = ({
    from,
    seen,
    to,
    forceEnumerable,
    maxDepth,
    depth,
    useToJSON,
    serialize
  }) => {
    if (!to) {
      if (Array.isArray(from)) {
        to = [];
      } else if (!serialize && isErrorLike(from)) {
        const Error = getErrorConstructor(from.name);
        to = new Error();
      } else {
        to = {};
      }
    }
    seen.push(from);
    if (depth >= maxDepth) {
      return to;
    }
    if (useToJSON && typeof from.toJSON === 'function' && from[toJsonWasCalled] !== true) {
      return toJSON(from);
    }
    const continueDestroyCircular = value => destroyCircular({
      from: value,
      seen: [...seen],
      forceEnumerable,
      maxDepth,
      depth,
      useToJSON,
      serialize
    });
    for (const [key, value] of Object.entries(from)) {
      if (typeof Buffer === 'function' && Buffer.isBuffer(value)) {
        to[key] = '[object Buffer]';
        continue;
      }
      if (value !== null && typeof value === 'object' && typeof value.pipe === 'function') {
        to[key] = '[object Stream]';
        continue;
      }
      if (typeof value === 'function') {
        continue;
      }
      if (!value || typeof value !== 'object') {
        to[key] = value;
        continue;
      }
      if (!seen.includes(from[key])) {
        depth++;
        to[key] = continueDestroyCircular(from[key]);
        continue;
      }
      to[key] = '[Circular]';
    }
    for (const {
      property,
      enumerable
    } of commonProperties) {
      if (typeof from[property] !== 'undefined' && from[property] !== null) {
        Object.defineProperty(to, property, {
          value: isErrorLike(from[property]) ? continueDestroyCircular(from[property]) : from[property],
          enumerable: forceEnumerable ? true : enumerable,
          configurable: true,
          writable: true
        });
      }
    }
    return to;
  };
  function serializeError(value, options = {}) {
    const {
      maxDepth = Number.POSITIVE_INFINITY,
      useToJSON = true
    } = options;
    if (typeof value === 'object' && value !== null) {
      return destroyCircular({
        from: value,
        seen: [],
        forceEnumerable: true,
        maxDepth,
        depth: 0,
        useToJSON,
        serialize: true
      });
    }
    if (typeof value === 'function') {
      return `[Function: ${value.name ?? 'anonymous'}]`;
    }
    return value;
  }
  function deserializeError(value, options = {}) {
    const {
      maxDepth = Number.POSITIVE_INFINITY
    } = options;
    if (value instanceof Error) {
      return value;
    }
    if (isMinimumViableSerializedError(value)) {
      const Error = getErrorConstructor(value.name);
      return destroyCircular({
        from: value,
        seen: [],
        to: new Error(),
        maxDepth,
        depth: 0,
        serialize: false
      });
    }
    return new NonError(value);
  }
  function isErrorLike(value) {
    return Boolean(value) && typeof value === 'object' && 'name' in value && 'message' in value && 'stack' in value;
  }
  function isMinimumViableSerializedError(value) {
    return Boolean(value) && typeof value === 'object' && 'message' in value && !Array.isArray(value);
  }

  function registerErrorConstructor(type, ctor) {
    __lwc_component_class_internal.set(type, ctor);
  }

  exports.deserializeError = deserializeError;
  exports.registerErrorConstructor = registerErrorConstructor;
  exports.serializeError = serializeError;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/utils', ['exports', 'experience/utilsInternal'], (function (exports, utilsInternal) {



	Object.defineProperty(exports, 'clearDebounceTimeout', {
		enumerable: true,
		get: function () { return utilsInternal.clearDebounceTimeout; }
	});
	Object.defineProperty(exports, 'debounce', {
		enumerable: true,
		get: function () { return utilsInternal.debounce; }
	});
	Object.defineProperty(exports, 'empty', {
		enumerable: true,
		get: function () { return utilsInternal.empty; }
	});
	Object.defineProperty(exports, 'extendDebouncedTimeout', {
		enumerable: true,
		get: function () { return utilsInternal.extendDebouncedTimeout; }
	});
	Object.defineProperty(exports, 'get', {
		enumerable: true,
		get: function () { return utilsInternal.get; }
	});
	Object.defineProperty(exports, 'getObjectTag', {
		enumerable: true,
		get: function () { return utilsInternal.getObjectTag; }
	});
	Object.defineProperty(exports, 'isBlank', {
		enumerable: true,
		get: function () { return utilsInternal.isBlank; }
	});
	Object.defineProperty(exports, 'isFunction', {
		enumerable: true,
		get: function () { return utilsInternal.isFunction; }
	});
	Object.defineProperty(exports, 'isInteger', {
		enumerable: true,
		get: function () { return utilsInternal.isInteger; }
	});
	Object.defineProperty(exports, 'isNil', {
		enumerable: true,
		get: function () { return utilsInternal.isNil; }
	});
	Object.defineProperty(exports, 'isObject', {
		enumerable: true,
		get: function () { return utilsInternal.isObject; }
	});
	Object.defineProperty(exports, 'isObjectLike', {
		enumerable: true,
		get: function () { return utilsInternal.isObjectLike; }
	});
	Object.defineProperty(exports, 'isPlainObject', {
		enumerable: true,
		get: function () { return utilsInternal.isPlainObject; }
	});
	Object.defineProperty(exports, 'isPromiseLike', {
		enumerable: true,
		get: function () { return utilsInternal.isPromiseLike; }
	});

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/data', ['exports', 'experience/utils', 'lwc', 'experience/coercion', 'experience/serializeError', 'transport', 'experience/uri'], (function (exports, utils, lwc, coercion, serializeError, transport, uri) {

  const DEFAULT_ABORT_REASON = 'Aborted';
  class AbortError extends Error {
    constructor(message) {
      super(coercion.coerceStringProperty(message, DEFAULT_ABORT_REASON));
      this.name = 'AbortError';
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(AbortError, {
    fields: ["name"]
  });
  serializeError.registerErrorConstructor('AbortError', AbortError);

  const ABORT = Symbol('abort');
  const ABORT_SIGNAL = Symbol('abortSignal');
  const ABORTERS = new WeakMap();
  class AbortablePromise extends Promise {
    static from(promise) {
      if (promise instanceof AbortablePromise) {
        return promise;
      } else if (promise instanceof Promise || typeof promise.catch === 'function') {
        return new AbortablePromise((resolve, reject) => promise.then(resolve).catch(reject));
      }
      return new AbortablePromise((resolve, reject) => promise.then(resolve, reject));
    }
    static connect(parent, child) {
      const parentEntry = ABORTERS.get(parent);
      const childEntry = ABORTERS.get(child);
      const {
        controller: parentController
      } = parentEntry;
      const {
        controller: childController
      } = childEntry;
      const {
        signal: parentSignal
      } = parentController;
      const {
        signal: childSignal
      } = childController;
      if (parentSignal === childSignal) {
        return;
      }
      childEntry.parent = parentEntry;
      const ensureReason = (receiver, donor) => {
        !receiver.reason && (receiver.reason = donor.reason);
      };
      if (childSignal.aborted && !parentSignal.aborted) {
        ensureReason(parentEntry, childEntry);
        parentController.abort();
      } else if (parentSignal.aborted && !childSignal.aborted) {
        ensureReason(childEntry, parentEntry);
        childController.abort();
      } else {
        const parentHandler = () => {
          childSignal.removeEventListener('abort', parentHandler);
          if (!childSignal.aborted) {
            ensureReason(childEntry, parentEntry);
            childController.abort();
          }
        };
        const childHandler = () => {
          childSignal.removeEventListener('abort', childHandler);
          if (!parentSignal.aborted) {
            ensureReason(parentEntry, childEntry);
            parentController.abort();
          }
        };
        parentSignal.addEventListener('abort', parentHandler);
        childSignal.addEventListener('abort', childHandler);
      }
    }
    constructor(executor) {
      const abortController = new AbortController();
      const {
        signal
      } = abortController;
      let isFulfilled = false;
      const aborter = reason => {
        ABORTERS.get(this).reason = reason || DEFAULT_ABORT_REASON;
        abortController.abort();
      };
      super((resolve, reject) => {
        const resolver = value => {
          !isFulfilled && !signal.aborted && resolve(value);
          isFulfilled = true;
        };
        const rejector = reason => {
          !isFulfilled && !signal.aborted && reject(reason);
          isFulfilled = true;
        };
        const abortHandler = () => {
          signal.removeEventListener('abort', abortHandler);
          const abortEntry = ABORTERS.get(this);
          let isHandled = !!abortEntry.isHandled;
          let parentAbortEntry = abortEntry.parent;
          while (parentAbortEntry) {
            isHandled = isHandled || !!parentAbortEntry.isHandled;
            parentAbortEntry = parentAbortEntry.parent;
          }
          abortEntry.isHandled = true;
          if (!isFulfilled && !isHandled) {
            isFulfilled = true;
            const abortReason = abortEntry.reason;
            reject(new AbortError(abortReason instanceof Error ? abortReason.message : abortReason));
          }
        };
        signal.addEventListener('abort', abortHandler);
        executor(resolver, rejector, aborter, signal);
      });
      this[ABORT] = void 0;
      this[ABORT_SIGNAL] = void 0;
      ABORTERS.set(this, {
        controller: abortController
      });
      this[ABORT] = aborter.bind(null);
      this[ABORT_SIGNAL] = signal;
    }
    _wrapHandler(handler) {
      if (!utils.isFunction(handler)) {
        return handler;
      }
      return result => {
        let handlerResult = handler(result);
        if (handlerResult instanceof AbortablePromise) {
          AbortablePromise.connect(this, handlerResult);
        } else if (handlerResult instanceof Promise) {
          const abortableResult = handlerResult = AbortablePromise.from(handlerResult);
          AbortablePromise.connect(this, abortableResult);
        }
        if (this[ABORT_SIGNAL].aborted) {
          const abortReason = ABORTERS.get(this).reason;
          throw new AbortError(abortReason instanceof Error ? abortReason.message : abortReason);
        }
        return handlerResult;
      };
    }
    then(onFulfilled, onRejected) {
      const child = AbortablePromise.from(super.then(this._wrapHandler(onFulfilled), this._wrapHandler(onRejected)));
      AbortablePromise.connect(this, child);
      return child;
    }
    catch(onRejected) {
      const child = AbortablePromise.from(super.catch(this._wrapHandler(onRejected)));
      AbortablePromise.connect(this, child);
      return child;
    }
    finally(onFinally) {
      const child = AbortablePromise.from(super.finally(this._wrapHandler(onFinally)));
      AbortablePromise.connect(this, child);
      return child;
    }
    /*LWC compiler v7.1.5*/
  }

  class FetchResponse {
    constructor(response, data) {
      this.response = response;
      this.data = data;
    }
  }
  function isFetchResponse(value) {
    return value instanceof FetchResponse;
  }
  function createFetchResponse(response, data) {
    const result = new FetchResponse(response, data);
    Object.freeze(result);
    return result;
  }

  const RESPONSE_TYPES_OPAQUE = ['opaque', 'opaqueredirect'];
  async function defaultHandleResponse(response) {
    const [resp, data] = isFetchResponse(response) ? [response.response, response.data] : [response, response];
    if (resp instanceof Response && !resp.ok && !RESPONSE_TYPES_OPAQUE.includes(resp.type)) {
      throw await data;
    }
    return data;
  }
  function execute(url, requestInit, signal) {
    let effectiveRequestInit = {
      ...requestInit
    };
    delete effectiveRequestInit.interceptRequest;
    delete effectiveRequestInit.interceptResponse;
    let handleResponse = defaultHandleResponse;
    if (requestInit && utils.isFunction(requestInit.interceptResponse)) {
      const {
        interceptResponse
      } = requestInit;
      handleResponse = response => {
        const interceptorResult = interceptResponse(response, url, effectiveRequestInit);
        if (utils.isPromiseLike(interceptorResult)) {
          return Promise.resolve(interceptorResult).then(defaultHandleResponse);
        }
        return defaultHandleResponse(interceptorResult);
      };
    }
    const executeRequest = ({
      url: _url,
      requestInit: _reqInit
    } = {}) => {
      if (_reqInit && typeof _reqInit === 'object') {
        effectiveRequestInit = {
          ..._reqInit,
          signal
        };
        delete effectiveRequestInit.interceptRequest;
        delete effectiveRequestInit.interceptResponse;
      }
      return transport.fetch(_url || url, effectiveRequestInit).then(handleResponse);
    };
    if (requestInit && utils.isFunction(requestInit.interceptRequest)) {
      const {
        interceptRequest
      } = requestInit;
      const interceptorResult = interceptRequest(url, effectiveRequestInit);
      if (utils.isPromiseLike(interceptorResult)) {
        return Promise.resolve(interceptorResult).then(executeRequest);
      }
      return executeRequest(interceptorResult);
    }
    return executeRequest();
  }
  function fetchAbortable(executor) {
    let resolve;
    let reject;
    let abort;
    let signal;
    const mainPromise = new AbortablePromise((_resolve, _reject, _abort, _signal) => {
      resolve = _resolve;
      reject = _reject;
      abort = _abort;
      signal = _signal;
    });
    let isAborted = false;
    signal.addEventListener('abort', () => isAborted = true);
    const fetcher = (requestInfo, requestInit) => {
      const isRequest = requestInfo instanceof Request;
      const init = requestInit && typeof requestInit === 'object' ? {
        ...requestInit,
        signal
      } : {
        signal
      };
      const reqInit = isRequest ? {
        ...requestInfo.clone(),
        ...init
      } : init;
      const url = isRequest ? requestInfo.url : requestInfo;
      if (!isAborted) {
        execute(url, reqInit, signal).then(_r => !isAborted && resolve(_r)).catch(reason => !isAborted && reject(reason));
      }
      return mainPromise;
    };
    executor(fetcher, abort, signal);
    return mainPromise;
  }

  const defaultRequestInterceptor = (url, requestInit) => {
    return {
      url,
      requestInit: {
        method: 'GET',
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'application/json;charset=UTF-8'
        },
        ...(requestInit && typeof requestInit === 'object' ? requestInit : {})
      }
    };
  };
  function createResponseInterceptor(obtainData) {
    return (response, _url, _requestInit) => {
      if (response instanceof Response) {
        const {
          headers,
          status
        } = response;
        const contentType = headers.get('content-type');
        if (typeof contentType === 'string' && contentType.includes('application/json')) {
          const contentLength = headers.has('content-length') && headers.get('transfer-encoding') !== 'chunked' ? Number(headers.get('content-length')) : -1;
          if (status === 204 || contentLength === 0) {
            return null;
          }
          const effectiveData = obtainData(response, _url, _requestInit);
          return createFetchResponse(response, effectiveData);
        }
      }
      return response;
    };
  }
  const defaultResponseInterceptor = createResponseInterceptor(response => response.ok ? response.json() : response);
  function prepareRequestInit(requestInit) {
    const reqInit = requestInit && typeof requestInit === 'object' ? {
      ...requestInit
    } : {};
    if (!utils.isFunction(reqInit.interceptRequest)) {
      reqInit.interceptRequest = defaultRequestInterceptor;
    }
    if (!utils.isFunction(reqInit.interceptResponse)) {
      reqInit.interceptResponse = defaultResponseInterceptor;
    }
    return reqInit;
  }
  function fetchService(executorOrRequestInfo, requestInit) {
    return fetchAbortable((fetch, abort, signal) => {
      if (typeof executorOrRequestInfo === 'function') {
        const fetcher = (reqInfo, reqInit) => fetch(reqInfo, prepareRequestInit(reqInit));
        executorOrRequestInfo(fetcher, abort, signal);
      } else {
        fetch(executorOrRequestInfo, prepareRequestInit(requestInit));
      }
    });
  }

  function verifyType(prop, type = 'string') {
    return prop === null || (type === 'array' ? typeof prop === 'undefined' || Array.isArray(prop) : ['undefined', type].includes(typeof prop));
  }
  function isFetchErrorResponse(value) {
    return value !== null && typeof value === 'object' && Reflect.has(value, 'message') && Reflect.has(value, 'type') && verifyType(value?.message) && verifyType(value?.type) && verifyType(value?.arguments, 'object');
  }
  function isFetchErrorData(value) {
    return value !== null && typeof value === 'object' && Reflect.has(value, 'status') && Reflect.has(value, 'errors') && verifyType(value?.status, 'number') && verifyType(value?.errors, 'array');
  }
  function normalizeArguments(args) {
    if (args) {
      return Reflect.ownKeys(args).reduce((acc, key) => {
        typeof key === 'string' && Reflect.set(acc, key, Reflect.get(args, key));
        return acc;
      }, {});
    }
    return {};
  }
  function toFetchErrorResponse$1({
    message,
    type,
    arguments: args
  }) {
    return {
      message: message ?? '',
      type: type ?? '',
      arguments: normalizeArguments(args)
    };
  }
  function normalizeErrors(value) {
    if (Array.isArray(value)) {
      return value.reduce((acc, element) => {
        if (isFetchErrorResponse(element)) {
          acc.push(toFetchErrorResponse$1(element));
        }
        return acc;
      }, []);
    } else if (isFetchErrorResponse(value)) {
      return [toFetchErrorResponse$1(value)];
    }
    return [];
  }
  function normalizeMessage(errors) {
    return errors.find(error => error.message.length > 0)?.message ?? '';
  }
  function normalizeData(value) {
    if (isFetchErrorData(value)) {
      const {
        status,
        errors
      } = value;
      return {
        status: status ?? null,
        errors: normalizeErrors(errors)
      };
    }
    return {
      status: null,
      errors: normalizeErrors(value)
    };
  }
  class FetchError extends Error {
    constructor(data) {
      super();
      this.name = 'FetchError';
      this.errors = [];
      this.status = null;
      let {
        status,
        errors
      } = normalizeData(data);
      this.status = status;
      this.errors = errors;
      this.message = normalizeMessage(errors);
      Object.defineProperty(this, 'errors', {
        enumerable: true,
        configurable: false,
        get: () => errors,
        set(v) {
          errors = normalizeErrors(v);
          this.message = normalizeMessage(errors);
        }
      });
      Object.defineProperty(this, 'status', {
        enumerable: true,
        configurable: false,
        get: () => status,
        set(v) {
          status = typeof v === 'number' ? v : null;
        }
      });
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(FetchError, {
    fields: ["name", "errors", "status"]
  });
  serializeError.registerErrorConstructor('FetchError', FetchError);

  function isConnectApiErrorResponse(value) {
    function verifyType(prop) {
      return typeof prop === 'string' || typeof prop === 'undefined' || prop === null;
    }
    return value !== null && typeof value === 'object' && Reflect.has(value, 'message') && Reflect.has(value, 'errorCode') && verifyType(value?.message) && verifyType(value?.errorCode);
  }
  function extractArguments(requestInit) {
    function filterStringEntries(it) {
      const acc = {};
      for (const [key, value] of it) {
        if (typeof value === 'string') {
          acc[key] = value;
        }
      }
      return acc;
    }
    if (requestInit && typeof requestInit === 'object' && (Reflect.has(requestInit, 'url') || Reflect.has(requestInit, 'body'))) {
      const {
        url: urlString = '',
        body
      } = requestInit;
      const acc = body instanceof URLSearchParams ? Object.fromEntries(body.entries()) : body instanceof FormData ? filterStringEntries(body.entries()) : {};
      try {
        const {
          searchParams
        } = new URL(urlString);
        return {
          ...acc,
          ...Object.fromEntries(searchParams.entries())
        };
      } catch {
        return acc;
      }
    }
    return {};
  }
  function toFetchErrorResponse({
    message,
    errorCode
  }, requestInit) {
    return {
      type: errorCode ?? '',
      message: message ?? '',
      arguments: extractArguments(requestInit)
    };
  }
  function transformConnectApiErrorResponse(value, requestInit) {
    if (Array.isArray(value)) {
      return value.reduce((acc, element) => {
        if (isConnectApiErrorResponse(element)) {
          acc.push(toFetchErrorResponse(element, requestInit));
        }
        return acc;
      }, []);
    } else if (isConnectApiErrorResponse(value)) {
      return [toFetchErrorResponse(value, requestInit)];
    }
    return [];
  }
  const connectApiResponseInterceptor = createResponseInterceptor((response, url, requestInit) => {
    return response.ok ? response.json() : response.json().then(errors => {
      throw new FetchError({
        status: response.status,
        errors: transformConnectApiErrorResponse(errors, {
          ...requestInit,
          url
        })
      });
    });
  });

  Object.defineProperty(exports, 'composeQueryString', {
    enumerable: true,
    get: function () { return uri.composeQueryString; }
  });
  Object.defineProperty(exports, 'composeUri', {
    enumerable: true,
    get: function () { return uri.composeUri; }
  });
  exports.ABORT = ABORT;
  exports.ABORT_SIGNAL = ABORT_SIGNAL;
  exports.AbortError = AbortError;
  exports.AbortablePromise = AbortablePromise;
  exports.FetchError = FetchError;
  exports.connectApiResponseInterceptor = connectApiResponseInterceptor;
  exports.createFetchResponse = createFetchResponse;
  exports.createResponseInterceptor = createResponseInterceptor;
  exports.defaultRequestInterceptor = defaultRequestInterceptor;
  exports.defaultResponseInterceptor = defaultResponseInterceptor;
  exports.fetchAbortable = fetchAbortable;
  exports.fetchService = fetchService;
  exports.transformConnectApiErrorResponse = transformConnectApiErrorResponse;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/store', ['exports', 'experience/utils', 'experience/utilsInternal', '@luvio/runtime', '@luvio/registry', 'experience/serializeError', 'lwc', 'experience/data'], (function (exports, utils, utilsInternal, runtime, registry, serializeError$1, lwc, data) {

  const INSTANCES = new Map();
  const ACTIONS_TO_INSTANCES = new Map();
  const LOADING_PROMISES = new Map();
  const CONNECTED_ADAPTER_PATHS = {};
  const ADAPTERS_DEBOUNCE = new WeakMap();
  const ADAPTERS_DEBOUNCING = new Map();
  const ADAPTERS_SSR_PERMITTED = new WeakMap();
  const CACHE_TTL = 300;

  const STORE_KEY = 'experience::ɵɵStore';
  const STORE_KEY_META = 'experience::ɵɵMeta';
  const META_KEY_ERRORS = 'ɵɵErrors';
  const commandRuntimeStore = new runtime.InMemoryStore();
  commandRuntimeStore.set(STORE_KEY, {});
  commandRuntimeStore.set(STORE_KEY_META, {});
  let effectiveStore = commandRuntimeStore;
  function getState() {
    return effectiveStore.get(STORE_KEY);
  }
  function getMeta() {
    return effectiveStore.get(STORE_KEY_META);
  }
  function getStateValue(key) {
    return Reflect.get(getState(), key);
  }
  function setStateValue(key, value) {
    const state = getState();
    Reflect.set(state, key, value);
    effectiveStore.set(STORE_KEY, state);
  }
  function getMetaValue(key) {
    return Reflect.get(getMeta(), key);
  }
  function setMetaValue(key, value) {
    const meta = getMeta();
    Reflect.set(meta, key, value);
    effectiveStore.set(STORE_KEY_META, meta);
  }
  function hasErrorProp(storeName, prop, ...props) {
    const path = JSON.stringify([storeName, prop, ...props]);
    const entries = getMeta();
    return Reflect.has(entries, META_KEY_ERRORS) && entries[META_KEY_ERRORS][path] === true;
  }
  function addErrorProp(storeName, prop, ...props) {
    const path = JSON.stringify([storeName, prop, ...props]);
    const entries = getMeta();
    !Reflect.has(entries, META_KEY_ERRORS) && (entries[META_KEY_ERRORS] = {});
    entries[META_KEY_ERRORS][path] = true;
  }
  function deleteErrorProp(storeName, prop, ...props) {
    const path = JSON.stringify([storeName, prop, ...props]);
    const entries = getMeta();
    delete entries[META_KEY_ERRORS]?.[path];
  }
  function set(obj, path, value) {
    path.reduce((acc, key, i) => {
      if (i === path.length - 1) {
        acc[key] = value;
      } else if (!Reflect.has(acc, key)) {
        acc[key] = {};
      } else if (typeof acc[key] === 'object' && acc[key] !== null) {
        acc[key] = {
          ...acc[key]
        };
      }
      return acc[key];
    }, obj);
  }
  function ensureState(store) {
    if (store !== effectiveStore) {
      if (!store.keys().contains(STORE_KEY_META)) {
        store.set(STORE_KEY_META, {});
      }
      const meta = store.get(STORE_KEY_META);
      if (!store.keys().contains(STORE_KEY)) {
        store.set(STORE_KEY, {});
      } else if (Reflect.has(meta, META_KEY_ERRORS)) {
        const state = store.get(STORE_KEY);
        const errors = meta[META_KEY_ERRORS];
        Object.keys(errors).forEach(key => {
          const path = JSON.parse(key);
          if (path.length > 2) {
            set(state, path, {
              data: undefined,
              error: undefined,
              loaded: false,
              loading: false
            });
          } else {
            set(state, path, undefined);
          }
        });
        Object.entries(state).forEach(([key, value]) => {
          state[key] = utilsInternal.readonly(value);
        });
      }
      store.set(STORE_KEY_META, {});
    }
    return store;
  }
  const commandModuleRegistration = {
    id: 'commandModule',
    runtimeDependencies: {
      store: true
    },
    setCommandRuntime: ({
      store
    }) => effectiveStore = ensureState(store)
  };
  registry.register(commandModuleRegistration);

  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const validStoreAdapterKeys = ['data', 'error', 'loaded', 'loading'];
  function loadWithDebounceContext(adapter, debounced) {
    ADAPTERS_DEBOUNCE.set(adapter, debounced);
    const result = adapter.load();
    ADAPTERS_DEBOUNCE.delete(adapter);
    return result;
  }
  function serializeError(ex) {
    const serialized = serializeError$1.serializeError(ex);
    return typeof serialized === 'string' ? serialized : JSON.stringify(serialized);
  }
  function deserializeError(error) {
    const strip = err => {
      if (err.name === 'NonError') {
        err.message = err.message.replace(/^"|"$/g, '');
      }
      return err;
    };
    try {
      return strip(serializeError$1.deserializeError(JSON.parse(error)));
    } catch (e) {
      return strip(serializeError$1.deserializeError(error));
    }
  }
  function assertKeyString(k) {
    const isKey = typeof k === 'string';
    {
      if (!isKey) {
        const message = `invalid type '${typeof k}' for key '${JSON.stringify(k)}'`;
        console.warn(`[store] ${message}`);
        throw new Error(message);
      }
      if (['.', '[', ']'].some(token => k.indexOf(token) !== -1)) {
        const message = `invalid character used in key '${k}'. Forbidden are: .[]`;
        console.warn(`[store] ${message}`);
        throw new Error(message);
      }
    }
    return k;
  }
  function isStoreAdapterEntry(v) {
    return utils.isPlainObject(v) && Object.keys(v).every(key => validStoreAdapterKeys.includes(key)) && (typeof v.error === 'string' || typeof v.error === 'undefined') && typeof v.loaded === 'boolean' && typeof v.loading === 'boolean';
  }
  function isStoreAdapterEntryContainer(v) {
    if (utils.isPlainObject(v)) {
      const keys = Object.keys(v);
      return keys.length > 0 && keys.some(prop => isStoreAdapterEntry(v[prop]));
    }
    return false;
  }
  function unwrapStoreAdapterEntryContainer(container, entryKey) {
    entryKey = typeof entryKey === 'string' ? entryKey : '{}';
    const entry = utils.isPlainObject(container) ? container[entryKey] : undefined;
    const isObj = utils.isPlainObject(entry);
    if (isObj && typeof entry.error === 'string') {
      return deserializeError(entry.error);
    }
    return isObj ? entry.data : undefined;
  }
  function wrapStoreAdapterEntryContainer(value, entryKey) {
    if (isStoreAdapterEntryContainer(value)) {
      return value;
    }
    const defaults = value instanceof Error ? {
      data: undefined,
      error: serializeError(value)
    } : {
      data: value,
      error: undefined
    };
    entryKey = typeof entryKey === 'string' ? entryKey : '{}';
    return {
      [entryKey]: {
        ...defaults,
        loaded: true,
        loading: false
      }
    };
  }
  function wrap(delegate, value, key, entryKey) {
    const path = `${delegate.name}.${assertKeyString(key)}`;
    const currentValue = delegate.get(key);
    const deepMergeValue = (...objects) => {
      return objects.reduce((acc, obj) => {
        const isContainer = isStoreAdapterEntryContainer(obj);
        Object.keys(obj).forEach(k => {
          const pVal = acc[k];
          const oVal = obj[k];
          if (isContainer && utils.isPlainObject(pVal) && utils.isPlainObject(oVal)) {
            acc[k] = deepMergeValue(pVal, oVal);
          } else {
            acc[k] = oVal;
          }
        });
        return acc;
      }, {});
    };
    const mergeValue = container => {
      return utils.isPlainObject(currentValue) ? deepMergeValue(utilsInternal.deepClone(currentValue).value, container) : container;
    };
    if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, path) && CONNECTED_ADAPTER_PATHS[path] > 0 || isStoreAdapterEntryContainer(currentValue)) {
      return mergeValue(wrapStoreAdapterEntryContainer(value, entryKey));
    }
    return value;
  }
  function wrapAll(delegate, value, key) {
    const path = `${delegate.name}.${assertKeyString(key)}`;
    const currentValue = delegate.get(key);
    if (isStoreAdapterEntryContainer(currentValue)) {
      return Object.keys(currentValue).reduce((acc, k) => {
        const container = wrapStoreAdapterEntryContainer(value, k);
        acc[k] = {
          ...currentValue[k],
          ...container[k]
        };
        return acc;
      }, {});
    } else if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, path) && CONNECTED_ADAPTER_PATHS[path] > 0) {
      return Object.keys(CONNECTED_ADAPTER_PATHS).reduce((acc, k) => {
        if (k.indexOf(`${path}.`) !== -1) {
          const ek = k.substring(k.lastIndexOf('.') + 1);
          const container = wrapStoreAdapterEntryContainer(value, ek);
          acc[ek] = container[ek];
        }
        return acc;
      }, {});
    }
    return value;
  }
  function obtainLocalState(delegate, entryKey, asPlugin = false) {
    const isAdapterMode = Array.isArray(entryKey);
    const adapterEntryKey = entryKey?.at?.(1);
    function unwrap(key, value) {
      const path = `${delegate.name}.${assertKeyString(key)}`;
      if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, path) && CONNECTED_ADAPTER_PATHS[path] > 0 || isStoreAdapterEntryContainer(value)) {
        return utils.isPlainObject(value) ? unwrapStoreAdapterEntryContainer(value, adapterEntryKey) : undefined;
      }
      return value;
    }
    class LocalState {
      get name() {
        return delegate.name;
      }
      get size() {
        if (isAdapterMode && utils.isPlainObject(delegate.container)) {
          return Object.entries(delegate.container).reduce((acc, [k, v]) => {
            const p = `${delegate.name}.${k}`;
            if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, p) && CONNECTED_ADAPTER_PATHS[p] > 0 || isStoreAdapterEntryContainer(v)) {
              if (utils.isPlainObject(v) && hasOwnProperty.call(v, entryKey[1])) {
                acc++;
              }
            } else {
              acc++;
            }
            return acc;
          }, 0);
        }
        return delegate.size;
      }
      has(key) {
        const result = delegate.has(key);
        if (isAdapterMode) {
          const value = delegate.get(key);
          const path = `${delegate.name}.${assertKeyString(key)}`;
          if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, path) && CONNECTED_ADAPTER_PATHS[path] > 0 || isStoreAdapterEntryContainer(value)) {
            return utils.isPlainObject(value) && hasOwnProperty.call(value, entryKey[1]);
          }
        }
        return result;
      }
      get(key) {
        const value = delegate.get(key);
        return isAdapterMode ? unwrap(key, value) : value;
      }
      set(key, data) {
        const effectiveValue = isAdapterMode ? wrap(delegate, data, key, adapterEntryKey) : wrapAll(delegate, data, key);
        delegate.set(key, effectiveValue);
      }
      delete(key) {
        if (isAdapterMode && isStoreAdapterEntryContainer(delegate.get(key))) {
          const currentValue = delegate.get(key);
          const hasProp = hasOwnProperty.call(currentValue, entryKey[1]);
          if (hasProp) {
            const effectiveValue = {
              ...currentValue
            };
            delete effectiveValue[entryKey[1]];
            if (Object.keys(effectiveValue).length === 0) {
              delegate.delete(key);
            } else {
              delegate.set(key, effectiveValue);
            }
          }
          return hasProp;
        }
        return delegate.delete(key);
      }
      clear() {
        delegate.clear();
      }
      update(key, updater) {
        const effectiveUpdater = value => {
          const effectiveValue = isAdapterMode ? unwrap(key, value) : value;
          const updatedValue = updater(effectiveValue);
          return isAdapterMode ? wrap(delegate, updatedValue, key, adapterEntryKey) : wrapAll(delegate, updatedValue, key);
        };
        return delegate.update(key, effectiveUpdater);
      }
      dispatch(type, payload) {
        return delegate.dispatch(type, payload);
      }
    }
    class LocalPluginState extends LocalState {
      subscribe(key, fnOrSubscriber) {
        return delegate.subscribe(key, fnOrSubscriber);
      }
      subscribeAction(type, fnOrSubscriber) {
        return utils.isFunction(fnOrSubscriber) ? delegate.subscribeAction(type, fnOrSubscriber) : delegate.subscribeAction(type, fnOrSubscriber);
      }
      /*LWC compiler v7.1.5*/
    }
    return asPlugin ? new LocalPluginState() : new LocalState();
  }
  function obtainLocalAdapter(delegate) {
    class LocalAdapter {
      get config() {
        return delegate.config;
      }
      get() {
        return delegate.get();
      }
      load() {
        return loadWithDebounceContext(delegate, true);
      }
      subscribe(fnOrSubscriber) {
        return utils.isFunction(fnOrSubscriber) ? delegate.subscribe(fnOrSubscriber) : delegate.subscribe(fnOrSubscriber);
      }
      subscribeAction(type, fnOrSubscriber) {
        return utils.isFunction(fnOrSubscriber) ? delegate.subscribeAction(type, fnOrSubscriber) : delegate.subscribeAction(type, fnOrSubscriber);
      }
      subscribeLoad(fnOrSubscriber) {
        return utils.isFunction(fnOrSubscriber) ? delegate.subscribeLoad(fnOrSubscriber) : delegate.subscribeLoad(fnOrSubscriber);
      }
    }
    return new LocalAdapter();
  }
  function subscribe(key, subscriber, subs) {
    !subs[key] && (subs[key] = []);
    subs[key].push(subscriber);
    return {
      unsubscribe() {
        const s = subs[key];
        const i = s?.indexOf(subscriber);
        i > -1 && s.splice(i, 1);
      }
    };
  }
  function notifySubscriber(subscriber, category, localState, stage, type, payload, error) {
    const fn = subscriber[stage];
    if (utils.isFunction(fn)) {
      try {
        const action = {
          type,
          payload
        };
        stage === 'error' ? fn(action, localState, error) : fn(action, localState);
      } catch (e) {
        {
          console.warn(`[store] error in ${stage} ${category} subscribers:`);
          console.warn(e);
        }
      }
    }
  }
  function notifySubscribers(subscribers, category, localState, stage, type, payload, error) {
    if (subscribers[type]) {
      const subs = subscribers[type];
      for (const sub of subs) {
        if (stage === 'error') {
          notifySubscriber(sub, category, localState, stage, type, payload, error);
        } else {
          notifySubscriber(sub, category, localState, stage, type, payload);
        }
      }
    }
  }
  function patchSubscriber(subscriber, localStateGetter, actionHandler = action => action) {
    function patchSubscriberFunction(subscriberFn) {
      return (action, state, error) => {
        error ? subscriberFn(actionHandler(action), localStateGetter(), error) : subscriberFn(actionHandler(action), localStateGetter());
      };
    }
    return Object.entries(subscriber).reduce((acc, [key, value]) => {
      acc[key] = patchSubscriberFunction(value);
      return acc;
    }, {});
  }
  function createStoreAdapter(AdapterClass, config, ...parameters) {
    const params = arguments.length > 2 ? parameters : [];
    const instance = new AdapterClass(...params);
    ADAPTERS_SSR_PERMITTED.set(instance, true);
    instance.update(utils.isPlainObject(config) ? config : {});
    instance.connect();
    return instance;
  }
  function getStoreAdapterValue(AdapterClass, config, ...parameters) {
    const instance = createStoreAdapter(AdapterClass, config, ...parameters);
    return instance.get().then(entry => entry.data).finally(() => {
      instance.disconnect();
    });
  }
  function distributeStoreAdapterValue(AdapterClass, value, ...parameters) {
    const instance = createStoreAdapter(AdapterClass, {}, ...parameters);
    instance.disconnect();
    const store = instance['store'];
    const sliceKey = instance['key'];
    const slice = Reflect.get(store.container, sliceKey);
    const path = `${store.name}.${assertKeyString(sliceKey)}`;
    if (hasOwnProperty.call(CONNECTED_ADAPTER_PATHS, path) && CONNECTED_ADAPTER_PATHS[path] > 0 || isStoreAdapterEntryContainer(slice)) {
      store.set(sliceKey, wrapAll(store, value, sliceKey));
    } else {
      store.set(sliceKey, value);
    }
  }
  function setStoreAdapterValue(AdapterClass, value, config, ...parameters) {
    const instance = createStoreAdapter(AdapterClass, config, ...parameters);
    const store = instance['store'];
    const sliceKey = instance['key'];
    instance.disconnect();
    store.set(sliceKey, wrap(store, value, sliceKey, instance['entryKey']));
  }
  function deleteStoreAdapterValue(AdapterClass, config, ...parameters) {
    const instance = createStoreAdapter(AdapterClass, config, ...parameters);
    const state = obtainLocalState(instance['store'], [instance['key'], instance['entryKey'], instance['uuid']]);
    instance.disconnect();
    if (!instance.options?.discard && !instance['store'].options.discard) {
      state.delete(instance['key']);
    }
  }
  function toEntryKey(config, context) {
    const orderedContext = utilsInternal.deepSort(context ?? {}).value;
    const orderedConfig = utilsInternal.deepSort(config ?? {}).value;
    const contextKey = JSON.stringify(orderedContext, utilsInternal.circularRefReplacer());
    const configKey = JSON.stringify(orderedConfig, utilsInternal.circularRefReplacer());
    return `${contextKey}:${configKey}`;
  }
  function hasSubscribers(store, key, config, context) {
    const pathRoot = `${store.name}.${key}`;
    if (utils.isPlainObject(config) || utils.isPlainObject(context)) {
      const entryKey = toEntryKey(config, context);
      const pathEntry = `${pathRoot}.${entryKey}`;
      return Reflect.has(CONNECTED_ADAPTER_PATHS, pathEntry) && Number(CONNECTED_ADAPTER_PATHS[pathEntry]) > 0;
    }
    return Reflect.has(CONNECTED_ADAPTER_PATHS, pathRoot) && Number(CONNECTED_ADAPTER_PATHS[pathRoot]) > 0 || Reflect.has(store['subscribers'], key) && store['subscribers']?.[key]?.length > 0;
  }

  class StoreActionError extends Error {
    constructor(error) {
      super(typeof error === 'string' ? error : error instanceof Error ? error.message : undefined);
      this.name = 'StoreActionError';
      this.error = error;
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(StoreActionError, {
    fields: ["name"]
  });
  serializeError$1.registerErrorConstructor('StoreActionError', StoreActionError);

  class Store {
    constructor(name, options = Object.freeze({})) {
      this.actions = {};
      this.actionSubscribers = {};
      this.subscribers = {};
      this.localState = obtainLocalState(this);
      this.name = name;
      this.options = options;
      if (INSTANCES.has(name)) {
        return INSTANCES.get(name);
      }
      INSTANCES.set(name, this);
      if (Reflect.has(options, 'state')) {
        this._updateContainer(utils.isFunction(options.state) ? options.state() : options.state);
      } else if (!utils.isPlainObject(getStateValue(this.name))) {
        setStateValue(this.name, {});
      }
      if (utils.isPlainObject(options.actions)) {
        for (const [type, action] of Object.entries(options.actions)) {
          if (utils.isPlainObject(action) && typeof action.namespace === 'string' && utils.isFunction(action.handler)) {
            const {
              namespace,
              handler
            } = action;
            const namespacedAction = `${namespace}/${type}`;
            if (ACTIONS_TO_INSTANCES.has(namespacedAction)) {
              throw new TypeError(`[store] handler already registered for action type in namespace '${namespace}': ${type}`);
            }
            ACTIONS_TO_INSTANCES.set(namespacedAction, this);
            this._registerAction(type, handler);
          } else if (utils.isFunction(action)) {
            this._registerAction(type, action);
          } else {
            throw new TypeError(`[store] invalid action configuration for store '${name}': ${type}`);
          }
        }
      }
      const pluginState = obtainLocalState(this, undefined, true);
      if (Array.isArray(options.plugins)) {
        for (const plugin of options.plugins) {
          plugin(pluginState);
        }
      }
    }
    get size() {
      return Object.keys(this.container).length;
    }
    get container() {
      return getStateValue(this.name);
    }
    _updateContainer(value) {
      const val = utilsInternal.readonly(value);
      setStateValue(this.name, utils.isPlainObject(val) ? val : {});
    }
    _has(key) {
      return Reflect.has(this.container, key);
    }
    _get(key) {
      const container = this.container;
      const data = Reflect.has(container, key) ? container[key] : undefined;
      if (hasErrorProp(this.name, key)) {
        return deserializeError(data);
      }
      return data;
    }
    _delete(key) {
      if (this._has(key)) {
        this._notify(key, () => {
          deleteErrorProp(this.name, key);
          const {
            [key]: _,
            ...newContainer
          } = this.container;
          this._updateContainer(newContainer);
        });
        return true;
      }
      return false;
    }
    _update(key, data) {
      this._notify(key, () => this._set(key, data));
    }
    _set(key, data) {
      const isError = data instanceof Error;
      const value = isError ? serializeError(data) : data;
      if (isError) {
        addErrorProp(this.name, key);
      } else {
        deleteErrorProp(this.name, key);
      }
      this._updateContainer({
        ...this.container,
        [key]: value
      });
    }
    _notify(key, handler) {
      const oldValue = this._get(key);
      this._notifyMutationSubscribers('before', key, oldValue instanceof Error ? undefined : oldValue);
      utils.isFunction(handler) && handler();
      const value = this._get(key);
      if (value instanceof Error) {
        this._notifyMutationSubscribers('error', key, undefined, value);
      } else {
        this._notifyMutationSubscribers('after', key, value);
      }
    }
    _registerAction(type, handler) {
      this.actions[type] = payload => {
        try {
          const res = handler.call(null, this.localState, payload);
          return Promise.resolve(res);
        } catch (e) {
          return Promise.reject(e);
        }
      };
    }
    _notifyActionSubscribers(stage, type, payload, error) {
      notifySubscribers(this.actionSubscribers, 'action', this.localState, stage, type, payload, error);
    }
    _notifyMutationSubscribers(stage, key, value, error) {
      notifySubscribers(this.subscribers, 'mutation', this.localState, stage, key, value, error);
    }
    _dispatchAction(type, handler, payload) {
      const effectivePayload = utilsInternal.readonly(payload);
      this._notifyActionSubscribers('before', type, effectivePayload);
      return new Promise((resolve, reject) => {
        handler(effectivePayload).then(res => {
          this._notifyActionSubscribers('after', type, res);
          resolve(res);
        }).catch(error => {
          const err = error instanceof Error ? error : new StoreActionError(error);
          this._notifyActionSubscribers('error', type, effectivePayload, err);
          reject(err);
        });
      });
    }
    has(key) {
      return this._has(assertKeyString(key));
    }
    get(key) {
      return this._get(assertKeyString(key));
    }
    set(key, data) {
      this._update(assertKeyString(key), data);
    }
    delete(key) {
      return this._delete(assertKeyString(key));
    }
    clear() {
      for (const key of Object.keys(this.container)) {
        this._delete(key);
      }
    }
    update(key, updater) {
      if (utils.isFunction(updater)) {
        const k = assertKeyString(key);
        this._update(k, updater(this._get(k)));
      }
    }
    dispatch(type, payload) {
      const handler = this.actions[type];
      if (utils.isFunction(handler)) {
        return this._dispatchAction(type, handler, payload);
      }
      if (type.includes('/') && ACTIONS_TO_INSTANCES.has(type)) {
        const effectiveType = type.substring(type.indexOf('/') + 1);
        const responsibleStore = ACTIONS_TO_INSTANCES.get(type);
        return responsibleStore.dispatch(effectiveType, payload);
      }
      const message = `unknown action type: ${type}`;
      {
        console.warn(`[store] ${message}`);
      }
      return Promise.reject(new TypeError(message));
    }
    subscribe(key, fnOrSubscriber) {
      const toSubscriber = input => typeof input === 'function' ? {
        after: input,
        error: input
      } : input;
      const k = assertKeyString(key);
      const subscriber = toSubscriber(fnOrSubscriber);
      const subscribers = this.subscribers;
      const subscription = subscribe(k, subscriber, subscribers);
      const discard = typeof window !== 'undefined' && this.options?.discard === true;
      const effectiveSubscription = {
        unsubscribe: () => {
          subscription.unsubscribe();
          if (discard && (!Reflect.has(subscribers, k) || subscribers[k].length === 0)) {
            delete subscribers[k];
            this._delete(k);
          }
        }
      };
      if (this._has(k)) {
        const v = this._get(k);
        v instanceof Error ? notifySubscriber(subscriber, 'mutation', this.localState, 'error', k, undefined, v) : notifySubscriber(subscriber, 'mutation', this.localState, 'after', k, v);
      }
      return effectiveSubscription;
    }
    subscribeAction(type, fnOrSubscriber) {
      const subscriber = typeof fnOrSubscriber === 'function' ? {
        after: fnOrSubscriber,
        error: fnOrSubscriber
      } : fnOrSubscriber;
      if (type.includes('/') && ACTIONS_TO_INSTANCES.has(type)) {
        const effectiveType = type.substring(type.indexOf('/') + 1);
        const responsibleStore = ACTIONS_TO_INSTANCES.get(type);
        return responsibleStore.subscribeAction(effectiveType, fnOrSubscriber);
      }
      return subscribe(type, subscriber, this.actionSubscribers);
    }
  }

  const defaultConfig = Object.freeze({});
  function obtainLoader(options) {
    const {
      loader
    } = options || {};
    const isObj = utils.isPlainObject(loader);
    return {
      handler: !isObj && utils.isFunction(loader) ? loader : isObj && utils.isFunction(loader.handler) ? loader.handler : undefined,
      abortable: isObj && loader.abortable === true
    };
  }
  function empty(loading = false) {
    return {
      data: undefined,
      error: undefined,
      loaded: false,
      loading
    };
  }
  function createLooseSubscriber(subscriber, subs, activeUnsub, key) {
    const entry = activeUnsub ? {
      key,
      subscriber,
      unsubscribable: activeUnsub
    } : {
      key,
      subscriber
    };
    subs.push(entry);
    return {
      unsubscribe: () => {
        entry.unsubscribable?.unsubscribe();
        const s = subs;
        const i = s.indexOf(entry);
        i > -1 && s.splice(i, 1);
      }
    };
  }
  function disarmLooseSubscribers(rawSubs) {
    for (const entry of rawSubs) {
      delete entry.unsubscribable;
    }
  }
  function obtainAdapterControlledPath(store, key, entryKey) {
    const rootPath = `${store.name}.${key}`;
    return entryKey ? `${rootPath}.${entryKey}` : rootPath;
  }
  function updateAdapterControlledPathsCounter(store, key, entryKey, update = 1) {
    const pathRoot = obtainAdapterControlledPath(store, key);
    const pathEntry = `${pathRoot}.${entryKey}`;
    [pathRoot, pathEntry].forEach(path => {
      const count = CONNECTED_ADAPTER_PATHS[path];
      const newCount = (utils.isInteger(count) ? count : 0) + update;
      if (newCount > 0) {
        CONNECTED_ADAPTER_PATHS[path] = newCount;
      } else {
        delete CONNECTED_ADAPTER_PATHS[path];
      }
    });
  }
  function ensureEntry(entry) {
    return isStoreAdapterEntry(entry) ? entry : empty();
  }
  class StoreAdapter {
    get config() {
      return this._config || defaultConfig;
    }
    constructor(dataCallback, store, key, options) {
      this.uuid = utilsInternal.uuidv4();
      this.connectors = [];
      this.rawMutationSubscribers = [];
      this.rawActionSubscribers = [];
      this.rawLoadSubscribers = [];
      this.loadSubscribers = {};
      this.activeSubscriptions = [];
      this.localState = void 0;
      this.isConnected = false;
      this.isSubscribed = false;
      this._config = void 0;
      this._context = void 0;
      this.entryKey = void 0;
      this.lastCallbackEntry = void 0;
      this.dataCallback = dataCallback;
      this.store = store;
      this.key = key;
      this.options = options;
      if (options && Array.isArray(options.connectors)) {
        for (const connector of options.connectors) {
          if (utils.isPlainObject(connector)) {
            this.connectors.push(connector);
          } else if (utils.isFunction(connector)) {
            this.connectors.push({
              connect: connector
            });
          }
        }
      }
    }
    get loadingPromises() {
      return LOADING_PROMISES.get(this.store.name);
    }
    _notifyConnectors(stage) {
      for (const connector of this.connectors) {
        if (utils.isFunction(connector[stage])) {
          connector[stage](obtainLocalAdapter(this), {
            type: this.key,
            payload: this.config
          }, this.localState);
        }
      }
    }
    _notifyLoadSubscribers(stage, error) {
      const {
        data
      } = this._read();
      notifySubscribers(this.loadSubscribers, 'load', this.localState, stage, this.key, data, error);
    }
    _obtainLoadingPromiseKey() {
      return `${assertKeyString(this.key)}:${this.entryKey}`;
    }
    _obtainRawEntryContainer() {
      return this.store.get(this.key);
    }
    _obtainEntryContainer() {
      const entry = this._obtainRawEntryContainer();
      return utils.isPlainObject(entry) ? {
        ...entry
      } : {};
    }
    _obtainEntry(entry) {
      const e = utils.isPlainObject(entry) ? entry : this._obtainEntryContainer();
      return e?.[this.entryKey];
    }
    _read(entry) {
      return ensureEntry(entry || this._obtainEntry());
    }
    _writeContainer(container) {
      this.store.set(this.key, container);
    }
    _write(value, entryKey = this.entryKey) {
      const container = this._obtainEntryContainer();
      container[entryKey] = value;
      this._updateMeta('w', entryKey);
      this._writeContainer(container);
    }
    _updateMeta(mode, entryKey = this.entryKey) {
      const metaKey = `${this.store.name}:${assertKeyString(this.key)}`;
      const metaValue = getMetaValue(metaKey) ?? {};
      if (mode === 'd') {
        Reflect.deleteProperty(metaValue, entryKey);
      } else {
        Reflect.set(metaValue, entryKey, performance.now() + performance.timeOrigin);
      }
      setMetaValue(metaKey, metaValue);
    }
    _callback(value) {
      if (this.isConnected && this.dataCallback && !utilsInternal.deepEqual(value, this.lastCallbackEntry).value) {
        this.lastCallbackEntry = value;
        const {
          error
        } = value;
        const cbVal = {
          ...value
        };
        cbVal.error = typeof error === 'string' ? deserializeError(error) : undefined;
        utilsInternal.readonly(cbVal);
        this.dataCallback.call(null, cbVal);
      }
    }
    _removeLoadingPromise(loadingPromiseKey) {
      const loadingPromises = this.loadingPromises;
      const loadingPromise = loadingPromises?.get(loadingPromiseKey);
      loadingPromises?.delete(loadingPromiseKey);
      utils.clearDebounceTimeout(loadingPromise);
      utils.clearDebounceTimeout(ADAPTERS_DEBOUNCING.get(loadingPromiseKey));
    }
    _unsubscribe() {
      if (this.isSubscribed) {
        this.isSubscribed = false;
        updateAdapterControlledPathsCounter(this.store, this.key, this.entryKey, -1);
        const discard = typeof window !== 'undefined' && (this.options?.discard || this.store.options.discard) === true;
        if (discard && utils.isPlainObject(this._obtainRawEntryContainer())) {
          const entryKeyPath = obtainAdapterControlledPath(this.store, this.key, this.entryKey);
          if (!Reflect.has(CONNECTED_ADAPTER_PATHS, entryKeyPath)) {
            const container = this._obtainEntryContainer();
            delete container[this.entryKey];
            if (Object.keys(container).length === 0) {
              const metaKey = `${this.store.name}:${assertKeyString(this.key)}`;
              setMetaValue(metaKey, {});
              this.store.delete(this.key);
            } else {
              this._updateMeta('d');
              this._writeContainer(container);
            }
          }
        }
        this._notifyConnectors('disconnect');
      }
      for (const sub of this.activeSubscriptions) {
        sub.unsubscribe();
      }
      this.activeSubscriptions.splice(0, this.activeSubscriptions.length);
      disarmLooseSubscribers(this.rawMutationSubscribers);
      disarmLooseSubscribers(this.rawActionSubscribers);
      disarmLooseSubscribers(this.rawLoadSubscribers);
      for (const key of Object.keys(this.loadSubscribers)) {
        delete this.loadSubscribers[key];
      }
      delete this.lastCallbackEntry;
    }
    _subscribe() {
      if (!this.isConnected || !this._config) {
        return;
      }
      this._unsubscribe();
      const comparedEntryKey = toEntryKey(this._config, this._context);
      if (this.entryKey !== comparedEntryKey) {
        this.entryKey = comparedEntryKey;
        this.localState = obtainLocalState(this.store, [this.key, this.entryKey, this.uuid]);
        const initialContainer = this._obtainRawEntryContainer();
        if (typeof initialContainer !== 'undefined' && !isStoreAdapterEntryContainer(initialContainer)) {
          const transformedContainer = wrapStoreAdapterEntryContainer(initialContainer, this.entryKey);
          {
            const entryRootPath = obtainAdapterControlledPath(this.store, this.key);
            const entryKeyPath = `${entryRootPath}.${this.entryKey}`;
            console.warn(`[store-adapter] entry for path '${entryKeyPath}' is connected to a store adapter, yet the data doesn't have the required shape.`);
            console.warn(`[store-adapter] going to transform data:`, initialContainer);
          }
          Object.keys(transformedContainer).forEach(entryKey => this._updateMeta('w', entryKey));
          this._writeContainer(transformedContainer);
        }
      }
      updateAdapterControlledPathsCounter(this.store, this.key, this.entryKey);
      if (!LOADING_PROMISES.has(this.store.name)) {
        LOADING_PROMISES.set(this.store.name, new Map());
      }
      this._notifyConnectors('connect');
      for (const entry of this.rawLoadSubscribers) {
        const activeUnsub = subscribe(this.key, entry.subscriber, this.loadSubscribers);
        this.activeSubscriptions.push(activeUnsub);
        entry.unsubscribable = activeUnsub;
      }
      this.isSubscribed = true;
      const mutationHandler = () => {
        let oldPayload;
        const beforeHandler = ({
          payload
        }) => {
          oldPayload = payload;
        };
        const afterHandler = ({
          payload
        }) => {
          if (this.entryKey && (utils.isPlainObject(oldPayload) && Reflect.has(oldPayload, this.entryKey) || utils.isPlainObject(payload) && Reflect.has(payload, this.entryKey))) {
            const newEntry = this._obtainEntry(payload);
            this._isValid(newEntry) && this._callback(this._read(newEntry));
          }
        };
        return {
          before: beforeHandler,
          after: afterHandler,
          error: afterHandler
        };
      };
      this.activeSubscriptions.push(this.store.subscribe(this.key, mutationHandler()));
      if (!obtainLoader(this.options).handler || typeof window === 'undefined' && !ADAPTERS_SSR_PERMITTED.get(this)) {
        this._callback(this._read());
      } else {
        this._getAsync(this._read());
      }
      for (const entry of this.rawMutationSubscribers) {
        const activeUnsub = this.store.subscribe(this.key, entry.subscriber);
        this.activeSubscriptions.push(activeUnsub);
        entry.unsubscribable = activeUnsub;
      }
      for (const entry of this.rawActionSubscribers) {
        const activeUnsub = this.store.subscribeAction(entry.key, entry.subscriber);
        this.activeSubscriptions.push(activeUnsub);
        entry.unsubscribable = activeUnsub;
      }
    }
    _getAsync(entry) {
      const loadingPromiseKey = this._obtainLoadingPromiseKey();
      const loadingPromise = this.loadingPromises?.get(loadingPromiseKey);
      const hasLoadingPromise = utils.isPromiseLike(loadingPromise);
      if (hasLoadingPromise) {
        return loadingPromise;
      } else if (!entry.loaded && !entry.loading) {
        return loadWithDebounceContext(this, false);
      } else if (entry.loading && !hasLoadingPromise) {
        return loadWithDebounceContext(this, false);
      }
      if (!this._isValid(entry)) {
        return loadWithDebounceContext(this, false);
      }
      return Promise.resolve(utilsInternal.readonly(entry));
    }
    _isValid(entry) {
      if (this.options && utils.isFunction(this.options.validator)) {
        try {
          if (!this.options.validator({
            type: this.key,
            payload: utilsInternal.readonly(entry)
          }, obtainLocalAdapter(this), this.localState)) {
            return false;
          }
        } catch {
          // Intentionally empty
        }
      }
      const metaKey = `${this.store.name}:${assertKeyString(this.key)}`;
      const lastUpdated = getMetaValue(metaKey)?.[this.entryKey];
      if (typeof lastUpdated === 'number') {
        const ttl = typeof this.options?.cache?.ttl === 'number' && !Number.isNaN(this.options.cache.ttl) && this.options.cache.ttl >= -1 ? this.options?.cache?.ttl : CACHE_TTL;
        if (ttl === -1) {
          return true;
        }
        const now = performance.now();
        const then = lastUpdated - performance.timeOrigin;
        const diff = now - then;
        return ttl * 1000 >= diff;
      }
      return true;
    }
    _load(loadHandler, loadingPromiseKey) {
      this._notifyLoadSubscribers('before');
      const {
        name: storeName
      } = this.store;
      try {
        const shouldDebounce = ADAPTERS_DEBOUNCE.get(this) !== false;
        const effectiveLoadHandler = shouldDebounce ? utils.debounce(loadHandler) : loadHandler;
        const result = effectiveLoadHandler({
          type: this.key,
          payload: this._config
        }, this.localState);
        if (utils.isPromiseLike(result)) {
          shouldDebounce && ADAPTERS_DEBOUNCING.set(loadingPromiseKey, result);
          const abortableResultPromise = data.AbortablePromise.from(result);
          const loadingPromise = abortableResultPromise.then(data => {
            const currentLoadingPromiseKey = this._obtainLoadingPromiseKey();
            const currentLoadingPromise = this.loadingPromises?.get(currentLoadingPromiseKey);
            if (currentLoadingPromiseKey !== loadingPromiseKey) {
              ADAPTERS_DEBOUNCING.delete(loadingPromiseKey);
              this._removeLoadingPromise(loadingPromiseKey);
              const oldEntryKey = loadingPromiseKey.substring(loadingPromiseKey.indexOf(':') + 1);
              deleteErrorProp(storeName, this.key, oldEntryKey);
              this._write({
                data,
                error: undefined,
                loaded: true,
                loading: false
              }, oldEntryKey);
            } else if (currentLoadingPromise && currentLoadingPromise === loadingPromise) {
              ADAPTERS_DEBOUNCING.delete(currentLoadingPromiseKey);
              this._removeLoadingPromise(currentLoadingPromiseKey);
              deleteErrorProp(storeName, this.key, this.entryKey);
              this._write({
                data,
                error: undefined,
                loaded: true,
                loading: false
              });
              this._notifyLoadSubscribers('after');
            }
            return utilsInternal.readonly(this._read());
          }, ex => {
            const currentLoadingPromiseKey = this._obtainLoadingPromiseKey();
            const currentLoadingPromise = this.loadingPromises?.get(currentLoadingPromiseKey);
            if (currentLoadingPromiseKey !== loadingPromiseKey) {
              ADAPTERS_DEBOUNCING.delete(loadingPromiseKey);
              this._removeLoadingPromise(loadingPromiseKey);
              const oldEntryKey = loadingPromiseKey.substring(loadingPromiseKey.indexOf(':') + 1);
              if (ex instanceof data.AbortError) {
                deleteErrorProp(storeName, this.key, oldEntryKey);
                const container = this._obtainEntryContainer();
                this._write({
                  ...ensureEntry(container?.[oldEntryKey]),
                  loading: false
                }, oldEntryKey);
              } else {
                addErrorProp(storeName, this.key, oldEntryKey);
                this._write({
                  data: undefined,
                  error: serializeError(ex),
                  loaded: true,
                  loading: false
                }, oldEntryKey);
              }
            } else if (currentLoadingPromise && currentLoadingPromise === loadingPromise) {
              ADAPTERS_DEBOUNCING.delete(currentLoadingPromiseKey);
              this._removeLoadingPromise(currentLoadingPromiseKey);
              if (ex instanceof data.AbortError) {
                deleteErrorProp(storeName, this.key, this.entryKey);
                this._write({
                  ...this._read(),
                  loading: false
                });
                this._notifyLoadSubscribers('after');
              } else {
                addErrorProp(storeName, this.key, this.entryKey);
                this._write({
                  data: undefined,
                  error: serializeError(ex),
                  loaded: true,
                  loading: false
                });
                this._notifyLoadSubscribers('error', ex);
              }
            }
            return utilsInternal.readonly(this._read());
          });
          this.loadingPromises?.set(loadingPromiseKey, loadingPromise);
          this._write({
            ...this._read(),
            loading: true
          });
          return loadingPromise;
        }
        deleteErrorProp(storeName, this.key, this.entryKey);
        this._write({
          data: result,
          error: undefined,
          loaded: true,
          loading: false
        });
        this._notifyLoadSubscribers('after');
      } catch (ex) {
        if (ex instanceof data.AbortError) {
          deleteErrorProp(storeName, this.key, this.entryKey);
          this._write({
            ...this._read(),
            loading: false
          });
          this._notifyLoadSubscribers('after');
        } else {
          addErrorProp(storeName, this.key, this.entryKey);
          const error = serializeError(ex);
          this._write({
            data: undefined,
            error,
            loaded: true,
            loading: false
          });
          this._notifyLoadSubscribers('error', ex);
        }
      }
      ADAPTERS_DEBOUNCING.delete(loadingPromiseKey);
      return Promise.resolve(utilsInternal.readonly(this._read()));
    }
    update(config, context) {
      this._config = utilsInternal.readonly(config);
      this._context = utilsInternal.readonly(context ?? {});
      this._subscribe();
    }
    connect() {
      if (!this.isConnected) {
        ADAPTERS_SSR_PERMITTED.has(this) && ADAPTERS_SSR_PERMITTED.set(this, true);
        this.isConnected = true;
        this._subscribe();
      }
    }
    disconnect() {
      if (this.isConnected) {
        ADAPTERS_SSR_PERMITTED.has(this) && ADAPTERS_SSR_PERMITTED.set(this, false);
        this.isConnected = false;
        this._unsubscribe();
      }
    }
    get() {
      const promise = this._getAsync(this._read());
      return promise.then(entry => {
        if (typeof entry.error === 'string') {
          throw deserializeError(entry.error);
        }
        return entry;
      });
    }
    load() {
      const loaderConfig = obtainLoader(this.options);
      if (!this.isSubscribed || !loaderConfig.handler) {
        return Promise.resolve(utilsInternal.readonly(this._read()));
      }
      const currentLoadingPromiseKey = this._obtainLoadingPromiseKey();
      const currentLoadingPromise = this.loadingPromises?.get(currentLoadingPromiseKey);
      if (utils.isPromiseLike(currentLoadingPromise) && (utils.extendDebouncedTimeout(currentLoadingPromise) || utils.extendDebouncedTimeout(ADAPTERS_DEBOUNCING.get(currentLoadingPromiseKey)))) {
        return currentLoadingPromise;
      }
      const {
        handler: loadHandler
      } = loaderConfig;
      return this._load(loadHandler, currentLoadingPromiseKey);
    }
    subscribe(fnOrSubscriber) {
      const localStateGetter = () => this.localState;
      const actionHandler = action => {
        const {
          payload
        } = action;
        return {
          type: action.type,
          payload: payload?.[this.entryKey]?.data
        };
      };
      const subscriber = utils.isFunction(fnOrSubscriber) ? patchSubscriber({
        after: fnOrSubscriber,
        error: fnOrSubscriber
      }, localStateGetter, actionHandler) : patchSubscriber(fnOrSubscriber, localStateGetter, actionHandler);
      const activeUnsub = this.isSubscribed ? this.store.subscribe(this.key, subscriber) : undefined;
      activeUnsub && this.activeSubscriptions.push(activeUnsub);
      return createLooseSubscriber(subscriber, this.rawMutationSubscribers, activeUnsub);
    }
    subscribeAction(type, fnOrSubscriber) {
      const localStateGetter = () => this.localState;
      const subscriber = typeof fnOrSubscriber === 'function' ? patchSubscriber({
        after: fnOrSubscriber,
        error: fnOrSubscriber
      }, localStateGetter) : patchSubscriber(fnOrSubscriber, localStateGetter);
      const activeUnsub = this.isSubscribed ? this.store.subscribeAction(type, subscriber) : undefined;
      activeUnsub && this.activeSubscriptions.push(activeUnsub);
      return createLooseSubscriber(subscriber, this.rawActionSubscribers, activeUnsub, type);
    }
    subscribeLoad(fnOrSubscriber) {
      const localStateGetter = () => this.localState;
      const subscriber = utils.isFunction(fnOrSubscriber) ? patchSubscriber({
        after: fnOrSubscriber,
        error: fnOrSubscriber
      }, localStateGetter) : patchSubscriber(fnOrSubscriber, localStateGetter);
      const activeUnsub = this.isSubscribed ? subscribe(this.key, subscriber, this.loadSubscribers) : undefined;
      activeUnsub && this.activeSubscriptions.push(activeUnsub);
      return createLooseSubscriber(subscriber, this.rawLoadSubscribers, activeUnsub);
    }
  }

  exports.Store = Store;
  exports.StoreActionError = StoreActionError;
  exports.StoreAdapter = StoreAdapter;
  exports.deleteStoreAdapterValue = deleteStoreAdapterValue;
  exports.deserializeError = deserializeError;
  exports.distributeStoreAdapterValue = distributeStoreAdapterValue;
  exports.getStoreAdapterValue = getStoreAdapterValue;
  exports.hasSubscribers = hasSubscribers;
  exports.serializeError = serializeError;
  exports.setStoreAdapterValue = setStoreAdapterValue;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_util/idGenerator', ['exports', 'dxp_util/common'], (function (exports, common) {

    const ones = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"];
    const tens = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"];

    /**
     * Convert a number to a word string in english
     *
     * @param {number} num Number to be converted words
     * @returns {string} A string which describe the number in english
     */
    function numberToWord(num = 0) {
      if (typeof num === "string") {
        num = parseInt(num, 10);
      }
      if (num < 0) {
        throw new Error("Negative numbers are not supported.");
      }
      if (num === 0) {
        return "zero";
      }

      //the case of 1 - 20
      if (num < 20) {
        return ones[num];
      }
      const numString = num.toString();
      if (numString.length === 2) {
        return `${tens[numString[0]]}${ones[numString[1]] ? "-" + ones[numString[1]] : ""}`;
      }

      // 100 +
      if (numString.length === 3) {
        if (numString[1] === "0" && numString[2] === "0") {
          return `${ones[numString[0]]}-hundred`;
        }
        const result = numberToWord(+(numString[1] + numString[2]));
        return `${ones[numString[0]]}-hundred-${result}`;
      }

      // 1000 +
      if (numString.length === 4) {
        const end = +(numString[1] + numString[2] + numString[3]);
        if (end === 0) {
          return ones[numString[0]] + "-thousand";
        }
        if (end < 100) {
          return `${ones[numString[0]]}-thousand-${numberToWord(end)}`;
        }
        return `${ones[numString[0]]}-thousand-${numberToWord(end)}`;
      }
      throw new Error(`${num} are not supported.`);
    }

    const indexToWord = baseIndex => index => numberToWord(index + baseIndex);
    const capitalize = capitalCase => string => capitalCase ?? false ? common.toCapitalized(string) : string;
    const appendPrefix = prefix => string => `${prefix}${string}`;

    /**
     * Generate id per given prefix
     *
     * @param {number} baseIndex base index such as start with 0, 1
     * @param {string} capitalCase whether use capital case
     * @param {string} prefix Prefix for each id
     * @param {number} index Index to generate id
     * @returns {string} such as CustomFieldOne or custom-field-twenty
     */
    function generateId(baseIndex, capitalCase, prefix, index) {
      return common.compose(appendPrefix(prefix), capitalize(capitalCase), indexToWord(baseIndex))(index);
    }
    const fnGenerateId = common.curry(generateId);

    /**
     * Generate ids per given prefix and total count
     *
     * @param {string} prefix Prefix for each id
     * @param {number} count How many ids are required
     * @param {object} options Options for generating id
     * @returns {Array} ids A array if generated ids
     */
    function generateIds(prefix, count, options = {
      baseIndex: 0,
      capitalCase: false
    }) {
      return common.compose(common.map(fnGenerateId(options.baseIndex, options.capitalCase, prefix)), common.toIndexes)(count);
    }

    /**
     * Generate unique number
     *
     * @returns {number} unique number
     */
    function generateUniqueNumber() {
      return Math.floor(new Date().valueOf() * Math.random());
    }

    exports.fnGenerateId = fnGenerateId;
    exports.generateId = generateId;
    exports.generateIds = generateIds;
    exports.generateUniqueNumber = generateUniqueNumber;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_data_provider/dataProviderUtils', ['exports', 'dxp_util/contentInfo', '@app/isDesignMode', 'dxp_util/idGenerator'], (function (exports, contentInfo, isDesignMode, idGenerator) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var isDesignMode__default = /*#__PURE__*/_interopDefaultCompat(isDesignMode);

    /**
     * Genereate a mock collection when it's in design mode
     *
     * @param {number} count how many items to generate
     * @returns {Array} mock collection or empty array
     */
    function generateMockCollection(count) {
      return isDesignMode__default.default ? idGenerator.generateIds("", count).map(id => ({
        key: id,
        data: {}
      })) : [];
    }

    const DATA_BIND_REGEX = /\{!Item\.(.+?)\}/g;
    const DATA_PROVIDER_GET_FIELD_DATA_EVENT_NAME = "dxp_data_provider__getfielddata";
    const DATA_PROVIDER_FIELD_METADATA_PREFIX = "_";
    const DATA_PROVIDER_DATA_ACCESS = `${DATA_PROVIDER_FIELD_METADATA_PREFIX}data`;
    const MASTER_RECORD_TYPE_ID = "012000000000000AAA";
    const SFDC_TYPES = {
      RECORD: "sfdc_record__",
      CMS: "sfdc_cms__"
    };
    const getFieldAndMetadata = fieldAndMetadata => {
      const fieldParts = fieldAndMetadata.split(".");
      if (fieldParts.length > 0 && fieldParts[fieldParts.length - 1].startsWith("_")) {
        // if a metadata access, determine if on data or on a field. ex. {!Item._data} vs {!Item.field._displayValue}
        const metadata = fieldParts[fieldParts.length - 1];
        const field = fieldParts.slice(0, fieldParts.length - 1);
        if (fieldParts.length === 1) {
          return [null, metadata];
        }
        return [field, metadata];
      }
      return [fieldAndMetadata, null];
    };

    /**
     * Normalize the content key
     *
     * @param {string} key content key to normalize
     * @returns {string} normalized content key
     */
    function normalizeContentKey(key) {
      // If content key has '-', then comes from the expression {!urlAlias} -> route param
      if (key?.includes("-")) {
        // content key is the last value divided by '-', (ex. we-still-meeting-today-MCKABCDYJW4ZCE5IECPBVBBLQY5I)
        return key.split("-").slice(-1)[0];
      }
      return key;
    }

    /**
     * Build field path with existing path and incoming field
     *
     * @param {string} existingPath current field path
     * @param {string} field appended field
     * @returns {string} combined path from existingPath and new path
     */
    function buildFieldPath(existingPath, field) {
      return !existingPath ? field : `${existingPath}.${field}`;
    }

    Object.defineProperty(exports, 'resolve', {
        enumerable: true,
        get: function () { return contentInfo.resolveUrl; }
    });
    exports.DATA_BIND_REGEX = DATA_BIND_REGEX;
    exports.DATA_PROVIDER_DATA_ACCESS = DATA_PROVIDER_DATA_ACCESS;
    exports.DATA_PROVIDER_FIELD_METADATA_PREFIX = DATA_PROVIDER_FIELD_METADATA_PREFIX;
    exports.DATA_PROVIDER_GET_FIELD_DATA_EVENT_NAME = DATA_PROVIDER_GET_FIELD_DATA_EVENT_NAME;
    exports.MASTER_RECORD_TYPE_ID = MASTER_RECORD_TYPE_ID;
    exports.SFDC_TYPES = SFDC_TYPES;
    exports.buildFieldPath = buildFieldPath;
    exports.generateMockCollection = generateMockCollection;
    exports.getFieldAndMetadata = getFieldAndMetadata;
    exports.normalizeContentKey = normalizeContentKey;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_data_provider/imageInfoLibrary', ['exports', 'dxp_data_provider/dataProviderUtils', 'dxp_util/common', 'experience/picture', 'experience/resourceResolver'], (function (exports, dataProviderUtils, common, picture, resourceResolver) {

    const DEVICE_WIDTH_SET = {
      mobile: 640,
      tablet: 960,
      desktop: 1920
    };
    const FORM_FACTOR_MEDIA_QUERY = {
      mobile: "",
      tablet: "(min-width: 47.9375em)",
      desktop: "(min-width: 64em)"
    };
    const DEVICE_DENSITY = [1];
    const IMAGE_INFO_AUXILIARY_PROPERTIES = ["bgPosition", "bgSizeOrRepeat"];

    /**
     * Extract content key from image info
     *
     * @param {object} imageInfo image info object
     * @returns {string} content-key
     */
    function computeContentKey(imageInfo) {
      if (!imageInfo) {
        return "";
      }
      let contentKey = imageInfo.imageInfoV1?.contentKey ||
      // imageInfoV1
      imageInfo.source?.ref?.contentKey ||
      // lightning__imageType
      imageInfo.image?.source?.ref?.contentKey ||
      // lightning__backgroundImageType
      imageInfo.contentKey ||
      // for non-nested image info
      "";
      // If the contentKeys are not populated for an image served from CMS(url will have /sfsites/c/cms/delivery/media), extract the contentKey manually
      if (!contentKey) {
        const reg = /(?:\/sfsites\/c\/cms\/delivery\/media\/)([^?]+)/,
          url = getFromImageInfo(imageInfo, "url");
        contentKey = url?.match(reg)?.[1] || "";
      }
      return dataProviderUtils.normalizeContentKey(contentKey);
    }

    /**
     * Extract key from image info
     *
     * @param {object} imageInfo image info object
     * @param {string} key of image info
     *
     * @returns {undefined|string} value of key in image info
     */
    function getFromImageInfo(imageInfo, key) {
      if (!key || !imageInfo) {
        return undefined;
      }

      // imageInfoV1
      if (imageInfo.imageInfoV1) {
        return imageInfo.imageInfoV1[key];
      }

      // lightning__backgroundImageType
      if (imageInfo.image) {
        imageInfo = imageInfo.image;
      }
      return imageInfo[key];
    }

    /**
     * Generate SrcSet
     *
     * @param {string} url url of given image
     * @returns {Array | undefined} set of url per device width
     */
    function generateRawSrcSet(url) {
      return picture.createImageDataMap(url, DEVICE_WIDTH_SET, DEVICE_DENSITY);
    }

    /**
     * Generate SrcSet
     *
     * @param {string} url url of given image
     * @returns {Array} set of url per device width
     */
    function generateSrcSet(url) {
      return generateRawSrcSet(url)?.map(image => ({
        ...image,
        // removing 1x from the url as it is default for srcSet and
        // of no use for background-image css-property
        srcSet: image.srcSet.split(/\s(\dx)/, 2),
        media: FORM_FACTOR_MEDIA_QUERY[image.formFactor]
      }));
    }

    /**
     * Extract additional image info properties like bgPosition from raw image info
     *
     * @param {object} raw raw info
     * @returns {object } auxiliary image properties
     */
    function getAuxiliaryImageInfoProperties(raw) {
      if (raw?._imageInfo && typeof raw._imageInfo === "object") {
        return IMAGE_INFO_AUXILIARY_PROPERTIES.reduce((result, prop) => prop in raw._imageInfo ? {
          ...result,
          [prop]: raw._imageInfo[prop]
        } : result, {});
      }
      return {};
    }

    /**
     * Generate sfdcData
     *
     * @param {object} raw raw info
     * @param {object} data cms data
     * @returns {object} sfdc data
     */
    function generateSfdcData(raw, data) {
      const url = data ? common.get(data, "contentBody.sfdc_cms:media.url") : raw.url;
      const srcSet = generateSrcSet(url);
      if (data) {
        const Picture = {
          Url: raw?.isLandingPageEditor?.() ? url : resourceResolver.resolve(url),
          RawUrl: url,
          AltText: raw.overrideAltText ? raw.imageAltText : common.get(data, "contentBody.altText") || "",
          SrcSet: srcSet,
          ...getAuxiliaryImageInfoProperties(raw)
        };
        return {
          ...data,
          Picture,
          Pictures: [Picture]
        };
      }
      const Picture = {
        Url: raw?.isLandingPageEditor?.() ? url : resourceResolver.resolve(url),
        RawUrl: raw.url,
        AltText: raw.imageAltText ?? "",
        SrcSet: srcSet,
        ...getAuxiliaryImageInfoProperties(raw)
      };
      return {
        Picture,
        Pictures: [Picture]
      };
    }

    /**
     * Generate bulk sfdcData
     *
     * @param {object} raw raw info
     * @param {object} data cms data
     * @returns {object | undefined} sfdc data
     */
    function generateBulkSfdcData(raw, data) {
      if (!data.contents || data.contents.length < 1) {
        return null;
      }
      const Pictures = data.contents.map(content => {
        const url = common.get(content, "contentBody.sfdc_cms:media.url");
        const srcSet = generateSrcSet(url);
        return {
          Url: resourceResolver.resolve(url),
          RawUrl: url,
          AltText: raw.overrideAltText ? raw.imageAltText : common.get(content, "contentBody.altText") || "",
          ContentKey: content.contentKey,
          SrcSet: srcSet,
          ...getAuxiliaryImageInfoProperties(raw)
        };
      });
      return {
        Picture: Pictures[0],
        Pictures
      };
    }

    /**
     * Normalize given url.
     *
     * @param {object} imageInfo image info object
     * @param {string} imageInfo.url image url
     * @param {string}  [fallback=""] fallback string, by default is empty string
     * @returns {string} normalized url string
     */
    function safeImageUrl(imageInfo, fallback = "") {
      if (typeof imageInfo === "string") {
        return imageInfo || fallback;
      }
      const {
        Url
      } = imageInfo ?? {};
      return common.hasUri(Url) ? Url : fallback;
    }

    /**
     * Get contentKeys from imageInfo.
     *
     * @param {object | Array} imageInfo image info object or contentKeys array
     * @returns {Array<string> | null} array of contentKeys
     */
    function getContentKeys(imageInfo) {
      let contentKeys;
      if (common.typeOf(imageInfo) === "object") {
        const contentKey = computeContentKey(imageInfo);
        contentKeys = contentKey ? [contentKey] : null;
      } else if (common.typeOf(imageInfo) === "array") {
        contentKeys = imageInfo.map(contentKey => dataProviderUtils.normalizeContentKey(contentKey));
      }
      return contentKeys;
    }

    /**
     * Get external url details
     *
     * @param {object | Array} imageInfo image info object or contentKeys array
     * @param {null | Array} contentKeys image info object or contentKeys array
     * @returns {object | undefined} array of contentKeys
     */
    function processExternalUrl(imageInfo, contentKeys) {
      if (common.typeOf(imageInfo) === "object" && imageInfo !== null && !(contentKeys?.length > 0)) {
        const imageAltText = getFromImageInfo(imageInfo, "altText") || "";
        const url = getFromImageInfo(imageInfo, "url");
        return {
          imageAltText,
          url
        };
      }
      return undefined;
    }

    /**
     * Get overrideAltText details
     *
     * @param {object | Array} imageInfo image info object or contentKeys array
     * @returns {object | undefined} array of contentKeys
     */
    function processOverrideAltText(imageInfo) {
      if (common.typeOf(imageInfo) === "object" && imageInfo !== null) {
        // overrideAltText overrides CMS AltText in es_base_components:image
        const overrideAltText = imageInfo.overrideAltText || false;
        const imageAltText = getFromImageInfo(imageInfo, "altText") || "";
        return {
          overrideAltText,
          imageAltText
        };
      }
      return undefined;
    }

    /**
     * Get url from the image info object
     *
     * @param {object} imageInfo image info object
     * @returns {string} the image url
     */
    function getDefaultUrl(imageInfo) {
      if (common.typeOf(imageInfo) === "object" && imageInfo !== null) {
        return getFromImageInfo(imageInfo, "url") || "";
      }
      return "";
    }

    /**
     * Get sfdcData with a url
     *
     * @param {string} url
     * @param {object} raw raw info
     * @returns {object} sfdcData with Picture key
     */
    function getSfdcDataWithUrl(url, raw) {
      return {
        Picture: {
          Url: resourceResolver.resolve(url),
          RawUrl: url,
          AltText: "",
          SrcSet: generateSrcSet(url),
          ...getAuxiliaryImageInfoProperties(raw)
        }
      };
    }

    /**
     * Get sfdcData with content-keys
     *
     * @param {array} contentKeys array of content keys
     * @returns {object} sfdcData with Pictures key
     */
    function getSfdcDataWithContentKeys(contentKeys) {
      const urls = contentKeys.map(contentKey => `/cms/delivery/media/${contentKey}`);
      return {
        Pictures: urls.map((url, i) => {
          return {
            Url: resourceResolver.resolve(url),
            RawUrl: url,
            AltText: "",
            SrcSet: generateSrcSet(url),
            ContentKey: contentKeys[i]
          };
        })
      };
    }

    exports.DEVICE_DENSITY = DEVICE_DENSITY;
    exports.IMAGE_INFO_AUXILIARY_PROPERTIES = IMAGE_INFO_AUXILIARY_PROPERTIES;
    exports.computeContentKey = computeContentKey;
    exports.generateBulkSfdcData = generateBulkSfdcData;
    exports.generateRawSrcSet = generateRawSrcSet;
    exports.generateSfdcData = generateSfdcData;
    exports.generateSrcSet = generateSrcSet;
    exports.getContentKeys = getContentKeys;
    exports.getDefaultUrl = getDefaultUrl;
    exports.getFromImageInfo = getFromImageInfo;
    exports.getSfdcDataWithContentKeys = getSfdcDataWithContentKeys;
    exports.getSfdcDataWithUrl = getSfdcDataWithUrl;
    exports.processExternalUrl = processExternalUrl;
    exports.processOverrideAltText = processOverrideAltText;
    exports.safeImageUrl = safeImageUrl;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/config', ['exports'], (function (exports) {

  const currentRelease = {
    currentRelease: '252',
    apiVersion: 'v62.0'
  };

  exports.currentRelease = currentRelease;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/cmsDeliveryApi', ['exports', 'experience/store', 'experience/config', 'experience/data', 'experience/utils'], (function (exports, store, config, data, utils) {

  const API_VERSION$1 = config.currentRelease.apiVersion;
  function getEndPointUrl$1(channelOrSiteId, contentKeyOrId) {
    if (channelOrSiteId.startsWith('0DM')) {
      return `/services/data/${API_VERSION$1}/connect/sites/${channelOrSiteId}/cms/delivery/contents/${contentKeyOrId}`;
    } else if (channelOrSiteId.startsWith('0ap')) {
      return `/services/data/${API_VERSION$1}/connect/cms/delivery/channels/${channelOrSiteId}/contents/${contentKeyOrId}`;
    }
    throw new TypeError("The 'channelOrSiteId' parameter is invalid");
  }
  async function getContent$1(options) {
    if (!utils.isPlainObject(options)) {
      throw new TypeError(`Options are required to successfully be able to execute this request.`);
    }
    if (typeof options.channelOrSiteId !== 'string' || options.channelOrSiteId.trim().length === 0) {
      throw new TypeError("The 'channelOrSiteId' parameter is required to successfully execute this request.");
    }
    if (typeof options.contentKeyOrId !== 'string' || options.contentKeyOrId.trim().length === 0) {
      throw new TypeError("The 'contentKeyOrId' parameter is required to successfully execute this request.");
    }
    const channelOrSiteId = encodeURIComponent(options.channelOrSiteId);
    const contentKeyOrId = encodeURIComponent(options.contentKeyOrId);
    const endPointUrl = getEndPointUrl$1(channelOrSiteId, contentKeyOrId);
    return data.fetchService(endPointUrl).catch(response => {
      throw new Error(response.statusText);
    });
  }
  const cmsStore = new store.Store('@@CmsDeliveryApi');
  function getContentLoader(action) {
    return getContent$1(action.payload);
  }

  const API_VERSION = config.currentRelease.apiVersion;
  const PATH_PARAM = ['channelOrSiteId'];
  const VALID_TYPES = {
    channelOrSiteId: 'string',
    contentKeys: 'array',
    managedContentIds: 'array',
    contentTypeFQN: 'string',
    page: 'number',
    pageSize: 'number',
    referenceDepth: 'number',
    includeContentBody: 'boolean'
  };
  const VALID_TYPE_VALUES = Object.values(VALID_TYPES).filter((type, index, self) => {
    return self.indexOf(type) === index;
  });
  function getEndPointUrl(channelOrSiteId, queryParams) {
    if (channelOrSiteId.startsWith('0DM')) {
      return data.composeUri(`/services/data/${API_VERSION}/connect/sites/${channelOrSiteId}/cms/delivery/contents`, queryParams);
    } else if (channelOrSiteId.startsWith('0ap')) {
      return data.composeUri(`/services/data/${API_VERSION}/connect/cms/delivery/channels/${channelOrSiteId}/contents`, queryParams);
    }
    throw new TypeError('Enter a valid prefix for channelOrSiteId.');
  }
  function isPathParam(param) {
    return PATH_PARAM.includes(param);
  }
  function isTypeValid(paramValue) {
    return VALID_TYPE_VALUES.includes(paramValue);
  }
  function isListType(type) {
    return type === 'array';
  }
  function isTypeMatch(value, type) {
    if (isListType(type)) {
      return Array.isArray(value);
    }
    return isTypeValid(type) && typeof value === type;
  }
  function isNotEmptyString(value) {
    return typeof value === 'string' && value.trim().length > 0;
  }
  function isBoolean(value) {
    return typeof value === 'boolean';
  }
  function getQueryParams(options) {
    const queryParams = {};
    for (const [optionKey, optionValue] of Object.entries(options)) {
      const optionType = VALID_TYPES[optionKey];
      if (isPathParam(optionKey) || utils.isNil(optionValue) || utils.isNil(optionType)) {
        continue;
      }
      if (!isTypeMatch(optionValue, optionType)) {
        if (optionType === 'array') {
          throw new TypeError(`The type entered for ${optionKey} isn’t valid. Enter the value as an ${optionType}.`);
        } else {
          throw new TypeError(`The type entered for ${optionKey} isn’t valid. Enter the value as a ${optionType}.`);
        }
      }
      if (isListType(optionType)) {
        const listOptionValue = optionValue.join(',');
        if (isNotEmptyString(listOptionValue)) {
          queryParams[optionKey] = listOptionValue;
        }
      }
      if (isNotEmptyString(optionValue) || utils.isInteger(optionValue) || isBoolean(optionValue)) {
        queryParams[optionKey] = optionValue.toString();
      }
    }
    return queryParams;
  }
  async function getContents$1(options) {
    if (!utils.isPlainObject(options)) {
      throw new TypeError(`Enter input parameters to execute the request.`);
    }
    if (!isNotEmptyString(options.channelOrSiteId)) {
      throw new TypeError('Enter a value for channelOrSiteId.');
    }
    const channelOrSiteId = encodeURIComponent(options.channelOrSiteId);
    const queryParams = getQueryParams(options);
    const endPointUrl = getEndPointUrl(channelOrSiteId, queryParams);
    return data.fetchService(endPointUrl).catch(response => {
      throw new Error(response.statusText);
    });
  }
  const cmsDeliveryListStore = new store.Store('@@CmsDeliveryListApi');
  function getContentsLoader(action) {
    return getContents$1(action.payload);
  }

  class getContent extends store.StoreAdapter {
    constructor(dataCallback) {
      super(dataCallback, cmsStore, 'content', {
        loader: getContentLoader
      });
    }
    /*LWC compiler v7.1.5*/
  }
  class getContents extends store.StoreAdapter {
    constructor(dataCallback) {
      super(dataCallback, cmsDeliveryListStore, 'contents', {
        loader: getContentsLoader
      });
    }
    /*LWC compiler v7.1.5*/
  }

  exports.getContent = getContent;
  exports.getContents = getContents;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/dataProvider', ['exports', 'lwc', 'experience/dataLayerObject', 'experience/utils'], (function (exports, lwc, _experienceDataLayerObject, utils) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var _experienceDataLayerObject__default = /*#__PURE__*/_interopDefaultCompat(_experienceDataLayerObject);

    const stc0 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {k: api_key, c: api_custom_element, i: api_iterator, s: api_slot, f: api_flatten} = $api;
      return api_flatten([$cmp.hasDataLayerObjects ? api_iterator($cmp.dataLayerObjects, function (dataLayerObject) {
        return api_custom_element("experience-data-layer-object", _experienceDataLayerObject__default.default, {
          props: {
            "scriptDataAttributes": dataLayerObject.attributes,
            "customObject": dataLayerObject.customObject
          },
          key: api_key(0, dataLayerObject.id)
        });
      }) : stc0, api_slot("", {
        key: 1,
        slotData: $cmp.dataProxyContext
      }, stc0, $slotset)]);
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = [""];
    tmpl.renderMode = "light";
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-1cva0bnnf5d";
    tmpl.legacyStylesheetToken = "experience-dataProvider_dataProvider";
    lwc.freezeTemplate(tmpl);

    const DATA_PROVIDER_ACTION_EVENT_NAME = 'sfdc__dataprovider_action';
    class DataProviderActionEvent extends CustomEvent {
      constructor(type, payload, callbackOrOptions) {
        const options = {
          onSuccess: utils.isFunction(callbackOrOptions) ? callbackOrOptions : utils.isPlainObject(callbackOrOptions) && utils.isFunction(callbackOrOptions.onSuccess) ? callbackOrOptions.onSuccess : undefined,
          onError: utils.isFunction(callbackOrOptions) ? callbackOrOptions : utils.isPlainObject(callbackOrOptions) && utils.isFunction(callbackOrOptions.onError) ? callbackOrOptions.onError : undefined
        };
        super(DATA_PROVIDER_ACTION_EVENT_NAME, {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            type,
            payload,
            options
          }
        });
      }
      /*LWC compiler v7.1.5*/
    }

    class DataProviderConnectionAdapter {
      constructor(dataCallback) {
        this.dataCallback = dataCallback;
      }
      update() {}
      connect() {
        this.dataCallback({
          connected: true
        });
      }
      disconnect() {
        this.dataCallback({
          connected: false
        });
      }
    }

    const registeredActionsMap = new WeakMap();
    function isDataProviderConstructor(obj) {
      return function evaluate(_obj) {
        if (utils.isFunction(_obj) && _obj.constructor === __lwc_component_class_internal.constructor) {
          return true;
        }
        const proto = _obj != null ? Object.getPrototypeOf(_obj) : null;
        if (proto != null) {
          return evaluate(proto);
        }
        return false;
      }(obj);
    }
    function getDataProviderConstructorChain(obj) {
      const chain = [];
      (function evaluate(_obj, isProvider) {
        if (isProvider) {
          chain.push(_obj);
        }
        const proto = _obj != null ? Object.getPrototypeOf(_obj) : null;
        if (isDataProviderConstructor(proto)) {
          evaluate(proto, true);
        }
      })(obj, isDataProviderConstructor(obj));
      return chain.reverse();
    }
    function registerAction(ctor, type, handler) {
      if (!isDataProviderConstructor(ctor)) {
        throw new TypeError(`[dataProvider] parameter 'ctor' needs to be a DataProvider constructor`);
      }
      if (typeof type !== 'string') {
        throw new TypeError(`[dataProvider] parameter 'type' needs to be a string`);
      }
      if (!utils.isFunction(handler)) {
        throw new TypeError(`[dataProvider] parameter 'handler' needs to be a function`);
      }
      if (!registeredActionsMap.has(ctor)) {
        registeredActionsMap.set(ctor, {});
      }
      const container = registeredActionsMap.get(ctor);
      if (Reflect.has(container, type)) {
        throw new TypeError(`[dataProvider] a handler has already been registered for action type '${type}'`);
      }
      container[type] = handler;
    }
    function getRegisteredActions(ctor) {
      return getDataProviderConstructorChain(ctor).reduce((acc, _ctor) => {
        if (registeredActionsMap.has(_ctor)) {
          const actionsMap = registeredActionsMap.get(_ctor);
          return {
            ...acc,
            ...actionsMap
          };
        }
        return acc;
      }, {});
    }

    const handleDataProviderActionEventFieldSymbol = Symbol('handleDataProviderActionEventField');
    const handleDataProviderActionEventSymbol = Symbol('handleDataProviderActionEvent');
    const SFDC_DATA_ATTRIBUTE = Symbol();
    const SFDC_PROVIDER_ATTRIBUTE = Symbol();
    class DataProvider extends lwc.LightningElement {
      wireConnectedState({
        connected
      }) {
        if (connected) {
          this.addEventListener(DATA_PROVIDER_ACTION_EVENT_NAME, this[handleDataProviderActionEventFieldSymbol]);
        } else {
          this.removeEventListener(DATA_PROVIDER_ACTION_EVENT_NAME, this[handleDataProviderActionEventFieldSymbol]);
        }
      }
      get sfdcData() {
        return this._sfdcData;
      }
      set sfdcData(value) {
        this._sfdcData = value;
      }
      get dataProxyContext() {
        return {
          [SFDC_DATA_ATTRIBUTE]: this.getData(),
          [SFDC_PROVIDER_ATTRIBUTE]: this
        };
      }
      hasData(_prop) {
        return true;
      }
      updateComponents() {
        // TODO: Remove once commerce data provider is updated.
      }
      getData() {
        return this.sfdcData;
      }
      get hasDataLayerObjects() {
        return !!this.dataLayerObjects && this.dataLayerObjects.length > 0;
      }
      constructor() {
        super();
        this[handleDataProviderActionEventFieldSymbol] = this[handleDataProviderActionEventSymbol].bind(this);
        this.sfdcFields = [];
        this.sfdcIsPreviewMode = false;
        this.sfdcType = void 0;
        this.sfdcExpressionKey = void 0;
        this.sfdcIsViewLevelDataProvider = false;
        this.generatedTemplate = void 0;
        this._sfdcData = void 0;
        this.dataLayerObjects = void 0;
        this._sfdcData = {};
      }
      [handleDataProviderActionEventSymbol](event) {
        if (event.defaultPrevented) {
          return;
        }
        const {
          detail,
          target
        } = event;
        const {
          type,
          payload,
          options
        } = detail;
        const actions = getRegisteredActions(Object.getPrototypeOf(this).constructor);
        if (Reflect.has(actions, type)) {
          event.preventDefault();
          event.stopPropagation();
          const hasSuccessCallback = utils.isFunction(options.onSuccess);
          const hasErrorCallback = utils.isFunction(options.onError);
          try {
            const result = actions[type].call(this, payload, this, target);
            if (result instanceof Promise) {
              result.then(value => {
                hasSuccessCallback && options.onSuccess?.call(undefined, value, true);
                return value;
              }, err => {
                if ("development" !== 'production') {
                  console.warn('[dataProvider] error during action execution:', err);
                }
                hasErrorCallback && options.onError?.call(undefined, err, false);
              });
            } else {
              hasSuccessCallback && options.onSuccess?.call(undefined, result, true);
            }
          } catch (err) {
            {
              console.warn('[dataProvider] error during action execution:', err);
            }
            hasErrorCallback && options.onError?.call(undefined, err, false);
          }
        }
      }
      /*LWC compiler v7.1.5*/
    }
    DataProvider.renderMode = 'light';
    DataProvider.preloadData = void 0;
    lwc.registerDecorators(DataProvider, {
      publicProps: {
        sfdcFields: {
          config: 0
        },
        sfdcIsPreviewMode: {
          config: 0
        },
        sfdcType: {
          config: 0
        },
        sfdcExpressionKey: {
          config: 0
        },
        sfdcIsViewLevelDataProvider: {
          config: 0
        },
        generatedTemplate: {
          config: 0
        },
        sfdcData: {
          config: 3
        }
      },
      publicMethods: ["hasData", "updateComponents", "getData"],
      track: {
        _sfdcData: 1
      },
      wire: {
        wireConnectedState: {
          adapter: DataProviderConnectionAdapter,
          method: 1,
          config: function ($cmp) {
            return {};
          }
        }
      },
      fields: ["dataLayerObjects"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(DataProvider, {
      tmpl: _tmpl,
      sel: "experience-data-provider",
      apiVersion: 62
    });

    exports.DataProviderActionEvent = DataProviderActionEvent;
    exports.SFDC_DATA_ATTRIBUTE = SFDC_DATA_ATTRIBUTE;
    exports.SFDC_PROVIDER_ATTRIBUTE = SFDC_PROVIDER_ATTRIBUTE;
    exports.default = __lwc_component_class_internal;
    exports.registerAction = registerAction;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_data_provider/imageDataProvider', ['exports', 'lwc', 'experience/dataLayerObject', 'experience/picture', 'experience/dataProvider', 'experience/cmsDeliveryApi', 'dxp_util/siteInfo', 'dxp_util/common', 'experience/store', 'dxp_data_provider/imageInfoLibrary'], (function (exports, lwc, _experienceDataLayerObject, _experiencePicture, DataProvider, cmsDeliveryApi, siteInfo, common, store, imageInfoLibrary) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var _experienceDataLayerObject__default = /*#__PURE__*/_interopDefaultCompat(_experienceDataLayerObject);
    var _experiencePicture__default = /*#__PURE__*/_interopDefaultCompat(_experiencePicture);
    var DataProvider__default = /*#__PURE__*/_interopDefaultCompat(DataProvider);

    const stc0 = [];
    const stc1 = {
      "slds-hide": true
    };
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {k: api_key, c: api_custom_element, i: api_iterator, fr: api_fragment, s: api_slot, f: api_flatten} = $api;
      return api_flatten([$cmp.hasDataLayerObjects ? api_iterator($cmp.dataLayerObjects, function (dataLayerObject) {
        return api_custom_element("experience-data-layer-object", _experienceDataLayerObject__default.default, {
          props: {
            "scriptDataAttributes": dataLayerObject.attributes,
            "customObject": dataLayerObject.customObject
          },
          key: api_key(0, dataLayerObject.id)
        });
      }) : stc0, $cmp.enableImageCache ? api_fragment(1, [api_custom_element("experience-picture", _experiencePicture__default.default, {
        classMap: stc1,
        props: {
          "url": $cmp.rawUrl,
          "images": $cmp.computedSrcSet
        },
        key: 2
      })], 0) : null, api_slot("", {
        key: 3,
        slotData: $cmp.dataProxyContext
      }, stc0, $slotset)]);
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = [""];
    tmpl.renderMode = "light";
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-kiush5r3gi";
    tmpl.legacyStylesheetToken = "dxp_data_provider-imageDataProvider_imageDataProvider";
    lwc.freezeTemplate(tmpl);

    /**
     * Image Data Provider to handle image info
     *
     * @class ImageDataProvider
     * @extends DataProvider
     */
    class ImageDataProvider extends DataProvider__default.default {
      constructor(...args) {
        super(...args);
        // default is 'shadow'
        /**
         *  Internal data binding expression key
         *
         * @type {string}
         * @memberof ImageDataProvider
         */
        this.sfdcExpressionKey = void 0;
        this._imageInfo = void 0;
        /**
         * Disable image caching
         *
         * @type {boolean}
         * @memberof ImageDataProvider
         */
        this.enableImageCache = void 0;
        this._sfdcData = {
          Picture: {
            Url: "",
            RawUrl: "",
            AltText: ""
          },
          Pictures: []
        };
      }
      /**
       * Get the siteId for delivery API
       */
      get siteId() {
        return this.contentKeys?.length > 0 ? siteInfo.SiteInfo.SiteId : null;
      }
      get imageInfo() {
        return this._imageInfo;
      }
      set imageInfo(value) {
        // filtering null, undefined, "", 0, false
        if (!value) {
          return;
        }

        // imageInfo contains number, true, object and array
        this._imageInfo = common.safeParseJson(value);
        this.contentKeys = imageInfoLibrary.getContentKeys(this.imageInfo); // returns Array<string> | null

        const externalUrlDetails = imageInfoLibrary.processExternalUrl(this._imageInfo, this.contentKeys);
        this.url = externalUrlDetails?.url;
        this.imageAltText = externalUrlDetails?.imageAltText;
        if (this.url) {
          this.updateData();
        }
        const overrideAltTextDetails = imageInfoLibrary.processOverrideAltText(this._imageInfo);
        this.overrideAltText = overrideAltTextDetails?.overrideAltText;
        this.imageAltText = overrideAltTextDetails?.imageAltText;
      }
      get rawUrl() {
        return this._sfdcData.Picture?.RawUrl;
      }
      get computedSrcSet() {
        return imageInfoLibrary.generateRawSrcSet(this.rawUrl);
      }
      updateData(data) {
        this._sfdcData = imageInfoLibrary.generateSfdcData(this, data);
      }
      updateBulkData(data) {
        this._sfdcData = imageInfoLibrary.generateBulkSfdcData(this, data) ?? this._sfdcData;
      }

      /**
       * Wire method to get managed content from cmsDeliveryApi
       */
      wiredCMSDeliveryContents({
        data,
        error
      }) {
        if (data) {
          this.updateBulkData(data);
        }
        if (error) {
          if (common.typeOf(this._imageInfo) === "object") {
            // single image
            const defaultImageUrl = imageInfoLibrary.getDefaultUrl(this._imageInfo);
            // resourceResolver doesn't resolve path prepended with /sfsites/c
            const url = defaultImageUrl.replace(/\/sfsites\/c/, "");
            this._sfdcData = imageInfoLibrary.getSfdcDataWithUrl(url, this);
          } else if (Array.isArray(this.contentKeys)) {
            // multiple images
            this._sfdcData = imageInfoLibrary.getSfdcDataWithContentKeys(this.contentKeys);
          }
        }
      }

      /**
       * Method to be used for preloading data to support SSR
       *
       * @param {object} preloadRequestContext - Request context to preload the data
       */
      static async preloadData(preloadRequestContext) {
        const errors = [];
        const channelOrSiteId = siteInfo.SiteInfo.SiteId;
        const requestIndexesMap = [];
        const getContentRequestsCollection =
        // eslint-disable-next-line @locker/locker/distorted-element-attributes-getter
        preloadRequestContext.attributes.reduce((requests, {
          imageInfo
        }, index) => {
          const contentKeys = imageInfoLibrary.getContentKeys(common.safeParseJson(imageInfo));
          if (contentKeys?.length > 0 && channelOrSiteId) {
            requests.push(
            // eslint-disable-next-line @lwc/lwc/no-unexpected-wire-adapter-usages
            store.getStoreAdapterValue(cmsDeliveryApi.getContents, {
              channelOrSiteId,
              contentKeys,
              includeContentBody: true
            }));
            requestIndexesMap.push(index);
          }
          return requests;
        }, []);
        await Promise.allSettled(getContentRequestsCollection).then(results => {
          results.forEach((result, index) => {
            if (result.status === "rejected") {
              const imageInfo =
              // eslint-disable-next-line @locker/locker/distorted-element-attributes-getter
              preloadRequestContext.attributes[requestIndexesMap[index]]?.imageInfo;
              const contentKeys = imageInfoLibrary.getContentKeys(common.safeParseJson(imageInfo));
              const error = {
                provider: "imageDataProvider",
                reason: result.reason?.toString()
              };
              errors.push({
                ...error,
                url: `/connect/sites/${siteInfo.SiteInfo.SiteId}/cms/delivery/contents/${contentKeys.join()}`
              });
            }
          });
        });
        return errors.length ? Promise.reject(new Error(JSON.stringify(errors))) : Promise.resolve();
      }
      /*LWC compiler v7.1.5*/
    }
    /**
     * Enable the component to render as lightDOM
     *
     * @static
     */
    ImageDataProvider.renderMode = "light";
    lwc.registerDecorators(ImageDataProvider, {
      publicProps: {
        sfdcExpressionKey: {
          config: 0
        },
        enableImageCache: {
          config: 0
        },
        imageInfo: {
          config: 3
        }
      },
      track: {
        _imageInfo: 1
      },
      wire: {
        wiredCMSDeliveryContents: {
          adapter: cmsDeliveryApi.getContents,
          dynamic: ["channelOrSiteId", "contentKeys"],
          method: 1,
          config: function ($cmp) {
            return {
              includeContentBody: true,
              channelOrSiteId: $cmp.siteId,
              contentKeys: $cmp.contentKeys
            };
          }
        }
      },
      fields: ["_sfdcData"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(ImageDataProvider, {
      tmpl: _tmpl,
      sel: "dxp_data_provider-image-data-provider",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_data_provider/dataProxy', ['exports', 'lwc', 'experience/dataProvider'], (function (exports, lwc, dataProvider) {

    var _tmpl = void 0;

    /**
     * Check if data is available
     *
     * @param {object} sfdcData data from the data provider
     * @param {string} name name of the data
     * @returns {boolean} true if the data is available
     */
    function hasData(sfdcData, name) {
      return sfdcData?.[dataProvider.SFDC_PROVIDER_ATTRIBUTE]?.hasData?.(name) ?? true;
    }

    /**
     * Return either .data or the sfdcData itself
     *
     * @param {object} sfdcData data from the data provider
     * @returns {object} actual data
     */
    function getData(sfdcData) {
      return sfdcData?.[dataProvider.SFDC_DATA_ATTRIBUTE] ?? sfdcData;
    }

    /**
     * Data Proxy to render generated template
     *
     * Data Proxy expect sfdcData is following DataProviderData<T> | T
     *
     * @class DataProxy
     */
    class DataProxy extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        // default is 'shadow'
        /**
         * Initial router container view to render, used for SSRed pages
         * both for server rendering and client hydration.
         * This is passed to webruntime-router-container.
         */
        this.routerContainerView = void 0;
        /**
         * Initial route params, used for SSRed pages
         * both for server rendering and client hydration
         */
        this.routeParams = void 0;
        this.attributes = {};
        this._sfdcData = void 0;
        this.generated = void 0;
        this.html = void 0;
      }
      /**
       * Accepts a generated template to render and a map of attributes for the components
       * in the template
       *
       * @type {object}
       * @memberof DataProxy
       */
      get generatedTemplate() {
        return this.generated;
      }
      set generatedTemplate(generated) {
        this.generated = generated;
        this.html = generated.html;
        // eslint-disable-next-line @locker/locker/distorted-element-attributes-getter
        this.attributes = this.evaluateAttributes(generated.attributes);
        this.updateComponents();
      }

      /**
       * Sfdc Data attribute
       *
       * DataProviderData<T> | T
       *
       * @type {object}
       * @memberof DataProxy
       */
      get sfdcData() {
        return this._sfdcData;
      }
      set sfdcData(value) {
        this._sfdcData = value;
        this.updateComponents();
      }
      hasData(name) {
        return hasData(this.sfdcData, name);
      }
      getData() {
        // Return symbolized data attributes or sfdcData itself
        return getData(this.sfdcData);
      }

      /**
       * If a data provider receives data to update the template with the new data,
       * it needs to call this function
       */
      updateComponents() {
        // Update any elements that are bound to data
        if (this.generatedTemplate) {
          this.attributes = this.evaluateAttributes(this.generatedTemplate.attributes);
        }
      }
      connectedCallback() {
        this.updateComponents();
      }

      /**
       * Injects the data into the attribute map, so the components can have the data
       *
       * @param {Function} [attr]  - function returning the map of attributes for the components
       * @returns {object} map of attributes
       */
      evaluateAttributes(attr) {
        if (typeof attr === "function") {
          return attr(this);
        }
        return {};
      }
      render() {
        return this.html;
      }
      /*LWC compiler v7.1.5*/
    }
    /**
     * Enable the component to render as lightDOM
     *
     * @static
     */
    DataProxy.renderMode = "light";
    lwc.registerDecorators(DataProxy, {
      publicProps: {
        routerContainerView: {
          config: 0
        },
        routeParams: {
          config: 0
        },
        generatedTemplate: {
          config: 3
        },
        sfdcData: {
          config: 3
        }
      },
      publicMethods: ["hasData", "getData", "updateComponents"],
      track: {
        attributes: 1,
        _sfdcData: 1
      },
      fields: ["generated", "html"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(DataProxy, {
      tmpl: _tmpl,
      sel: "dxp_data_provider-data-proxy",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('force/ldsBindings', ['exports', 'lwc'], (function (exports, lwc) {

    // instrumentation keys to be imported by ldsInstrumentation
    const REFRESH_ADAPTER_EVENT = 'refresh-adapter-event';
    const ADAPTER_UNFULFILLED_ERROR = 'adapter-unfulfilled-error';
    const USERLAND_PROVISION_ERROR_MESSAGE = "LWC component's @wire target property or method threw an error during value provisioning. Original error:";
    const ADAPTER_SNAPSHOT_REJECTED_MESSAGE = 'Luvio wire adapter Promise<Snapshot> rejected. Original error:';
    const USERLAND_GRAPHQL_PARSER_ERROR_MESSAGE = 'Use `gql` parser to parse your "query" string';

    // map of emitted object -> [ adapter name, snapshot ]; snapshot is only undefined for the
    // initially-emitted { data: undefined, error: undefined } value
    const dataToTupleWeakMap = new WeakMap();
    var SnapshotState$1;
    (function (SnapshotState) {
      SnapshotState["Fulfilled"] = "Fulfilled";
      SnapshotState["Unfulfilled"] = "Unfulfilled";
      SnapshotState["Error"] = "Error";
      SnapshotState["Pending"] = "Pending";
      SnapshotState["Stale"] = "Stale";
    })(SnapshotState$1 || (SnapshotState$1 = {}));
    function isErrorSnapshot$1(snapshot) {
      return snapshot.state === SnapshotState$1.Error;
    }
    function isFulfilledSnapshot(snapshot) {
      return snapshot.state === SnapshotState$1.Fulfilled;
    }
    function isStaleSnapshot(snapshot) {
      return snapshot.state === SnapshotState$1.Stale;
    }
    function isUnfulfilledSnapshot(snapshot) {
      return snapshot.state === SnapshotState$1.Unfulfilled;
    }
    /**
     * Transform a Snapshot into a payload suitable for passing to a DataCallback.
     *
     * @param snapshot Snapshot
     */
    function snapshotToPayload$1(snapshot) {
      if (snapshot === undefined) {
        return {
          data: undefined,
          error: undefined
        };
      }
      if (isErrorSnapshot$1(snapshot)) {
        return {
          data: undefined,
          error: snapshot.error
        };
      }
      // fulfilled or stale
      return {
        data: snapshot.data,
        error: undefined
      };
    }
    function bindWireRefresh$1(luvio) {
      return function refresh(data) {
        return refreshData(data, dataToTupleWeakMap, luvio);
      };
    }
    function refreshData(data, dataToTuple, luvio) {
      const tuple = dataToTuple.get(lwc.unwrap(data));
      if (tuple === undefined) {
        {
          throw new Error('Refresh failed because resolved configuration is not available.');
        }
      }
      const [adapterName, snapshot] = tuple;
      luvio.instrument(() => {
        return {
          [REFRESH_ADAPTER_EVENT]: true,
          adapterName
        };
      });
      // snapshot is undefined when a caller refreshes the initial
      // { data: undefined, error: undefined } object that we emitted
      if (snapshot === undefined) {
        return Promise.resolve(undefined);
      }
      return luvio.refreshSnapshot(snapshot).then(refreshed => {
        if (isErrorSnapshot$1(refreshed)) {
          throw refreshed.error;
        }
        {
          if (isUnfulfilledSnapshot(refreshed)) {
            throw new Error('Refresh resulted in unfulfilled snapshot');
          }
        }
        return undefined;
      });
    }
    function isPromise$1(value) {
      // check for Thenable due to test frameworks using custom Promise impls
      return value.then !== undefined;
    }
    const {
      isArray
    } = Array;
    const {
      stringify
    } = JSON;

    /**
     * (Re)throws an error after adding a prefix to the message.
     *
     * @param error Error
     * @param messagePrefix prefix to add to error's message
     */
    function throwAnnotatedError(error, messagePrefix) {
      if (error instanceof Error) {
        error.message = `${messagePrefix}\n[${error.message}]`;
        throw error;
      }
      throw new Error(`${messagePrefix}\n[${stringify(error)}]`);
    }
    class Sanitizer {
      constructor(obj) {
        this.obj = obj;
        this.copy = {};
        this.currentPath = {
          key: '',
          value: obj,
          parent: null,
          data: this.copy
        };
      }
      sanitize() {
        const sanitizer = this;
        stringify(this.obj, function (key, value) {
          if (key === '') {
            return value;
          }
          const parent = this;
          if (parent !== sanitizer.currentPath.value) {
            sanitizer.exit(parent);
          }
          if (typeof value === 'object' && value !== null) {
            sanitizer.enter(key, value);
            return value;
          }
          sanitizer.currentPath.data[key] = value;
          return value;
        });
        return this.copy;
      }
      enter(key, value) {
        const {
          currentPath: parentPath
        } = this;
        const data = parentPath.data[key] = isArray(value) ? [] : {};
        this.currentPath = {
          key,
          value,
          parent: parentPath,
          data
        };
      }
      exit(parent) {
        while (this.currentPath.value !== parent) {
          this.currentPath = this.currentPath.parent || this.currentPath;
        }
      }
    }
    /**
     * Returns a sanitized version of an object by recursively unwrapping the Proxies.
     *
     * In order to keep luvio performance optimal on IE11, we need to make sure that luvio code gets
     * transformed by the es5-proxy-compat. At the same time we need to ensure that no ProxyCompat leaks
     * into the luvio engine code nor into the adapters. All the data coming from LWC-land need to be
     * sanitized first.
     */
    function sanitize(obj) {
      return new Sanitizer(obj).sanitize();
    }
    class LWCLuvioWireAdapter {
      /**
       * Constructs a new wire adapter instance for the given adapter.
       *
       * @param callback callback to be invoked with new values
       */
      constructor(adapter, name, luvio, callback, sourceContext) {
        // a component can be connected-disconnected-reconnected multiple times during its
        // life but we only want to keep subscriptions active while it is connected; the
        // connect/disconnect methods below keep this value updated to reflect the current
        // state
        this.connected = false;
        this.adapter = adapter;
        this.name = name;
        this.luvio = luvio;
        this.callback = callback;
        this.sourceContext = sourceContext;
        // initialize the wired property with a properly shaped object so cmps can use <template if:true={wiredProperty.data}>
        this.emit();
      }
      // WireAdapter interface methods
      /**
       * Called when the component associated with the wire adapter is connected.
       */
      connect() {
        this.connected = true;
        this.callAdapter(this.generateAdapterRequestContext());
      }
      /**
       * Called when the component associated with the wire adapter is disconnected.
       */
      disconnect() {
        this.unsubscribe();
        this.connected = false;
      }
      /**
       * Called when new or updated config is supplied to the wire adapter.
       *
       * @param config new config parameters for the wire adapter
       * @param _context not used
       */
      update(config, context) {
        this.unsubscribe();
        this.config = sanitize(config);
        this.callAdapter(this.generateAdapterRequestContext(context));
      }
      // private and protected utility methods
      /**
       * Accepts a WireContext and generates corresponding AdapterRequestContext
       */
      generateAdapterRequestContext(_context) {
        if (!this.sourceContext) {
          return {};
        }
        return {
          sourceContext: {
            ...this.sourceContext
          }
        };
      }
      /**
       * Calls the adapter if config has been set and the component is connected.
       */
      callAdapter(context) {
        if (!this.connected || this.config === undefined) {
          return;
        }
        const snapshotOrPromise = this.adapter(this.config, context);
        this.processAdapterResponse(snapshotOrPromise);
      }
      processAdapterResponse(snapshotOrPromise) {
        // insufficient config, wait for new config from component
        if (snapshotOrPromise === null) {
          return;
        }
        const configForSnapshot = this.config;
        const emitAndSubscribe = snapshot => {
          // adapters leveraging adapter context could asynchronously
          // return null (due to invalid config)
          if (snapshot === null) {
            return;
          }
          // We should never broadcast an unfulfilled snapshot to a component
          if (isUnfulfilledSnapshot(snapshot)) {
            {
              throw new Error(`Unfulfilled snapshot emitted to component from subscription, missingPaths: ${snapshot.missingPaths.keysAsArray()}`);
            }
          }
          // if config has changed before the snapshot arrives then ignore snapshot
          if (this.config !== configForSnapshot) {
            return;
          }
          // emit unless snapshot is pending
          if (isFulfilledSnapshot(snapshot) || isErrorSnapshot$1(snapshot) || isStaleSnapshot(snapshot)) {
            this.emit(snapshot);
          }
          // subscribe to the new snapshot
          this.subscribe(snapshot);
        };
        // Data resolved sync
        if (!isPromise$1(snapshotOrPromise)) {
          emitAndSubscribe(snapshotOrPromise);
        } else {
          // We want to let errors from this promise propagate to the app container,
          // which is why we do not have a reject handler here.
          // If an error is thrown here, it means that there was an error somewhere
          // inside an adapter which means that there was a mistake by the implementor.
          // Errors that come from the network should never hit this block because
          // they are treated like regular snapshots, not true error paths.
          snapshotOrPromise.then(emitAndSubscribe, error => throwAnnotatedError(error, ADAPTER_SNAPSHOT_REJECTED_MESSAGE));
        }
      }
      /**
       * Emits new values to the callback.
       *
       * @param snapshot Snapshot to be emitted, if omitted then undefineds will be emitted
       */
      emit(snapshot) {
        const payload = snapshotToPayload$1(snapshot);
        dataToTupleWeakMap.set(payload, [this.name, snapshot]);
        try {
          this.callback(payload);
        } catch (error) {
          if (error instanceof Error) {
            throwAnnotatedError(error, USERLAND_PROVISION_ERROR_MESSAGE);
          }
        }
      }
      /**
       * Subscribes this wire adapter to future changes to the specified snapshot. Any changes
       * to the snapshot will be automatically emitted to the component.
       *
       * @param snapshot Snapshot
       * @param subscriptionCallback callback
       */
      subscribe(snapshot) {
        // always clean up any old subscription that we might have
        this.unsubscribe();
        // but only subscribe if component is currently connected
        if (this.connected) {
          this.unsubscriber = this.luvio.storeSubscribe(snapshot, this.emit.bind(this));
        }
      }
      /**
       * Deletes this wire adapter's snapshot subscription (if any).
       */
      unsubscribe() {
        // clean up subscription
        if (this.unsubscriber !== undefined) {
          this.unsubscriber();
          this.unsubscriber = undefined;
        }
      }
    }
    /**
     * Wraps a luvio Adapter in a WireAdapterConstructor that conforms to https://rfcs.lwc.dev/rfcs/lwc/0000-wire-reform#wire-adapter-protocol.
     *
     * @param adapter Adapter
     * @param name name to assign to the generated constructor
     * @param luvio Luvio
     */
    function createWireAdapterConstructor$1(adapter, name, luvio) {
      const constructor = function (callback, sourceContext) {
        const delegate = new LWCLuvioWireAdapter(adapter, name, luvio, callback, sourceContext);
        this.connect = () => delegate.connect();
        this.disconnect = () => delegate.disconnect();
        this.update = (config, context) => delegate.update(config, context);
      };
      Object.defineProperty(constructor, 'name', {
        value: name
      });
      return constructor;
    }
    class LWCInfinteScrollingLuvioWireAdapter extends LWCLuvioWireAdapter {
      /**
       * Called when the component associated with the wire adapter is connected.
       */
      connect() {
        this.connectTimestamp = Date.now();
        super.connect();
      }
      /**
       * Called when the component associated with the wire adapter is disconnected.
       */
      disconnect() {
        this.connectTimestamp = undefined;
        super.disconnect();
      }
      /**
       * Called when new or updated config is supplied to the wire adapter.
       *
       * @param config new config parameters for the wire adapter
       * @param context context for the wire adapter
       */
      update(config, context) {
        if (this.connectTimestamp) {
          const adapterRequestContext = this.generateAdapterRequestContext(context);
          super.unsubscribe();
          this.config = sanitize(config);
          // this.callAdapterWithContext(mergedContext);
          super.callAdapter(adapterRequestContext);
        } else {
          super.update(config, context);
        }
      }
      generateAdapterRequestContext(context) {
        const baseContext = super.generateAdapterRequestContext(context);
        // this code-path is only called when the wire adapter is connected
        // and the connectTimestamp is set
        return {
          ...baseContext,
          cachePolicy: {
            type: 'valid-at',
            timestamp: this.connectTimestamp
          }
        };
      }
      subscribe(snapshot) {
        var _a;
        super.subscribe(snapshot);
        // if the snapshot is refreshed we should stop using data from before the refresh
        if (this.connected && ((_a = snapshot.refresh) === null || _a === void 0 ? void 0 : _a.resolve)) {
          const originalResolve = snapshot.refresh.resolve;
          snapshot.refresh.resolve = config => {
            this.connectTimestamp = Date.now();
            return originalResolve(config);
          };
        }
      }
      /*LWC compiler v7.1.5*/
    }
    function createInfiniteScrollingWireAdapterConstructor$1(adapter, name, luvio) {
      const constructor = function (callback, sourceContext) {
        const delegate = new LWCInfinteScrollingLuvioWireAdapter(adapter, name, luvio, callback, sourceContext);
        this.connect = () => delegate.connect();
        this.disconnect = () => delegate.disconnect();
        this.update = (config, context) => delegate.update(config, context);
      };
      Object.defineProperty(constructor, 'name', {
        value: name
      });
      return constructor;
    }
    function snapshotToPayload(snapshot) {
      const payload = {
        data: undefined,
        errors: undefined
      };
      if (snapshot === undefined) {
        return payload;
      }
      payload.data = extractSnapshotData(snapshot);
      // TODO handle batch error scenarios.
      if ('error' in snapshot && snapshot.error !== undefined) {
        if (Array.isArray(snapshot.error)) {
          payload.errors = snapshot.error;
        } else {
          payload.errors = [snapshot.error];
        }
      }
      return payload;
    }
    class LWCGraphQLLuvioWireAdapter extends LWCLuvioWireAdapter {
      constructor(adapter, name, luvio, astResolver, callback, sourceContext) {
        super(adapter, name, luvio, callback, sourceContext);
        this.astResolver = astResolver;
      }
      update(config, context) {
        this.unsubscribe();
        if (config.batchQuery) {
          this.config = {
            batchQuery: config.batchQuery.map(individualConfig => safeSanitizeGraphQLConfigObject(individualConfig))
          };
        } else {
          this.config = safeSanitizeGraphQLConfigObject(config);
        }
        this.callAdapter(super.generateAdapterRequestContext(context));
      }
      /**
       * Emits new values to the callback.
       *
       * @param snapshot Snapshot to be emitted, if omitted then undefineds will be emitted
       */
      emit(snapshot) {
        const payload = snapshotToPayload(snapshot);
        dataToTupleWeakMap.set(payload, [this.name, snapshot]);
        try {
          this.callback(payload);
        } catch (error) {
          if (error instanceof Error) {
            throwAnnotatedError(error, USERLAND_PROVISION_ERROR_MESSAGE);
          }
        }
      }
      /**
       * Coerce config before calling the adapter, preserve current behavior otherwise
       */
      callAdapter(context) {
        if (!this.connected || this.config === undefined) {
          return;
        }
        const config = this.config;
        if ('batchQuery' in config) {
          const batchConfig = {
            batchQuery: config.batchQuery.map(individualConfig => this.resolveQueryAst(individualConfig))
          };
          // If any of the configurations are invalid, we bail out of calling the adapter.
          if (batchConfig.batchQuery.some(val => val === undefined)) {
            return;
          }
          const snapshotOrPromise = this.adapter(batchConfig, context);
          this.processAdapterResponse(snapshotOrPromise);
        } else if ('query' in config) {
          const singleConfig = this.resolveQueryAst(config);
          if (singleConfig !== undefined) {
            const snapshotOrPromise = this.adapter(singleConfig, context);
            this.processAdapterResponse(snapshotOrPromise);
          }
        }
      }
      resolveQueryAst(config) {
        if (config.query === null) {
          return;
        }
        const ast = this.astResolver(config.query);
        if (ast === undefined && config.query !== undefined) {
          // this should only happen if the user didn't parse the query
          {
            throw new Error(USERLAND_GRAPHQL_PARSER_ERROR_MESSAGE);
          }
        }
        const resolvedAdapterConfig = {
          ...config,
          query: ast
        };
        return resolvedAdapterConfig;
      }
      /*LWC compiler v7.1.5*/
    }
    function extractSnapshotData(snapshot) {
      if ('data' in snapshot && snapshot.data !== undefined) {
        const isSingleGraphQLData = 'data' in snapshot.data && snapshot.data.data !== undefined;
        const isBatchGraphQLData = 'results' in snapshot.data && snapshot.data.results !== undefined;
        if (isSingleGraphQLData) return snapshot.data.data;
        if (isBatchGraphQLData) return snapshot.data;
      }
    }
    /**
     * Wraps a luvio Adapter in a WireAdapterConstructor that conforms to https://rfcs.lwc.dev/rfcs/lwc/0000-wire-reform#wire-adapter-protocol.
     *
     * @param adapter Adapter
     * @param name name to assign to the generated constructor
     * @param luvio Luvio
     */
    function createGraphQLWireAdapterConstructor$1(adapter, name, luvio, astResolver) {
      const constructor = function (callback, sourceContext) {
        const delegate = new LWCGraphQLLuvioWireAdapter(adapter, name, luvio, astResolver, callback, sourceContext);
        this.connect = () => delegate.connect();
        this.disconnect = () => delegate.disconnect();
        this.update = (config, context) => delegate.update(config, context);
      };
      Object.defineProperty(constructor, 'name', {
        value: name
      });
      return constructor;
    }
    function safeSanitizeGraphQLConfigObject(config) {
      // graphql query AST is passed by reference
      // sanitizing it makes a copy and we lose that reference
      // so we avoid sanitizing it
      return {
        ...sanitize(config),
        query: config.query
      };
    }

    // For use by callers within this module to instrument interesting things.
    let instrumentation = {
      refreshCalled: _fromSource => {},
      instrumentAdapter: (adapter, _metadata) => {
        return adapter;
      }
    };
    /**
     * Allows external modules (typically a runtime environment) to set
     * instrumentation hooks for this module. Note that the hooks are
     * incremental - hooks not suppiled in newInstrumentation will retain
     * their previous values. The default instrumentation hooks are no-ops.
     *
     * @param newInstrumentation instrumentation hooks to be overridden
     */
    function instrument(newInstrumentation) {
      instrumentation = Object.assign(instrumentation, newInstrumentation);
    }
    exports.refresh = void 0;
    function bindWireRefresh(luvio) {
      const wireRefresh = bindWireRefresh$1(luvio);
      exports.refresh = (data, apiFamily) => {
        instrumentation.refreshCalled(apiFamily);
        return wireRefresh(data);
      };
    }
    function createInstrumentedAdapter(adapter, metadata) {
      return instrumentation.instrumentAdapter(adapter, metadata);
    }
    function createLDSAdapter(luvio, name, factory) {
      return factory(luvio);
    }
    const {
      create,
      defineProperty,
      defineProperties
    } = Object;
    var SnapshotState;
    (function (SnapshotState) {
      SnapshotState["Fulfilled"] = "Fulfilled";
      SnapshotState["Unfulfilled"] = "Unfulfilled";
      SnapshotState["Error"] = "Error";
      SnapshotState["Pending"] = "Pending";
      SnapshotState["Stale"] = "Stale";
    })(SnapshotState || (SnapshotState = {}));
    function isErrorSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Error;
    }
    function isPendingSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Pending;
    }
    function isPromise(value) {
      // check for Thenable due to test frameworks using custom Promise impls
      return value !== null && value.then !== undefined;
    }
    function snapshotToTuple$1(snapshot) {
      if (isErrorSnapshot(snapshot)) {
        return {
          data: undefined,
          error: snapshot.error
        };
      }
      // We might still get pending snapshot here from invoke calls here
      return {
        data: snapshot.data,
        error: undefined
      };
    }
    function createInvalidConfigError$1() {
      return {
        data: undefined,
        error: {
          ok: false,
          status: 400,
          statusText: 'INVALID_CONFIG',
          body: undefined,
          headers: {},
          errorType: 'fetchResponse'
        }
      };
    }
    /**
     * Creates an imperative adapter
     *
     * @param luvio Luvio
     * @param adapter luvio adapter
     * @param metadata AdapterMetadata
     * @returns Imperative adapter object with invoke and subscribe functions
     */
    function createImperativeAdapter(luvio, adapter, metadata) {
      const {
        name
      } = metadata;
      const imperativeAdapterInvoke = (config, requestContext, callback) => {
        const snapshotOrPromise = adapter(config, requestContext);
        if (snapshotOrPromise === null) {
          callback(createInvalidConfigError$1());
          return;
        }
        if (!isPromise(snapshotOrPromise)) {
          callback(snapshotToTuple$1(snapshotOrPromise));
          return;
        }
        snapshotOrPromise.then(snapshot => {
          if (snapshot === null) {
            callback(createInvalidConfigError$1());
            return;
          }
          callback(snapshotToTuple$1(snapshot));
        }).finally(() => {
          luvio.storeCleanup();
        });
      };
      defineProperty(imperativeAdapterInvoke, 'name', {
        value: `${name}_invoke`
      });
      // Invokes the adapter and subscribes to the received snapshot
      // Returns an unsubscribe function to the consumer
      const imperativeAdapterSubscribe = (config, requestContext, callback) => {
        let subscriberCallback = callback;
        let unsub;
        const snapshotOrPromise = adapter(config, requestContext);
        if (snapshotOrPromise === null) {
          subscriberCallback(createInvalidConfigError$1());
          return () => {};
        }
        // Can rebuild lead to pending snapshots?
        const luvioStoreSubscribe = snapshot => {
          unsub = luvio.storeSubscribe(snapshot, snapshotFromRebuild => {
            if (subscriberCallback !== null && !isPendingSnapshot(snapshotFromRebuild)) {
              subscriberCallback(snapshotToTuple$1(snapshotFromRebuild));
            }
          });
        };
        if (!isPromise(snapshotOrPromise)) {
          // We don't want to return pending snapshots to user-land
          // Instead we just subscribe to it
          if (!isPendingSnapshot(snapshotOrPromise)) {
            subscriberCallback(snapshotToTuple$1(snapshotOrPromise));
          }
          luvioStoreSubscribe(snapshotOrPromise);
        } else {
          snapshotOrPromise.then(snapshot => {
            if (subscriberCallback !== null) {
              if (snapshot === null) {
                subscriberCallback(createInvalidConfigError$1());
                return;
              }
              // We don't want to return pending snapshots to user-land
              // Instead we just subscribe to it
              if (!isPendingSnapshot(snapshot)) {
                subscriberCallback(snapshotToTuple$1(snapshot));
              }
              luvioStoreSubscribe(snapshot);
            }
          });
        }
        return () => {
          if (subscriberCallback !== null && unsub !== undefined) {
            unsub();
          }
          subscriberCallback = null;
          unsub = undefined;
        };
      };
      defineProperty(imperativeAdapterSubscribe, 'name', {
        value: `${name}_subscribe`
      });
      return {
        invoke: imperativeAdapterInvoke,
        subscribe: imperativeAdapterSubscribe
      };
    }
    function snapshotToTuple(snapshot) {
      if (isErrorSnapshot(snapshot)) {
        if (snapshot.error.errorType === 'adapterError') {
          // GraphQL can return 200 with an errors array
          return {
            data: undefined,
            errors: snapshot.error.error
          };
        } else {
          // This is a network error or some other error - usually with a single error bubled up.
          return {
            data: undefined,
            errors: [snapshot.error]
          };
        }
      }
      // cast any PendingSnapshot to FulfilledSnapshot here,
      //  we shouldn't get anything pending at this point
      const payload = {};
      const dataSnapshot = snapshot;
      if ('data' in dataSnapshot.data && dataSnapshot.data.data !== undefined) {
        payload.data = dataSnapshot.data.data;
      }
      if (dataSnapshot.data.errors !== undefined) {
        payload.errors = dataSnapshot.data.errors;
      }
      return payload;
    }
    function createInvalidConfigError() {
      return {
        data: undefined,
        errors: [{
          ok: false,
          status: 400,
          statusText: 'INVALID_CONFIG',
          body: undefined,
          headers: {},
          errorType: 'fetchResponse'
        }]
      };
    }
    /**
     * Creates an imperative adapter
     *
     * @param luvio Luvio
     * @param adapter luvio adapter
     * @param metadata AdapterMetadata
     * @returns Imperative adapter object with invoke and subscribe functions
     */
    function createGraphQLImperativeAdapter(luvio, adapter, metadata, astResolver) {
      const {
        name
      } = metadata;
      const imperativeAdapterInvoke = (config, requestContext, callback) => {
        let coercedConfig = null;
        if ('batchQuery' in config) {
          coercedConfig = {
            batchQuery: config.batchQuery.map(individualConfig => ({
              ...individualConfig,
              query: astResolver(individualConfig.query)
            }))
          };
          // If any of the configurations are invalid, we bail out of calling the adapter.
          if (coercedConfig.batchQuery.some(individualConfig => individualConfig.query === undefined)) {
            callback(createInvalidConfigError());
            return;
          }
        } else if ('query' in config) {
          const ast = astResolver(config.query);
          if (ast === undefined) {
            callback(createInvalidConfigError());
            return;
          }
          coercedConfig = {
            ...config,
            query: ast
          };
        }
        const snapshotOrPromise = adapter(coercedConfig, requestContext);
        if (snapshotOrPromise === null) {
          callback(createInvalidConfigError());
          return;
        }
        if (!isPromise(snapshotOrPromise)) {
          callback(snapshotToTuple(snapshotOrPromise));
          return;
        }
        snapshotOrPromise.then(snapshot => {
          if (snapshot === null) {
            callback(createInvalidConfigError());
            return;
          }
          callback(snapshotToTuple(snapshot));
        });
      };
      defineProperty(imperativeAdapterInvoke, 'name', {
        value: `${name}_invoke`
      });
      // Invokes the adapter and subscribes to the received snapshot
      // Returns an unsubscribe function to the consumer
      const imperativeAdapterSubscribe = (config, requestContext, callback) => {
        let subscriberCallback = callback;
        let unsub;
        let coercedConfig = null;
        if ('batchQuery' in config) {
          coercedConfig = {
            batchQuery: config.batchQuery.map(individualConfig => ({
              ...individualConfig,
              query: astResolver(individualConfig.query)
            }))
          };
          // If any of the configurations are invalid, we bail out of calling the adapter.
          if (coercedConfig.batchQuery.some(individualConfig => individualConfig.query === undefined)) {
            callback(createInvalidConfigError());
            return () => {};
          }
        } else if ('query' in config) {
          const ast = astResolver(config.query);
          if (ast === undefined) {
            callback(createInvalidConfigError());
            return () => {};
          }
          coercedConfig = {
            ...config,
            query: ast
          };
        }
        const snapshotOrPromise = adapter(coercedConfig, requestContext);
        if (snapshotOrPromise === null) {
          subscriberCallback(createInvalidConfigError());
          return () => {};
        }
        // Can rebuild lead to pending snapshots?
        const luvioStoreSubscribe = snapshot => {
          unsub = luvio.storeSubscribe(snapshot, snapshotFromRebuild => {
            if (subscriberCallback !== null && !isPendingSnapshot(snapshotFromRebuild)) {
              subscriberCallback(snapshotToTuple(snapshotFromRebuild));
            }
          });
        };
        if (!isPromise(snapshotOrPromise)) {
          // We don't want to return pending snapshots to user-land
          // Instead we just subscribe to it
          if (!isPendingSnapshot(snapshotOrPromise)) {
            subscriberCallback(snapshotToTuple(snapshotOrPromise));
          }
          luvioStoreSubscribe(snapshotOrPromise);
        } else {
          snapshotOrPromise.then(snapshot => {
            if (subscriberCallback !== null) {
              if (snapshot === null) {
                subscriberCallback(createInvalidConfigError());
                return;
              }
              // TODO [W-11370904]: revisit this. Does GraphQL need to worry about pending?
              // We don't want to return pending snapshots to user-land
              // Instead we just subscribe to it
              if (!isPendingSnapshot(snapshot)) {
                subscriberCallback(snapshotToTuple(snapshot));
              }
              luvioStoreSubscribe(snapshot);
            }
          });
        }
        return () => {
          if (subscriberCallback !== null && unsub !== undefined) {
            unsub();
          }
          subscriberCallback = null;
          unsub = undefined;
        };
      };
      defineProperty(imperativeAdapterSubscribe, 'name', {
        value: `${name}_subscribe`
      });
      return {
        invoke: imperativeAdapterInvoke,
        subscribe: imperativeAdapterSubscribe
      };
    }
    function createWireAdapterConstructor(luvio, adapter, metadata) {
      const {
        apiFamily,
        name
      } = metadata;
      return createWireAdapterConstructor$1(adapter, `${apiFamily}.${name}`, luvio);
    }
    function createInfiniteScrollingWireAdapterConstructor(luvio, adapter, metadata) {
      const {
        apiFamily,
        name
      } = metadata;
      return createInfiniteScrollingWireAdapterConstructor$1(adapter, `${apiFamily}.${name}`, luvio);
    }
    function createGraphQLWireAdapterConstructor(luvio, adapter, metadata, astResolver) {
      const {
        apiFamily,
        name
      } = metadata;
      return createGraphQLWireAdapterConstructor$1(adapter, `${apiFamily}.${name}`, luvio, astResolver);
    }
    // version: 1.309.0-dev21-4baf03ecaf
    const __lwc_hmr_context = { moduleHash : '98b357084df1318c8344ddb799ce6fda' };
    if (lwc.hot) {
        lwc.hot.register('force/ldsBindings/ldsBindings.js', '98b357084df1318c8344ddb799ce6fda', {"name":"ldsBindings","namespace":"force","enableLightningWebSecurityTransforms":false,"experimentalDynamicComponent":{"loader":"@salesforce/loader","strictSpecifier":false},"experimentalDynamicDirective":false,"enableDynamicComponents":true,"enableStaticContentOptimization":true,"outputConfig":{"sourcemap":false}});
    }

    exports.ADAPTER_UNFULFILLED_ERROR = ADAPTER_UNFULFILLED_ERROR;
    exports.REFRESH_ADAPTER_EVENT = REFRESH_ADAPTER_EVENT;
    exports.__lwc_hmr_context = __lwc_hmr_context;
    exports.bindWireRefresh = bindWireRefresh;
    exports.createGraphQLImperativeAdapter = createGraphQLImperativeAdapter;
    exports.createGraphQLWireAdapterConstructor = createGraphQLWireAdapterConstructor;
    exports.createImperativeAdapter = createImperativeAdapter;
    exports.createInfiniteScrollingWireAdapterConstructor = createInfiniteScrollingWireAdapterConstructor;
    exports.createInstrumentedAdapter = createInstrumentedAdapter;
    exports.createLDSAdapter = createLDSAdapter;
    exports.createWireAdapterConstructor = createWireAdapterConstructor;
    exports.instrument = instrument;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('force/luvioEngine', ['exports', 'lwc'], (function (exports, lwc) {

    /**
     * Copyright (c) 2022, Salesforce, Inc.,
     * All rights reserved.
     * For full license text, see the LICENSE.txt file
     */

    /*
     *  ATTENTION!
     *  THIS IS A GENERATED FILE FROM https://github.com/salesforce-experience-platform-emu/lds-lightning-platform
     *  If you would like to contribute to LDS, please follow the steps outlined in the git repo.
     *  Any changes made to this file in p4 will be automatically overwritten.
     *  *******************************************************************************************
     */
    /* proxy-compat-disable */
    var SnapshotState;
    (function (SnapshotState) {
      SnapshotState["Fulfilled"] = "Fulfilled";
      SnapshotState["Unfulfilled"] = "Unfulfilled";
      SnapshotState["Error"] = "Error";
      SnapshotState["Pending"] = "Pending";
      SnapshotState["Stale"] = "Stale";
    })(SnapshotState || (SnapshotState = {}));
    const {
      create,
      entries,
      freeze,
      keys,
      values,
      assign
    } = Object;
    const {
      hasOwnProperty
    } = Object.prototype;
    const {
      isArray
    } = Array;
    const {
      push,
      indexOf,
      slice
    } = Array.prototype;
    const {
      parse,
      stringify
    } = JSON;
    const WeakSetCtor = WeakSet;
    const deeplyFrozen = new WeakSetCtor();
    // Allow custom environments to bypass deep freeze for performance reasons
    let bypassDeepFreeze = false;
    function setBypassDeepFreeze(value) {
      bypassDeepFreeze = value;
    }
    function deepFreeze(value) {
      // No need to freeze primitives or already frozen stuff
      if (bypassDeepFreeze || typeof value !== 'object' || value === null || deeplyFrozen.has(value)) {
        return;
      }
      deeplyFrozen.add(value);
      if (isArray(value)) {
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepFreeze(value[i]);
        }
      } else {
        const keys$1 = keys(value);
        for (let i = 0, len = keys$1.length; i < len; i += 1) {
          deepFreeze(value[keys$1[i]]);
        }
      }
      freeze(value);
    }
    function isErrorSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Error;
    }
    function isFulfilledSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Fulfilled;
    }
    function isStaleSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Stale;
    }
    function isUnfulfilledSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Unfulfilled;
    }
    function isPendingSnapshot(snapshot) {
      return snapshot.state === SnapshotState.Pending;
    }
    function createErrorSnapshot(error, refresh) {
      deepFreeze(error);
      const snap = {
        error,
        state: SnapshotState.Error,
        data: undefined,
        refresh
      };
      return snap;
    }
    function isPromise(value) {
      if (value === undefined) {
        return false;
      }
      // check for Thenable due to test frameworks using custom Promise impls
      return value.then !== undefined;
    }
    function isNonError(obj, isError) {
      return isError === false;
    }
    function cachePolicyImplWithEvents(cachePolicyImplementation, cachePolicyType, eventObservers) {
      return wrapFunctionInEvents(cachePolicyImplementation, eventObservers, {
        type: 'adapter-lookup-start',
        cachePolicy: cachePolicyType,
        timestamp: Date.now()
      }, (_result, wasError, _, startEvent) => {
        const timestamp = Date.now();
        return {
          type: 'adapter-lookup-end',
          hasError: wasError,
          timestamp,
          duration: timestamp - startEvent.timestamp
        };
      });
    }
    function buildCachedSnapshotWithEvents(buildCachedSnapshot, eventObservers) {
      return wrapFunctionInEvents(buildCachedSnapshot, eventObservers, {
        type: 'cache-lookup-start',
        timestamp: Date.now()
      }, (result, wasError, wasAsync, startEvent) => {
        const timestamp = Date.now();
        return {
          type: 'cache-lookup-end',
          hasError: wasError,
          wasResultAsync: wasAsync,
          snapshotState: result !== undefined && isNonError(result, wasError) ? result.state : undefined,
          timestamp,
          duration: timestamp - startEvent.timestamp
        };
      });
    }
    function buildNetworkSnapshotWithEvents(buildNetworkSnapshot, eventObservers) {
      return wrapFunctionInEvents(buildNetworkSnapshot, eventObservers, {
        type: 'network-lookup-start',
        timestamp: Date.now()
      }, (_result, wasError, _, startEvent) => {
        const timestamp = Date.now();
        return {
          type: 'network-lookup-end',
          hasError: wasError,
          timestamp,
          duration: timestamp - startEvent.timestamp
        };
      });
    }
    function emitLuvioStoreEvent(event, observers = []) {
      for (const observer of observers) {
        switch (event.type) {
          case 'cache-miss-out-of-ttl':
            if (observer.onCacheMissOutOfTtl) {
              observer.onCacheMissOutOfTtl(event);
            }
            break;
          case 'data-out-of-ttl-duration-update':
            if (observer.onDataOutOfTtlDurationUpdate) {
              observer.onDataOutOfTtlDurationUpdate(event);
            }
            break;
          case 'store-reset':
            if (observer.onStoreReset) {
              observer.onStoreReset(event);
            }
            break;
          case 'store-publish':
            if (observer.onStorePublish) {
              observer.onStorePublish(event);
            }
            break;
          case 'store-snapshot-emit':
          case 'store-snapshot-rebuild':
          case 'store-snapshot-refresh':
          case 'store-snapshot-subscribe':
          case 'store-snapshot-unsubscribe':
            if (observer.onStoreSnapshotEvent) {
              observer.onStoreSnapshotEvent(event);
            }
            break;
        }
      }
    }
    function emitAdapterEvent(event, observers = []) {
      for (const observer of observers) {
        switch (event.type) {
          case 'custom':
            if (observer.onCustomAdapterEvent) {
              observer.onCustomAdapterEvent(event);
            }
            break;
          case 'environment':
            if (observer.onEnvironmentEvent) {
              observer.onEnvironmentEvent(event);
            }
            break;
          default:
            if (observer.onAdapterEvent) {
              observer.onAdapterEvent(event);
            }
            break;
        }
      }
    }
    const createCustomAdapterEventEmitter = (namespace, observers = []) => eventData => {
      emitAdapterEvent({
        type: 'custom',
        namespace,
        timestamp: Date.now(),
        data: eventData
      }, observers);
    };
    function wrapFunctionInEvents(fn, eventObservers, startEvent, buildResultEvent) {
      return function (...args) {
        emitAdapterEvent(startEvent, eventObservers);
        try {
          const result = fn(...args);
          if (isPromise(result)) {
            return result.then(x => {
              //emit async end event
              emitAdapterEvent(buildResultEvent(x, false, true, startEvent), eventObservers);
              return x;
            }).catch(e => {
              // emit async error
              emitAdapterEvent(buildResultEvent(e, true, true, startEvent), eventObservers);
              throw e;
            });
          } else {
            // emit sync success
            emitAdapterEvent(buildResultEvent(result, false, false, startEvent), eventObservers);
            return result;
          }
        } catch (e) {
          // emit sync error
          emitAdapterEvent(buildResultEvent(e, true, false, startEvent), eventObservers);
          throw e;
        }
      };
    }
    const resolvedPromise = Promise.resolve();
    function throwNext(error) {
      setTimeout(() => {
        throw error;
      }, 0);
    }
    /**
     * An alternative to flushPromises based on Promise.
     */
    function resolveImmediate(callback) {
      resolvedPromise.then(callback).catch(throwNext);
    }
    const TRIM_DEBOUNCE_TIME_MS = 5000;
    function buildDefaultScheduler() {
      let timeSinceLastTrim = Date.now() - (TRIM_DEBOUNCE_TIME_MS + 1);
      const defaultScheduler = (task, done) => {
        const now = Date.now();
        if (timeSinceLastTrim + TRIM_DEBOUNCE_TIME_MS < now) {
          timeSinceLastTrim = now;
          resolveImmediate(task);
          return done();
        }
        done();
      };
      return defaultScheduler;
    }
    var StoreErrorStatus;
    (function (StoreErrorStatus) {
      StoreErrorStatus[StoreErrorStatus["RESOURCE_NOT_FOUND"] = 404] = "RESOURCE_NOT_FOUND";
    })(StoreErrorStatus || (StoreErrorStatus = {}));
    var StoreRecordType;
    (function (StoreRecordType) {
      StoreRecordType["Error"] = "error";
    })(StoreRecordType || (StoreRecordType = {}));
    var StoreLinkStateValues$1;
    (function (StoreLinkStateValues) {
      StoreLinkStateValues[StoreLinkStateValues["NotPresent"] = 0] = "NotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefNotPresent"] = 1] = "RefNotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefPresent"] = 2] = "RefPresent";
      StoreLinkStateValues[StoreLinkStateValues["Null"] = 3] = "Null";
      StoreLinkStateValues[StoreLinkStateValues["Missing"] = 4] = "Missing";
      StoreLinkStateValues[StoreLinkStateValues["Pending"] = 5] = "Pending";
    })(StoreLinkStateValues$1 || (StoreLinkStateValues$1 = {}));
    exports.StoreResolveResultState = void 0;
    (function (StoreResolveResultState) {
      StoreResolveResultState[StoreResolveResultState["Found"] = 0] = "Found";
      StoreResolveResultState[StoreResolveResultState["Error"] = 1] = "Error";
      StoreResolveResultState[StoreResolveResultState["Null"] = 2] = "Null";
      StoreResolveResultState[StoreResolveResultState["NotPresent"] = 3] = "NotPresent";
      StoreResolveResultState[StoreResolveResultState["Stale"] = 4] = "Stale";
    })(exports.StoreResolveResultState || (exports.StoreResolveResultState = {}));

    /**
     * A deterministic JSON stringify implementation. Heavily adapted from https://github.com/epoberezkin/fast-json-stable-stringify.
     * This is needed because insertion order for JSON.stringify(object) affects output:
     * JSON.stringify({a: 1, b: 2})
     *      "{"a":1,"b":2}"
     * JSON.stringify({b: 2, a: 1})
     *      "{"b":2,"a":1}"
     * @param data Data to be JSON-stringified.
     * @returns JSON.stringified value with consistent ordering of keys.
     */
    function stableJSONStringify(node) {
      // This is for Date values.
      if (node && node.toJSON && typeof node.toJSON === 'function') {
        // eslint-disable-next-line no-param-reassign
        node = node.toJSON();
      }
      if (node === undefined) {
        return;
      }
      if (typeof node === 'number') {
        return isFinite(node) ? '' + node : 'null';
      }
      if (typeof node !== 'object') {
        return stringify(node);
      }
      let i;
      let out;
      if (isArray(node)) {
        out = '[';
        for (i = 0; i < node.length; i++) {
          if (i) {
            out += ',';
          }
          out += stableJSONStringify(node[i]) || 'null';
        }
        return out + ']';
      }
      if (node === null) {
        return 'null';
      }
      const keys$1 = keys(node).sort();
      out = '';
      for (i = 0; i < keys$1.length; i++) {
        const key = keys$1[i];
        const value = stableJSONStringify(node[key]);
        if (!value) {
          continue;
        }
        if (out) {
          out += ',';
        }
        out += stringify(key) + ':' + value;
      }
      return '{' + out + '}';
    }
    function isStoreRecordError(storeRecord) {
      return storeRecord.__type === StoreRecordType.Error;
    }
    const structuredKeySerializationCache = new WeakMap();
    function serializeStructuredKey(key) {
      if (typeof key === 'string') {
        return key;
      }
      const cacheValue = structuredKeySerializationCache.get(key);
      if (cacheValue === undefined) {
        const value = stableJSONStringify(key);
        structuredKeySerializationCache.set(key, value);
        return value;
      }
      return cacheValue;
    }
    const undefinedKeyError$1 = 'Undefined value used in StoreKeyMap operation';
    class StoreKeyMap {
      constructor() {
        this.keyMap = new Map();
        this.valueMap = new Map();
      }
      clear() {
        this.valueMap.clear();
        this.keyMap.clear();
      }
      delete(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          this.keyMap.delete(stringifiedKey);
          return this.valueMap.delete(stringifiedKey);
        } else {
          throw new Error(`${undefinedKeyError$1}: delete`);
        }
      }
      entries() {
        const recordEntries = this.valueMap.entries();
        const keyRecordArray = [];
        for (const [stringifiedKey, value] of Array.from(recordEntries)) {
          const structuredKey = this.keyMap.get(stringifiedKey);
          if (structuredKey !== undefined) {
            keyRecordArray.push([structuredKey, value]);
          }
        }
        return keyRecordArray.values();
      }
      forEachKey(callbackFn, thisArg) {
        return this.keyMap.forEach(callbackFn, thisArg);
      }
      forEachValue(callbackFn, thisArg) {
        return this.valueMap.forEach(callbackFn, thisArg);
      }
      get(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          return this.valueMap.get(stringifiedKey);
        } else {
          throw new Error(`${undefinedKeyError$1}: get`);
        }
      }
      has(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          return this.valueMap.has(stringifiedKey);
        } else {
          throw new Error(`${undefinedKeyError$1}: has`);
        }
      }
      keys() {
        return this.keyMap.values();
      }
      keysAsArray() {
        return Array.from(this.keys());
      }
      keysAsStrings() {
        return this.keyMap.keys();
      }
      /**
       * Merges in the values of the passed-in StoreKeyMap. Overwrites existing values.
       * @param sourceSet - The StoreKeyMap to merge in.
       */
      merge(sourceMap) {
        sourceMap.keyMap.forEach((value, key) => {
          this.keyMap.set(key, value);
        });
        sourceMap.valueMap.forEach((value, key) => {
          this.valueMap.set(key, value);
        });
      }
      set(key, value) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          this.keyMap.set(stringifiedKey, key);
          return this.valueMap.set(stringifiedKey, value);
        } else {
          throw new Error(`${undefinedKeyError$1}: set`);
        }
      }
      size() {
        return this.valueMap.size;
      }
      values() {
        return this.valueMap.values();
      }
    }
    const undefinedKeyError = 'Undefined value used in StoreKeySet operation';
    class StoreKeySet {
      constructor() {
        this.set = new Set();
        this.valueMap = new Map();
      }
      add(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          this.set.add(stringifiedKey);
          this.valueMap.set(stringifiedKey, key);
        } else {
          throw new Error(`${undefinedKeyError}: add`);
        }
        return this;
      }
      clear() {
        this.set.clear();
        this.valueMap.clear();
      }
      delete(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          this.set.delete(stringifiedKey);
          return this.valueMap.delete(stringifiedKey);
        } else {
          throw new Error(`${undefinedKeyError}: delete`);
        }
      }
      entries() {
        return this.valueMap.entries();
      }
      forEach(callbackFn, thisArg) {
        return this.valueMap.forEach(callbackFn, thisArg);
      }
      has(key) {
        const stringifiedKey = serializeStructuredKey(key);
        if (stringifiedKey !== undefined) {
          return this.set.has(stringifiedKey);
        } else {
          throw new Error(`${undefinedKeyError}: has`);
        }
      }
      keys() {
        return this.valueMap.values();
      }
      keysAsArray() {
        return Array.from(this.keys());
      }
      keysAsStrings() {
        return this.set.keys();
      }
      /**
       * Merges in the values of the passed-in StoreKeySet. Overwrites existing values.
       * @param sourceSet - The StoreKeySet to merge in.
       */
      merge(sourceSet) {
        sourceSet.set.forEach(value => {
          this.set.add(value);
        });
        sourceSet.valueMap.forEach((value, key) => {
          this.valueMap.set(key, value);
        });
      }
      size() {
        return this.set.size;
      }
      values() {
        return this.valueMap.values();
      }
    }
    function defaultTrimPolicy(data, deallocateFn) {
      return new Promise(resolve => {
        let deallocatedCount = 0;
        const {
          pendingTrimKeys,
          retainedIds,
          metadata
        } = data;
        const now = Date.now();
        pendingTrimKeys.forEach(key => {
          const recordExpiration = metadata[key];
          if (retainedIds[key] !== undefined || recordExpiration === undefined || recordExpiration !== undefined && recordExpiration.expirationTimestamp >= now) {
            return;
          }
          deallocateFn(key);
          deallocatedCount++;
        });
        resolve({
          deallocatedCount
        });
      });
    }
    const Serialized_StringKey_Version = '1';
    function hasOverlappingIds$1(snapshot, visitedIds) {
      const {
        length: len
      } = visitedIds;
      const {
        seenRecords
      } = snapshot;
      for (let i = 0; i < len; i += 1) {
        const id = visitedIds[i];
        if (seenRecords.has(id) || id === snapshot.recordId) {
          return true;
        }
      }
      return false;
    }
    function isNonPendingSnapshotWithNoOverlappingIds$1(snapshot, visitedIds) {
      return isPendingSnapshot(snapshot) === false && hasOverlappingIds$1(snapshot, visitedIds) === false;
    }
    function isPendingSnapshotWithNoOverlappingIds$1(snapshot, visitedIds, refreshedIds) {
      // pending snapshot need to check both visited and refreshed IDs
      // because the top-level record might only be refreshed (if it was
      // already in the store after a TTL expired then storePublish won't
      // be called).  And it's not enough to just check refreshed because
      // some records don't have TTLs so refreshedIds would be empty.
      return isPendingSnapshot(snapshot) === true && hasOverlappingIds$1(snapshot, refreshedIds) === false && hasOverlappingIds$1(snapshot, visitedIds) === false;
    }
    function getMatchingIds$1(prefix, visitedIds) {
      const matchingIds = [];
      for (let i = 0, len = visitedIds.length; i < len; i++) {
        const visitedId = visitedIds[i];
        if (visitedId.indexOf(prefix) === 0) {
          push.call(matchingIds, visitedId);
        }
      }
      return matchingIds;
    }
    const OVERRIDE_TTL_KEY_SEPARATOR = '::';
    function getTTLOverrideKey(namespace, representationName) {
      return `${namespace}${OVERRIDE_TTL_KEY_SEPARATOR}${representationName}`;
    }
    function getTTLOverride$1(ttlOverrideKey, ttlOverrides, defaultTTLOverride) {
      const override = ttlOverrides[ttlOverrideKey];
      const ttlOverride = override === undefined ? defaultTTLOverride : override;
      return ttlOverride;
    }
    class StringKeyInMemoryStore {
      constructor(options = {}) {
        // public, in memory properties
        this.records = create(null);
        this.metadata = create(null);
        this.visitedIds = create(null);
        this.refreshedIds = create(null);
        this.redirectKeys = create(null);
        this.retainedIds = create(null);
        this.ttlOverrides = create(null);
        this.snapshotSubscriptions = [];
        this.trimTask = null;
        this.pendingTrimKeys = new Set();
        this.defaultTTLOverride = undefined;
        this.watchSubscriptions = [];
        this.eventObservers = [];
        // private/protected
        this.insertedIds = create(null);
        this.reverseRedirectKeys = create(null);
        this.currentSnapshotId = 0;
        this.scheduler = options.scheduler || buildDefaultScheduler();
        if (options.initialData) {
          this.deserialize(options.initialData, options.resetInitialDataTtls);
        }
        this.trimPolicy = options.customTrimPolicy || defaultTrimPolicy;
      }
      // interface methods
      readEntry(key) {
        return this.records[this.getCanonicalRecordId(key)];
      }
      getNumEntries() {
        return keys(this.records).length;
      }
      readMetadata(key) {
        return this.metadata[this.getCanonicalRecordId(key)];
      }
      readMetadataWhere(query) {
        const keys$1 = keys(this.metadata);
        const results = [];
        const hasNamespaceQuery = hasOwnProperty.call(query, 'namespace');
        const hasRepresentationNameQuery = hasOwnProperty.call(query, 'representationName');
        const hasTtlOverrideQuery = hasOwnProperty.call(query, 'ttlOverride');
        for (let i = 0, length = keys$1.length; i < length; i++) {
          const key = keys$1[i];
          const storeMetadata = this.metadata[key];
          if (hasNamespaceQuery && storeMetadata.namespace !== query.namespace) {
            continue;
          }
          if (hasRepresentationNameQuery && storeMetadata.representationName !== query.representationName) {
            continue;
          }
          if (hasTtlOverrideQuery) {
            const ttlOverride = this.ttlOverrides[getTTLOverrideKey(storeMetadata.namespace, storeMetadata.representationName)];
            if (ttlOverride !== query.ttlOverride) {
              continue;
            }
          }
          results.push({
            metadata: storeMetadata,
            key
          });
        }
        return results;
      }
      put(recordId, record) {
        const {
          records,
          insertedIds,
          pendingTrimKeys,
          retainedIds
        } = this;
        const canonicalKey = this.getCanonicalRecordId(recordId);
        if (hasOwnProperty.call(records, canonicalKey) === false) {
          insertedIds[canonicalKey] = true;
        }
        records[canonicalKey] = record;
        // if this id is not retained, add it to the pendingTrim collection.
        // this does not mean it will be trimmed right away, it still needs to be expired
        // and if this key is subsequently subscribed to it will be retained and no longer considered for
        // trim
        if (retainedIds[canonicalKey] === undefined) {
          pendingTrimKeys.add(canonicalKey);
        }
        {
          freeze(record);
        }
      }
      publish(recordId, record) {
        // make sure we publish to the canonical record id in case it's been redirected
        const canonicalKey = this.getCanonicalRecordId(recordId);
        this.put(canonicalKey, record);
        this.markVisited(canonicalKey);
        // TODO: Emit event for store publish once structured keys are used everywhere.
      }
      /**
       * Given a record id, this method returns the key where the corresponding data is actually stored.
       * It could be that this record id has been redirected, so this method will follow the redirects, if applicable,
       * and return the canonical key for the record
       * @param recordId The original location of the record
       * @returns The canonical key where the record is stored
       */
      getCanonicalRecordId(recordId) {
        let canonicalKey = recordId;
        const {
          redirectKeys
        } = this;
        while (redirectKeys[canonicalKey]) {
          canonicalKey = redirectKeys[canonicalKey];
        }
        return canonicalKey;
      }
      getRedirectLineage(key) {
        const {
          redirectKeys
        } = this;
        const lineage = [];
        if (redirectKeys[key] === undefined) {
          return [];
        }
        let canonicalKey = key;
        while (redirectKeys[canonicalKey] !== undefined) {
          push.call(lineage, canonicalKey);
          canonicalKey = redirectKeys[canonicalKey];
        }
        return lineage;
      }
      redirect(key, canonicalKey) {
        const {
          redirectKeys,
          reverseRedirectKeys
        } = this;
        if (key === canonicalKey) {
          throw new Error('cannot redirect a key to itself');
        }
        if (reverseRedirectKeys[canonicalKey] !== undefined && reverseRedirectKeys[canonicalKey] !== key) {
          throw new Error('cannot have multiple redirects keys point to the same canonical key');
        }
        if (redirectKeys[canonicalKey] !== undefined) {
          throw new Error('the canonical key must be terminal and cannot already be part of a redirect chain');
        }
        redirectKeys[key] = canonicalKey;
        reverseRedirectKeys[canonicalKey] = key;
        // evict key at original location as it now lives at the canonical key
        delete this.records[key];
        this.visitedIds[key] = true;
      }
      broadcast(rebuildSnapshot, snapshotAvailable) {
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions,
          watchSubscriptions,
          visitedIds,
          refreshedIds,
          insertedIds
        } = this;
        const allVisitedIds = keys(visitedIds);
        const allRefreshedIds = keys(refreshedIds);
        // Early exit if nothing has changed
        if (allVisitedIds.length === 0 && allRefreshedIds.length === 0) {
          return Promise.resolve();
        }
        // Process snapshot subscriptions
        const snapshotSubPromises = [];
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot
          } = subscription;
          // Don't re-emit the snapshot if there is no overlap between the visited keys and the
          // snapshot seen keys.
          if (isErrorSnapshot(snapshot) || isNonPendingSnapshotWithNoOverlappingIds$1(snapshot, allVisitedIds) || isPendingSnapshotWithNoOverlappingIds$1(snapshot, allVisitedIds, allRefreshedIds)) {
            continue;
          }
          snapshotSubPromises.push(new Promise(resolve => {
            rebuildSnapshot(snapshot, rebuiltSnapshot => {
              emitLuvioStoreEvent({
                type: 'store-snapshot-rebuild',
                timestamp: Date.now(),
                snapshot: rebuiltSnapshot,
                subscriptionId: subscription.id
              }, this.eventObservers);
              this.emitOrRefreshRebuiltSnapshot(rebuiltSnapshot, subscription, snapshotAvailable).then(() => resolve());
            });
          }));
        }
        // Process watch subscriptions
        for (let i = 0, len = watchSubscriptions.length; i < len; i++) {
          const {
            prefix,
            callback
          } = watchSubscriptions[i];
          const matchingIds = getMatchingIds$1(prefix, allVisitedIds);
          if (matchingIds.length > 0) {
            const watchCallbackEntries = [];
            for (let i = 0, len = matchingIds.length; i < len; i++) {
              const id = matchingIds[i];
              const inserted = insertedIds[id] || false;
              push.call(watchCallbackEntries, {
                id,
                inserted
              });
            }
            callback(watchCallbackEntries);
          }
        }
        this.visitedIds = create(null);
        this.refreshedIds = create(null);
        this.insertedIds = create(null);
        // the .then removes the return of an array of voids to a single void
        return Promise.all(snapshotSubPromises).then(() => {});
      }
      /**
       * Broadcasts an ErrorSnapshot to any Pending snapshots for the given
       * recordId.
       */
      broadcastNonCachedSnapshot(recordId, errorSnapshot) {
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions
        } = this;
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot,
            callback
          } = subscription;
          // if the subscriber is pending and its recordId matches then emit
          // the error to it
          if (isPendingSnapshot(snapshot) && snapshot.recordId === recordId) {
            subscription.snapshot = errorSnapshot;
            callback(errorSnapshot);
          }
        }
      }
      lookup(selector, createSnapshot, refresh, ttlStrategy) {
        return createSnapshot(selector, refresh, ttlStrategy);
      }
      subscribe(snapshot, callback) {
        const subscription = {
          id: this.currentSnapshotId++,
          snapshot,
          callback
        };
        emitLuvioStoreEvent({
          type: 'store-snapshot-subscribe',
          subscriptionId: subscription.id,
          snapshot,
          timestamp: Date.now()
        }, this.eventObservers);
        this.snapshotSubscriptions = [...this.snapshotSubscriptions, subscription];
        if (!isErrorSnapshot(snapshot)) {
          this.retainSnapshotIds(snapshot);
        }
        return () => {
          const {
            snapshotSubscriptions
          } = this;
          const index = indexOf.call(snapshotSubscriptions, subscription);
          // only attempt to slice if the subscription is in the list (in case someone
          // calls unsubscribe multiple times)
          if (index > -1) {
            this.snapshotSubscriptions = [...slice.call(snapshotSubscriptions, 0, index), ...slice.call(snapshotSubscriptions, index + 1)];
            {
              this.snapshotSubscriptions = freeze(this.snapshotSubscriptions);
            }
            // need to re-gather snapshot associated Ids to capture latest refs
            const {
              snapshot,
              id: uuid
            } = subscription;
            emitLuvioStoreEvent({
              type: 'store-snapshot-unsubscribe',
              subscriptionId: uuid,
              snapshot,
              timestamp: Date.now()
            }, this.eventObservers);
            if (!isErrorSnapshot(snapshot)) {
              this.releaseSnapshotIds(snapshot);
            }
          }
        };
      }
      updateAvailable(keys) {
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions
        } = this;
        // read metadata for each key, and mark as expired
        this.expirePossibleStaleRecords(keys);
        // Process snapshot subscriptions
        const pendingPromises = [];
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot,
            id
          } = subscription;
          if (isErrorSnapshot(snapshot)) {
            // TODO: If we want to support refreshing Error Snapshots, we will need
            // to update the ErrorSnapshot interface to include the recordId, or
            // resolve the snapshot through its refresh.config property
            continue;
          }
          if (!hasOverlappingIds$1(snapshot, keys)) {
            continue;
          }
          pendingPromises.push(this.refreshSnapshot(snapshot, id, 'update-available'));
        }
        // resolves after all snapshots refresh resolve
        // for now catch in case of reject and resolve
        return Promise.all(pendingPromises).then(_promises => undefined).catch(_err => Promise.resolve(undefined));
      }
      retain(keys) {
        const keysLength = keys.length;
        for (let i = 0; i < keysLength; i++) {
          const key = keys[i];
          this.increaseRetentionCount(key);
        }
        return () => {
          this.release(keys);
        };
      }
      watch(prefix, callback) {
        const subscription = {
          prefix,
          callback
        };
        this.watchSubscriptions = [...this.watchSubscriptions, subscription];
        return () => {
          const {
            watchSubscriptions
          } = this;
          const index = indexOf.call(watchSubscriptions, subscription);
          this.watchSubscriptions = [...slice.call(watchSubscriptions, 0, index), ...slice.call(watchSubscriptions, index + 1)];
          {
            this.watchSubscriptions = freeze(this.watchSubscriptions);
          }
        };
      }
      /**
       * Evicts data at the canonical key location and marks any redirects (if applicable)
       * to the key as visited
       * @param key key to evict
       */
      evict(key) {
        // find and evict the canonical key
        const canonicalKey = this.getCanonicalRecordId(key);
        delete this.records[canonicalKey];
        this.markVisited(canonicalKey);
      }
      cleanup() {
        this.scheduleTrim();
      }
      /**
       * Deallocates data at the canonical key location for in-memory (L1) cache
       * @param key key to deallocate
       */
      dealloc(key) {
        // find and deallocate the canonical key
        const canonicalKey = this.getCanonicalRecordId(key);
        delete this.records[canonicalKey];
      }
      keyExistsInStore(key) {
        return this.records[key] !== undefined;
      }
      publishMetadata(key, storeMetadata) {
        this.putMetadata(key, storeMetadata, true);
        const canonicalKey = this.getCanonicalRecordId(key);
        this.markRefreshed(canonicalKey);
      }
      putMetadata(key, storeMetadata, adjustTTLOverride) {
        const {
          namespace,
          representationName,
          ingestionTimestamp
        } = storeMetadata;
        const ttlOverrideKey = getTTLOverrideKey(namespace, representationName);
        const ttlOverride = getTTLOverride$1(ttlOverrideKey, this.ttlOverrides, this.defaultTTLOverride);
        const canonicalKey = this.getCanonicalRecordId(key);
        if (ttlOverride !== undefined && adjustTTLOverride === true) {
          const newExpiration = ingestionTimestamp + ttlOverride;
          // Create a new StoreMetadata object and publish the new object to storeMetadata.
          const metaDataOverride = {
            ...storeMetadata,
            expirationTimestamp: newExpiration
          };
          this.metadata[canonicalKey] = metaDataOverride;
        } else {
          // If it does not exist, publish the user passed StoreMetadata into the storeMetadata map.
          this.metadata[canonicalKey] = storeMetadata;
        }
      }
      expirePossibleStaleRecords(keys) {
        const expirationTimestamp = Date.now() - 1;
        for (let i = 0, len = keys.length; i < len; i++) {
          const key = keys[i];
          const metadata = this.readMetadata(key);
          if (metadata !== undefined) {
            this.publishMetadata(key, {
              ...metadata,
              expirationTimestamp
            });
          }
        }
      }
      setTTLOverride(namespace, representationName, ttl) {
        this.ttlOverrides[getTTLOverrideKey(namespace, representationName)] = ttl;
      }
      getTTLOverride(namespace, representationName) {
        return this.ttlOverrides[getTTLOverrideKey(namespace, representationName)];
      }
      getTTLOverrides() {
        return this.ttlOverrides;
      }
      setDefaultTTLOverride(ttl) {
        this.defaultTTLOverride = ttl;
      }
      getDefaultTTLOverride() {
        return this.defaultTTLOverride;
      }
      reset() {
        this.records = create(null);
        this.snapshotSubscriptions = [];
        this.watchSubscriptions = [];
        this.visitedIds = create(null);
        this.refreshedIds = create(null);
        this.insertedIds = create(null);
        this.redirectKeys = create(null);
        this.reverseRedirectKeys = create(null);
        this.retainedIds = create(null);
        this.ttlOverrides = create(null);
        this.trimTask = null;
        this.metadata = create(null);
        this.defaultTTLOverride = undefined;
        emitLuvioStoreEvent({
          type: 'store-reset',
          timestamp: Date.now()
        }, this.eventObservers);
      }
      addStoreEventObserver(storeEventObserver) {
        this.eventObservers.push(storeEventObserver);
        return () => {
          const {
            eventObservers
          } = this;
          const index = this.eventObservers.indexOf(storeEventObserver);
          if (index > -1) {
            this.eventObservers = [...slice.call(eventObservers, 0, index), ...slice.call(eventObservers, index + 1)];
          }
        };
      }
      // public in memory methods
      scheduleTrim() {
        if (this.trimTask === null) {
          this.trimTask = () => {
            const {
              metadata,
              pendingTrimKeys,
              retainedIds,
              records: storeRecords,
              dealloc
            } = this;
            return this.trimPolicy({
              metadata,
              pendingTrimKeys,
              retainedIds,
              storeRecords
            }, dealloc.bind(this)).then(result => {
              this.pendingTrimKeys.clear();
              const {
                trimKeysSkipped
              } = result;
              if (trimKeysSkipped !== undefined) {
                this.pendingTrimKeys = trimKeysSkipped;
              }
              return result;
            });
          };
          this.scheduler(this.trimTask, () => {
            this.trimTask = null;
          });
        }
      }
      buildIngestionStagingStore() {
        const stagingStore = new StringKeyInMemoryStore();
        const upstreamStore = this;
        const originalReadEntry = stagingStore.readEntry.bind(stagingStore);
        const originalReadMetadata = stagingStore.readMetadata.bind(stagingStore);
        const originalEvict = stagingStore.evict.bind(stagingStore);
        // the staging store will read from the upstream store if it doesn't have the data
        // this is because some adapters will only do partial ingests if they determine data
        // is already in L1 prior to ingestion
        stagingStore.readEntry = key => {
          const entry = originalReadEntry(key);
          if (entry === undefined) {
            return upstreamStore.readEntry(key);
          }
          return entry;
        };
        stagingStore.readMetadata = key => {
          const metadata = originalReadMetadata(key);
          if (!metadata) {
            return upstreamStore.readMetadata(key);
          }
          return metadata;
        };
        stagingStore.evict = key => {
          originalEvict(key);
          upstreamStore.evict(key);
        };
        stagingStore.ttlOverrides = upstreamStore.ttlOverrides;
        stagingStore.defaultTTLOverride = upstreamStore.defaultTTLOverride;
        stagingStore.redirectKeys = upstreamStore.redirectKeys;
        stagingStore.reverseRedirectKeys = upstreamStore.reverseRedirectKeys;
        return stagingStore;
      }
      // private/protected methodss
      /**
       * Updates a subscription with a new snapshot and performs retention book-keeping
       * on the existing and new snapshot.
       */
      updateSubscriptionSnapshot(subscription, newSnapshot) {
        const {
          snapshot: oldSnapshot
        } = subscription;
        if (oldSnapshot === newSnapshot) {
          return;
        }
        subscription.snapshot = newSnapshot;
        if (!isErrorSnapshot(newSnapshot)) {
          this.retainSnapshotIds(newSnapshot);
        }
        if (!isErrorSnapshot(oldSnapshot)) {
          this.releaseSnapshotIds(oldSnapshot);
        }
      }
      refreshSnapshot(snapshot, subscriptionId, reason) {
        const {
          refresh
        } = snapshot;
        if (refresh !== undefined) {
          emitLuvioStoreEvent({
            type: 'store-snapshot-refresh',
            subscriptionId,
            reason,
            snapshot,
            timestamp: Date.now()
          }, this.eventObservers);
          return refresh.resolve(refresh.config);
        }
        return Promise.resolve(undefined);
      }
      instrumentIngestedNewData(snapshot, rebuiltSnapshot) {
        const recordId = rebuiltSnapshot.recordId;
        {
          if (typeof recordId !== 'string') {
            throw new Error(`Received invalid snapshot.recordId value: ${snapshot.recordId}`);
          }
        }
        const recordMetadata = this.metadata[recordId];
        // Non-batch scenario
        if (recordMetadata) {
          emitLuvioStoreEvent({
            type: 'cache-miss-out-of-ttl',
            oldSnapshot: snapshot,
            newSnapshot: rebuiltSnapshot,
            recordId,
            recordMetadata,
            timestamp: Date.now()
          }, this.eventObservers);
        } else {
          rebuiltSnapshot.seenRecords.keysAsArray().forEach(seenRecordId => {
            const seenRecordMetadata = this.metadata[seenRecordId];
            if (seenRecordMetadata) {
              emitLuvioStoreEvent({
                type: 'cache-miss-out-of-ttl',
                oldSnapshot: snapshot,
                newSnapshot: rebuiltSnapshot,
                recordId: seenRecordId,
                recordMetadata: seenRecordMetadata,
                timestamp: Date.now()
              }, this.eventObservers);
            }
          });
        }
      }
      emitOrRefreshRebuiltSnapshot(rebuiltSnapshot, subscription, snapshotAvailable) {
        const {
          snapshot,
          callback,
          id: subscriptionId
        } = subscription;
        // if the rebuilt snapshot is pending then continue on, broadcast will get
        // called again once the pending snapshot is resolved
        if (isPendingSnapshot(rebuiltSnapshot)) {
          if (isPendingSnapshot(snapshot)) {
            this.updateSubscriptionSnapshot(subscription, rebuiltSnapshot);
          }
          return Promise.resolve();
        }
        this.updateSubscriptionSnapshot(subscription, rebuiltSnapshot);
        if (snapshotAvailable(rebuiltSnapshot)) {
          // TODO [W-10186366]: revisit if we want to handle errors thrown in user-land callback
          if (rebuiltSnapshot !== snapshot) {
            emitLuvioStoreEvent({
              type: 'store-snapshot-emit',
              snapshot: rebuiltSnapshot,
              timestamp: Date.now(),
              subscriptionId
            }, this.eventObservers);
            callback(rebuiltSnapshot);
          }
          this.instrumentIngestedNewDataOnFulfilledSnapshots(snapshot, rebuiltSnapshot);
        } else if (isUnfulfilledSnapshot(rebuiltSnapshot)) {
          return this.refreshSnapshot(rebuiltSnapshot, subscriptionId, 'rebuild-unfulfilled').then();
        }
        return Promise.resolve();
      }
      instrumentIngestedNewDataOnFulfilledSnapshots(snapshot, rebuiltSnapshot) {
        if (isFulfilledSnapshot(snapshot) && isFulfilledSnapshot(rebuiltSnapshot)) {
          this.instrumentIngestedNewData(snapshot, rebuiltSnapshot);
        }
      }
      retainSnapshotIds(snapshot) {
        const recordId = snapshot.recordId;
        {
          if (typeof recordId !== 'string') {
            throw new Error(`Received invalid snapshot.recordId value: ${snapshot.recordId}`);
          }
        }
        const {
          seenRecords
        } = snapshot;
        const snapshotRetainedIds = seenRecords === undefined ? [recordId] : [recordId, ...Array.from(seenRecords.keysAsStrings())];
        this.retain(snapshotRetainedIds);
      }
      releaseSnapshotIds(snapshot) {
        const recordId = snapshot.recordId;
        {
          if (typeof recordId !== 'string') {
            throw new Error(`Received invalid snapshot.recordId value: ${snapshot.recordId}`);
          }
        }
        const {
          seenRecords
        } = snapshot;
        const snapshotReleaseIds = seenRecords === undefined ? [recordId] : [recordId, ...Array.from(seenRecords.keysAsStrings())];
        this.release(snapshotReleaseIds);
      }
      increaseRetentionCount(key) {
        const count = this.retainedIds[key];
        this.retainedIds[key] = count === undefined ? 1 : count + 1;
        // do not consider this key for trim while retained
        this.pendingTrimKeys.delete(key);
      }
      decreaseRetentionCount(key) {
        const count = this.retainedIds[key];
        if (count === 1) {
          // consider this key for trimming when ref count goes to zero
          this.pendingTrimKeys.add(key);
          return delete this.retainedIds[key];
        } else if (count === undefined) {
          return false;
        } else {
          this.retainedIds[key] = count - 1;
        }
        return false;
      }
      release(keys) {
        const keysLength = keys.length;
        let shouldScheduleTrim = false;
        for (let i = 0; i < keysLength; i++) {
          const key = keys[i];
          const result = this.decreaseRetentionCount(key);
          if (result === true) {
            shouldScheduleTrim = true;
          }
        }
        // only schedule trim if an entry is removed from retention map
        if (shouldScheduleTrim === true) {
          // schedule trim for next tick
          this.scheduleTrim();
        }
      }
      markVisited(canonicalKey) {
        const {
          visitedIds,
          reverseRedirectKeys
        } = this;
        visitedIds[canonicalKey] = true;
        // mark all redirects leading up to the canonical key as visited so
        // affected snapshots are updated
        let redirectKey = reverseRedirectKeys[canonicalKey];
        while (redirectKey !== undefined) {
          visitedIds[redirectKey] = true;
          redirectKey = reverseRedirectKeys[redirectKey];
        }
      }
      markRefreshed(canonicalKey) {
        const {
          refreshedIds,
          reverseRedirectKeys
        } = this;
        refreshedIds[canonicalKey] = true;
        // mark all redirects leading up to the canonical key as refreshed so
        // affected snapshots are updated
        let redirectKey = reverseRedirectKeys[canonicalKey];
        while (redirectKey !== undefined) {
          refreshedIds[redirectKey] = true;
          redirectKey = reverseRedirectKeys[redirectKey];
        }
      }
      serialize() {
        return {
          luvioStoreData: {
            data: this.records,
            metadata: this.metadata,
            version: Serialized_StringKey_Version
          }
        };
      }
      deserialize(storeData, resetInitialDataTtls) {
        const luvioStoreData = storeData.luvioStoreData;
        if (Serialized_StringKey_Version === luvioStoreData.version) {
          this.records = luvioStoreData.data;
          this.metadata = this.calculateAndSetNewTTLs(luvioStoreData.metadata, resetInitialDataTtls);
        }
      }
      calculateAndSetNewTTLs(storeMetadata, resetInitialDataTtls) {
        if (resetInitialDataTtls === true) {
          const now = Date.now();
          keys(storeMetadata).forEach(key => {
            const storeMetadataEntry = storeMetadata[key];
            const ttl = storeMetadataEntry.expirationTimestamp - storeMetadataEntry.ingestionTimestamp;
            storeMetadataEntry.ingestionTimestamp = now;
            storeMetadataEntry.expirationTimestamp = now + ttl;
          });
        }
        return storeMetadata;
      }
    }
    function hasOverlappingIds(snapshot, visitedIds) {
      const {
        seenRecords
      } = snapshot;
      return visitedIds.some(id => seenRecords.has(id) || id === snapshot.recordId);
    }
    function isNonPendingSnapshotWithNoOverlappingIds(snapshot, visitedIds) {
      return isPendingSnapshot(snapshot) === false && hasOverlappingIds(snapshot, visitedIds) === false;
    }
    function isPendingSnapshotWithNoOverlappingIds(snapshot, visitedIds, refreshedIds) {
      // pending snapshot need to check both visited and refreshed IDs
      // because the top-level record might only be refreshed (if it was
      // already in the store after a TTL expired then storePublish won't
      // be called).  And it's not enough to just check refreshed because
      // some records don't have TTLs so refreshedIds would be empty.
      return isPendingSnapshot(snapshot) === true && hasOverlappingIds(snapshot, refreshedIds) === false && hasOverlappingIds(snapshot, visitedIds) === false;
    }
    function getMatchingIds(partialKey, visitedIds) {
      const keys$1 = keys(partialKey);
      return visitedIds.filter(visitedId => {
        return keys$1.every(key => {
          return partialKey[key] === visitedId[key];
        });
      });
    }
    function getTTLOverride(ttlOverrideKey, ttlOverrides, defaultTTLOverride) {
      const override = ttlOverrides.get(ttlOverrideKey);
      const ttlOverride = override === undefined ? defaultTTLOverride : override;
      return ttlOverride;
    }
    class InMemoryStore {
      constructor(options = {}) {
        // public, in memory properties
        this.recordsMap = new StoreKeyMap();
        this.metadataMap = new StoreKeyMap();
        this.visitedIdsSet = new StoreKeySet();
        this.refreshedIdsSet = new StoreKeySet();
        this.redirectKeysMap = new StoreKeyMap();
        this.retainedIdsMap = new StoreKeyMap();
        this.ttlOverridesMap = new StoreKeyMap();
        // End Structured Key Variables
        this.snapshotSubscriptions = [];
        this.trimTask = null;
        this.pendingTrims = new StoreKeySet();
        this.defaultTTLOverride = undefined;
        this.watchSubscriptions = [];
        this.eventObservers = [];
        // private/protected
        this.insertedIdsSet = new StoreKeySet();
        this.reverseRedirectKeysMap = new StoreKeyMap();
        this.scheduler = options.scheduler || buildDefaultScheduler();
        this.fallbackStringKeyInMemoryStore = new StringKeyInMemoryStore(options);
      }
      // interface methods
      readEntry(key) {
        if (typeof key === 'string') {
          return this.fallbackStringKeyInMemoryStore.readEntry(key);
        }
        return this.recordsMap.get(key);
      }
      getNumEntries() {
        const numKeys = this.recordsMap.size();
        if (numKeys === 0) {
          return this.fallbackStringKeyInMemoryStore.getNumEntries();
        }
        return numKeys;
      }
      readMetadata(key) {
        if (typeof key === 'string') {
          return this.fallbackStringKeyInMemoryStore.readMetadata(key);
        }
        return this.metadataMap.get(key);
      }
      readMetadataWhere(query) {
        const keys = this.metadataMap.keysAsArray();
        if (keys.length === 0) {
          return this.fallbackStringKeyInMemoryStore.readMetadataWhere(query);
        }
        const results = [];
        const hasNamespaceQuery = hasOwnProperty.call(query, 'namespace');
        const hasRepresentationNameQuery = hasOwnProperty.call(query, 'representationName');
        const hasTtlOverrideQuery = hasOwnProperty.call(query, 'ttlOverride');
        for (let i = 0, length = keys.length; i < length; i++) {
          const key = keys[i];
          const storeMetadata = this.metadataMap.get(key);
          if (storeMetadata) {
            if (hasNamespaceQuery && storeMetadata.namespace !== query.namespace) {
              continue;
            }
            if (hasRepresentationNameQuery && storeMetadata.representationName !== query.representationName) {
              continue;
            }
            if (hasTtlOverrideQuery) {
              const ttlOverride = this.ttlOverridesMap.get(this.buildStructuredKey(storeMetadata.namespace, storeMetadata.representationName, {}));
              if (ttlOverride !== query.ttlOverride) {
                continue;
              }
            }
            results.push({
              metadata: storeMetadata,
              key
            });
          }
        }
        return results;
      }
      put(recordId, record) {
        if (typeof recordId === 'string') {
          this.fallbackStringKeyInMemoryStore.put(recordId, record);
          return;
        }
        const {
          recordsMap,
          insertedIdsSet,
          pendingTrims,
          retainedIdsMap
        } = this;
        // make sure we publish to the canonical record id in case it's been redirected
        const canonicalKey = this.getCanonicalRecordId(recordId);
        if (recordsMap.get(canonicalKey) === false) {
          insertedIdsSet.add(canonicalKey);
        }
        recordsMap.set(canonicalKey, record);
        // if this id is not retained, add it to the pendingTrim collection.
        // this does not mean it will be trimmed right away, it still needs to be expired
        // and if this key is subsequently subscribed to it will be retained and no longer considered for
        // trim
        if (retainedIdsMap.get(canonicalKey) === undefined) {
          pendingTrims.add(canonicalKey);
        }
        {
          freeze(record);
        }
      }
      publish(recordId, record) {
        if (typeof recordId === 'string') {
          this.fallbackStringKeyInMemoryStore.publish(recordId, record);
          return;
        }
        const canonicalKey = this.getCanonicalRecordId(recordId);
        this.put(canonicalKey, record);
        this.markVisited(canonicalKey);
        this.emitStorePublishEvent(recordId);
      }
      /**
       * Given a record id, this method returns the key where the corresponding data is actually stored.
       * It could be that this record id has been redirected, so this method will follow the redirects, if applicable,
       * and return the canonical key for the record
       * @param recordId The original location of the record
       * @returns The canonical key where the record is stored
       */
      getCanonicalRecordId(recordId) {
        if (typeof recordId === 'string') {
          return this.fallbackStringKeyInMemoryStore.getCanonicalRecordId(recordId);
        }
        const {
          redirectKeysMap
        } = this;
        let canonicalKey = recordId;
        while (redirectKeysMap.get(canonicalKey)) {
          canonicalKey = redirectKeysMap.get(canonicalKey);
        }
        return canonicalKey;
      }
      getRedirectLineage(key) {
        if (typeof key === 'string') {
          return this.fallbackStringKeyInMemoryStore.getRedirectLineage(key);
        }
        const {
          redirectKeysMap
        } = this;
        const lineage = [];
        let canonicalKey = redirectKeysMap.get(key);
        while (canonicalKey !== undefined) {
          push.call(lineage, canonicalKey);
          canonicalKey = redirectKeysMap.get(canonicalKey);
        }
        return lineage;
      }
      redirect(key, canonicalKey) {
        if (typeof key === 'string' && typeof canonicalKey === 'string') {
          this.fallbackStringKeyInMemoryStore.redirect(key, canonicalKey);
          return;
        }
        if (typeof key === 'string' || typeof canonicalKey === 'string') {
          throw new Error('cannot have key and canonicalKey of different types');
        }
        const {
          redirectKeysMap,
          reverseRedirectKeysMap
        } = this;
        if (key === canonicalKey) {
          throw new Error('cannot redirect a key to itself');
        }
        if (reverseRedirectKeysMap.has(canonicalKey)) {
          throw new Error('cannot have multiple redirects keys point to the same canonical key');
        }
        if (redirectKeysMap.has(canonicalKey)) {
          throw new Error('the canonical key must be terminal and cannot already be part of a redirect chain');
        }
        redirectKeysMap.set(key, canonicalKey);
        reverseRedirectKeysMap.set(canonicalKey, key);
        // evict key at original location as it now lives at the canonical key
        this.recordsMap.delete(key);
        this.visitedIdsSet.add(key);
      }
      broadcast(rebuildSnapshot, snapshotAvailable) {
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions,
          watchSubscriptions,
          visitedIdsSet,
          refreshedIdsSet,
          insertedIdsSet
        } = this;
        const allVisitedIds = visitedIdsSet.keysAsArray();
        const allRefreshedIds = refreshedIdsSet.keysAsArray();
        // Early exit if nothing has changed
        if (allVisitedIds.length === 0 && allRefreshedIds.length === 0) {
          if (this.isUsingStringKeys()) {
            return this.fallbackStringKeyInMemoryStore.broadcast(rebuildSnapshot, snapshotAvailable);
          }
          return Promise.resolve();
        }
        // Process snapshot subscriptions
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot
          } = subscription;
          // Don't re-emit the snapshot if there is no overlap between the visited keys and the
          // snapshot seen keys.
          if (isErrorSnapshot(snapshot) || isNonPendingSnapshotWithNoOverlappingIds(snapshot, allVisitedIds) || isPendingSnapshotWithNoOverlappingIds(snapshot, allVisitedIds, allRefreshedIds)) {
            continue;
          }
          rebuildSnapshot(snapshot, asyncAvailableSnapshot => {
            this.emitOrRefreshRebuiltSnapshot(asyncAvailableSnapshot, subscription, snapshotAvailable);
          });
        }
        // Process watch subscriptions
        for (let i = 0, len = watchSubscriptions.length; i < len; i++) {
          const {
            partialKey,
            callback
          } = watchSubscriptions[i];
          const matchingIds = getMatchingIds(partialKey, allVisitedIds);
          if (matchingIds.length > 0) {
            const watchCallbackEntries = [];
            for (let i = 0, len = matchingIds.length; i < len; i++) {
              const id = matchingIds[i];
              const inserted = insertedIdsSet.has(id);
              push.call(watchCallbackEntries, {
                id,
                inserted
              });
            }
            callback(watchCallbackEntries);
          }
        }
        this.visitedIdsSet = new StoreKeySet();
        this.refreshedIdsSet = new StoreKeySet();
        this.insertedIdsSet = new StoreKeySet();
        return Promise.resolve();
      }
      /**
       * Broadcasts an ErrorSnapshot to any Pending snapshots for the given
       * recordId.
       */
      broadcastNonCachedSnapshot(key, errorSnapshot) {
        if (typeof key === 'string') {
          this.fallbackStringKeyInMemoryStore.broadcastNonCachedSnapshot(key, errorSnapshot);
          return;
        }
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions
        } = this;
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot,
            callback
          } = subscription;
          // if the subscriber is pending and its recordId matches then emit
          // the error to it
          if (isPendingSnapshot(snapshot) && snapshot.recordId === key) {
            subscription.snapshot = errorSnapshot;
            callback(errorSnapshot);
          }
        }
      }
      lookup(selector, createSnapshot, refresh, ttlStrategy) {
        return createSnapshot(selector, refresh, ttlStrategy);
      }
      subscribe(snapshot, callback) {
        if (this.delegateToFallbackStringKeyStore(snapshot)) {
          return this.fallbackStringKeyInMemoryStore.subscribe(snapshot, callback);
        }
        const subscription = {
          snapshot,
          callback
        };
        this.snapshotSubscriptions = [...this.snapshotSubscriptions, subscription];
        if (!isErrorSnapshot(snapshot)) {
          this.retainSnapshotIds(snapshot);
        }
        return () => {
          const {
            snapshotSubscriptions
          } = this;
          const index = indexOf.call(snapshotSubscriptions, subscription);
          // only attempt to slice if the subscription is in the list (in case someone
          // calls unsubscribe multiple times)
          if (index > -1) {
            this.snapshotSubscriptions = [...slice.call(snapshotSubscriptions, 0, index), ...slice.call(snapshotSubscriptions, index + 1)];
            {
              this.snapshotSubscriptions = freeze(this.snapshotSubscriptions);
            }
            // need to re-gather snapshot associated Ids to capture latest refs
            const {
              snapshot
            } = subscription;
            if (!isErrorSnapshot(snapshot)) {
              this.releaseSnapshotIds(snapshot);
            }
          }
        };
      }
      updateAvailable(keys) {
        if (keys.length > 0 && typeof keys[0] === 'string') {
          return this.fallbackStringKeyInMemoryStore.updateAvailable(keys);
        }
        // Note: we should always get the subscription references from this at the beginning
        // of the function, in case the reference changes (because of an unsubscribe)
        const {
          snapshotSubscriptions
        } = this;
        // read metadata for each key, and mark as expired
        this.expirePossibleStaleRecords(keys);
        // Process snapshot subscriptions
        const pendingPromises = [];
        for (let i = 0, len = snapshotSubscriptions.length; i < len; i++) {
          const subscription = snapshotSubscriptions[i];
          const {
            snapshot
          } = subscription;
          if (isErrorSnapshot(snapshot)) {
            // TODO: If we want to support refreshing Error Snapshots, we will need
            // to update the ErrorSnapshot interface to include the recordId, or
            // resolve the snapshot through its refresh.config property
            continue;
          }
          if (!hasOverlappingIds(snapshot, keys)) {
            continue;
          }
          pendingPromises.push(this.refreshSnapshot(snapshot));
        }
        // resolves after all snapshots refresh resolve
        // for now catch in case of reject and resolve
        return Promise.all(pendingPromises).then(_promises => undefined).catch(_err => Promise.resolve(undefined));
      }
      retain(keys) {
        if (keys.length > 0 && typeof keys[0] === 'string') {
          return this.fallbackStringKeyInMemoryStore.retain(keys);
        }
        for (let i = 0, keysLength = keys.length; i < keysLength; i++) {
          const key = keys[i];
          this.increaseRetentionCount(key);
        }
        return () => {
          this.release(keys);
        };
      }
      watch(partialKey, callback) {
        if (typeof partialKey === 'string') {
          return this.fallbackStringKeyInMemoryStore.watch(partialKey, callback);
        }
        const subscription = {
          partialKey,
          callback
        };
        this.watchSubscriptions = [...this.watchSubscriptions, subscription];
        return () => {
          const {
            watchSubscriptions
          } = this;
          const index = indexOf.call(watchSubscriptions, subscription);
          this.watchSubscriptions = [...slice.call(watchSubscriptions, 0, index), ...slice.call(watchSubscriptions, index + 1)];
          {
            this.watchSubscriptions = freeze(this.watchSubscriptions);
          }
        };
      }
      /**
       * Evicts data at the canonical key location and marks any redirects (if applicable)
       * to the key as visited
       * @param key key to evict
       */
      evict(key) {
        if (typeof key === 'string') {
          this.fallbackStringKeyInMemoryStore.evict(key);
          return;
        }
        // find and evict the canonical key
        const canonicalKey = this.getCanonicalRecordId(key);
        this.recordsMap.delete(canonicalKey);
        this.markVisited(canonicalKey);
      }
      cleanup() {
        if (this.fallbackStringKeyInMemoryStore.pendingTrimKeys.size > 0) {
          this.fallbackStringKeyInMemoryStore.cleanup();
        }
      }
      /**
       * Deallocates data at the canonical key location for in-memory (L1) cache
       * @param key key to deallocate
       */
      dealloc(key) {
        if (typeof key === 'string') {
          this.fallbackStringKeyInMemoryStore.dealloc(key);
          return;
        }
        // find and deallocate the canonical key
        const canonicalKey = this.getCanonicalRecordId(key);
        this.recordsMap.delete(canonicalKey);
      }
      keyExistsInStore(key) {
        if (typeof key === 'string') {
          return this.fallbackStringKeyInMemoryStore.keyExistsInStore(key);
        }
        return this.recordsMap.get(key) !== undefined;
      }
      publishMetadata(key, storeMetadata) {
        if (typeof key === 'string') {
          this.fallbackStringKeyInMemoryStore.publishMetadata(key, storeMetadata);
          return;
        }
        this.putMetadata(key, storeMetadata, true);
        const canonicalKey = this.getCanonicalRecordId(key);
        this.markRefreshed(canonicalKey);
      }
      putMetadata(key, storeMetadata, adjustTTLOverride) {
        if (typeof key === 'string') {
          this.fallbackStringKeyInMemoryStore.putMetadata(key, storeMetadata, adjustTTLOverride);
          return;
        }
        const {
          namespace,
          representationName,
          ingestionTimestamp
        } = storeMetadata;
        const ttlOverrideKey = this.buildStructuredKey(namespace, representationName, {});
        const ttlOverride = getTTLOverride(ttlOverrideKey, this.ttlOverridesMap, this.defaultTTLOverride);
        const canonicalKey = this.getCanonicalRecordId(key);
        if (ttlOverride !== undefined && adjustTTLOverride) {
          // It should check if the namespace + representationName exists in the ttlOverride map.
          // If a ttlOverride does exist, calculate a new ExpirationTimestamp with the override.
          const newExpiration = ingestionTimestamp + ttlOverride;
          // Create a new StoreMetadata object and publish the new object to storeMetadata.
          const metaDataOverride = {
            ...storeMetadata,
            expirationTimestamp: newExpiration
          };
          this.metadataMap.set(canonicalKey, metaDataOverride);
        } else {
          // If it does not exist, publish the user passed StoreMetadata into the storeMetadata map.
          this.metadataMap.set(canonicalKey, storeMetadata);
        }
      }
      expirePossibleStaleRecords(keys) {
        if (keys.length > 0 && typeof keys[0] === 'string') {
          return this.fallbackStringKeyInMemoryStore.expirePossibleStaleRecords(keys);
        }
        const expirationTimestamp = Date.now();
        for (let i = 0, len = keys.length; i < len; i++) {
          const key = keys[i];
          const metadata = this.readMetadata(key);
          if (metadata !== undefined) {
            this.publishMetadata(key, {
              ...metadata,
              expirationTimestamp
            });
          }
        }
      }
      setTTLOverride(namespace, representationName, ttl) {
        // Set the TTLs in both the stores
        this.fallbackStringKeyInMemoryStore.setTTLOverride(namespace, representationName, ttl);
        this.ttlOverridesMap.set(this.buildStructuredKey(namespace, representationName, {}), ttl);
      }
      getTTLOverride(namespace, representationName) {
        return this.ttlOverridesMap.get(this.buildStructuredKey(namespace, representationName, {}));
      }
      getTTLOverrides() {
        return this.ttlOverridesMap;
      }
      setDefaultTTLOverride(ttl) {
        // Set the TTLs in both the stores
        this.fallbackStringKeyInMemoryStore.setDefaultTTLOverride(ttl);
        this.defaultTTLOverride = ttl;
      }
      getDefaultTTLOverride() {
        return this.defaultTTLOverride;
      }
      reset() {
        this.recordsMap = new StoreKeyMap();
        this.snapshotSubscriptions = [];
        this.watchSubscriptions = [];
        this.visitedIdsSet = new StoreKeySet();
        this.refreshedIdsSet = new StoreKeySet();
        this.insertedIdsSet = new StoreKeySet();
        this.redirectKeysMap = new StoreKeyMap();
        this.reverseRedirectKeysMap = new StoreKeyMap();
        this.retainedIdsMap = new StoreKeyMap();
        this.ttlOverridesMap = new StoreKeyMap();
        this.trimTask = null;
        this.metadataMap = new StoreKeyMap();
        this.defaultTTLOverride = undefined;
        // Don't emit this for now as InMemoryStore's reset() also calls emitLuvioStoreEvent
        //emitLuvioStoreEvent({ type: 'store-reset', timestamp: Date.now() }, this.eventObservers);
        // Also reset the fallbackStringKeyInMemoryStore
        this.fallbackStringKeyInMemoryStore.reset();
      }
      addStoreEventObserver(storeEventObserver) {
        const inMemoryStoreUnsubscribe = this.fallbackStringKeyInMemoryStore.addStoreEventObserver(storeEventObserver);
        this.eventObservers.push(storeEventObserver);
        return () => {
          const {
            eventObservers
          } = this;
          const index = this.eventObservers.indexOf(storeEventObserver);
          if (index > -1) {
            this.eventObservers = [...slice.call(eventObservers, 0, index), ...slice.call(eventObservers, index + 1)];
          }
          inMemoryStoreUnsubscribe();
        };
      }
      // public in memory methods
      scheduleTrim() {
        if (this.fallbackStringKeyInMemoryStore.pendingTrimKeys.size > 0) {
          this.fallbackStringKeyInMemoryStore.scheduleTrim();
          return;
        }
        if (this.trimTask === null) {
          this.trimTask = () => {
            const {
              metadataMap,
              retainedIdsMap,
              pendingTrims
            } = this;
            let deallocCount = 0;
            const now = Date.now();
            pendingTrims.forEach(key => {
              const recordExpiration = metadataMap.get(key);
              if (retainedIdsMap.get(key) !== undefined || recordExpiration === undefined || recordExpiration !== undefined && recordExpiration.expirationTimestamp >= now) {
                return;
              }
              this.dealloc(key);
              deallocCount++;
            });
            pendingTrims.clear();
            return Promise.resolve({
              deallocatedCount: deallocCount
            });
          };
          this.scheduler(this.trimTask, () => {
            this.trimTask = null;
          });
        }
      }
      // private/protected methods
      /**
       * Updates a subscription with a new snapshot and performs retention book-keeping
       * on the existing and new snapshot.
       */
      updateSubscriptionSnapshot(subscription, newSnapshot) {
        const {
          snapshot: oldSnapshot
        } = subscription;
        if (oldSnapshot === newSnapshot) {
          return;
        }
        subscription.snapshot = newSnapshot;
        if (!isErrorSnapshot(newSnapshot)) {
          this.retainSnapshotIds(newSnapshot);
        }
        if (!isErrorSnapshot(oldSnapshot)) {
          this.releaseSnapshotIds(oldSnapshot);
        }
      }
      refreshSnapshot(snapshot) {
        const {
          refresh
        } = snapshot;
        if (refresh !== undefined) {
          return refresh.resolve(refresh.config);
        }
        return Promise.resolve(undefined);
      }
      instrumentIngestedNewData(snapshot, rebuiltSnapshot) {
        const recordId = rebuiltSnapshot.recordId;
        const recordMetadata = this.metadataMap.get(recordId);
        // Non-batch scenario
        if (recordMetadata) {
          emitLuvioStoreEvent({
            type: 'cache-miss-out-of-ttl',
            oldSnapshot: snapshot,
            newSnapshot: rebuiltSnapshot,
            recordId,
            recordMetadata,
            timestamp: Date.now()
          }, this.eventObservers);
        } else {
          rebuiltSnapshot.seenRecords.keysAsArray().forEach(seenRecordId => {
            const seenRecordMetadata = this.metadataMap.get(seenRecordId);
            if (seenRecordMetadata) {
              emitLuvioStoreEvent({
                type: 'cache-miss-out-of-ttl',
                oldSnapshot: snapshot,
                newSnapshot: rebuiltSnapshot,
                recordId: seenRecordId,
                recordMetadata: seenRecordMetadata,
                timestamp: Date.now()
              }, this.eventObservers);
            }
          });
        }
      }
      emitOrRefreshRebuiltSnapshot(rebuiltSnapshot, subscription, snapshotAvailable) {
        const {
          snapshot,
          callback
        } = subscription;
        // if the rebuilt snapshot is pending then continue on, broadcast will get
        // called again once the pending snapshot is resolved
        if (isPendingSnapshot(rebuiltSnapshot)) {
          if (isPendingSnapshot(snapshot)) {
            this.updateSubscriptionSnapshot(subscription, rebuiltSnapshot);
          }
          return;
        }
        this.updateSubscriptionSnapshot(subscription, rebuiltSnapshot);
        if (snapshotAvailable(rebuiltSnapshot)) {
          // TODO [W-10186366]: revisit if we want to handle errors thrown in user-land callback
          if (rebuiltSnapshot !== snapshot) {
            callback(rebuiltSnapshot);
          }
          this.instrumentIngestedNewDataOnFulfilledSnapshots(snapshot, rebuiltSnapshot);
        } else if (isUnfulfilledSnapshot(rebuiltSnapshot)) {
          const {
            refresh
          } = rebuiltSnapshot;
          if (refresh !== undefined) {
            refresh.resolve(refresh.config);
          }
        }
      }
      instrumentIngestedNewDataOnFulfilledSnapshots(snapshot, rebuiltSnapshot) {
        if (isFulfilledSnapshot(snapshot) && isFulfilledSnapshot(rebuiltSnapshot)) {
          this.instrumentIngestedNewData(snapshot, rebuiltSnapshot);
        }
      }
      retainSnapshotIds(snapshot) {
        const {
          recordId,
          seenRecords
        } = snapshot;
        const snapshotRetainedIds = seenRecords === undefined ? [recordId] : [recordId, ...seenRecords.keysAsArray()];
        this.retain(snapshotRetainedIds);
      }
      releaseSnapshotIds(snapshot) {
        const {
          recordId,
          seenRecords
        } = snapshot;
        const snapshotReleaseIds = seenRecords === undefined ? [recordId] : [recordId, ...seenRecords.keysAsArray()];
        this.release(snapshotReleaseIds);
      }
      increaseRetentionCount(key) {
        const count = this.retainedIdsMap.get(key);
        this.retainedIdsMap.set(key, count === undefined ? 1 : count + 1);
        // do not consider this key for trim while retained
        this.pendingTrims.delete(key);
      }
      decreaseRetentionCount(key) {
        const count = this.retainedIdsMap.get(key);
        if (count === 1) {
          // consider this key for trimming when ref count goes to zero
          this.pendingTrims.add(key);
          this.retainedIdsMap.delete(key);
          return true;
        } else if (count === undefined) {
          return false;
        } else {
          this.retainedIdsMap.set(key, count - 1);
        }
        return false;
      }
      release(keys) {
        const keysLength = keys.length;
        let shouldScheduleTrim = false;
        for (let i = 0; i < keysLength; i++) {
          const key = keys[i];
          const result = this.decreaseRetentionCount(key);
          if (result === true) {
            shouldScheduleTrim = true;
          }
        }
        // only schedule trim if an entry is removed from retention map
        if (shouldScheduleTrim === true) {
          // schedule trim for next tick
          this.scheduleTrim();
        }
      }
      markVisited(canonicalKey) {
        if (typeof canonicalKey === 'string') {
          this.fallbackStringKeyInMemoryStore.markVisited(canonicalKey);
          return;
        }
        const {
          visitedIdsSet,
          reverseRedirectKeysMap
        } = this;
        let redirectKey = canonicalKey;
        // mark all redirects leading up to the canonical key as visited so
        // affected snapshots are updated
        do {
          visitedIdsSet.add(redirectKey);
          redirectKey = reverseRedirectKeysMap.get(redirectKey);
        } while (redirectKey !== undefined);
      }
      markRefreshed(canonicalKey) {
        const {
          refreshedIdsSet,
          reverseRedirectKeysMap
        } = this;
        let redirectKey = canonicalKey;
        // mark all redirects leading up to the canonical key as refreshed so
        // affected snapshots are updated
        do {
          refreshedIdsSet.add(redirectKey);
          redirectKey = reverseRedirectKeysMap.get(redirectKey);
        } while (redirectKey !== undefined);
      }
      isUsingStringKeys() {
        return keys(this.fallbackStringKeyInMemoryStore.visitedIds).length !== 0 || keys(this.fallbackStringKeyInMemoryStore.refreshedIds).length !== 0;
      }
      delegateToFallbackStringKeyStore(snapshot) {
        return !isErrorSnapshot(snapshot) && typeof snapshot.recordId === 'string';
      }
      emitStorePublishEvent(keyMetadata) {
        emitLuvioStoreEvent({
          type: 'store-publish',
          timestamp: Date.now(),
          store: this,
          key: keyMetadata,
          keySchema: this.buildKeySchema(keyMetadata)
        }, this.eventObservers);
      }
      buildStructuredKey(namespace, representationName, idValues) {
        {
          const undefinedIdValues = entries(idValues).filter(entry => entry[1] === undefined);
          if (undefinedIdValues.length > 0) {
            throw new Error(`Undefined value for config keys: ${undefinedIdValues.map(entry => entry[0]).join(', ')}. Undefined values are not supported- use null instead.`);
          }
        }
        const key = {
          ...idValues,
          namespace,
          representationName
        };
        return key;
      }
      buildIngestionStagingStore() {
        const store = new InMemoryStore();
        store.ttlOverridesMap = this.ttlOverridesMap;
        store.defaultTTLOverride = this.defaultTTLOverride;
        store.redirectKeysMap = this.redirectKeysMap;
        store.reverseRedirectKeysMap = this.reverseRedirectKeysMap;
        store.fallbackStringKeyInMemoryStore = this.fallbackStringKeyInMemoryStore.buildIngestionStagingStore();
        return store;
      }
      /**
       * Builds keySchema from provided NormalizedKeyMetadata.
       *
       * Rules of key schema:
       *   1. all keys start with "namespace":"representationName:"
       *   2. sort keys from extracted key metadata, as ordering is not guaranteed
       */
      buildKeySchema(keyMetadata) {
        // pull NamespacedType type out of NormalizedKeyMetadata
        const {
          namespace: _ns,
          representationName: _rn,
          ...keyParamValues
        } = keyMetadata;
        const keySchema = keys(keyParamValues).sort();
        return ['namespace', 'representationName', ...keySchema];
      }
      serialize() {
        return this.fallbackStringKeyInMemoryStore.serialize();
      }
    }
    function adapterToNetworkPriority(priority) {
      switch (priority) {
        case 'background':
          return 'background';
        case 'high':
          return 'high';
        case 'normal':
        default:
          return 'normal';
      }
    }
    exports.HttpStatusCode = void 0;
    (function (HttpStatusCode) {
      HttpStatusCode[HttpStatusCode["Ok"] = 200] = "Ok";
      HttpStatusCode[HttpStatusCode["Created"] = 201] = "Created";
      HttpStatusCode[HttpStatusCode["NoContent"] = 204] = "NoContent";
      HttpStatusCode[HttpStatusCode["NotModified"] = 304] = "NotModified";
      HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
      HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
      HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
      HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
      HttpStatusCode[HttpStatusCode["ServerError"] = 500] = "ServerError";
      HttpStatusCode[HttpStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(exports.HttpStatusCode || (exports.HttpStatusCode = {}));
    /**
     * A type guard function for determining if an unknown object is a {@link FormData}
     */
    function isFormData(obj) {
      return typeof obj === 'object' && obj !== null && 'namedEntries' in obj && isArray(obj.namedEntries);
    }
    /**
     * A type guard function for determining if an unknown object is a {@link FileReference}
     */
    function isFileReference(entryValue) {
      return typeof entryValue === 'object' && entryValue !== null && 'isFileReference' in entryValue && entryValue.isFileReference === true;
    }
    function coerceAdapterRequestContext(adapterRequestContext) {
      const {
        priority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = adapterRequestContext;
      return {
        networkPriority: adapterToNetworkPriority(priority),
        requestCorrelator,
        eventObservers,
        sourceContext
      };
    }
    function appendTTLStrategy(storeLookup, ttlStrategy) {
      const returnStoreLookup = (sel, refresh) => storeLookup(sel, refresh, ttlStrategy);
      // append ttlStrategy to storeLookup function (in cases where custom adapter
      // wants to perform it's own lookup)
      returnStoreLookup.ttlStrategy = ttlStrategy;
      return returnStoreLookup;
    }
    function buildNetworkSnapshot(args) {
      const {
        buildNetworkSnapshot,
        buildSnapshotContext,
        coercedAdapterRequestContext
      } = args;
      return buildNetworkSnapshot(buildSnapshotContext, coercedAdapterRequestContext).then(snapshot => snapshot.state === 'Pending' ? args.resolvePendingSnapshot(snapshot) : snapshot);
    }
    function buildTTLStrategy(staleDurationMilliseconds = 0) {
      return (timestamp, metadata, valueIsError) => {
        if (metadata !== undefined) {
          const {
            expirationTimestamp
          } = metadata;
          if (timestamp > expirationTimestamp) {
            if (timestamp <= expirationTimestamp + staleDurationMilliseconds && valueIsError !== true) {
              return exports.StoreResolveResultState.Stale;
            }
            return exports.StoreResolveResultState.NotPresent;
          }
        }
        if (valueIsError === true) {
          return exports.StoreResolveResultState.Error;
        }
        return exports.StoreResolveResultState.Found;
      };
    }
    // TODO - update userland-facing APIs to return `AvailableSnapshot` instead of `Snapshot`
    // and then the signatures here can be updated as well
    function buildAvailableSnapshotFromCachedSnapshotResponse(cachedSnapshot, availableSnapshotFunc) {
      if (isPromise(cachedSnapshot)) {
        return cachedSnapshot.then(availableSnapshotFunc);
      }
      return availableSnapshotFunc(cachedSnapshot);
    }
    function buildCacheAndNetworkImplementation(staleDurationSeconds = 0) {
      return function (args) {
        const {
          buildCachedSnapshot,
          buildNetworkSnapshot: buildNetworkSnapshot$1,
          buildSnapshotContext,
          storeLookup,
          coercedAdapterRequestContext,
          luvio
        } = args;
        const staleDurationMilliseconds = staleDurationSeconds * 1000;
        const cachedSnapshot = buildCachedSnapshot(buildSnapshotContext, appendTTLStrategy(storeLookup, buildTTLStrategy(staleDurationMilliseconds)), luvio);
        return buildAvailableSnapshotFromCachedSnapshotResponse(cachedSnapshot, snapshot => {
          if (snapshot !== undefined) {
            // data found in L1 cache
            if (isFulfilledSnapshot(snapshot) || isErrorSnapshot(snapshot) || isStaleSnapshot(snapshot)) {
              // kick off network request, do not await it
              buildNetworkSnapshot$1(buildSnapshotContext, coercedAdapterRequestContext);
              // return the cached snapshot to caller
              return snapshot;
            }
            if (isPendingSnapshot(snapshot)) {
              return args.resolvePendingSnapshot(snapshot);
            }
            // any other state falls through to network snapshot
          }
          return buildNetworkSnapshot(args);
        });
      };
    }
    const cacheThenNetworkImplementation = function (args) {
      const {
        buildCachedSnapshot,
        buildSnapshotContext,
        storeLookup,
        luvio
      } = args;
      const cachedSnapshot = buildCachedSnapshot(buildSnapshotContext, appendTTLStrategy(storeLookup, buildTTLStrategy()), luvio);
      return buildAvailableSnapshotFromCachedSnapshotResponse(cachedSnapshot, snapshot => {
        if (snapshot !== undefined) {
          if (isFulfilledSnapshot(snapshot) || isErrorSnapshot(snapshot)) {
            return snapshot;
          }
          if (isPendingSnapshot(snapshot)) {
            return args.resolvePendingSnapshot(snapshot);
          }
        }
        return buildNetworkSnapshot(args);
      });
    };
    const noCacheImplementation = function (args) {
      return buildNetworkSnapshot(args);
    };
    const onlyIfCachedImplementation = function (args) {
      const {
        buildCachedSnapshot,
        buildSnapshotContext,
        storeLookup,
        luvio
      } = args;
      const cachedSnapshot = buildCachedSnapshot(buildSnapshotContext, appendTTLStrategy(storeLookup, buildTTLStrategy()), luvio);
      return buildAvailableSnapshotFromCachedSnapshotResponse(cachedSnapshot, snapshot => {
        if (snapshot !== undefined && (isFulfilledSnapshot(snapshot) || isErrorSnapshot(snapshot))) {
          return snapshot;
        }
        const refresh = snapshot !== undefined ? snapshot.refresh : undefined;
        return createErrorSnapshot({
          body: undefined,
          headers: {},
          ok: false,
          status: exports.HttpStatusCode.GatewayTimeout,
          statusText: 'Data requested with only-if-cached policy and not found in the cache.',
          errorType: 'fetchResponse'
        }, refresh);
      });
    };
    function buildStaleWhileRevalidateImplementation(staleDurationSeconds) {
      return function (args) {
        const {
          buildCachedSnapshot,
          buildNetworkSnapshot: buildNetworkSnapshot$1,
          buildSnapshotContext,
          storeLookup,
          coercedAdapterRequestContext,
          luvio
        } = args;
        const staleDurationMilliseconds = staleDurationSeconds * 1000;
        const cachedSnapshot = buildCachedSnapshot(buildSnapshotContext, appendTTLStrategy(storeLookup, buildTTLStrategy(staleDurationMilliseconds)), luvio);
        return buildAvailableSnapshotFromCachedSnapshotResponse(cachedSnapshot, snapshot => {
          if (snapshot !== undefined) {
            if (isFulfilledSnapshot(snapshot) || isErrorSnapshot(snapshot)) {
              return snapshot;
            }
            if (isPendingSnapshot(snapshot)) {
              return args.resolvePendingSnapshot(snapshot);
            }
            if (snapshot.state === SnapshotState.Stale) {
              buildNetworkSnapshot$1(buildSnapshotContext, coercedAdapterRequestContext);
              return snapshot;
            }
          }
          return buildNetworkSnapshot(args);
        });
      };
    }
    function buildValidAtImplementation(basePolicyImplementation, timestamp) {
      return function validAtImplementation(args) {
        // This somewhat convoluted code is used to force the basePolicyImplementation's
        // TTLStrategy to use the the valid-at cache policy's timestamp. The flow goes:
        //
        // Environment.applyCachePolicy => validAtImplementation (this function) =>
        //    basePolicyImplementation => adapter's buildCachedSnapshot =>
        //    basePolicyImplementation's storeLookup => validAtStoreLookup (below) =>
        //    Environment.applyCachePolicy's storeLookup => InMemoryStore/Reader code =>
        //    valid-at TTLStrategy (below) =>
        //    basePolicyImplementation's TTLStrategy (with valid-at timestamp)
        const validAtStoreLookup = (sel, refresh, ttlStrategy) => args.storeLookup(sel, refresh, (_readerTimestamp, metadata, valueIsError) => ttlStrategy(timestamp, metadata, valueIsError));
        // let basePolicy make all the decisions, but have it use our storeLookup
        // so we can override the timestamp passed to the basePolicy's TTLStrategy
        return basePolicyImplementation({
          ...args,
          storeLookup: validAtStoreLookup
        });
      };
    }
    function isNodeLink(node) {
      return typeof node === 'object' && node !== null && hasOwnProperty.call(node, '__ref');
    }
    function isGraphNode(node) {
      return node !== null && node.type === GraphNodeType.Node;
    }
    var GraphNodeType;
    (function (GraphNodeType) {
      GraphNodeType["Link"] = "Link";
      GraphNodeType["Node"] = "Node";
      GraphNodeType["Error"] = "Error";
      GraphNodeType["Locked"] = "Locked";
    })(GraphNodeType || (GraphNodeType = {}));
    class GraphNodeError {
      constructor(store, data) {
        this.type = GraphNodeType.Error;
        this.store = store;
        this.data = data;
      }
      retrieve() {
        return this.data;
      }
    }
    function followLink(store, key) {
      return store.readEntry(key);
    }
    class GraphLink {
      constructor(store, data) {
        this.type = GraphNodeType.Link;
        this.store = store;
        this.data = data;
      }
      isPending() {
        return this.data.pending === true;
      }
      isMissing() {
        return this.data.isMissing === true;
      }
      follow() {
        const {
          __ref
        } = this.data;
        if (__ref === undefined) {
          return null;
        }
        const linked = followLink(this.store, __ref);
        if (linked === null || linked === undefined) {
          return null;
        }
        if (isStoreRecordError(linked)) {
          return new GraphNodeError(this.store, linked);
        }
        return new GraphNode(this.store, linked, __ref);
      }
      linkData() {
        return this.data.data;
      }
      writeLinkData(data) {
        this.data.data = data;
      }
    }
    class GraphNode {
      constructor(store, data, storeKey) {
        this.type = GraphNodeType.Node;
        this.store = store;
        this.data = data;
        this.storeKey = storeKey;
      }
      object(propertyName) {
        const value = this.data[propertyName];
        if (isNodeLink(value)) {
          throw new Error(`Cannot walk to path ${String(propertyName)}. "${String(propertyName)}" is a link: "${value}"`);
        }
        if (typeof value !== 'object' || value === null) {
          throw new Error(`Cannot walk to path ${String(propertyName)}. "${String(propertyName)}" is a scalar: "${value}"`);
        }
        // We're walking to an object property on the current store record, pass the storeKey down.
        return new GraphNode(this.store, value, this.storeKey);
      }
      link(propertyName) {
        const value = this.data[propertyName];
        if (!isNodeLink(value)) {
          throw new Error(`Cannot walk to link ${String(propertyName)}. "${String(propertyName)}" is not a link: "${value}"`);
        }
        return new GraphLink(this.store, value);
      }
      scalar(propertyName) {
        const value = this.data[propertyName];
        if (typeof value === 'object' && value !== null) {
          throw new Error(`Cannot return value at path ${String(propertyName)}. ${String(propertyName)} is not a scalar.`);
        }
        return value;
      }
      keys() {
        return keys(this.data);
      }
      isScalar(propertyName) {
        // TODO W-6900046 - merge.ts casts these to any and manually sets `data`
        // so this guard is required
        if (this.data === undefined) {
          return true;
        }
        const value = this.data[propertyName];
        return typeof value !== 'object' || value === null;
      }
      isMissing(propertyName) {
        const value = this.data[propertyName];
        if (value && typeof value.__state === 'object' && value.__state !== null) {
          return !!value.__state.isMissing;
        }
        return false;
      }
      isPending(propertyName) {
        const value = this.data[propertyName];
        if (value && typeof value.__state === 'object' && value.__state !== null) {
          return !!value.__state.pending;
        }
        return false;
      }
      write(propertyName, value) {
        this.data[propertyName] = value;
        const canonicalKey = this.store.getCanonicalRecordId(this.storeKey);
        this.store.markVisited(canonicalKey);
      }
      isUndefined(propertyName) {
        return this.data[propertyName] === undefined;
      }
      retrieve() {
        return this.data;
      }
    }
    function isUnionObjectSelection(sel) {
      return sel.union === true && sel.kind === 'Object';
    }
    function isReaderFragment(fragment) {
      return fragment.reader === true;
    }
    function isFragmentUnionSelection(sel) {
      return sel.union === true;
    }
    function formatStorageKey(name, argValues) {
      if (!argValues) {
        return name;
      }
      var values = [];
      for (var _argName in argValues) {
        if (hasOwnProperty.call(argValues, _argName)) {
          var value = argValues[_argName];
          if (value !== null || value !== undefined) {
            values.push(_argName + ':' + stringify(value));
          }
        }
      }
      return values.length === 0 ? name : name + '('.concat(values.join(','), ')');
    }
    function getArgumentValues(args, variables) {
      const values = {};
      args.forEach(arg => {
        if (arg.kind === 'Variable') {
          // Variables are provided at runtime and are not guaranteed to be stable.
          values[arg.name] = variables[arg.variableName];
        } else {
          values[arg.name] = arg.value;
        }
      });
      return values;
    }
    function getStorageKey(field, variables) {
      const {
        args,
        name
      } = field;
      if (args && args.length !== 0) {
        return formatStorageKey(name, getArgumentValues(args, variables));
      }
      return name;
    }

    /**
     * Checks if the given variable is defined
     */
    function isDefined(value) {
      return value !== undefined && value !== null;
    }

    /**
     * Checks if the given variable is an object
     */
    function isObject(value) {
      return typeof value === 'object' && value !== null;
    }
    var StoreLinkStateValues;
    (function (StoreLinkStateValues) {
      StoreLinkStateValues[StoreLinkStateValues["NotPresent"] = 0] = "NotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefNotPresent"] = 1] = "RefNotPresent";
      StoreLinkStateValues[StoreLinkStateValues["RefPresent"] = 2] = "RefPresent";
      StoreLinkStateValues[StoreLinkStateValues["Null"] = 3] = "Null";
      StoreLinkStateValues[StoreLinkStateValues["Missing"] = 4] = "Missing";
      StoreLinkStateValues[StoreLinkStateValues["Pending"] = 5] = "Pending";
    })(StoreLinkStateValues || (StoreLinkStateValues = {}));
    function getLinkState(link) {
      // This condition is hit when the link itself isn't present
      if (link === undefined) {
        return {
          state: StoreLinkStateValues.NotPresent
        };
      }
      if (link === null) {
        return {
          state: StoreLinkStateValues.Null
        };
      }
      const {
        __ref: key,
        pending,
        isMissing
      } = link;
      if (pending === true) {
        return {
          state: StoreLinkStateValues.Pending
        };
      }
      if (isMissing === true) {
        return {
          state: StoreLinkStateValues.Missing
        };
      }
      if (key === undefined) {
        return {
          state: StoreLinkStateValues.RefNotPresent
        };
      }
      return {
        state: StoreLinkStateValues.RefPresent,
        key
      };
    }
    const skipTTLStrategy = (_timestamp, _metadata, valueIsError) => {
      if (valueIsError === true) {
        return exports.StoreResolveResultState.Error;
      }
      return exports.StoreResolveResultState.Found;
    };
    function storeLookup(key, timestamp, store, ttlStrategy) {
      const redirectKeys = store.getRedirectLineage(key);
      const canonicalKey = store.getCanonicalRecordId(key);
      const value = store.readEntry(canonicalKey);
      if (value === undefined) {
        return {
          state: exports.StoreResolveResultState.NotPresent,
          redirects: redirectKeys,
          resolvedKey: canonicalKey
        };
      }
      let version = undefined;
      const metadata = store.readMetadata(canonicalKey);
      if (metadata !== undefined) {
        version = metadata.version;
      }
      const valueIsError = value !== null && isStoreRecordError(value);
      const state = ttlStrategy(timestamp, metadata, valueIsError);
      if (state === exports.StoreResolveResultState.NotPresent || state === exports.StoreResolveResultState.Stale) {
        if (metadata && metadata.ingestionTimestamp) {
          emitLuvioStoreEvent({
            type: 'data-out-of-ttl-duration-update',
            lastExpiredDuration: timestamp - metadata.ingestionTimestamp,
            recordId: canonicalKey,
            storeResolveResultState: state === exports.StoreResolveResultState.NotPresent ? 'not-present' : 'stale'
          }, store.eventObservers);
        }
      }
      switch (state) {
        case exports.StoreResolveResultState.NotPresent:
          return {
            state,
            redirects: redirectKeys,
            resolvedKey: canonicalKey
          };
        case exports.StoreResolveResultState.Error:
          return {
            state,
            value: value.error,
            version,
            redirects: redirectKeys,
            resolvedKey: canonicalKey
          };
        case exports.StoreResolveResultState.Stale:
          return {
            state,
            value,
            version: version,
            redirects: redirectKeys,
            resolvedKey: canonicalKey
          };
        default:
          return {
            state,
            value: value,
            redirects: redirectKeys,
            resolvedKey: canonicalKey,
            version
          };
      }
    }
    const READER_PATH_ROOT = 'ROOT';
    const EMPTY_STRING = '';
    var FragmentReadResultState;
    (function (FragmentReadResultState) {
      FragmentReadResultState[FragmentReadResultState["Missing"] = 0] = "Missing";
      FragmentReadResultState[FragmentReadResultState["Success"] = 1] = "Success";
      FragmentReadResultState[FragmentReadResultState["Error"] = 2] = "Error";
    })(FragmentReadResultState || (FragmentReadResultState = {}));
    const FRAGMENT_READ_RESULT_MISSING = {
      state: FragmentReadResultState.Missing
    };
    function validateUnionSelection(record, selection, path) {
      const {
        discriminator
      } = selection;
      const discriminatorValue = record[discriminator];
      if (discriminatorValue === undefined) {
        throw new Error(`Invalid discriminator. Expected discriminator at path "${path.fullPath}.${discriminator}" but received "${stringify(record)}"`);
      }
      const unionSelection = selection.unionSelections[discriminatorValue];
      if (unionSelection === undefined) {
        const keys = Object.keys(selection.unionSelections).map(key => `"${key}"`).join(', ');
        throw new Error(`Invalid union selection. Expected to be one of ${keys} but received "${discriminatorValue}"`);
      }
    }
    function resolveLink(reader, storeLink, version) {
      const {
        StoreLinkStateValues
      } = reader;
      const linkState = reader.getLinkState(storeLink);
      switch (linkState.state) {
        case StoreLinkStateValues.RefNotPresent:
        case StoreLinkStateValues.NotPresent:
        case StoreLinkStateValues.Missing:
          reader.markMissingLink(storeLink.__ref);
          reader.markMissing();
          return;
        case StoreLinkStateValues.Pending:
          reader.markPending();
          return;
        case StoreLinkStateValues.Null:
          {
            throw new Error(`TODO: Invalid Link State. Link on "${reader.currentPath.fullPath}"`);
          }
      }
      const {
        key: __ref
      } = linkState;
      return reader.read({
        recordId: __ref,
        node: {
          kind: 'Fragment',
          private: [],
          opaque: true,
          version
        },
        variables: {}
      });
    }
    const readerOpaqueReferenceMap = new WeakMap();
    class Reader {
      constructor(store, variables, refresh, baseSnapshot, ttlStrategy) {
        this.store = store;
        this.hasPendingData = false;
        this.getLinkState = getLinkState;
        this.StoreLinkStateValues = StoreLinkStateValues;
        this.StoreResolveResultState = exports.StoreResolveResultState;
        this.variables = variables;
        this.seenIds = new StoreKeySet();
        this.missingPaths = new StoreKeySet();
        this.missingLinks = new StoreKeySet();
        this.isMissingData = false;
        this.hasStaleData = false;
        this.refresh = refresh;
        // When we aren't passed a base snapshot, we don't have to worry about
        // marking the snapshot as changed because there is nothing to compare against.
        // Therefore, our initial state is that the snapshot has changed.
        let snapshotChanged = true;
        // When we aren't passed a base snapshot, we do not have any previous data
        // So we can just assign this to undefined
        let baseSnapshotValue = undefined;
        // When we are passed a base snapshot, we want to keep track of the previous data
        // We also will need to compare all of our data against the snapshot's previous data
        // Our initial state is that the snapshot has not changed. The reason for this is because
        // Once we detect a change, we can just flip this boolean on the first change and then
        // not have to worry about it for additional changes.
        if (baseSnapshot !== undefined && (baseSnapshot.state === SnapshotState.Fulfilled || baseSnapshot.state === SnapshotState.Stale)) {
          baseSnapshotValue = baseSnapshot.data;
          snapshotChanged = false;
        }
        this.snapshotChanged = snapshotChanged;
        this.currentPath = {
          fullPath: EMPTY_STRING,
          key: READER_PATH_ROOT,
          parent: null,
          baseSnapshotValue
        };
        this.baseSnapshot = baseSnapshot;
        this.timestamp = Date.now();
        this.ttlStrategy = ttlStrategy === undefined ? skipTTLStrategy : ttlStrategy;
      }
      resolveMetadata(source, version) {
        const link = source.__metadata;
        const linkState = getLinkState(link);
        if (linkState.state !== StoreLinkStateValues.RefPresent) {
          this.markMissing();
          return;
        }
        const lookup = this.resolveKey(linkState.key);
        if (lookup.version !== version) {
          this.markMissing();
          return;
        }
        return lookup.value;
      }
      readFragmentUnion(result, selection) {
        const {
          value: record
        } = result;
        {
          validateUnionSelection(record, selection, this.currentPath);
        }
        const {
          discriminator
        } = selection;
        const discriminatorValue = record[discriminator];
        return this.readFragment(result, selection.unionSelections[discriminatorValue]);
      }
      read(selector) {
        const {
          node: selectorNode
        } = selector;
        const {
          recordId: key
        } = selector;
        const result = this.storeLookup(key);
        const fragmentResult = this.readFragment(result, selectorNode);
        switch (fragmentResult.state) {
          case FragmentReadResultState.Missing:
            if (this.isMissingData === false) {
              this.isMissingData = true;
              this.snapshotChanged = true;
            }
            return this.createSnapshot(undefined, selector);
          case FragmentReadResultState.Error:
            return this.createErrorSnapshot(fragmentResult.value);
          default:
            return this.createSnapshot(fragmentResult.value, selector);
        }
      }
      getSnapshotState() {
        if (this.isMissingData === true) {
          return SnapshotState.Unfulfilled;
        }
        if (this.hasPendingData === true) {
          return SnapshotState.Pending;
        }
        if (this.hasStaleData === true) {
          return SnapshotState.Stale;
        }
        return SnapshotState.Fulfilled;
      }
      createErrorSnapshot(data) {
        return {
          data: undefined,
          error: data,
          state: SnapshotState.Error,
          refresh: this.refresh
        };
      }
      createSnapshot(data, selector) {
        // If snapshotChanged === false then we have established that baseSnapshot is present
        // Typescript is unable to conclude this fact hence adding a non-null assertion operator !
        // recordId of selector will be different than of baseSnapshot when reading a child of composite resource
        if (this.snapshotChanged === false && selector.recordId === this.baseSnapshot.recordId) {
          return this.baseSnapshot;
        }
        deepFreeze(data);
        return {
          recordId: selector.recordId,
          select: selector,
          variables: this.variables,
          seenRecords: this.seenIds,
          data,
          state: this.getSnapshotState(),
          missingPaths: this.missingPaths,
          missingLinks: this.missingLinks,
          refresh: this.refresh
        }; // Typescript complains about unfulfilled vs fulfilled snapshot if we don't cast
      }
      // Only works for non-complex values.. No Date or Functions.
      opaqueCopy(value) {
        return parse(stringify(value));
      }
      deepCopy(record, data, key, visitedKeys) {
        const value = record[key];
        this.enterPath(key);
        if (isArray(value)) {
          // Array
          const items = [];
          this.selectAll(value, items, visitedKeys);
          data[key] = items;
        } else if (typeof value === 'object' && value !== null) {
          // Object
          if (value.__ref !== undefined) {
            // Link
            const nextRecordId = value.__ref;
            if (isArray(nextRecordId)) {
              const items = [];
              this.selectAll(nextRecordId, items, visitedKeys);
              data[key] = items;
            } else {
              if (hasOwnProperty.call(visitedKeys, nextRecordId) === true) {
                throw new Error(`Invalid eager selection on records with circular references.`);
              }
              const lookupResult = this.resolveKey(nextRecordId);
              switch (lookupResult.state) {
                case exports.StoreResolveResultState.NotPresent:
                  data[key] = undefined;
                  break;
                case exports.StoreResolveResultState.Found:
                  {
                    const nested = {};
                    this.selectAll(lookupResult.value, nested, {
                      ...visitedKeys,
                      [nextRecordId]: true
                    });
                    data[key] = nested;
                    break;
                  }
              }
            }
          } else {
            // Inlined object
            const items = {};
            this.selectAll(value, items, visitedKeys);
            data[key] = items;
          }
        } else {
          // Scalar
          this.checkIfChanged(value);
          data[key] = value;
        }
        this.exitPath();
      }
      selectAllArray(record, data, visitedKeys) {
        const {
          length
        } = record;
        for (let key = 0; key < length; key += 1) {
          this.deepCopy(record, data, key, visitedKeys);
        }
      }
      selectAllObject(record, data, visitedKeys) {
        const recordKeys = keys(record);
        const {
          length
        } = recordKeys;
        for (let i = 0; i < length; i += 1) {
          const key = recordKeys[i];
          this.deepCopy(record, data, key, visitedKeys);
        }
      }
      selectAll(record, data, visitedKeys = {}) {
        const recordIsArray = isArray(record);
        if (recordIsArray === true) {
          this.selectAllArray(record, data, visitedKeys);
        } else {
          this.selectAllObject(record, data, visitedKeys);
        }
      }
      markPending() {
        this.hasPendingData = true;
      }
      markStale() {
        this.hasStaleData = true;
      }
      markMissing() {
        this.isMissingData = true;
        const fullPath = this.getFullPathString(this.currentPath.fullPath);
        this.missingPaths.add(fullPath);
        this.checkIfChanged(undefined);
      }
      markMissingLink(linkKey) {
        this.missingLinks.add(linkKey);
        this.markMissing();
      }
      unMarkMissing() {
        const fullPath = this.getFullPathString(this.currentPath.fullPath);
        this.missingPaths.delete(fullPath);
        if (this.missingPaths.size() === 0) {
          this.isMissingData = false;
        }
      }
      assignNonScalar(sink, key, value) {
        sink[key] = value;
      }
      enterPath(key) {
        const parent = this.currentPath;
        const {
          key: parentKey,
          fullPath: parentFullPath,
          baseSnapshotValue: parentBaseSnapshotValue
        } = parent;
        let baseSnapshotValue = undefined;
        if (parentBaseSnapshotValue !== undefined && parentBaseSnapshotValue !== null) {
          baseSnapshotValue = parentBaseSnapshotValue[key];
        }
        this.currentPath = {
          parent,
          key,
          fullPath: parentKey === READER_PATH_ROOT ? key : parentFullPath + '.' + key,
          baseSnapshotValue
        };
      }
      exitPath() {
        this.currentPath = this.currentPath.parent;
      }
      readSingleLink(propertyName, selection, source, sink, assignmentProperty) {
        const {
          required,
          nullable,
          fragment
        } = selection;
        const link = source[propertyName];
        const property = assignmentProperty === undefined ? propertyName : assignmentProperty;
        const linkState = getLinkState(link);
        switch (linkState.state) {
          case StoreLinkStateValues.RefNotPresent:
          case StoreLinkStateValues.NotPresent:
          case StoreLinkStateValues.Missing:
            // We need to read synthetic fragments here because data from the link is missing,
            // So we won't have a chance to call readFragment
            if (isReaderFragment(fragment) && fragment.synthetic === true) {
              return this.assignNonScalar(sink, property, fragment.read(this));
            }
            if (linkState.state === StoreLinkStateValues.Missing && required === false) {
              return;
            }
            this.markMissing();
            return;
          case StoreLinkStateValues.Null:
            if (nullable === true) {
              this.readScalar(propertyName, source, sink);
              return;
            }
            throw new Error(`Invalid Link State. Link on "${this.currentPath.fullPath}" is null but selection is not nullable: \n${stringify(selection, null, 2)}`);
          case StoreLinkStateValues.Pending:
            this.markPending();
            return;
          default:
            // if we have a link reference we override the required property passed to true
            // because if there was a missing reference the `isMissing` property would be true and the links state would
            // have returned `Missing`.
            this.readStoreLinkWithRef(linkState, fragment, sink, property, true);
        }
      }
      markRedirectsSeen(state) {
        const {
          redirects
        } = state;
        const {
          length: len
        } = redirects;
        if (len === 0) {
          return;
        }
        for (let i = 0; i < len; i += 1) {
          this.markSeenId(redirects[i]);
        }
      }
      resolveKey(key, options = {}) {
        const lookup = this.storeLookup(key);
        const {
          required
        } = options;
        switch (lookup.state) {
          case exports.StoreResolveResultState.Stale:
            this.markStale();
            break;
          case exports.StoreResolveResultState.NotPresent:
            if (required !== false) {
              this.markMissingLink(key);
            }
            break;
        }
        this.markRedirectsSeen(lookup);
        this.markSeenId(lookup.resolvedKey);
        return lookup;
      }
      readStoreLinkWithRef(linkState, fragment, sink, assignmentProperty, required) {
        const fragmentResult = this.readFragment(this.resolveKey(linkState.key, {
          required
        }), fragment);
        switch (fragmentResult.state) {
          case FragmentReadResultState.Error:
            this.markMissing();
            return;
          case FragmentReadResultState.Success:
            this.assignNonScalar(sink, assignmentProperty, fragmentResult.value);
        }
      }
      readObject(key, selection, source, sink) {
        const sourceValue = source[key];
        if (selection.nullable === true && sourceValue === null) {
          this.readScalar(key, source, sink);
          return;
        }
        if (selection.opaque === true) {
          this.readOpaque(sink, key, sourceValue, selection.required);
          return;
        }
        if (sourceValue === undefined) {
          if (selection.required === false) {
            this.checkIfChanged(sourceValue);
            return;
          }
          return this.markMissing();
        }
        if (typeof sourceValue.__state === 'object') {
          if (selection.supportsMissingMarker === true && sourceValue.__state.isMissing === true) {
            this.checkIfChanged(sourceValue);
            return;
          }
          if (sourceValue.__state.pending === true) {
            this.markPending();
            return;
          }
        }
        const sinkValue = isArray(sourceValue) ? [] : {};
        if (selection.selections === undefined) {
          this.selectAll(sourceValue, sinkValue);
        } else {
          this.traverseSelections(selection, sourceValue, sinkValue);
        }
        this.assignNonScalar(sink, key, sinkValue);
      }
      /**
       * Flip snapshotChanged flag to 'true' if current size of the value 'array' is different from the length of base snapshot.
       *
       * @param value - Sink array to be checked against baseSnapshotValue
       */
      checkIfArrayLengthChanged(value) {
        // If we've already detected a change, just return
        if (this.snapshotChanged === true) {
          return;
        }
        const {
          baseSnapshotValue
        } = this.currentPath;
        if (isDefined(baseSnapshotValue)) {
          this.snapshotChanged = baseSnapshotValue.length !== value.length;
        }
      }
      /**
       * Flip snapshotChanged flag to 'true' if number of keys in the 'Object' is different from the length of keys in base snapshot.
       *
       * @param keys - Array of Object keys to be checked against baseSnapshotValue
       */
      checkIfObjectKeysLengthChanged(keys$1) {
        // If we've already detected a change, just return
        if (this.snapshotChanged === true) {
          return;
        }
        const {
          baseSnapshotValue
        } = this.currentPath;
        if (isDefined(baseSnapshotValue)) {
          this.snapshotChanged = keys$1.length !== keys(baseSnapshotValue).length;
        }
      }
      checkIfChanged(value, options) {
        // If we've already detected a change, just return
        if (this.snapshotChanged === true) {
          return;
        }
        if ((options === null || options === void 0 ? void 0 : options.useDeepEquals) === true) {
          this.snapshotChanged = stringify(this.currentPath.baseSnapshotValue) !== stringify(value);
        } else {
          this.snapshotChanged = this.currentPath.baseSnapshotValue !== value;
        }
      }
      readPluralLink(propertyName, selection, record, data) {
        if (selection.fragment === undefined) {
          return;
        }
        const array = record[propertyName];
        if (array === undefined) {
          if (selection.required === false) {
            return;
          }
          return this.markMissing();
        }
        const sink = data[propertyName] = [];
        for (let i = 0, len = array.length; i < len; i += 1) {
          this.enterPath(i);
          this.readSingleLink(i, selection, array, sink);
          this.exitPath();
        }
        this.checkIfArrayLengthChanged(sink);
      }
      readObjectMap(propertyName, selection, record, data) {
        const obj = record[propertyName];
        if (obj === undefined) {
          if (selection.required === false) {
            return;
          }
          return this.markMissing();
        }
        const sink = data[propertyName] = {};
        const keys$1 = keys(obj);
        this.checkIfObjectKeysLengthChanged(keys$1);
        for (let i = 0, len = keys$1.length; i < len; i += 1) {
          const key = keys$1[i];
          this.enterPath(key);
          this.readObject(key, selection, obj, sink);
          this.exitPath();
        }
      }
      readLinkMap(propertyName, selection, record, data) {
        const map = record[propertyName];
        const keys$1 = keys(map);
        const sink = {};
        this.checkIfObjectKeysLengthChanged(keys$1);
        for (let i = 0, len = keys$1.length; i < len; i += 1) {
          const key = keys$1[i];
          this.enterPath(key);
          this.readSingleLink(key, selection, map, sink);
          this.exitPath();
        }
        this.assignNonScalar(data, propertyName, sink);
      }
      readSuccessResolveState(result, fragment) {
        if (isReaderFragment(fragment) && fragment.synthetic === true) {
          // this state should never occur
          return {
            state: FragmentReadResultState.Missing
          };
        }
        if (isFragmentUnionSelection(fragment)) {
          return this.readFragmentUnion(result, fragment);
        }
        const {
          version
        } = result;
        // apply version checking if version metadata exists
        if (version !== undefined && fragment.version !== undefined && version !== fragment.version) {
          return {
            state: FragmentReadResultState.Missing
          };
        }
        if (isReaderFragment(fragment)) {
          const value = fragment.read(result.value, this);
          return {
            state: FragmentReadResultState.Success,
            value
          };
        }
        if (fragment.opaque) {
          this.checkIfChanged(result.value, {
            useDeepEquals: true
          });
          if (isObject(result.value) && !readerOpaqueReferenceMap.has(result.value)) {
            readerOpaqueReferenceMap.set(result.value, this.opaqueCopy(result.value));
          }
          const opaqueValue = isObject(result.value) ? readerOpaqueReferenceMap.get(result.value) : result.value;
          return {
            state: FragmentReadResultState.Success,
            value: opaqueValue
          };
        }
        const sink = {};
        this.traverseSelections(fragment, result.value, sink);
        return {
          state: FragmentReadResultState.Success,
          value: sink
        };
      }
      readFragment(result, fragment) {
        if (isReaderFragment(fragment) && fragment.synthetic === true) {
          const value = fragment.read(this);
          // Handle the scenario where a synthetic read fails
          // One case being with a top level 404 response
          // from a composite adapter
          if (value.state === 'Error') {
            return {
              state: FragmentReadResultState.Error,
              value: value.value
            };
          }
          return {
            state: FragmentReadResultState.Success,
            value
          };
        }
        switch (result.state) {
          case exports.StoreResolveResultState.NotPresent:
            return FRAGMENT_READ_RESULT_MISSING;
          case exports.StoreResolveResultState.Error:
            return {
              state: FragmentReadResultState.Error,
              value: result.value
            };
          case exports.StoreResolveResultState.Stale:
            this.markStale();
            return this.readSuccessResolveState(result, fragment);
          case exports.StoreResolveResultState.Found:
            return this.readSuccessResolveState(result, fragment);
        }
      }
      readPluralObject(propertyName, selection, record, data) {
        if (selection.selections === undefined) {
          return;
        }
        const array = record[propertyName];
        if (array === undefined) {
          if (selection.required === false) {
            return;
          }
          return this.markMissing();
        }
        const sink = data[propertyName] = [];
        for (let i = 0, len = array.length; i < len; i += 1) {
          this.enterPath(i);
          const nextRecord = array[i];
          if (nextRecord === undefined) {
            this.markMissing();
            this.exitPath();
            return;
          }
          const obj = {};
          this.traverseSelections(selection, nextRecord, obj);
          push.call(sink, obj);
          this.exitPath();
        }
        this.checkIfArrayLengthChanged(sink);
      }
      readOpaque(sink, propertyName, value, required) {
        this.checkIfChanged(value);
        if (value === undefined && required === false) {
          return;
        }
        sink[propertyName] = value; // Should we be using this.opaqueCopy here? Not used by gql but seems bad to directly expose store entries.
      }
      readScalarMap(propertyName, record, data, required) {
        const obj = record[propertyName];
        if (obj === undefined) {
          if (required !== false) {
            this.markMissing();
            return;
          }
          this.checkIfChanged(undefined);
          return;
        }
        const sink = data[propertyName] = {};
        const keys$1 = keys(obj);
        this.checkIfObjectKeysLengthChanged(keys$1);
        for (let i = 0, len = keys$1.length; i < len; i += 1) {
          const key = keys$1[i];
          this.enterPath(key);
          this.readScalar(key, obj, sink);
          this.exitPath();
        }
      }
      readScalarPlural(propertyName, record, data, required) {
        const array = record[propertyName];
        if (array === undefined) {
          if (required === false) {
            return;
          }
          return this.markMissing();
        }
        const sink = data[propertyName] = [];
        // If the current snapshot is already know to be different from
        // previous snapshot, we can fast track and just copy the array
        // over.
        if (this.snapshotChanged === true) {
          // fast path: just copy from array to sink
          push.apply(sink, array);
          return;
        }
        this.checkIfArrayLengthChanged(array);
        // tsc seems to think 'this.snapshotChanged' is constant false here,
        // and it flags comparisons of false === true as error 'ts(2367)'
        // Oddly, this comparison exactly the same as earlier, yet the earlier
        // has no tsc errors.
        // @ts-ignore
        if (this.snapshotChanged === true) {
          // fast path: just copy from array to sink
          push.apply(sink, array);
          return;
        }
        for (let i = 0, len = array.length; i < len; i += 1) {
          this.enterPath(i);
          const value = array[i];
          push.call(sink, value);
          // the following method will change 'this.snapshotChanged'.
          // Later, check to see if 'this.snapshotChanged' is true,
          // if so, we can short-circuit the rest of this loop, and just
          // copy over the remainder of the array.
          this.checkIfChanged(value);
          this.exitPath();
          // see explanation for previous ts-ignore
          // @ts-ignore
          if (this.snapshotChanged === true) {
            // fast path the remainder: just copy from array to sink
            push.apply(sink, slice.call(array, i + 1));
            break;
          }
        }
      }
      readScalar(propertyName, record, data, required) {
        if (!hasOwnProperty.call(record, propertyName)) {
          if (required !== false) {
            this.markMissing();
            return;
          }
          this.checkIfChanged(undefined);
          return;
        }
        this.assignScalar(propertyName, data, record[propertyName]);
      }
      assignScalar(key, sink, value) {
        sink[key] = value;
        this.checkIfChanged(value);
      }
      storeLookup(key) {
        return storeLookup(key, this.timestamp, this.store, this.ttlStrategy);
      }
      selectUnion(selection, storeEntry, discriminatedObject, sink) {
        const {
          discriminator
        } = selection;
        const discriminatorValue = discriminatedObject[discriminator];
        {
          validateUnionSelection(discriminatedObject, selection, this.currentPath);
        }
        const unionSelection = selection.unionSelections[discriminatorValue];
        const childSelection = {
          selections: unionSelection.selections,
          private: unionSelection.private,
          name: selection.name,
          kind: selection.kind
        };
        this.traverseSelection(childSelection, storeEntry, sink);
      }
      selectObjectUnion(selection, source, sink) {
        const {
          name: propertyName
        } = selection;
        const object = source[propertyName];
        if (object === undefined) {
          this.markMissing();
          return;
        }
        if (selection.nullable === true && object === null) {
          this.readScalar(propertyName, source, sink);
          return;
        }
        this.selectUnion(selection, source, object, sink);
      }
      traverseSelection(selection, record, data) {
        const {
          variables
        } = this;
        const key = getStorageKey(selection, variables);
        if (isUnionObjectSelection(selection)) {
          this.selectObjectUnion(selection, record, data);
          return;
        }
        if (selection.kind === 'Link') {
          if (selection.plural === true) {
            this.readPluralLink(key, selection, record, data);
          } else if (selection.map === true) {
            this.readLinkMap(key, selection, record, data);
          } else {
            this.readSingleLink(key, selection, record, data);
          }
        } else if (selection.kind === 'Scalar') {
          if (selection.map === true) {
            this.readScalarMap(key, record, data, selection.required !== false);
          } else if (selection.plural === true) {
            this.readScalarPlural(key, record, data, selection.required !== false);
          } else {
            this.readScalar(key, record, data, selection.required);
          }
        } else if (selection.kind === 'Object') {
          if (selection.map === true) {
            this.readObjectMap(key, selection, record, data);
          } else if (selection.plural === true) {
            this.readPluralObject(key, selection, record, data);
          } else {
            this.readObject(key, selection, record, data);
          }
        }
      }
      traverseSelections(node, record, data) {
        const {
          selections
        } = node;
        if (selections === undefined) {
          this.selectAll(record, data);
          return;
        }
        const {
          length: len
        } = selections;
        for (let i = 0; i < len; i += 1) {
          const selection = selections[i];
          this.enterPath(selection.name);
          this.traverseSelection(selection, record, data);
          this.exitPath();
        }
      }
      isRebuilding() {
        return this.baseSnapshot !== undefined;
      }
      getIsDataMissing() {
        return this.isMissingData;
      }
      getTimeStamp() {
        return this.timestamp;
      }
      markSeenId(key) {
        this.seenIds.add(key);
      }
      getFullPathString(fullPath) {
        return typeof fullPath === 'number' ? fullPath.toString() : fullPath;
      }
    }

    /**
     * Maps a CachePolicy to a CachePolicyImplementation.  We don't necessarily trust
     * "cachePolicy" because that could come from userland code.  But we do trust
     * "defaultCachePolicy" because that comes from our own library code and should
     * be a valid type, so this function will fall back to "defaultCachePolicy" if
     * "cachePolicy" is invalid.
     *
     * @param cachePolicy cache policy
     * @param defaultCachePolicy default cache policy
     * @returns cache policy implementation corresponding to cachePolicy
     */
    function resolveCachePolicy(cachePolicy, defaultCachePolicy) {
      if (cachePolicy === undefined) {
        return resolveCachePolicy(defaultCachePolicy, defaultCachePolicy);
      }
      const {
        type
      } = cachePolicy;
      switch (type) {
        case 'cache-and-network':
          return buildCacheAndNetworkImplementation(cachePolicy.staleDurationSeconds);
        case 'cache-then-network':
          return cacheThenNetworkImplementation;
        case 'no-cache':
          return noCacheImplementation;
        case 'only-if-cached':
          return onlyIfCachedImplementation;
        case 'stale-while-revalidate':
          return buildStaleWhileRevalidateImplementation(cachePolicy.staleDurationSeconds);
        case 'valid-at':
          {
            const basePolicy = resolveCachePolicy(cachePolicy.basePolicy, defaultCachePolicy);
            return buildValidAtImplementation(basePolicy, cachePolicy.timestamp);
          }
        default:
          {
            // use TS "never" here to ensure our switch cases include all enumerations
            const exhaustiveCheck = type;
            {
              throw new Error(`unrecognized cache policy: ${exhaustiveCheck}`);
            }
          }
      }
    }
    function isFetchResponse(error) {
      return error !== null && typeof error === 'object' && 'status' in error;
    }
    /**
     * This function takes the unknown rejected response from a network adapter
     * and normalizes it to an Error object with the proper errorType
     */
    function normalizeNetworkAdapterError(error) {
      // if it's an Error (it should be) then add the errorType
      // NOTE: this preserves stack trace
      if (typeof error === 'object' && error instanceof Error) {
        error.errorType = 'networkAdapterError';
        return error;
      }
      // anything else should get turned into an Error with the errorType set
      const normalizedError = new Error(`NetworkAdapter rejected with non-Error object: ${typeof error === 'undefined' ? 'undefined' : stringify(error)}`);
      normalizedError.errorType = 'networkAdapterError';
      return normalizedError;
    }
    class Environment {
      constructor(store, networkAdapter) {
        this.networkCount = 0;
        this.storeQueryEvaluator = undefined;
        this.defaultCachePolicy = {
          type: 'cache-then-network'
        };
        this.store = store;
        this.networkAdapter = networkAdapter;
        this.adapterContextMap = create(null);
        this.typeQueryEvaluatorMap = create(null);
        // bind these methods so when they get passed into the
        // Store, the this reference is preserved
        this.createSnapshot = this.createSnapshot.bind(this);
        this.rebuildSnapshot = this.rebuildSnapshot.bind(this);
      }
      setDefaultCachePolicy(cachePolicy) {
        this.defaultCachePolicy = cachePolicy;
      }
      /**
       * Returns a resolved promise of a FetchResponse for ok http status codes.
       * Returns a rejected promise of an ErrorResponse of type "fetchResponse" for non-ok http status codes.
       * Returns a rejected promise of an ErrorResponse of type "networkError" if server can't be reached
       *
       * @throws {ErrorResponse}
       */
      dispatchResourceRequest(request, context, eventObservers) {
        const start = Date.now();
        const uuid = `${start}${this.networkCount++}`;
        emitAdapterEvent({
          type: 'network-request-start',
          timestamp: start,
          request,
          uuid
        }, eventObservers);
        return new Promise((resolve, reject) => {
          this.networkAdapter(request, context).then(response => {
            const end = Date.now();
            emitAdapterEvent({
              type: 'network-request-end',
              timestamp: end,
              duration: end - start,
              response,
              uuid
            }, eventObservers);
            if (!response.ok) {
              return reject({
                ...response,
                errorType: 'fetchResponse'
              });
            }
            return resolve(response);
          }, error => {
            const end = Date.now();
            emitAdapterEvent({
              type: 'network-request-error',
              uuid,
              timestamp: end,
              duration: end - start,
              error: error
            }, eventObservers);
            // return reject(normalizeNetworkAdapterError(error));
            // TODO [W-11204139]: uncomment above line and remove below line
            // once all network adapter impls has been updated to follow
            // the new network adapter behavior
            return reject(
            // legacy network adapter check
            isFetchResponse(error) ? {
              ...error,
              errorType: 'fetchResponse'
            } : normalizeNetworkAdapterError(error));
          });
        });
      }
      isErrorCacheable(errorSnapshot) {
        const {
          error
        } = errorSnapshot;
        if (error.errorType === 'fetchResponse') {
          return error.status === exports.HttpStatusCode.NotFound;
        }
        return false;
      }
      /**
       * Returns a Promise that resolves once the given PendingSnapshot is available.
       */
      resolvePendingSnapshot(snapshot) {
        return new Promise(resolve => {
          let unsubscribe;
          unsubscribe = this.storeSubscribe(snapshot, resolvedSnapshot => {
            if (unsubscribe !== undefined) {
              unsubscribe();
            }
            resolve(resolvedSnapshot);
          });
        });
      }
      storeIngest(key, ingest, response, luvio, storeOverride) {
        if (ingest !== null) {
          ingest(response, {
            fullPath: key,
            parent: null,
            propertyName: null
          }, luvio, storeOverride === undefined ? this.store : storeOverride, Date.now());
        }
      }
      storeIngestError(key, errorSnapshot, storeMetadataParams, storeOverride) {
        const {
          error
        } = errorSnapshot;
        if (this.isErrorCacheable(errorSnapshot)) {
          const store = storeOverride === undefined ? this.store : storeOverride;
          const entry = {
            __type: StoreRecordType.Error,
            status: StoreErrorStatus.RESOURCE_NOT_FOUND,
            error
          };
          freeze(entry);
          store.publish(key, entry);
          if (storeMetadataParams !== undefined) {
            const {
              ttl,
              namespace,
              representationName,
              version
            } = storeMetadataParams;
            const now = Date.now();
            const storeMetadata = {
              ingestionTimestamp: now,
              expirationTimestamp: now + ttl,
              representationName,
              namespace,
              version
            };
            store.publishMetadata(key, storeMetadata);
          }
          return;
        }
        // this error is not cached, notify any pending subscribers here
        // since broadcast only deals with cached recordIds
        this.store.broadcastNonCachedSnapshot(key, errorSnapshot);
      }
      // Adds the given data to the store at the given key and marks the key as visited.  Will cause subscribers to rebuild.
      storePublish(key, data) {
        this.store.publish(key, data);
      }
      // Adds the given data to the store at the given key (does NOT mark the key as visited).  Will NOT cause subscribers to rebuild.  NOTE: This should really only be used by internal Luvio APIs.
      storePut(key, data) {
        this.store.put(key, data);
      }
      storeRedirect(existingKey, redirectKey) {
        this.store.redirect(existingKey, redirectKey);
      }
      storeGetCanonicalKey(key) {
        return this.store.getCanonicalRecordId(key);
      }
      storeBroadcast(rebuildSnapshot, snapshotAvailable) {
        return this.store.broadcast(rebuildSnapshot, snapshotAvailable);
      }
      storeSubscribe(snapshot, callback) {
        return this.store.subscribe(snapshot, callback);
      }
      storeWatch(prefix, callback) {
        return this.store.watch(prefix, callback);
      }
      storeLookup(sel, createSnapshot, refresh, ttlStrategy) {
        return this.store.lookup(sel, createSnapshot, refresh, ttlStrategy);
      }
      storeCleanup() {
        this.store.cleanup();
      }
      storeEvict(key) {
        this.store.evict(key);
      }
      storeDealloc(key) {
        this.store.dealloc(key);
      }
      storeReset() {
        this.store.reset();
      }
      storeRetain(keys) {
        return this.store.retain(keys);
      }
      storeKeyExists(key) {
        return this.store.keyExistsInStore(key);
      }
      snapshotAvailable(snapshot) {
        return isFulfilledSnapshot(snapshot) || isErrorSnapshot(snapshot) || isStaleSnapshot(snapshot);
      }
      createSnapshot(selector, refresh, ttlStrategy) {
        const reader = new Reader(this.store, selector.variables, refresh, undefined, ttlStrategy);
        return reader.read(selector);
      }
      rebuildSnapshot(snapshot, onRebuild) {
        const reader = new Reader(this.store, snapshot.variables, snapshot.refresh, snapshot);
        onRebuild(reader.read(snapshot.select));
      }
      getNode(key, storeOverride) {
        const store = storeOverride === undefined ? this.store : storeOverride;
        const value = store.readEntry(key);
        // doesn't exist
        if (value === undefined) {
          return null;
        }
        return this.wrapNormalizedGraphNode(value, key, store);
      }
      wrapNormalizedGraphNode(normalized, key, storeOverride) {
        if (normalized === null) {
          return null;
        }
        const store = storeOverride === undefined ? this.store : storeOverride;
        if (isStoreRecordError(normalized)) {
          return new GraphNodeError(store, normalized);
        }
        return new GraphNode(store, normalized, key);
      }
      withContext(adapter, options) {
        const {
          contextId,
          onContextLoaded
        } = options;
        // simple in-memory object stores metadata
        // retrieve from adapterContextMap if contextId is supplied
        // we will only track context of adapters that explicitly provide a contextId
        if (this.adapterContextMap[contextId] === undefined) {
          this.adapterContextMap[contextId] = create(null);
        }
        const contextStore = this.adapterContextMap[contextId];
        const context = {
          set(key, value) {
            contextStore[key] = value;
          },
          get(key) {
            return contextStore[key];
          }
        };
        // if no onContextLoaded hook then return a function that
        // simply returns the adapter
        if (onContextLoaded === undefined) {
          return (config, requestContext) => {
            return adapter(config, context, requestContext);
          };
        }
        // if we got here then we need to return a function that awaits the
        // onContextLoaded hook only on the first invocation.
        let firstRun = true;
        const hookAsPromise = onContextLoaded(context);
        return (config, requestContext) => {
          if (firstRun) {
            return hookAsPromise.then(() => {
              firstRun = false;
              return adapter(config, context, requestContext); // TODO - remove as any cast after https://github.com/salesforce-experience-platform-emu/luvio/pull/230
            });
          }
          return adapter(config, context, requestContext);
        };
      }
      publishStoreMetadata(key, storeMetadata) {
        this.store.publishMetadata(key, storeMetadata);
      }
      putStoreMetadata(key, storeMetadata, adjustTTLOverride) {
        this.store.putMetadata(key, storeMetadata, adjustTTLOverride);
      }
      storeSetTTLOverride(namespace, representationName, ttl) {
        this.store.setTTLOverride(namespace, representationName, ttl);
        this.recomputeTTLOverrideExpirations(namespace, representationName);
        return Promise.resolve();
      }
      storeGetTTLOverride(namespace, representationName) {
        return Promise.resolve(this.store.getTTLOverride(namespace, representationName));
      }
      storeGetTTLOverrides() {
        return this.store.getTTLOverrides();
      }
      recomputeTTLOverrideExpirations(ttlNamespace, ttlRepresentationName) {
        const metadataResults = this.store.readMetadataWhere({
          namespace: ttlNamespace,
          representationName: ttlRepresentationName
        });
        for (let i = 0, length = metadataResults.length; i < length; i++) {
          const result = metadataResults[i];
          this.publishStoreMetadata(result.key, result.metadata);
        }
      }
      storeSetDefaultTTLOverride(ttl) {
        this.store.setDefaultTTLOverride(ttl);
        this.recomputeDefaultTTLOverrideExpirations();
        return Promise.resolve();
      }
      storeGetDefaultTTLOverride() {
        return this.store.getDefaultTTLOverride();
      }
      recomputeDefaultTTLOverrideExpirations() {
        const metadataResults = this.store.readMetadataWhere({
          ttlOverride: undefined
        });
        for (let i = 0, length = metadataResults.length; i < length; i++) {
          const result = metadataResults[i];
          this.publishStoreMetadata(result.key, result.metadata);
        }
      }
      storeBuildIngestionStagingStore() {
        return this.store.buildIngestionStagingStore();
      }
      applyCachePolicy(luvio, adapterRequestContext, buildSnapshotContext, buildCachedSnapshot, buildNetworkSnapshot) {
        const {
          defaultCachePolicy
        } = this;
        const {
          cachePolicy,
          eventObservers
        } = adapterRequestContext;
        let cachePolicyImpl = resolveCachePolicy(cachePolicy, defaultCachePolicy);
        const resolvePendingSnapshot = snapshot => this.resolvePendingSnapshot(snapshot);
        const storeLookup = (sel, refresh, ttlStrategy) => this.storeLookup(sel, this.createSnapshot, refresh, ttlStrategy);
        let wrappedBuildCacheSnapshot = buildCachedSnapshot;
        let wrappedBuildNetworkSnapshot = buildNetworkSnapshot;
        // if eventObservers are provided for the adapter, wrap calls in versions that emit events
        if (eventObservers !== undefined) {
          const cachePolicyType = cachePolicy === undefined ? defaultCachePolicy.type : cachePolicy.type;
          cachePolicyImpl = cachePolicyImplWithEvents(cachePolicyImpl, cachePolicyType, eventObservers);
          wrappedBuildCacheSnapshot = buildCachedSnapshotWithEvents(buildCachedSnapshot, eventObservers);
          wrappedBuildNetworkSnapshot = buildNetworkSnapshotWithEvents(buildNetworkSnapshot, eventObservers);
        }
        return cachePolicyImpl({
          buildCachedSnapshot: wrappedBuildCacheSnapshot,
          buildNetworkSnapshot: wrappedBuildNetworkSnapshot,
          buildSnapshotContext,
          resolvePendingSnapshot,
          storeLookup,
          coercedAdapterRequestContext: coerceAdapterRequestContext(adapterRequestContext),
          luvio
        });
      }
      handleSuccessResponse(ingestAndBroadcastFunc, _getResponseCacheKeysFunc) {
        return ingestAndBroadcastFunc();
      }
      handleErrorResponse(ingestAndBroadcastFunc) {
        return ingestAndBroadcastFunc();
      }
      /**
       * Gets store entries for notifyChange purposes.  Returns a Promise to
       * support environments that need to do async cache lookups.
       *
       * If not in the store then the cache key is not added to the returned set.
       */
      getNotifyChangeStoreEntries(keys) {
        const entries = [];
        for (let i = 0, len = keys.length; i < len; i++) {
          const key = keys[i];
          const node = this.getNode(key);
          if (isGraphNode(node)) {
            entries.push({
              key,
              record: node.retrieve()
            });
          }
        }
        return Promise.resolve(entries);
      }
      notifyStoreUpdateAvailable(keys) {
        return this.store.updateAvailable(keys);
      }
      registerStoreQueryEvaluator(queryEvaluator) {
        this.storeQueryEvaluator = queryEvaluator;
      }
      getStoreQueryEvaluator() {
        return this.storeQueryEvaluator;
      }
      registerTypeQueryEvaluator(namespace, representationName, queryEvaluator) {
        if (!this.typeQueryEvaluatorMap[namespace]) {
          this.typeQueryEvaluatorMap[namespace] = Object.create(null);
        }
        this.typeQueryEvaluatorMap[namespace][representationName] = queryEvaluator;
      }
      getTypeQueryEvaluator(namespace, representationName) {
        const evaluatorsByNamespace = this.typeQueryEvaluatorMap[namespace];
        if (evaluatorsByNamespace && evaluatorsByNamespace[representationName]) {
          return evaluatorsByNamespace[representationName];
        }
        return undefined;
      }
      buildStructuredKey(namespace, representationName, idValues) {
        return this.store.buildStructuredKey(namespace, representationName, idValues);
      }
      /**
       * Take a list of keys and marks them as stale to be refreshed.
       * Then will be refreshed with the provided refresh function.
       * If no refresh and makeConfig functions are provided it will refresh
       * time that record is trying to be fetched
       *
       * Example: one record from graphql needs to be refreshed and not
       * the entire graphql query
       *
       * @param keys
       * @param makeConfig
       * @param refresh
       * @returns
       */
      expirePossibleStaleRecords(keys, config, refresh) {
        this.store.expirePossibleStaleRecords(keys);
        if (refresh !== undefined && config !== undefined) {
          return this.refreshPossibleStaleRecords(config, refresh);
        }
        return Promise.resolve();
      }
      refreshPossibleStaleRecords(config, refresh) {
        return Promise.resolve(refresh(config, {
          cachePolicy: {
            type: 'no-cache'
          }
        })).then(() => {});
      }
    }
    class Luvio {
      constructor(environment, options = {}) {
        this.environment = environment;
        this.options = options;
      }
      storePublish(key, data) {
        this.environment.storePublish(key, data);
      }
      storeRedirect(existingKey, canonicalKey) {
        this.environment.storeRedirect(existingKey, canonicalKey);
      }
      storeRetain(keys) {
        return this.environment.storeRetain(keys);
      }
      storeGetCanonicalKey(key) {
        return this.environment.storeGetCanonicalKey(key);
      }
      /**
       * Broadcast any cache entry changes to subscribers.
       *
       * NOTE: this MUST be called *AFTER* storeLookup in the ingestion flow as
       * some environments (namely, makeDurable) modify the store in this method.
       */
      storeBroadcast() {
        return this.environment.storeBroadcast(this.environment.rebuildSnapshot, this.environment.snapshotAvailable);
      }
      storeIngest(key, ingest, response) {
        this.environment.storeIngest(key, ingest, response, this);
      }
      storeIngestError(key, errorSnapshot, storeMetadataParams) {
        return this.environment.storeIngestError(key, errorSnapshot, storeMetadataParams);
      }
      /**
       * Subscribe to the Luvio store to observe any changes to the data in the given
       * snapshot.
       *
       * NOTE: Errors are terminal - the callback will never be called after an ErrorSnapshot
       * is emitted (or if the given Snapshot is an ErrorSnapshot).
       *
       * @template D
       * @template V
       * @param {Snapshot<D, V>} snapshot The snapshot that contains data to observe.
       * @param {SnapshotSubscriptionCallback<D, V>} callback The callback to be called
       * whenever the given snapshot's data changes.  NOTE: the snapshot passed to the
       * callback will have consistent, normalized data - however it is not guaranteed
       * to be within the TTL of that data type.
       * @returns {Unsubscribe} A function that will unsubscribe when invoked.
       * @memberof Luvio
       */
      storeSubscribe(snapshot, callback) {
        return this.environment.storeSubscribe(snapshot, callback);
      }
      storeWatch(prefix, callback) {
        return this.environment.storeWatch(prefix, callback);
      }
      storeLookup(sel, refresh) {
        return this.environment.storeLookup(sel, this.environment.createSnapshot, refresh);
      }
      storeEvict(key) {
        this.environment.storeEvict(key);
      }
      storeCleanup() {
        this.environment.storeCleanup();
      }
      storeExpirePossibleStaleRecords(keys, config, refresh) {
        return this.environment.expirePossibleStaleRecords(keys, config, refresh);
      }
      createSnapshot(selector, refresh) {
        return this.environment.createSnapshot(selector, refresh);
      }
      errorSnapshot(error, refresh) {
        return createErrorSnapshot(error, refresh);
      }
      dispatchResourceRequest(resourceRequest, context) {
        let mergedResourceRequest = resourceRequest;
        let resourceRequestContext = {};
        let eventObservers = [];
        if (context !== undefined) {
          if (context.resourceRequestContext !== undefined) {
            resourceRequestContext = context.resourceRequestContext;
          }
          if (context.eventObservers !== undefined) {
            eventObservers = context.eventObservers;
          }
          const {
            overrides
          } = context;
          // Apply resource request override if passed as argument.
          if (overrides !== undefined) {
            const {
              headers,
              priority
            } = overrides;
            if (headers !== undefined) {
              mergedResourceRequest = {
                ...resourceRequest,
                headers: {
                  ...resourceRequest.headers,
                  ...headers
                }
              };
            }
            if (priority !== undefined) {
              mergedResourceRequest.priority = priority;
            }
          }
        }
        // ResourceRequest params are derived from Adapter config properties, which
        // can be optional.  This could leave some queryParams or urlParams with undefined
        // values.  We don't want to put the responsibility of filtering out those
        // undefined values on the injected networkAdapter.  So we do it here, on
        // the API that those adapters call to dispatch their ResourceRequests.
        const {
          queryParams,
          urlParams
        } = mergedResourceRequest;
        for (const paramKey of keys(queryParams)) {
          const value = queryParams[paramKey];
          if (value === undefined) {
            delete queryParams[paramKey];
          }
        }
        for (const paramKey of keys(urlParams)) {
          const value = urlParams[paramKey];
          if (value === undefined) {
            delete urlParams[paramKey];
          }
        }
        return this.environment.dispatchResourceRequest(mergedResourceRequest, resourceRequestContext, eventObservers);
      }
      refreshSnapshot(snapshot) {
        const {
          refresh
        } = snapshot;
        if (refresh !== undefined) {
          const {
            config,
            resolve
          } = refresh;
          return resolve(config);
        }
        throw new Error('Snapshot is not refreshable');
      }
      /**
       * This method is meant for custom scenarios and should not be used for
       * general store lookups.  Use applyCachePolicy instead.
       *
       * NOTE: this method works against synchronous stores only.
       */
      getNode(key) {
        return this.environment.getNode(key);
      }
      wrapNormalizedGraphNode(normalized, key) {
        return this.environment.wrapNormalizedGraphNode(normalized, key);
      }
      instrument(paramsBuilder) {
        const {
          instrument
        } = this.options;
        if (instrument) {
          instrument(paramsBuilder());
        }
      }
      /**
       * Returns true if the given snapshot can be returned to userland without
       * requiring any additional resolution.
       */
      snapshotAvailable(snapshot) {
        return this.environment.snapshotAvailable(snapshot);
      }
      withContext(adapter, options) {
        return this.environment.withContext(adapter, options);
      }
      /**
       * Returns a Promise that resolves once the given PendingSnapshot is available.  This
       * is syntactic sugar for calling storeSubscribe and unsubscribing after the
       * first emit.  Useful for one-shot data reads.  Use storeSubscribe instead of
       * this to get continual updates when data changes.
       *
       * @template D
       * @template V
       * @param {PendingSnapshot<D, V>} snapshot
       * @returns {Promise<Snapshot<D, V>>}
       */
      resolvePendingSnapshot(snapshot) {
        return this.environment.resolvePendingSnapshot(snapshot);
      }
      publishStoreMetadata(key, storeMetadataParams) {
        const {
          ttl,
          namespace,
          representationName,
          version
        } = storeMetadataParams;
        let {
          ingestionTimestamp
        } = storeMetadataParams;
        if (ingestionTimestamp === undefined) {
          ingestionTimestamp = Date.now();
        }
        const storeMetadata = {
          ingestionTimestamp: ingestionTimestamp,
          expirationTimestamp: ingestionTimestamp + ttl,
          representationName,
          namespace,
          version
        };
        return this.environment.publishStoreMetadata(key, storeMetadata);
      }
      /**
       * Sets the TTL value for a specific namespace-representation Type.  The given
       * TTL takes precedence over TTL values defined in RAML and also over the
       * default TTL value (if set using storeSetDefaultTTLOverride).
       *
       * @param {number} ttl Time-to-live in milliseconds
       * @returns {Promise<void>}
       */
      storeSetTTLOverride(namespace, representationName, ttl) {
        return this.environment.storeSetTTLOverride(namespace, representationName, ttl);
      }
      storeGetTTLOverride(namespace, representationName) {
        return this.environment.storeGetTTLOverride(namespace, representationName);
      }
      /**
       * Sets the default TTL value.  The given TTL takes precedence over TTL values
       * defined in RAML, but defers to namespace-representation-specific override
       * values.
       *
       * @param {number} ttl Time-to-live in milliseconds
       * @returns {Promise<void>}
       */
      storeSetDefaultTTLOverride(ttl) {
        return this.environment.storeSetDefaultTTLOverride(ttl);
      }
      applyCachePolicy(adapterRequestContext, buildSnapshotContext, buildCachedSnapshot, buildNetworkSnapshot) {
        return this.environment.applyCachePolicy(this, adapterRequestContext, buildSnapshotContext, buildCachedSnapshot, buildNetworkSnapshot);
      }
      /**
       * A method to be called any time an adapter gets a successful response
       * from the network adapter
       *
       * @param ingestAndBroadcastFunc A function that ingests a response and broadcasts
       * @param getResponseCacheKeysFunc A function that returns the set of cache keys present in a response body
       * @returns A snapshot or the Promise of a snapshot that comes from resource ingestion.  Can return undefined
       * or Promise<undefined> for adapters that do not return a response (ie: DELETE adapters).
       */
      handleSuccessResponse(ingestAndBroadcastFunc, getResponseCacheKeysFunc) {
        const memoizedGetResponseCacheKeysFunc = () => {
          let cachedResult = undefined;
          return function () {
            if (cachedResult === undefined) {
              cachedResult = getResponseCacheKeysFunc();
            }
            return cachedResult;
          };
        };
        return this.environment.handleSuccessResponse(ingestAndBroadcastFunc, memoizedGetResponseCacheKeysFunc());
      }
      /**
       * A method to be called any time an adapter gets an error response
       * from the network adapter
       *
       * @param ingestAndBroadcastFunc A function that ingests a response and broadcasts
       * @returns An ErrorSnapshot or the Promise of an ErrorSnapshot that comes from resource ingestion
       */
      handleErrorResponse(ingestAndBroadcastFunc) {
        return this.environment.handleErrorResponse(ingestAndBroadcastFunc);
      }
      /**
       * This method is meant to be used by adapter's notifyChange function.  It
       * accepts a set of cache keys and returns normalized store entries for each
       * cache key that is present in the store. Results are returned in a Promise
       * to support Environments that use asynchronous stores.
       *
       * If a cache key is not present in the store then that key will not be included
       * in the returned set.
       *
       * NOTE: this method is meant to be used by notifyChange and SHOULD NOT be used
       * as a general purpose way to get data out of the cache.  Use luvio.applyCachePolicy
       * for general-purpose cache lookups.
       *
       * @param keys A list of cache keys to check
       * @returns A Promise of a set of store entries that are present in the cache
       */
      getNotifyChangeStoreEntries(keys) {
        return this.environment.getNotifyChangeStoreEntries(keys);
      }
      notifyStoreUpdateAvailable(keys) {
        return this.environment.notifyStoreUpdateAvailable(keys);
      }
      registerStoreQueryEvaluator(queryEvaluator) {
        return this.environment.registerStoreQueryEvaluator(queryEvaluator);
      }
      getStoreQueryEvaluator() {
        return this.environment.getStoreQueryEvaluator();
      }
      registerTypeQueryEvaluator(namespace, representationName, queryEvaluator) {
        return this.environment.registerTypeQueryEvaluator(namespace, representationName, queryEvaluator);
      }
      getTypeQueryEvaluator(namespace, representationName) {
        return this.environment.getTypeQueryEvaluator(namespace, representationName);
      }
      buildStructuredKey(namespace, representationName, idValues) {
        return this.environment.buildStructuredKey(namespace, representationName, idValues);
      }
    }
    const Wildcard = Symbol('Wildcard');
    class InMemoryStoreQueryEvaluator {
      constructor(store) {
        this.store = store;
        this.storeToIndexMap = new WeakMap();
        this.storeToIndexMap.set(store, {
          nodeType: 'indexBySchema',
          value: {}
        });
      }
      queryByKey(keyQuery, keySchema) {
        const keyIndex = this.getKeyIndex(this.store, keySchema);
        if (keyIndex === undefined) {
          return Promise.resolve([]);
        }
        // Breadth-first search with known/constant depth on all branches
        let visited = [keyIndex];
        for (let i = 0; i < keySchema.length; i++) {
          const newVisited = [];
          const keyValue = keyQuery[keySchema[i]];
          // If the query value is wildcard, all values are acceptable
          const wildcard = keyValue === Wildcard;
          for (let j = 0, visitedLength = visited.length; j < visitedLength; j++) {
            const node = visited[j];
            if (node.nodeType === 'key') {
              // Shouldn't happen
              throw new Error('');
            }
            let children = [];
            if (wildcard) {
              // Push all children into queue
              children = values(node.value);
            } else {
              // Only push matching child if it exists
              if (hasOwnProperty.call(node.value, String(keyValue))) {
                children = [node.value[String(keyValue)]];
              }
            }
            newVisited.push(...children);
          }
          visited = newVisited;
        }
        // Once the whole tree has been traversed, visited should only contain leaf nodes, which always have a KeyMetadata value
        const foundKeyNodes = visited.map(element => {
          if (element.nodeType !== 'key') {
            throw new Error(`Found non-key in result: ${stringify(element, undefined, 2)}`);
          }
          return element;
        }) ;
        return Promise.resolve(foundKeyNodes.map(keyNode => keyNode.value));
      }
      queryWhere(keyQuery, keySchema, valueQuery, valueResolver) {
        const defaultResolver = (store, data) => {
          return this.resolveData(store, data);
        };
        const resolver = valueResolver !== null && valueResolver !== void 0 ? valueResolver : defaultResolver;
        return this.queryByKey(keyQuery, keySchema).then(keys => {
          return keys.filter(key => {
            const value = this.store.readEntry(JSON.stringify(key));
            return evaluateValueQuery(this.store, valueQuery, resolver(this.store, value), resolver);
          });
        });
      }
      resolveData(store, value) {
        if (typeof value === 'object' && value !== null && '__link' in value && typeof value['__link'] === 'string') {
          return store.readEntry(value.__link);
        }
        return value;
      }
      registerKey(store, key, keySchema) {
        const keyIndex = this.getOrRegisterKeyIndex(store, keySchema);
        if (keyIndex === undefined) {
          return;
        }
        const keySchemaLength = keySchema.length;
        let currentIndex = keyIndex;
        // Walk the index tree to find the node right above the leaf
        for (let i = 0; i < keySchemaLength - 1; i++) {
          const keyProperty = keySchema[i];
          const keyValue = key[keyProperty];
          currentIndex = this.getOrRegisterSubKeyIndex(currentIndex, keyValue);
        }
        // Set the leaf node for the key
        currentIndex.value[String(key[keySchema[keySchemaLength - 1]])] = {
          nodeType: 'key',
          value: key
        };
      }
      getIndexBySchema(store) {
        return this.storeToIndexMap.get(store);
      }
      getOrRegisterKeyIndex(store, keySchema) {
        const keyIndexBySchema = this.getIndexBySchema(store);
        if (keyIndexBySchema === undefined) {
          return undefined;
        }
        const keySchemaIdentifier = this.getKeySchemaIdentifier(keySchema);
        let maybeKeyIndex = keyIndexBySchema.value[keySchemaIdentifier];
        if (maybeKeyIndex === undefined) {
          maybeKeyIndex = {
            nodeType: 'index',
            value: {}
          };
          keyIndexBySchema.value[keySchemaIdentifier] = maybeKeyIndex;
        }
        return maybeKeyIndex;
      }
      getKeyIndex(store, keySchema) {
        let maybeKeyIndexBySchema = this.storeToIndexMap.get(store);
        if (maybeKeyIndexBySchema === undefined) {
          return undefined;
        }
        const keySchemaIdentifier = this.getKeySchemaIdentifier(keySchema);
        return maybeKeyIndexBySchema.value[keySchemaIdentifier];
      }
      getOrRegisterSubKeyIndex(index, keyValue) {
        let nextSubIndex = index.value[String(keyValue)];
        if (nextSubIndex === undefined) {
          nextSubIndex = {
            nodeType: 'index',
            value: {}
          };
          index.value[String(keyValue)] = nextSubIndex;
        } else if (nextSubIndex.nodeType !== 'index') {
          // This condition shouldn't be possible
          throw new Error('Failed to find subindex value');
        }
        return nextSubIndex;
      }
      getKeySchemaIdentifier(keySchema) {
        return keySchema.join(':');
      }
    }
    function evaluateValueQuery(store, query, value, resolver) {
      return Object.entries(query).map(([valueQueryKey, propertyQuery]) => {
        if (valueQueryKey.startsWith('$')) {
          return evaluateValueQueryOperator(store, valueQueryKey, query, value, resolver);
        } else {
          if (typeof value === 'object') {
            if (isArray(value)) {
              {
                throw new Error('Array querying is not supported yet');
              }
            }
            return evaluateValueQuery(store, propertyQuery, resolver(store, value[valueQueryKey]), resolver);
          }
        }
      }).every(result => result === true);
    }
    const queryOperatorToEvaluatorMap = {
      $eq: evaluateEqualsOperator,
      $ne: evaluateNotEqualOperator,
      $gt: evaluateGreaterThanOperator,
      $gte: evaluateGreaterThanOrEqualOperator,
      $lt: evaluateLessThanOperator,
      $lte: evaluateLessThanOrEqualOperator,
      $and: evaluateAndOperator,
      $not: evaluateNotOperator,
      $nor: evaluateNorOperator,
      $or: evaluateOrOperator,
      $in: evaluateInOperator,
      $nin: evaluateNotInOperator,
      $exists: evaluateExistsOperator,
      $regex: evaluateRegexOperator
    };
    function evaluateValueQueryOperator(store, operator, operatorQuery, value, resolver) {
      const evaluator = queryOperatorToEvaluatorMap[operator];
      if (evaluator === undefined) {
        {
          throw new Error(`Unsupported operator: ${operator}`);
        }
      }
      return evaluator(store, operatorQuery, value, resolver);
    }
    function evaluateEqualsOperator(_store, query, value, _resolver) {
      // TODO: This won't handle deep comparisons
      if (typeof value === 'object' && value !== null) {
        {
          throw new Error('Equals comparison against objects is not supported');
        }
      }
      return query.$eq === value;
    }
    function evaluateNotEqualOperator(store, query, value, resolver) {
      return !evaluateEqualsOperator(store, {
        $eq: query.$ne
      }, value);
    }
    function evaluateGreaterThanOperator(_store, query, value, _resolver) {
      const result = value > query.$gt;
      return result;
    }
    function evaluateGreaterThanOrEqualOperator(_store, query, value, _resolver) {
      const result = value >= query.$gte;
      return result;
    }
    function evaluateLessThanOperator(_store, query, value, _resolver) {
      const result = value < query.$lt;
      return result;
    }
    function evaluateLessThanOrEqualOperator(_store, query, value, _resolver) {
      const result = value <= query.$lte;
      return result;
    }
    function evaluateAndOperator(store, query, value, resolver) {
      for (let i = 0; i < query.$and.length; i++) {
        const subQuery = query.$and[i];
        const result = evaluateValueQuery(store, subQuery, value, resolver);
        if (result === false) {
          return false;
        }
      }
      return true;
    }
    function evaluateOrOperator(store, query, value, resolver) {
      for (let i = 0; i < query.$or.length; i++) {
        const subQuery = query.$or[i];
        const result = evaluateValueQuery(store, subQuery, value, resolver);
        if (result === true) {
          return true;
        }
      }
      return false;
    }
    function evaluateNorOperator(store, query, value, resolver) {
      const result = !evaluateOrOperator(store, {
        $or: query.$nor
      }, value, resolver);
      return result;
    }
    function evaluateNotOperator(store, query, value, resolver) {
      const result = !evaluateValueQuery(store, query.$not, value, resolver);
      return result;
    }
    function evaluateInOperator(store, query, value, resolver) {
      for (let i = 0; i < query.$in.length; i++) {
        const comparisonValue = query.$in[i];
        if (evaluateEqualsOperator(store, {
          $eq: comparisonValue
        }, value)) {
          return true;
        }
      }
      return false;
    }
    function evaluateNotInOperator(store, query, value, resolver) {
      const result = !evaluateInOperator(store, {
        $in: query.$nin
      }, value);
      return result;
    }
    function evaluateExistsOperator(_store, query, value, _resolver) {
      const valueExists = value !== undefined && value !== null;
      const result = query.$exists ? valueExists : !valueExists;
      return result;
    }
    function evaluateRegexOperator(_store, query, value, _resolver) {
      const result = query.$regex.test(value);
      return result;
    }
    var ResourceParamType;
    (function (ResourceParamType) {
      ResourceParamType[ResourceParamType["UrlParameter"] = 0] = "UrlParameter";
      ResourceParamType[ResourceParamType["QueryParameter"] = 1] = "QueryParameter";
      ResourceParamType[ResourceParamType["Body"] = 2] = "Body";
      ResourceParamType[ResourceParamType["Header"] = 3] = "Header";
    })(ResourceParamType || (ResourceParamType = {}));
    var TypeCheckShapes;
    (function (TypeCheckShapes) {
      TypeCheckShapes[TypeCheckShapes["String"] = 0] = "String";
      TypeCheckShapes[TypeCheckShapes["Boolean"] = 1] = "Boolean";
      TypeCheckShapes[TypeCheckShapes["Number"] = 2] = "Number";
      TypeCheckShapes[TypeCheckShapes["Integer"] = 3] = "Integer";
      TypeCheckShapes[TypeCheckShapes["Unsupported"] = 4] = "Unsupported";
    })(TypeCheckShapes || (TypeCheckShapes = {}));

    // Note: these should be in sync with the compiler ones:
    // https://github.com/salesforce-experience-platform-emu/luvio/blob/main/packages/%40luvio/compiler/src/intermediate/resource.ts#L76-L79
    const CONFIG_PROPERTY_URL_PARAMS = 'urlParams';
    const CONFIG_PROPERTY_QUERY_PARAMS = 'queryParams';
    const CONFIG_PROPERTY_BODY = 'body';
    const CONFIG_PROPERTY_HEADERS = 'headers';
    function isCorrectScalarType(value, type) {
      switch (type) {
        case TypeCheckShapes.String:
          return typeof value === 'string';
        case TypeCheckShapes.Boolean:
          return typeof value === 'boolean';
        case TypeCheckShapes.Number:
          return typeof value === 'number';
        case TypeCheckShapes.Integer:
          return typeof value === 'number' && Math.floor(value) === value;
        default:
          return false;
      }
    }
    function typeCheckArrayOfScalars(untrustedConfig, config, name, typeCheckShape) {
      const untrustedConfig_field = untrustedConfig[name];
      if (isArray(untrustedConfig_field)) {
        const untrustedConfig_field_array = [];
        for (let i = 0, arrayLength = untrustedConfig_field.length; i < arrayLength; i++) {
          const untrustedConfig_field_item = untrustedConfig_field[i];
          if (isCorrectScalarType(untrustedConfig_field_item, typeCheckShape)) {
            untrustedConfig_field_array.push(untrustedConfig_field_item);
          }
        }
        config[name] = untrustedConfig_field_array;
      }
    }
    function typeCheckConfig(untrustedConfig, config, configMetadata) {
      configMetadata.forEach(({
        name,
        typeCheckShape,
        isArrayShape
      }) => {
        switch (typeCheckShape) {
          case TypeCheckShapes.Unsupported:
            return;
          case TypeCheckShapes.String:
          case TypeCheckShapes.Boolean:
          case TypeCheckShapes.Number:
          case TypeCheckShapes.Integer:
            {
              if (isArrayShape) {
                typeCheckArrayOfScalars(untrustedConfig, config, name, typeCheckShape);
              } else {
                const untrustedConfig_field = untrustedConfig[name];
                if (isCorrectScalarType(untrustedConfig_field, typeCheckShape)) {
                  config[name] = untrustedConfig_field;
                }
              }
              return;
            }
          default:
            {
              return;
            }
        }
      });
    }
    function coerceConfig(uncoercedConfig, configMetadata) {
      const config = {};
      configMetadata.forEach(({
        name,
        coerceFn
      }) => {
        const value = coerceFn === undefined ? uncoercedConfig[name] : coerceFn(uncoercedConfig[name]);
        if (value !== undefined) {
          config[name] = value;
        }
      });
      return config;
    }
    function buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext, buildNetworkSnapshotIdentifier, alternativeMethod, includeCacheSnapshot) {
      const {
        luvio,
        config
      } = context;
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext,
          luvioRequestMethod: alternativeMethod
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return includeCacheSnapshot ? buildNetworkSnapshotIdentifier(luvio, config, dispatchOptions, context.cacheSnapshot) : buildNetworkSnapshotIdentifier(luvio, config, dispatchOptions);
    }
    function ingestShape(input, path, luvio, store, timestamp, ttlToUse, key, normalize, namespace, version, representationName, equals) {
      const existingRecord = store.readEntry(key);
      let incomingRecord = normalize(input, existingRecord, {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
        ttl: ttlToUse
      }, luvio, store, timestamp);
      if (existingRecord === undefined || equals(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
      }
      if (ttlToUse !== undefined) {
        const storeMetadataParams = {
          ttl: ttlToUse,
          namespace,
          version,
          representationName,
          ingestionTimestamp: timestamp
        };
        luvio.publishStoreMetadata(key, storeMetadataParams);
      }
    }
    function createResourceParams(configMetadata) {
      return config => createResourceParamsImpl(config, configMetadata);
    }
    function createResourceParamsImpl(config, configMetadata) {
      const parametersReducer = (acc, {
        name
      }) => {
        acc[name] = config[name];
        return acc;
      };
      const urlParams = configMetadata.filter(p => p.resourceType === ResourceParamType.UrlParameter).reduce(parametersReducer, {});
      const queryParams = configMetadata.filter(p => p.resourceType === ResourceParamType.QueryParameter).reduce(parametersReducer, {});
      const headerParams = configMetadata.filter(p => p.resourceType === ResourceParamType.Header).reduce(parametersReducer, {});
      const bodyParams = configMetadata.filter(p => p.resourceType === ResourceParamType.Body);
      const actualBodyParams = bodyParams.reduce((acc, {
        name,
        required
      }) => {
        const configValue = config[name];
        if (required) {
          acc[name] = configValue;
        } else if (configValue !== undefined) {
          acc[name] = configValue;
        }
        return acc;
      }, {});
      const resourceParams = {};
      if (keys(urlParams).length > 0) {
        resourceParams[CONFIG_PROPERTY_URL_PARAMS] = urlParams;
      }
      if (keys(queryParams).length > 0) {
        resourceParams[CONFIG_PROPERTY_QUERY_PARAMS] = queryParams;
      }
      if (bodyParams.length > 0) {
        resourceParams[CONFIG_PROPERTY_BODY] = actualBodyParams;
      }
      if (keys(headerParams).length > 0) {
        resourceParams[CONFIG_PROPERTY_HEADERS] = headerParams;
      }
      return resourceParams;
    }
    // version: 1.309.0-dev21-4baf03ecaf
    const __lwc_hmr_context = { moduleHash : '111984866657c41c81ca4000779f8a87' };
    if (lwc.hot) {
        lwc.hot.register('force/luvioEngine/luvioEngine.js', '111984866657c41c81ca4000779f8a87', {"name":"luvioEngine","namespace":"force","enableLightningWebSecurityTransforms":false,"experimentalDynamicComponent":{"loader":"@salesforce/loader","strictSpecifier":false},"experimentalDynamicDirective":false,"enableDynamicComponents":true,"enableStaticContentOptimization":true,"outputConfig":{"sourcemap":false}});
    }

    exports.Environment = Environment;
    exports.GraphNode = GraphNode;
    exports.InMemoryStore = InMemoryStore;
    exports.InMemoryStoreQueryEvaluator = InMemoryStoreQueryEvaluator;
    exports.Luvio = Luvio;
    exports.Reader = Reader;
    exports.StoreKeyMap = StoreKeyMap;
    exports.StoreKeySet = StoreKeySet;
    exports.StringKeyInMemoryStore = StringKeyInMemoryStore;
    exports.Wildcard = Wildcard;
    exports.__lwc_hmr_context = __lwc_hmr_context;
    exports.adapterToNetworkPriority = adapterToNetworkPriority;
    exports.buildNetworkSnapshotCachePolicy = buildNetworkSnapshotCachePolicy;
    exports.coerceAdapterRequestContext = coerceAdapterRequestContext;
    exports.coerceConfig = coerceConfig;
    exports.createCustomAdapterEventEmitter = createCustomAdapterEventEmitter;
    exports.createResourceParams = createResourceParams;
    exports.deepFreeze = deepFreeze;
    exports.emitAdapterEvent = emitAdapterEvent;
    exports.ingestShape = ingestShape;
    exports.isFileReference = isFileReference;
    exports.isFormData = isFormData;
    exports.resolveLink = resolveLink;
    exports.serializeStructuredKey = serializeStructuredKey;
    exports.setBypassDeepFreeze = setBypassDeepFreeze;
    exports.typeCheckConfig = typeCheckConfig;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('force/ldsAdaptersApex', ['exports', 'lwc', 'force/luvioEngine', 'force/ldsBindings', 'force/ldsEngineWebruntime'], (function (exports, lwc, luvioEngine, ldsBindings, ldsEngine) {

    const {
      hasOwnProperty
    } = Object.prototype;

    /**
     * Returns the field API name, qualified with an object name if possible.
     * @param value The value from which to get the qualified field API name.
     * @return The qualified field API name.
     */
    function getFieldApiName(value) {
      if (typeof value === 'string') {
        return value;
      } else if (value && typeof value.objectApiName === 'string' && typeof value.fieldApiName === 'string') {
        return value.objectApiName + '.' + value.fieldApiName;
      }
      throw new TypeError('Value is not a string or FieldId.');
    }
    /**
     * Split the object API name and field API name from a qualified field name.
     * Eg: Opportunity.Title returns ['Opportunity', 'Title']
     * Eg: Opportunity.Account.Name returns ['Opportunity', 'Account.Name']
     * @param fieldApiName The qualified field name.
     * @return The object and field API names.
     */
    function splitQualifiedFieldApiName(fieldApiName) {
      const idx = fieldApiName.indexOf('.');
      if (idx < 1) {
        // object api name must non-empty
        throw new TypeError('Value does not include an object API name.');
      }
      return [fieldApiName.substring(0, idx), fieldApiName.substring(idx + 1)];
    }
    const {
      isArray: ArrayIsArray$1
    } = Array;
    function untrustedIsObject$1(untrusted) {
      return typeof untrusted === 'object' && untrusted !== null && ArrayIsArray$1(untrusted) === false;
    }

    /**
     * Gets a field value from an Apex sObject.
     * @param sobject The sObject holding the field.
     * @param field The qualified API name of the field to return.
     * @returns The field's value. If it doesn't exist, undefined is returned.
     */
    function getSObjectValue(sObject, field) {
      if (untrustedIsObject$1(sObject) === false) {
        return;
      }
      const unqualifiedField = splitQualifiedFieldApiName(getFieldApiName(field))[1];
      const fields = unqualifiedField.split('.');
      let ret = sObject;
      for (let i = 0, fieldsLength = fields.length; i < fieldsLength; i++) {
        const nextField = fields[i];
        if (!hasOwnProperty.call(ret, nextField)) {
          return undefined;
        }
        ret = ret[nextField];
      }
      return ret;
    }
    if (lwc.hot) {
        lwc.hot.register('force/ldsAdaptersApex/lds-apex-static-utils.js', '8c7b0e16bff01b5bde95d56d061a2226', {"name":"ldsAdaptersApex","namespace":"force","enableLightningWebSecurityTransforms":false,"experimentalDynamicComponent":{"loader":"@salesforce/loader","strictSpecifier":false},"experimentalDynamicDirective":false,"enableDynamicComponents":true,"enableStaticContentOptimization":true,"outputConfig":{"sourcemap":false}});
    }

    const {
      keys: ObjectKeys,
      create: ObjectCreate
    } = Object;
    const {
      stringify: JSONStringify
    } = JSON;
    const {
      isArray: ArrayIsArray
    } = Array;
    function untrustedIsObject(untrusted) {
      return typeof untrusted === 'object' && untrusted !== null && ArrayIsArray(untrusted) === false;
    }
    const snapshotRefreshOptions = {
      overrides: {
        headers: {
          'Cache-Control': 'no-cache'
        }
      }
    };
    /**
     * A deterministic JSON stringify implementation. Heavily adapted from https://github.com/epoberezkin/fast-json-stable-stringify.
     * This is needed because insertion order for JSON.stringify(object) affects output:
     * JSON.stringify({a: 1, b: 2})
     *      "{"a":1,"b":2}"
     * JSON.stringify({b: 2, a: 1})
     *      "{"b":2,"a":1}"
     * @param data Data to be JSON-stringified.
     * @returns JSON.stringified value with consistent ordering of keys.
     */
    function stableJSONStringify$1(node) {
      // This is for Date values.
      if (node && node.toJSON && typeof node.toJSON === 'function') {
        // eslint-disable-next-line no-param-reassign
        node = node.toJSON();
      }
      if (node === undefined) {
        return;
      }
      if (typeof node === 'number') {
        return isFinite(node) ? '' + node : 'null';
      }
      if (typeof node !== 'object') {
        return JSONStringify(node);
      }
      let i;
      let out;
      if (ArrayIsArray(node)) {
        out = '[';
        for (i = 0; i < node.length; i++) {
          if (i) {
            out += ',';
          }
          out += stableJSONStringify$1(node[i]) || 'null';
        }
        return out + ']';
      }
      if (node === null) {
        return 'null';
      }
      const keys = ObjectKeys(node).sort();
      out = '';
      for (i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = stableJSONStringify$1(node[key]);
        if (!value) {
          continue;
        }
        if (out) {
          out += ',';
        }
        out += JSONStringify(key) + ':' + value;
      }
      return '{' + out + '}';
    }
    const keyPrefix = 'Apex';
    function createResourceRequest$1(config) {
      const headers = {};
      const header_xSFDCAllowContinuation = config.headers.xSFDCAllowContinuation;
      if (header_xSFDCAllowContinuation !== undefined) {
        headers['X-SFDC-Allow-Continuation'] = header_xSFDCAllowContinuation;
      }
      return {
        baseUri: '/lwr/apex/v62.0',
        basePath: '/' + config.urlParams.apexClass + '/' + config.urlParams.apexMethod + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
        priority: 'normal'
      };
    }
    const {
      create,
      keys,
      values
    } = Object;
    const {
      isArray
    } = Array;
    const {
      stringify
    } = JSON;
    function createLink(ref) {
      return {
        __ref: luvioEngine.serializeStructuredKey(ref)
      };
    }
    const CACHE_CONTROL = 'cache-control';
    // eslint-disable-next-line @salesforce/lds/no-invalid-todo
    // TODO: APEX_TTL, apexResponseEquals, apexResponseIngest, and validateAdapterConfig should have been code generated
    // however compiler does not support response body type any so hand roll for now
    /**
     * Time to live for the Apex cache value. 5 minutes.
     */
    const APEX_TTL = 5 * 60 * 1000;
    // apex is essentially versionless, we can never know the shape of apex data
    // so we will rely on components to code defensively. All apex data will be ingested
    // and looked up with this version
    const APEX_VERSION = 'APEX_V_1';
    const APEX_STORE_METADATA_PARAMS = {
      ttl: APEX_TTL,
      namespace: keyPrefix,
      representationName: '',
      version: APEX_VERSION
    };
    function apexResponseEquals(existing, incoming) {
      return stringify(incoming) === stringify(existing);
    }
    const apexResponseIngest = (input, path, luvio, store, timestamp) => {
      // skip validation and normalization, since input type is any
      const key = path.fullPath;
      const incomingRecord = input;
      const existingRecord = store.readEntry(key);
      // freeze on ingest (luvio.opaque)
      luvioEngine.deepFreeze(incomingRecord);
      if (existingRecord === undefined || apexResponseEquals(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
      }
      luvio.publishStoreMetadata(key, {
        ...APEX_STORE_METADATA_PARAMS,
        ingestionTimestamp: timestamp
      });
      return createLink(key);
    };
    function validateAdapterConfig(untrustedConfig) {
      if (untrustedIsObject(untrustedConfig)) {
        const values$1 = values(untrustedConfig);
        return values$1.indexOf(undefined) === -1 ? untrustedConfig : null;
      }
      return untrustedConfig;
    }
    /**
     * A standard delimiter when producing cache keys.
     */
    const KEY_DELIM = ':';
    function isEmptyParam(param) {
      return param === undefined || param === null || typeof param === 'object' && keys(param).length === 0;
    }
    function keyBuilder(classname, method, isContinuation, params) {
      return [classname.replace('__', KEY_DELIM), method, isContinuation, isEmptyParam(params) ? '' : stableJSONStringify$1(params)].join(KEY_DELIM);
    }
    function configBuilder(config, classname, method, isContinuation) {
      return {
        apexMethod: method,
        apexClass: classname,
        methodParams: config,
        xSFDCAllowContinuation: isContinuation + ''
      };
    }
    function apexClassnameBuilder(namespace, classname) {
      return namespace !== '' ? `${namespace}__${classname}` : classname;
    }
    function isCacheControlValueCacheable(value) {
      if (value === undefined || value === null || typeof value !== 'string') {
        return false;
      }
      return value.indexOf('no-cache') < 0 && value.indexOf('no-store') < 0;
    }
    function getCacheControlHeaderValue(headers) {
      if (headers === undefined) {
        return undefined;
      }
      // header fields are case-insensitive according to
      // https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
      const headerKeys = keys(headers);
      for (let i = 0, len = headerKeys.length; i < len; i += 1) {
        const key = headerKeys[i];
        if (key.toLowerCase() === CACHE_CONTROL) {
          return headers[key];
        }
      }
      return undefined;
    }
    function shouldCache(response) {
      const {
        headers
      } = response;
      const headerValue = getCacheControlHeaderValue(headers);
      return isCacheControlValueCacheable(headerValue);
    }
    function createResourceParams$1(config) {
      const queryParams = create(null);
      if (!isEmptyParam(config.methodParams)) {
        queryParams.methodParams = config.methodParams;
      }
      return {
        queryParams,
        urlParams: {
          apexMethod: config.apexMethod,
          apexClass: config.apexClass
        },
        headers: {
          xSFDCAllowContinuation: config.xSFDCAllowContinuation
        }
      };
    }
    function keyBuilderFromResourceParams$1(params) {
      let classname = params.urlParams.apexClass.replace('__', KEY_DELIM);
      return [classname, params.urlParams.apexMethod, params.headers.xSFDCAllowContinuation, isEmptyParam(params.queryParams.methodParams) ? '' : stableJSONStringify$1(params.queryParams.methodParams)].join(KEY_DELIM);
    }
    function ingestSuccess$1(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const recordId = keyBuilderFromResourceParams$1(resourceParams);
      const select = {
        recordId,
        node: {
          kind: 'Fragment',
          opaque: true,
          private: [],
          version: APEX_VERSION
        },
        variables: {}
      };
      luvio.storeIngest(recordId, apexResponseIngest, body);
      const snapshot = luvio.storeLookup(select, snapshotRefresh);
      {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
          throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
      }
      return snapshot;
    }
    function buildCachedSnapshotCachePolicy$1(buildSnapshotContext, storeLookup) {
      const {
        luvio,
        config
      } = buildSnapshotContext;
      const {
        apexClass,
        apexMethod,
        xSFDCAllowContinuation,
        methodParams
      } = config;
      const recordId = keyBuilder(apexClass, apexMethod, xSFDCAllowContinuation, methodParams);
      return storeLookup({
        recordId: recordId,
        node: {
          kind: 'Fragment',
          opaque: true,
          private: [],
          version: APEX_VERSION
        },
        variables: {}
      }, {
        config,
        resolve: () => buildNetworkSnapshot$1(luvio, config, snapshotRefreshOptions)
      });
    }
    function onFetchResponseSuccess$1(luvio, config, resourceParams, response) {
      const recordId = keyBuilderFromResourceParams$1(resourceParams);
      const select = {
        recordId,
        node: {
          kind: 'Fragment',
          opaque: true,
          private: [],
          version: APEX_VERSION
        },
        variables: {}
      };
      if (shouldCache(response)) {
        const snapshot = ingestSuccess$1(luvio, resourceParams, response, {
          config,
          resolve: () => buildNetworkSnapshot$1(luvio, config, snapshotRefreshOptions)
        });
        return luvio.storeBroadcast().then(() => snapshot);
      }
      // if Cache-Control is not set or set to 'no-cache', return a synthetic snapshot
      return Promise.resolve({
        recordId,
        variables: {},
        seenRecords: new luvioEngine.StoreKeySet(),
        select,
        state: 'Fulfilled',
        data: response.body
      });
    }
    function onFetchResponseError$1(luvio, config, _resourceParams, response) {
      return Promise.resolve(luvio.errorSnapshot(response, {
        config,
        resolve: () => buildNetworkSnapshot$1(luvio, config, snapshotRefreshOptions)
      }));
    }
    function buildNetworkSnapshot$1(luvio, config, options) {
      const resourceParams = createResourceParams$1(config);
      const request = createResourceRequest$1(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess$1(luvio, config, resourceParams, response),
        // TODO [W-10490362]: Properly generate the response cache keys
        () => {
          return new luvioEngine.StoreKeyMap();
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError$1(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy$1(context, coercedAdapterRequestContext) {
      const {
        luvio,
        config
      } = context;
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return buildNetworkSnapshot$1(luvio, config, dispatchOptions);
    }
    const factory = (luvio, invokerParams) => {
      const {
        namespace,
        classname,
        method,
        isContinuation
      } = invokerParams;
      return getApexAdapterFactory(luvio, namespace, classname, method, isContinuation);
    };
    function getApexAdapterFactory(luvio, namespace, classname, method, isContinuation) {
      return (untrustedConfig, requestContext) => {
        // Even though the config is of type `any`,
        // validation is required here because `undefined`
        // values on a wire mean that properties on the component
        // used in the config have not been loaded yet.
        const config = validateAdapterConfig(untrustedConfig);
        // Invalid or incomplete config
        if (config === null) {
          return null;
        }
        const configPlus = configBuilder(config, apexClassnameBuilder(namespace, classname), method, isContinuation);
        return luvio.applyCachePolicy(requestContext || {}, {
          config: configPlus,
          luvio
        }, buildCachedSnapshotCachePolicy$1, buildNetworkSnapshotCachePolicy$1);
      };
    }

    /**
     * A deterministic JSON stringify implementation. Heavily adapted from https://github.com/epoberezkin/fast-json-stable-stringify.
     * This is needed because insertion order for JSON.stringify(object) affects output:
     * JSON.stringify({a: 1, b: 2})
     *      "{"a":1,"b":2}"
     * JSON.stringify({b: 2, a: 1})
     *      "{"b":2,"a":1}"
     * @param data Data to be JSON-stringified.
     * @returns JSON.stringified value with consistent ordering of keys.
     */
    function stableJSONStringify(node) {
      // This is for Date values.
      if (node && node.toJSON && typeof node.toJSON === 'function') {
        // eslint-disable-next-line no-param-reassign
        node = node.toJSON();
      }
      if (node === undefined) {
        return;
      }
      if (typeof node === 'number') {
        return isFinite(node) ? '' + node : 'null';
      }
      if (typeof node !== 'object') {
        return stringify(node);
      }
      let i;
      let out;
      if (isArray(node)) {
        out = '[';
        for (i = 0; i < node.length; i++) {
          if (i) {
            out += ',';
          }
          out += stableJSONStringify(node[i]) || 'null';
        }
        return out + ']';
      }
      if (node === null) {
        return 'null';
      }
      const keys$1 = keys(node).sort();
      out = '';
      for (i = 0; i < keys$1.length; i++) {
        const key = keys$1[i];
        const value = stableJSONStringify(node[key]);
        if (!value) {
          continue;
        }
        if (out) {
          out += ',';
        }
        out += stringify(key) + ':' + value;
      }
      return '{' + out + '}';
    }
    function createResourceRequest(config) {
      const headers = {};
      const header_xSFDCAllowContinuation = config.headers.xSFDCAllowContinuation;
      if (header_xSFDCAllowContinuation !== undefined) {
        headers['X-SFDC-Allow-Continuation'] = header_xSFDCAllowContinuation;
      }
      return {
        baseUri: '/lwr/apex/v62.0',
        basePath: '/' + config.urlParams.apexClass + '/' + config.urlParams.apexMethod + '',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
        priority: 'normal'
      };
    }
    function createResourceParams(config) {
      return {
        urlParams: {
          apexMethod: config.apexMethod,
          apexClass: config.apexClass
        },
        body: config.methodParams,
        headers: {
          xSFDCAllowContinuation: config.xSFDCAllowContinuation
        }
      };
    }
    function keyBuilderFromResourceParams(params) {
      let classname = params.urlParams.apexClass.replace('__', KEY_DELIM);
      return [classname, params.urlParams.apexMethod, params.headers.xSFDCAllowContinuation, isEmptyParam(params.body) ? '' : stableJSONStringify(params.body)].join(KEY_DELIM);
    }
    function ingestSuccess(luvio, resourceParams, response, snapshotRefresh) {
      const {
        body
      } = response;
      const recordId = keyBuilderFromResourceParams(resourceParams);
      const select = {
        recordId,
        node: {
          kind: 'Fragment',
          opaque: true,
          private: [],
          version: APEX_VERSION
        },
        variables: {}
      };
      luvio.storeIngest(recordId, apexResponseIngest, body);
      const snapshot = luvio.storeLookup(select, snapshotRefresh);
      {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
          throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
          throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
      }
      return snapshot;
    }
    function buildCachedSnapshotCachePolicy(buildSnapshotContext, storeLookup) {
      const {
        config
      } = buildSnapshotContext;
      const {
        apexClass,
        apexMethod,
        xSFDCAllowContinuation,
        methodParams
      } = config;
      const recordId = keyBuilder(apexClass, apexMethod, xSFDCAllowContinuation, methodParams);
      return storeLookup({
        recordId: recordId,
        node: {
          kind: 'Fragment',
          opaque: true,
          private: [],
          version: APEX_VERSION
        },
        variables: {}
      });
    }
    function onFetchResponseSuccess(luvio, _config, resourceParams, response) {
      const recordId = keyBuilderFromResourceParams(resourceParams);
      const select = {
        recordId,
        node: {
          kind: 'Fragment',
          opaque: true,
          private: [],
          version: APEX_VERSION
        },
        variables: {}
      };
      if (shouldCache(response)) {
        const snapshot = ingestSuccess(luvio, resourceParams, response);
        return luvio.storeBroadcast().then(() => snapshot);
      }
      // if Cache-Control is not set or set to 'no-cache', return a synthetic snapshot
      return Promise.resolve({
        recordId,
        variables: {},
        seenRecords: new luvioEngine.StoreKeySet(),
        select,
        state: 'Fulfilled',
        data: response.body
      });
    }
    function onFetchResponseError(luvio, _config, _resourceParams, response) {
      return Promise.resolve(luvio.errorSnapshot(response));
    }
    function buildNetworkSnapshot(luvio, config, options) {
      const resourceParams = createResourceParams(config);
      const request = createResourceRequest(resourceParams);
      return luvio.dispatchResourceRequest(request, options).then(response => {
        return luvio.handleSuccessResponse(() => onFetchResponseSuccess(luvio, config, resourceParams, response),
        // TODO [W-10490362]: Properly generate response cache keys
        () => {
          return new luvioEngine.StoreKeyMap();
        });
      }, response => {
        return luvio.handleErrorResponse(() => onFetchResponseError(luvio, config, resourceParams, response));
      });
    }
    function buildNetworkSnapshotCachePolicy(context, coercedAdapterRequestContext) {
      const {
        luvio,
        config
      } = context;
      const {
        networkPriority,
        requestCorrelator,
        eventObservers,
        sourceContext
      } = coercedAdapterRequestContext;
      const dispatchOptions = {
        resourceRequestContext: {
          requestCorrelator,
          sourceContext
        },
        eventObservers
      };
      if (networkPriority !== 'normal') {
        dispatchOptions.overrides = {
          priority: networkPriority
        };
      }
      return buildNetworkSnapshot(luvio, config, dispatchOptions);
    }
    function handleSnapshot(snapshot) {
      if (snapshot.state === 'Error') {
        throw snapshot.error;
      }
      return snapshot.data;
    }
    /**
     * Returns a function that executes the supplied ldsAdapter,
     * and handles unwrapping the snapshot to return to caller
     *
     * @param ldsAdapter adapter to be invoked
     * @returns an ApexInvoker
     */
    function invoker(ldsAdapter) {
      return (config, requestContext) => {
        const snapshotOrPromise = ldsAdapter(config, requestContext);
        return Promise.resolve(snapshotOrPromise).then(handleSnapshot);
      };
    }
    const invokerFactory = (luvio, invokerParams, adapterFactory) => {
      const {
        namespace,
        classname,
        method,
        isContinuation
      } = invokerParams;
      const ldsAdapter = adapterFactory(luvio, namespace, classname, method, isContinuation);
      return invoker(ldsAdapter);
    };
    const postInvoker = (luvio, invokerParams) => {
      return invokerFactory(luvio, invokerParams, postApexAdapterFactory);
    };
    const getInvoker = (luvio, invokerParams) => {
      return invokerFactory(luvio, invokerParams, getApexAdapterFactory);
    };
    function postApexAdapterFactory(luvio, namespace, classname, method, isContinuation) {
      return (config, requestContext) => {
        // config validation is unnecessary for this imperative adapter
        // due to the config being of type `any`.
        // however, we have special config validation for the wire adapter,
        // explanation in getApex
        const configPlus = configBuilder(config, apexClassnameBuilder(namespace, classname), method, isContinuation);
        return luvio.applyCachePolicy(requestContext || {}, {
          config: configPlus,
          luvio
        }, buildCachedSnapshotCachePolicy, buildNetworkSnapshotCachePolicy);
      };
    }
    const engineForPrefetcherMap = new Map();
    function registerPrefetcher(luvio, prefetcher) {
      {
        if (engineForPrefetcherMap.has(luvio)) {
          throw new Error('Environment error: Only one prefetcher per engine is allowed.');
        }
      }
      engineForPrefetcherMap.set(luvio, prefetcher);
    }
    function getPrefetcherFor(luvio) {
      return engineForPrefetcherMap.get(luvio);
    }
    function createGetApexAdapterWithPrediction(adapter, luvio, invokerParams, name) {
      return (config, requestContext) => {
        const prefetcher = getPrefetcherFor(luvio);
        const result = adapter(config, requestContext);
        // only save requests with a valid config.
        if (result !== null && prefetcher !== undefined && !(requestContext && requestContext.excludeFromPredictions)) {
          prefetcher.saveRequest({
            adapterName: 'getApex',
            config: {
              name,
              invokerParams,
              config
            }
          });
        }
        return result;
      };
    }
    const REFRESH_APEX_KEY = 'refreshApex';
    // export for @salesforce/apex
    const refreshApex = function (data) {
      return ldsBindings.refresh(data, REFRESH_APEX_KEY);
    };
    let luvio;
    ldsEngine.withDefaultLuvio(_luvio => {
      luvio = _luvio;
      ldsBindings.bindWireRefresh(luvio);
    });
    /**
     * Imperative GET Apex Adapter.
     *
     * @param namespace a one- to 15-character alphanumeric identifier that distinguishes a package and its contents from other packages
     * @param classname name of class where method is defined
     * @param method name of method defining the Apex code
     * @param isContinuation used to specify if the Apex method is a Continuation
     * @returns an ImperativeAdapter that uses the GET endpoint
     */
    const getApexInvoker_imperative = function (namespace, classname, method, isContinuation) {
      if (luvio === undefined) {
        {
          throw new Error('cannot create Apex adapter before default luvio is set');
        }
      }
      const adapterName = `getApex_${namespace}_${classname}_${method}_${isContinuation}`;
      const adapterMetadata = {
        apiFamily: 'Apex',
        name: adapterName
      };
      const getApexInstrumentedLdsAdapter = ldsBindings.createInstrumentedAdapter(ldsBindings.createLDSAdapter(luvio, adapterName, luvio => factory(luvio, {
        namespace,
        classname,
        method,
        isContinuation
      })), adapterMetadata);
      return ldsBindings.createImperativeAdapter(luvio, getApexInstrumentedLdsAdapter, adapterMetadata);
    };
    /**
     * Apex
     *
     * The Apex invoker is dual purpose; it can be invoked imperatively or be provided to an @wire
     * In order for this to work, LWC will look for the property "adapter" on the object, and check that
     * it conforms to the WireAdapter interface.
     */
    const getApexInvoker = function (namespace, classname, method, isContinuation, isCacheable) {
      if (luvio === undefined) {
        {
          throw new Error('cannot create Apex adapter before default luvio is set');
        }
      }
      const adapterName = `getApex_${namespace}_${classname}_${method}_${isContinuation}`;
      const adapterMetadata = {
        apiFamily: 'Apex',
        name: adapterName
      };
      const apexInvoker = isCacheable ? getInvoker : postInvoker;
      const invokeApexImperative = ldsBindings.createLDSAdapter(luvio, adapterName, luvio => apexInvoker(luvio, {
        namespace,
        classname,
        method,
        isContinuation
      }));
      invokeApexImperative.adapter = ldsBindings.createWireAdapterConstructor(luvio, ldsBindings.createInstrumentedAdapter(createGetApexAdapterWithPrediction(ldsBindings.createLDSAdapter(luvio, adapterName, luvio => factory(luvio, {
        namespace,
        classname,
        method,
        isContinuation
      })), luvio, {
        namespace,
        classname,
        method,
        isContinuation
      }, adapterName), adapterMetadata), adapterMetadata);
      return invokeApexImperative;
    };
    // version: 1.309.0-dev21-4baf03ecaf
    const __lwc_hmr_context = { moduleHash : '337d289492b7a095e50463d26bd160e8' };
    if (lwc.hot) {
        lwc.hot.register('force/ldsAdaptersApex/ldsAdaptersApex.js', '337d289492b7a095e50463d26bd160e8', {"name":"ldsAdaptersApex","namespace":"force","enableLightningWebSecurityTransforms":false,"experimentalDynamicComponent":{"loader":"@salesforce/loader","strictSpecifier":false},"experimentalDynamicDirective":false,"enableDynamicComponents":true,"enableStaticContentOptimization":true,"outputConfig":{"sourcemap":false}});
    }

    exports.GetApexWireAdapterFactory = factory;
    exports.__lwc_hmr_context = __lwc_hmr_context;
    exports.getApexInvoker = getApexInvoker;
    exports.getApexInvoker_imperative = getApexInvoker_imperative;
    exports.getSObjectValue = getSObjectValue;
    exports.refreshApex = refreshApex;
    exports.registerPrefetcher = registerPrefetcher;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/apex/applauncher.ForgotPasswordController.forgotPassword', ['exports', 'lwc', 'force/ldsAdaptersApex'], (function (exports, lwc, ldsAdaptersApex) {

	var _tmpl = void 0;

	const apexInvoker = ldsAdaptersApex.getApexInvoker("applauncher", "ForgotPasswordController", "forgotPassword", "false");
	const __lwc_component_class_internal = lwc.registerComponent(apexInvoker, {
	  tmpl: _tmpl,
	  sel: "@salesforce-3zagzgknf2hxnp3k2nw0a48qbhhx05j6l55ygssu1wjwtdld04kqwistyyte4zgvkuvld4jwyerx91dnkohvfqc",
	  apiVersion: 62
	});

	exports.default = __lwc_component_class_internal;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/label/ForgotPasswordLWC.title', ['@view/forgotPassword/labels'], m => m[1]);
LWR.define('@salesforce/label/ForgotPasswordLWC.prompt', ['@view/forgotPassword/labels'], m => m[2]);
LWR.define('@salesforce/label/ForgotPasswordLWC.username', ['@view/forgotPassword/labels'], m => m[3]);
LWR.define('@salesforce/label/ForgotPasswordLWC.resetButton', ['@view/forgotPassword/labels'], m => m[4]);
LWR.define('@salesforce/label/ForgotPasswordLWC.cancelButton', ['@view/forgotPassword/labels'], m => m[5]);
(function() { LWR.define('lightning/shadowBaseClassPrivate', ['exports', 'lwc'], (function (exports, lwc) {

    const stc0 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      return stc0;
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-758d5qnnql0";
    tmpl.legacyStylesheetToken = "lightning-shadowBaseClassPrivate_shadowBaseClassPrivate";
    lwc.freezeTemplate(tmpl);

    class LightningShadowBaseClass extends lwc.LightningElement {
      connectedCallback() {
        if (!this.template.synthetic) {
          this.setAttribute('data-render-mode', 'shadow');
        }
      }
      /*LWC compiler v7.1.5*/
    }
    const __lwc_component_class_internal = lwc.registerComponent(LightningShadowBaseClass, {
      tmpl: _tmpl,
      sel: "lightning-shadow-base-class-private",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/sldsCommon', ['exports'], (function (exports) {

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ["*", shadowSelector, ",", shadowSelector, "::before,", shadowSelector, "::after {box-sizing: border-box;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) h1" + shadowSelector + ",:host([data-render-mode='shadow']) h2" + shadowSelector + ",:host([data-render-mode='shadow']) h3" + shadowSelector + ",:host([data-render-mode='shadow']) h4" + shadowSelector + ",:host([data-render-mode='shadow']) h5" + shadowSelector + ",:host([data-render-mode='shadow']) h6" : hostSelector + "[data-render-mode='shadow'] h1" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] h2" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] h3" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] h4" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] h5" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] h6")), shadowSelector, " {font-weight: var(--sds-s-heading-font-weight, inherit);margin-block-start: var(\n --sds-s-heading-spacing-block-start,\n var(--sds-s-heading-spacing-block)\n );margin-block-end: var(\n --sds-s-heading-spacing-block-end,\n var(--sds-s-heading-spacing-block)\n );font-size: 1em;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) a" : hostSelector + "[data-render-mode='shadow'] a")), shadowSelector, " {color: var(--slds-s-link-color);text-decoration: var(--_slds-g-font-decoration, none);transition: color 0.1s linear;background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) a:active" + shadowSelector + ",:host([data-render-mode='shadow']) a:hover" : hostSelector + "[data-render-mode='shadow'] a:active" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] a:hover")), shadowSelector, " {outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) a:hover" + shadowSelector + ",:host([data-render-mode='shadow']) a:focus" : hostSelector + "[data-render-mode='shadow'] a:hover" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] a:focus")), shadowSelector, " {text-decoration: var(--_slds-g-font-decoration-hover, underline);color: var(\n --slds-g-link-color-hover,\n var(--slds-g-color-brand-base-30, #014486)\n );}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) a:active" : hostSelector + "[data-render-mode='shadow'] a:active")), shadowSelector, " {color: var(\n --slds-g-link-color-active,\n var(--slds-g-color-brand-base-30, #014486)\n );}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) a:focus-visible" : hostSelector + "[data-render-mode='shadow'] a:focus-visible")), shadowSelector, " {outline-color: var(\n --_slds-g-color-outline,\n var(--slds-g-color-brand-base-50, #0176d3)\n );}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) a:focus" : hostSelector + "[data-render-mode='shadow'] a:focus")), shadowSelector, " {box-shadow: var(--_slds-g-shadow);border-color: var(--_slds-g-color-border);border-width: var(--_slds-g-sizing-border);border-style: var(--_slds-g-style-border);outline: var(--_slds-g-font-decoration-hover);}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) a" + shadowSelector + ",:host([data-render-mode='shadow']) button" : hostSelector + "[data-render-mode='shadow'] a" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] button")), shadowSelector, " {cursor: pointer;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) p" : hostSelector + "[data-render-mode='shadow'] p")), shadowSelector, " {margin-block-start: var(\n --sds-s-content-spacing-block-start,\n var(--sds-s-content-spacing-block, 0)\n );margin-block-end: var(\n --sds-s-content-spacing-block-end,\n var(--sds-s-content-spacing-block, 0)\n );margin-inline-start: 0;margin-inline-end: 0;padding-block-start: 0;padding-block-end: 0;padding-inline-start: 0;padding-inline-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) ol" + shadowSelector + ",:host([data-render-mode='shadow']) ul" : hostSelector + "[data-render-mode='shadow'] ol" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] ul")), shadowSelector, " {list-style: none;padding: 0;margin-block-start: var(\n --sds-s-content-spacing-block-start,\n var(--sds-s-content-spacing-block)\n );margin-block-end: var(\n --sds-s-content-spacing-block-end,\n var(--sds-s-content-spacing-block)\n );}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) button" + shadowSelector + ",:host([data-render-mode='shadow']) [type='button']" + shadowSelector + ",:host([data-render-mode='shadow']) [type='reset']" + shadowSelector + ",:host([data-render-mode='shadow']) [type='submit']" : hostSelector + "[data-render-mode='shadow'] button" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] [type='button']" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] [type='reset']" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] [type='submit']")), shadowSelector, " {-webkit-appearance: button;appearance: button;cursor: pointer;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) [type='search']" : hostSelector + "[data-render-mode='shadow'] [type='search']")), shadowSelector, " {-webkit-appearance: textfield;outline-offset: -2px;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) [type='search']" + shadowSelector + "::-webkit-search-decoration,:host([data-render-mode='shadow']) [type='search']" + shadowSelector + "::-webkit-search-cancel-button,:host([data-render-mode='shadow']) [type='search']" + shadowSelector + "::-webkit-search-results-button,:host([data-render-mode='shadow']) [type='search']" : hostSelector + "[data-render-mode='shadow'] [type='search']" + shadowSelector + "::-webkit-search-decoration," + hostSelector + "[data-render-mode='shadow'] [type='search']" + shadowSelector + "::-webkit-search-cancel-button," + hostSelector + "[data-render-mode='shadow'] [type='search']" + shadowSelector + "::-webkit-search-results-button," + hostSelector + "[data-render-mode='shadow'] [type='search']")), shadowSelector, "::-webkit-search-results-decoration {display: none;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) select" : hostSelector + "[data-render-mode='shadow'] select")), shadowSelector, " {color: inherit;font: inherit;margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) input:focus" + shadowSelector + ",:host([data-render-mode='shadow']) button:focus" + shadowSelector + ",:host([data-render-mode='shadow']) select:focus" + shadowSelector + ",:host([data-render-mode='shadow']) textarea:focus" : hostSelector + "[data-render-mode='shadow'] input:focus" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] button:focus" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] select:focus" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] textarea:focus")), shadowSelector, " {outline-offset: 0;}", shadowSelector, "::-moz-focus-inner {border-style: none;padding: 0;}", shadowSelector, "::-webkit-search-decoration {-webkit-appearance: none;}", shadowSelector, "::-webkit-file-upload-button {-webkit-appearance: button;font: inherit;}:-moz-focusring", shadowSelector, " {outline: 1px dotted ButtonText;}:-moz-ui-invalid", shadowSelector, " {box-shadow: none;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) code" + shadowSelector + ",:host([data-render-mode='shadow']) kbd" + shadowSelector + ",:host([data-render-mode='shadow']) samp" + shadowSelector + ",:host([data-render-mode='shadow']) pre" : hostSelector + "[data-render-mode='shadow'] code" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] kbd" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] samp" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] pre")), shadowSelector, " {font-family: var(\n --sds-g-font-family-monospace,\n Consolas,\n Menlo,\n Monaco,\n Courier,\n monospace,\n monospace\n );font-size: var(--sds-g-font-size-base, 0.875rem, 1rem);}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) img" + shadowSelector + ",:host([data-render-mode='shadow']) [type='image']" : hostSelector + "[data-render-mode='shadow'] img" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] [type='image']")), shadowSelector, " {max-width: 100%;height: auto;border: 0;vertical-align: middle;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) iframe" : hostSelector + "[data-render-mode='shadow'] iframe")), shadowSelector, " {border-style: none;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) svg:not([fill])" : hostSelector + "[data-render-mode='shadow'] svg:not([fill])")), shadowSelector, " {fill: currentColor;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) abbr[title]" : hostSelector + "[data-render-mode='shadow'] abbr[title]")), shadowSelector, " {text-decoration: none;cursor: help;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) table" : hostSelector + "[data-render-mode='shadow'] table")), shadowSelector, " {border-collapse: collapse;border-spacing: 0;border: 0;width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) hr" : hostSelector + "[data-render-mode='shadow'] hr")), shadowSelector, " {display: block;margin: var(--sds-g-spacing-6, 2rem, 2rem) 0;border-top: var(--sds-g-sizing-border-1, 1px, 1px) solid\n var(--slds-g-color-border-base-1, #c9c9c9);height: var(--sds-g-sizing-border-1, 1px, 1px);clear: both;box-sizing: content-box;border: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) abbr[title]" : hostSelector + "[data-render-mode='shadow'] abbr[title]")), shadowSelector, " {border-bottom: var(--sds-g-sizing-border-1, 1px, 1px) dotted;text-decoration: none;border: 0;cursor: help;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) caption" + shadowSelector + ",:host([data-render-mode='shadow']) th" + shadowSelector + ",:host([data-render-mode='shadow']) td" : hostSelector + "[data-render-mode='shadow'] caption" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] th" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] td")), shadowSelector, " {text-align: left;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) td" + shadowSelector + ",:host([data-render-mode='shadow']) th" : hostSelector + "[data-render-mode='shadow'] td" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] th")), shadowSelector, " {padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) dl" : hostSelector + "[data-render-mode='shadow'] dl")), shadowSelector, " {margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) dd" : hostSelector + "[data-render-mode='shadow'] dd")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) pre" : hostSelector + "[data-render-mode='shadow'] pre")), shadowSelector, " {overflow: auto;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) mark" : hostSelector + "[data-render-mode='shadow'] mark")), shadowSelector, " {background-color: #ff0;color: #000;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) small" : hostSelector + "[data-render-mode='shadow'] small")), shadowSelector, " {font-size: 80%;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) sub" + shadowSelector + ",:host([data-render-mode='shadow']) sup" : hostSelector + "[data-render-mode='shadow'] sub" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] sup")), shadowSelector, " {font-size: 75%;line-height: 0;position: relative;vertical-align: baseline;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) sup" : hostSelector + "[data-render-mode='shadow'] sup")), shadowSelector, " {top: -0.5em;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) sub" : hostSelector + "[data-render-mode='shadow'] sub")), shadowSelector, " {bottom: -0.25em;}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) b" + shadowSelector + ",:host([data-render-mode='shadow']) strong" + shadowSelector + ",:host([data-render-mode='shadow']) dfn" : hostSelector + "[data-render-mode='shadow'] b" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] strong" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] dfn")), shadowSelector, " {font-weight: var(--sds-g-font-weight-7, 700, 700);}", ((useActualHostSelector ? ":host([data-render-mode='shadow']) b" + shadowSelector + ",:host([data-render-mode='shadow']) strong" : hostSelector + "[data-render-mode='shadow'] b" + shadowSelector + "," + hostSelector + "[data-render-mode='shadow'] strong")), shadowSelector, " {font-weight: var(--sds-g-font-weight-bold, bold, bold);}[data-f6-region].f6-highlight", shadowSelector, " {position: relative;}[data-f6-region].f6-highlight", shadowSelector, "::after {width: 100%;height: 100%;content: '';outline: rgb(94, 158, 214) 3px solid;outline-offset: -3px;position: absolute;top: 0;left: 0;z-index: 9999;}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var sldsCommon = [stylesheet];

  exports.default = sldsCommon;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/i18n/locale', [], function() { return "en-US"; });
(function() { LWR.define('lightning/iso8601Utils', ['exports'], (function (exports) {

    // TODO: remove file when migrating off aura
    /*
     * Regex to test a string for an ISO8601 Date. The following formats are matched.
     *
     *  YYYY
     *  YYYY-MM
     *  YYYY-MM-DD
     *  YYYY-MM-DDThh:mmTZD
     *  YYYY-MM-DDThh:mm:ssTZD
     *  YYYY-MM-DDThh:mm:ss.STZD
     *
     *
     * @see: https://www.w3.org/TR/NOTE-datetime
     */
    const ISO8601_STRICT_PATTERN = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d[:]?\d\d)|Z)?)?)?)?$/i;

    /* Regex to test a string for an ISO8601 partial time or full time:
     * hh:mm
     * hh:mm:ss
     * hh:mm:ss.S
     * full time = partial time + TZD
     */
    const ISO8601_TIME_PATTERN = /^\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d[:]?\d\d)|Z)?$/i;
    const STANDARD_TIME_FORMAT = 'HH:mm:ss.SSS';
    const STANDARD_DATE_FORMAT = 'YYYY-MM-DD';
    const TIME_SEPARATOR = 'T';
    const TIMEZONE_INDICATOR = /(Z|([+-])(\d{2})[:]?(\d{2}))$/i;
    function isValidISODateTimeString(dateTimeString) {
      return isValidISO8601String(dateTimeString) && isValidDate(dateTimeString);
    }
    function isValidISOTimeString(timeString) {
      if (!isValidISO8601TimeString(timeString)) {
        return false;
      }
      const timeOnly = removeTimeZoneSuffix(timeString);
      return isValidDate(`2018-09-09T${timeOnly}Z`);
    }
    function removeTimeZoneSuffix(dateTimeString) {
      if (typeof dateTimeString === 'string') {
        return dateTimeString.split(TIMEZONE_INDICATOR)[0];
      }
      return dateTimeString;
    }

    /**
     * Ensures that any valid ISO string with a milliseconds
     * component has exactly three digits
     *
     * @param {any} dateTimeString
     * @returns {any}
     */
    function padMilliseconds(dateTimeString) {
      if (typeof dateTimeString === 'string' && (isValidDate(dateTimeString) || isValidISOTimeString(dateTimeString))) {
        const millisecondIndex = dateTimeString.indexOf('.');
        let timezoneIndex = dateTimeString.search(TIMEZONE_INDICATOR);
        if (timezoneIndex === -1) {
          timezoneIndex = dateTimeString.length;
        }
        // if milliseconds present, make sure exactly 3 digits present
        if (millisecondIndex !== -1) {
          const milliseconds = dateTimeString.substring(millisecondIndex + 1, timezoneIndex);
          let newMilliseconds = milliseconds;
          if (milliseconds.length > 3) {
            // if more than 3 digits, cut to three digits
            newMilliseconds = newMilliseconds.substring(0, 3);
          } else if (milliseconds.length < 3) {
            // if less than 3 digits, add zeros to make it 3 digits
            const extraZeros = '0'.repeat(3 - milliseconds.length);
            newMilliseconds = `${newMilliseconds}${extraZeros}`;
          }
          // replace old milliseconds with new 3 digit milliseconds
          const start = dateTimeString.substring(0, millisecondIndex);
          const end = dateTimeString.substring(timezoneIndex);
          return `${start}.${newMilliseconds}${end}`;
        }
      }
      return dateTimeString;
    }
    function isValidISO8601String(dateTimeString) {
      if (typeof dateTimeString !== 'string') {
        return false;
      }
      return ISO8601_STRICT_PATTERN.test(dateTimeString);
    }
    function isValidISO8601TimeString(timeString) {
      if (typeof timeString !== 'string') {
        return false;
      }
      return ISO8601_TIME_PATTERN.test(timeString);
    }
    function isValidDate(value) {
      // Date.parse returns NaN if the argument doesn't represent a valid date
      const timeStamp = Date.parse(value);
      return isFinite(timeStamp);
    }

    exports.STANDARD_DATE_FORMAT = STANDARD_DATE_FORMAT;
    exports.STANDARD_TIME_FORMAT = STANDARD_TIME_FORMAT;
    exports.TIME_SEPARATOR = TIME_SEPARATOR;
    exports.isValidISODateTimeString = isValidISODateTimeString;
    exports.isValidISOTimeString = isValidISOTimeString;
    exports.padMilliseconds = padMilliseconds;
    exports.removeTimeZoneSuffix = removeTimeZoneSuffix;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/utilsPrivate', ['exports', '@salesforce/client/formFactor', '@salesforce/i18n/locale', 'lightning/iso8601Utils', 'lwc'], (function (exports, formFactor, locale, iso8601Utils, lwc) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var formFactor__default = /*#__PURE__*/_interopDefaultCompat(formFactor);
    var locale__default = /*#__PURE__*/_interopDefaultCompat(locale);

    /**
     * Determine if environment is CSR or SSR
     */
    const isCSR = typeof window !== 'undefined';

    function assert(condition, message) {
      {
        if (!condition) {
          throw new Error(message);
        }
      }
    }

    /* All Valid Aria Attributes, in camel case
     * - it's better to start from camel-case
     *   because `aria-${_.kebabCase('describedBy')}` => 'aria-described-by' (NOT aria property)
     * - correct aria property: 'aria-describedby'
     *  https://www.w3.org/TR/wai-aria/
     */
    const ARIA_PROP_LIST = ['activeDescendant', 'atomic', 'autoComplete', 'busy', 'checked', 'colCount', 'colIndex', 'colSpan', 'controls', 'current', 'describedAt', 'describedBy', 'description', 'details', 'disabled', 'dropEffect', 'errorMessage', 'expanded', 'flowTo', 'grabbed', 'hasPopup', 'hidden', 'invalid', 'keyShortcuts', 'label', 'labelledBy', 'level', 'live', 'modal', 'multiLine', 'multiSelectable', 'orientation', 'owns', 'placeholder', 'posInSet', 'pressed', 'readOnly', 'relevant', 'required', 'roleDescription', 'rowCount', 'rowIndex', 'rowSpan', 'selected', 'setSize', 'sort', 'valueMax', 'valueMin', 'valueNow', 'valueText'];

    /**
     * Generate an ARIA lookup object when passing in a list of ARIA values
     * @param {Array} list A list of ARIA properties (array of strings)
     * @param {String} type A type which defaults to output ARIA properties as modified kebab-case, or camel-case
     * @example 'valueMax' string becomes: { VALUEMAX: 'aria-valuemax' }
     * @returns {Object} A lookup object for ARIA properties in (modified) kebab-case or camel-case
     */
    const getAriaLookup = (list, type = 'default') => {
      const length = list ? list.length : 0;
      if (length === 0) {
        throw new Error('List of aria properties is required');
      }
      const lookupObj = {};
      if (type === 'default') {
        for (let i = 0; i < length; i += 1) {
          const name = list[i];
          const nameUpperCase = name.toUpperCase();
          if (!lookupObj[nameUpperCase]) {
            lookupObj[nameUpperCase] = `aria-${name.toLowerCase()}`;
          }
        }
        return lookupObj;
      }
      for (let i = 0; i < length; i += 1) {
        const name = list[i];
        const ariaPropertyLowerCase = `aria-${name.toLowerCase()}`;
        if (!lookupObj[ariaPropertyLowerCase]) {
          const ariaPropertyCamelCase = `aria${name[0].toUpperCase()}${name.slice(1)}`;
          lookupObj[ariaPropertyLowerCase] = ariaPropertyCamelCase;
        }
      }
      return lookupObj;
    };

    /**
     * ARIA lookup, 'modified' kebab-case
     * Given an array of aria property strings in camel-case, produce a lookup object
     * NOTE: 'ariaDescribedBy' (camel-case ARIA property) in TRUE kebab-case would be:
     * - 'aria-described-by' (not valid ARIA)
     * - 'aria-describedby' (valid ARIA, or modified kebab-case)
     * Example: 'describedBy' -> { DESCRIBEDBY: 'aria-describedby' }
     */
    const ARIA = getAriaLookup(ARIA_PROP_LIST);

    /**
     * ARIA lookup, aria-property (key): 'ariaCamelCase' (value)
     * Example: 'valueMax' -> { 'aria-valuemax': 'ariaValueMax' }
     * Useful for converting from normal aria properties to aria camel cased values
     */
    const ARIA_TO_CAMEL = getAriaLookup(ARIA_PROP_LIST, 'cc');

    /**
     * Set either 'aria-describedby' or 'aria-description' value for accessibility
     * based on the presence of 'description' api value and support of the newer ARIA
     * 'aria-description'.  At launch, Firefox, Safari do not support it (and IE11 never will).
     * https://caniuse.com/mdn-api_element_ariadescription
     * @private
     * @returns {boolean} true indicates aria-description is supported; false, no support
     */
    // cached value, so check once and only once
    let ariaDescriptionSupported = null;
    function isAriaDescriptionSupported() {
      // return previously cached value, don't recheck
      if (ariaDescriptionSupported !== null) {
        return ariaDescriptionSupported;
      }
      // if not previously set, test for browser support
      const testVal = 'test ability to set';
      try {
        const span = document.createElement('span');
        span.ariaDescription = testVal;
        const ariaDescVal = span.getAttribute(ARIA.DESCRIPTION);
        ariaDescriptionSupported = testVal === ariaDescVal;
      } catch (e) {
        ariaDescriptionSupported = false;
      }
      return ariaDescriptionSupported;
    }
    function updateAriaInvalidOnElement(element, isInvalid) {
      if (isInvalid) {
        element.setAttribute('aria-invalid', true);
      } else {
        element.removeAttribute('aria-invalid');
      }
    }

    /**
     * If value is empty, then do no calculate aria-invalid. This is intentional for 240.
     * In the future, we may be removing emptiness this check.
     *
     * Then if isInvalid is truthy, return true else return undefined to remove
     * aria-invalid attribute.
     *
     * @param isInvalid
     * @param value
     * @returns {boolean|undefined}
     */
    function computeAriaInvalid(isInvalid, value, ariaInvalid) {
      if (typeof ariaInvalid !== 'undefined') {
        return ariaInvalid;
      }
      if (value === undefined || value === null || value === '') {
        /* To Preserve backward compatibility */
        return undefined;
      }
      return !!isInvalid || undefined;
    }

    /**
    An emitter implementation based on the Node.js EventEmitter API:
    https://nodejs.org/dist/latest-v6.x/docs/api/events.html#events_class_eventemitter
    **/
    class EventEmitter {
      constructor() {
        this.registry = {};
      }

      /**
      Registers a listener on the emitter
      @method EventEmitter#on
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/
      on(name, listener) {
        this.registry[name] = this.registry[name] || [];
        this.registry[name].push(listener);
        return this;
      }

      /**
      Registers a listener on the emitter that only executes once
      @method EventEmitter#once
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/
      once(name, listener) {
        const doOnce = function () {
          listener.apply(null, arguments);
          this.removeListener(name, doOnce);
        }.bind(this);
        this.on(name, doOnce);
        return this;
      }

      /**
      Synchronously calls each listener registered with the specified event
      @method EventEmitter#emit
      @param {String} name - The name of the event
      @return {Boolean} - Returns `true` if the event had listeners, `false` otherwise
      **/
      emit(name) {
        const listeners = this.registry[name];
        let count = 0;
        if (listeners) {
          const args = Array.prototype.slice.call(arguments, 1);
          for (let i = 0, {
              length
            } = listeners; i < length; i += 1) {
            count += 1;
            listeners[i].apply(null, args);
          }
        }
        return count > 0;
      }

      /**
      Removes the specified `listener` from the listener array for the event named `name`
      @method EventEmitter#removeListener
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/
      removeListener(name, listener) {
        const listeners = this.registry[name];
        if (listeners) {
          for (let i = 0, len = listeners.length; i < len; i += 1) {
            if (listeners[i] === listener) {
              listeners.splice(i, 1);
              return this;
            }
          }
        }
        return this;
      }
    }

    const NA_PHONE_NUMBER = '($1) $2-$3';
    const IS_TEN_DIGITS = /^\d{10}$/;
    const TEN_TO_NA = /(\d{3})(\d{3})(\d{4})/;
    const IS_ELEVEN_DIGITS = /^1\d{10}$/;
    const ELEVEN_TO_NA = /1(\d{3})(\d{3})(\d{4})$/;

    // The locale argument has been added for tests since there's currently no clean way of mocking the locale
    function toNorthAmericanPhoneNumber(value, userLocale) {
      if (!isNorthAmericanCountry(userLocale || locale__default.default)) {
        return value;
      }
      if (IS_TEN_DIGITS.test(value)) {
        return value.replace(TEN_TO_NA, NA_PHONE_NUMBER);
      } else if (IS_ELEVEN_DIGITS.test(value)) {
        return value.replace(ELEVEN_TO_NA, NA_PHONE_NUMBER);
      }
      return value || '';
    }
    function isNorthAmericanCountry(userLocale) {
      const localeCountry = getLocaleCountry(userLocale);
      if (localeCountry === 'US' || localeCountry === 'CA') {
        return true;
      }
      return false;
    }
    function getLocaleCountry(userLocale) {
      if (!userLocale) {
        // just adding a guard in case locale is undefined
        return null;
      }
      const [, country] = userLocale.split('-');
      return country;
    }

    const URL_CHECK_REGEX = /^(\/+|\.+|ftp|http(s?):\/\/)/i;
    const SSR_PROTOCOL = 'https:'; // For LWR (SSR), the protocol will always be HTTPS. See TD-0141280.

    function isAbsoluteUrl(url) {
      return URL_CHECK_REGEX.test(url);
    }
    function makeAbsoluteUrl(url) {
      const protocol = isCSR ? window.location.protocol : SSR_PROTOCOL;
      return isAbsoluteUrl(url) ? url : `${protocol}//${url}`;
    }

    // eslint-disable-next-line no-script-url
    const FALLBACK_URL = 'javascript:void(0)';
    const IS_SCRIPT_OR_DATA = /^(?:\w+script|data):/i;
    const IS_HTML_ENTITY = /&#(\w+)(^\w|;)?/g;
    const htmlCtrlEntityRegex = /&(newline|tab);/gi;
    const ctrlCharactersRegex =
    // eslint-disable-next-line no-control-regex
    /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
    function decodeHtmlCharacters(str) {
      return str.replace(IS_HTML_ENTITY, (match, dec) => {
        return String.fromCharCode(dec);
      });
    }
    /**
     * Mark sure to preventDefault, when sanitized url matches FALLBACK_URL
     * W-12029667 - Making FALLBACK_URL as '#' causes click action to fail on tests
     * */
    function sanitizeURL(url) {
      if (url) {
        // remove html entity characters from url
        const sanitizedUrl = decodeHtmlCharacters(url).replace(htmlCtrlEntityRegex, '').replace(ctrlCharactersRegex, '').trim();
        return sanitizedUrl.match(IS_SCRIPT_OR_DATA) ? FALLBACK_URL : url;
      }
      return FALLBACK_URL;
    }

    const urlRegexString = "((?:(?:https?|ftp):\\/\\/(?:[\\w\\-\\|=%~#\\/+*@\\.,;:\\?!']|&){0,2047}(?:[\\(\\)\\.\\w=\\/+#-]*)[^\\s()\\.<>,;\\[\\]`'\"])|(?:\\b(?:[a-z0-9](?:[-a-z0-9]{0,62}[a-z0-9])?\\.)+(?:AC|AD|AE|AERO|AF|AG|AI|AL|AM|AN|AO|AQ|AR|ARPA|AS|ASIA|AT|AU|AW|AX|AZ|BA|BB|BD|BE|BF|BG|BH|BI|BIZ|BJ|BM|BN|BO|BR|BS|BT|BV|BW|BY|BZ|CA|CAT|CC|CD|CF|CG|CH|CI|CK|CL|CM|CN|CO|COM|COOP|CR|CU|CV|CX|CY|CZ|DE|DJ|DK|DM|DO|DZ|EC|EDU|EE|EG|ER|ES|ET|EU|FI|FJ|FK|FM|FO|FR|GA|GB|GD|GE|GF|GG|GH|GI|GL|GM|GN|GOV|GP|GQ|GR|GS|GT|GU|GW|GY|HK|HM|HN|HR|HT|HU|ID|IE|IL|IM|IN|INFO|INT|IO|IQ|IR|IS|IT|JE|JM|JO|JOBS|JP|KE|KG|KH|KI|KM|KN|KP|KR|KW|KY|KZ|LA|LB|LC|LI|LK|LR|LS|LT|LU|LV|LY|MA|MC|MD|ME|MG|MH|MIL|MK|ML|MM|MN|MO|MOBI|MP|MQ|MR|MS|MT|MU|MUSEUM|MV|MW|MX|MY|MZ|NA|NAME|NC|NE|NET|NF|NG|NI|NL|NO|NP|NR|NU|NZ|OM|ORG|PA|PE|PF|PG|PH|PK|PL|PM|PN|PR|PRO|PS|PT|PW|PY|QA|RE|RO|RS|RU|RW|SA|SB|SC|SD|SE|SG|SH|SI|SJ|SK|SL|SM|SN|SO|SR|ST|SU|SV|SY|SZ|TC|TD|TEL|TF|TG|TH|TJ|TK|TL|TM|TN|TO|TP|TR|TRAVEL|TT|TV|TW|TZ|UA|UG|UK|US|UY|UZ|VA|VC|VE|VG|VI|VN|VU|WF|WS|XN--0ZWM56D|XN--11B5BS3A9AJ6G|XN--80AKHBYKNJ4F|XN--9T4B11YI5A|XN--DEBA0AD|XN--FIQS8S|XN--FIQZ9S|XN--G6W251D|XN--HGBK6AJ7F53BBA|XN--HLCJ6AYA9ESC7A|XN--J6W193G|XN--JXALPDLP|XN--KGBECHTV|XN--KPRW13D|XN--KPRY57D|XN--MGBAAM7A8H|XN--MGBERP4A5D4AR|XN--P1AI|XN--WGBH1C|XN--ZCKZAH|YE|YT|ZA|ZM|ZW)(?!@(?:[a-z0-9](?:[-a-z0-9]{0,62}[a-z0-9])?\\.)+(?:AC|AD|AE|AERO|AF|AG|AI|AL|AM|AN|AO|AQ|AR|ARPA|AS|ASIA|AT|AU|AW|AX|AZ|BA|BB|BD|BE|BF|BG|BH|BI|BIZ|BJ|BM|BN|BO|BR|BS|BT|BV|BW|BY|BZ|CA|CAT|CC|CD|CF|CG|CH|CI|CK|CL|CM|CN|CO|COM|COOP|CR|CU|CV|CX|CY|CZ|DE|DJ|DK|DM|DO|DZ|EC|EDU|EE|EG|ER|ES|ET|EU|FI|FJ|FK|FM|FO|FR|GA|GB|GD|GE|GF|GG|GH|GI|GL|GM|GN|GOV|GP|GQ|GR|GS|GT|GU|GW|GY|HK|HM|HN|HR|HT|HU|ID|IE|IL|IM|IN|INFO|INT|IO|IQ|IR|IS|IT|JE|JM|JO|JOBS|JP|KE|KG|KH|KI|KM|KN|KP|KR|KW|KY|KZ|LA|LB|LC|LI|LK|LR|LS|LT|LU|LV|LY|MA|MC|MD|ME|MG|MH|MIL|MK|ML|MM|MN|MO|MOBI|MP|MQ|MR|MS|MT|MU|MUSEUM|MV|MW|MX|MY|MZ|NA|NAME|NC|NE|NET|NF|NG|NI|NL|NO|NP|NR|NU|NZ|OM|ORG|PA|PE|PF|PG|PH|PK|PL|PM|PN|PR|PRO|PS|PT|PW|PY|QA|RE|RO|RS|RU|RW|SA|SB|SC|SD|SE|SG|SH|SI|SJ|SK|SL|SM|SN|SO|SR|ST|SU|SV|SY|SZ|TC|TD|TEL|TF|TG|TH|TJ|TK|TL|TM|TN|TO|TP|TR|TRAVEL|TT|TV|TW|TZ|UA|UG|UK|US|UY|UZ|VA|VC|VE|VG|VI|VN|VU|WF|WS|XN--0ZWM56D|XN--11B5BS3A9AJ6G|XN--80AKHBYKNJ4F|XN--9T4B11YI5A|XN--DEBA0AD|XN--FIQS8S|XN--FIQZ9S|XN--G6W251D|XN--HGBK6AJ7F53BBA|XN--HLCJ6AYA9ESC7A|XN--J6W193G|XN--JXALPDLP|XN--KGBECHTV|XN--KPRW13D|XN--KPRY57D|XN--MGBAAM7A8H|XN--MGBERP4A5D4AR|XN--P1AI|XN--WGBH1C|XN--ZCKZAH|YE|YT|ZA|ZM|ZW))(?:/[\\w\\-=?/.&;:%~,+@#*]{0,2048}(?:[\\w=/+#-]|\\([^\\s()]*\\)))?(?:$|(?=\\.$)|(?=\\.\\s)|(?=[^\\w\\.]))))";
    const emailRegexString = "([\\w-\\.\\+_']{1,64}@(?:[\\w-]){1,255}(?:\\.[\\w-]{1,255}){1,10})";
    const newLineRegexString = '(\r\n|\r|\n)';
    const tagRegexString = '(<a[\\s]+[^>]+[^/]>[\\s\\S]*?</a>|<a[\\s]+[^>]+/>|' + '<i?frame[\\s]+[^>]+[^/]>[\\s\\S]*?</i?frame>|<i?frame[\\s]+[^>]+/>|' + '<area[\\s]+[^>]+[^/]>[\\s\\S]*?</area>|<area[\\s]+[^>]+/>|' + '<link[\\s]+[^>]+[^/]>[\\s\\S]*?</link>|<link[\\s]+[^>]+/>|' + '<img[\\s]+[^>]+[^/]>[\\s\\S]*?</img>|<img[\\s]+[^>]+>|' + '<form[\\s]+[^>]+[^/]>[\\s\\S]*?</form>|<form[\\s]+[^>]+/>|' + '<body[\\s]+[^>]+[^/]>[\\s\\S]*?</body>|<body[\\s]+[^>]+/>|' + '<head[\\s]+[^>]+[^/]>[\\s\\S]*?</head>|<head[\\s]+[^>]+/>|' + '<input[\\s]+[^>]+[^/]>[\\s\\S]*?</input>|<input[\\s]+[^>]+/>|' + '<button[\\s]+[^>]+[^/]>[\\s\\S]*?</button>|<button[\\s]+[^>]+/>|' + '<blockquote[\\s]+[^>]+[^/]>[\\s\\S]*?</blockquote>|<blockquote[\\s]+[^>]+/>|' + '<q[\\s]+[^>]+[^/]>[\\s\\S]*?</q>|<q[\\s]+[^>]+/>|' + '<del[\\s]+[^>]+[^/]>[\\s\\S]*?</del>|<del[\\s]+[^>]+/>|' + '<ins[\\s]+[^>]+[^/]>[\\s\\S]*?</ins>|<ins[\\s]+[^>]+/>)';
    const createHttpHref = function (url) {
      return makeAbsoluteUrl(url);
    };
    const createEmailHref = function (email) {
      return `mailto:${email}`;
    };

    /**
     * Create a deep copy of an object or array
     * @param {object|array} obj - item to be copied
     * @returns {object|array} copy of the item
     */
    function deepCopy(obj) {
      if (Object(obj) !== obj) {
        // primitives
        return obj;
      }
      if (obj instanceof Set) {
        return new Set(obj);
      }
      if (obj instanceof Date) {
        return new Date(obj);
      }
      if (typeof obj === 'function') {
        return obj.bind({});
      }
      if (Array.isArray(obj)) {
        const obj2 = [];
        const len = obj.length;
        for (let i = 0; i < len; i++) {
          obj2.push(deepCopy(obj[i]));
        }
        return obj2;
      }
      const result = Object.create({});
      let keys = Object.keys(obj);
      if (obj instanceof Error) {
        // Error properties are non-enumerable
        keys = Object.getOwnPropertyNames(obj);
      }
      const len = keys.length;
      for (let i = 0; i < len; i++) {
        const key = keys[i];
        result[key] = deepCopy(obj[key]);
      }
      return result;
    }

    /**
     * Compare two arrays and return true if they are equal
     * @param {array} array1 - first array to compare
     * @param {array} array2 - second array to compare
     * @returns {boolean} if the arrays are identical
     */
    function arraysEqual(array1, array2) {
      // if either array is falsey, return false
      if (!array1 || !array2) {
        return false;
      }

      // if array lengths don't match, return false
      if (array1.length !== array2.length) {
        return false;
      }
      for (let index = 0; index < array1.length; index++) {
        // Check if we have nested arrays
        if (array1[index] instanceof Array && array2[index] instanceof Array) {
          // recurse into the nested arrays
          if (!arraysEqual(array1[index], array2[index])) {
            return false;
          }
        } else if (array1[index] !== array2[index]) {
          // Warning - two different object instances will never be equal: {x:20} != {x:20}
          return false;
        }
      }
      return true;
    }
    const ArraySlice = Array.prototype.slice;

    /**
     * Utility function to generate an unique guid.
     * used on state objects to provide a performance aid when iterating
     * through the items and marking them for render
     * @returns {String} an unique string ID
     */
    function guid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }
      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }

    function classListMutation(classList, config) {
      const keys = Object.keys(config);
      for (let i = 0, {
          length
        } = keys[i]; i < length; i += 1) {
        const key = keys[i];
        if (typeof key === 'string' && key.length > 0) {
          if (config[key]) {
            classList.add(key);
          } else {
            classList.remove(key);
          }
        }
      }
    }

    function classSetToString(classes) {
      let string = '';
      const keys = Object.keys(classes);
      for (let i = 0, {
          length
        } = keys; i < length; i += 1) {
        const key = keys[i];
        if (classes[key]) {
          string += (string.length ? ' ' : '') + key;
        }
      }
      return string;
    }

    /**
     * This marks all siblings of the blocking elements and the siblings of all of its parents as inert by setting
     * 'aria-hidden' to 'true'.
     *
     * This assumes that the DOM is not being modified while the blocking element is showing, otherwise observers would
     * be needed.
     *
     * @param {Element} blockingElement The active element that will be be blocking the rest of the page.
     * @returns {Array} An array of {node, ariaHidden} objects, where node is the node that had its ariaHidden set
     * to 'true', and ariaHidden is the previous value of the 'aria-hidden' attribute. Use this to restore inertness.
     */
    function makeEverythingExceptElementInert(blockingElement) {
      const savedInertElements = [];
      let nonInertElement = blockingElement;
      let parent = nonInertElement.parentNode.host || nonInertElement.parentNode;
      while (parent != null) {
        if (parent.nodeType === Node.ELEMENT_NODE) {
          // Start with the first child, if the parent blockingElement has a shadow root then use the first child of that
          let child = parent.firstChild;
          if (child === null && parent.shadowRoot) {
            child = parent.shadowRoot.firstChild;
          }
          while (child !== null) {
            // Ignore the blocking elements and all its parents (nonInertElement).
            if (child.nodeType === Node.ELEMENT_NODE && child !== nonInertElement && child.localName !== 'head') {
              savedInertElements.push({
                node: child,
                ariaHidden: child.ariaHidden
              });
              child.ariaHidden = true;
            }
            child = child.nextSibling;
          }
          nonInertElement = parent;
          parent = parent.parentNode;
        } else if (parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          // It maybe a custom component, attempt to get the host
          parent = parent.host;
        } else {
          parent = parent.parentNode;
        }
      }
      return savedInertElements;
    }
    function restoreInertness(savedInertElements) {
      for (let i = 0, {
          length
        } = savedInertElements; i < length; i += 1) {
        const element = savedInertElements[i];
        const {
          node
        } = element;
        if (node) {
          node.ariaHidden = element.ariaHidden;
        }
      }
    }

    /**
     * Does the browser display animation.
     * Always returns false for IE11 due to performance.
     */
    function hasAnimation() {
      if (isCSR) {
        if (!window.matchMedia) {
          return true;
        }
        const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
        return !(!mediaQuery || mediaQuery.matches);
      }
      return false;
    }

    /**
    A string normalization utility for attributes.
    @param {String} value - The value to normalize.
    @param {Object} config - The optional configuration object.
    @param {String} [config.fallbackValue] - The optional fallback value to use if the given value is not provided or invalid. Defaults to an empty string.
    @param {Array} [config.validValues] - An optional array of valid values. Assumes all input is valid if not provided.
    @return {String} - The normalized value.
    **/
    function normalizeString(value, config = {}) {
      const {
        fallbackValue = '',
        validValues,
        toLowerCase = true
      } = config;
      let normalized = typeof value === 'string' && value.trim() || '';
      normalized = toLowerCase ? normalized.toLowerCase() : normalized;
      if (validValues && validValues.indexOf(normalized) === -1) {
        normalized = fallbackValue;
      }
      return normalized;
    }

    /**
    A boolean normalization utility for attributes.
    @param {Any} value - The value to normalize.
    @return {Boolean} - The normalized value.
    **/
    function normalizeBoolean(value) {
      return typeof value === 'string' || !!value;
    }
    const isNotNumber = value => {
      // Need to make sure it is a number than check isNaN
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#difference_between_number.isnan_and_global_isnan
      if (Number.isNaN(value) || value === null || value === undefined || value === '' || Array.isArray(value)) {
        return true;
      }
      // to eliminate non numeric string or other non numeric-typed objects
      const convertedNumber = Number(value);
      return Number.isNaN(convertedNumber);
    };

    /**
     * A number normalization utility for attributes.
     * @param {number} value - The value to normalize.
     * @param {object} config -  The optional configuration object.
     * @param {number} [config.minValue] - The optional min value to check against the given value.
     * @param {number} [config.maxValue] - The optional max value to check against the given value.
     * @param {number} [config.fallbackValue] - The optional fallback value to use if the given value is not provided or outside of the min or max range
     * @return {number} - The normalized value
     */
    function normalizeNumber(value, config = {}) {
      const {
        fallbackValue,
        minValue,
        maxValue
      } = config;
      const returnValueIfInvalid = typeof fallbackValue === 'number' && fallbackValue || undefined;
      if (isNotNumber(value)) {
        return returnValueIfInvalid;
      }
      if (!isNotNumber(value) && value < minValue) {
        return returnValueIfInvalid;
      }
      if (!isNotNumber(value) && value > maxValue) {
        return returnValueIfInvalid;
      }
      // multiplying 1 is to make sure to convert from a numeric string to a number
      return value * 1;
    }
    function normalizeArray(value) {
      if (Array.isArray(value)) {
        return value;
      }
      return [];
    }

    /**
    A aria attribute normalization utility.
    @param {Any} value - A single aria value or an array of aria values
    @return {String} - A space separated list of aria values
    **/
    function normalizeAriaAttribute(value) {
      let arias = Array.isArray(value) ? value : [value];
      arias = arias.map(ariaValue => {
        if (typeof ariaValue === 'string') {
          return ariaValue.replace(/\s+/g, ' ').trim();
        }
        return '';
      }).filter(ariaValue => !!ariaValue);
      return arias.length > 0 ? arias.join(' ') : null;
    }

    const keyCodes = {
      tab: 9,
      backspace: 8,
      enter: 13,
      escape: 27,
      space: 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      delete: 46,
      shift: 16
    };

    // Acceptable values are defined here: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values
    // remove this function when IE11 support is dropped
    function normalizeKeyValue(value) {
      switch (value) {
        case 'Spacebar':
          return ' ';
        case 'Esc':
          return 'Escape';
        case 'Del':
          return 'Delete';
        case 'Left':
          return 'ArrowLeft';
        case 'Right':
          return 'ArrowRight';
        case 'Down':
          return 'ArrowDown';
        case 'Up':
          return 'ArrowUp';
        default:
          return value;
      }
    }
    const buffer = {};
    function isShiftMetaOrControlKey(event) {
      return event.shiftKey || event.metaKey || event.ctrlKey;
    }

    /**
     * Runs an action and passes the string of buffered keys typed within a short time period.
     * Use for type-ahead like functionality in menus, lists, comboboxes, and similar components.
     *
     * @param {CustomEvent} event A keyboard event
     * @param {Function} action function to run, it's passed the buffered text
     */
    function runActionOnBufferedTypedCharacters(event, action) {
      const letter = event.key;
      if (letter && letter.length > 1) {
        // Not an individual character/letter, but rather a special code (like Shift, Backspace, etc.)
        return;
      }

      // If we were going to clear what keys were typed, don't yet.
      if (buffer._clearBufferId) {
        clearTimeout(buffer._clearBufferId);
      }
      buffer._keyBuffer = buffer._keyBuffer || [];
      buffer._keyBuffer.push(letter);
      const matchText = buffer._keyBuffer.join('').toLowerCase();
      action(matchText);

      // eslint-disable-next-line @lwc/lwc/no-async-operation
      buffer._clearBufferId = setTimeout(() => {
        buffer._keyBuffer = [];
      }, 700);
    }

    function raf(fn) {
      let ticking = false;
      return function (event) {
        if (!ticking) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            fn.call(this, event);
            ticking = false;
          });
        }
        ticking = true;
      };
    }

    const isIE11 = isCSR && isIE11Test(navigator);
    const isChrome = isCSR && isChromeTest(navigator);
    const isSafari = isCSR && isSafariTest(navigator);

    // The following functions are for tests only
    function isIE11Test(navigator) {
      // https://stackoverflow.com/questions/17447373/how-can-i-target-only-internet-explorer-11-with-javascript
      return /Trident.*rv[ :]*11\./.test(navigator.userAgent);
    }
    function isChromeTest(navigator) {
      // https://stackoverflow.com/questions/4565112/javascript-how-to-find-out-if-the-user-browser-is-chrome
      return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    }
    function isSafariTest(navigator) {
      // via https://stackoverflow.com/questions/49872111/detect-safari-and-stop-script
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }

    // hide panel on scroll
    const POSITION_CHANGE_THRESHOLD = 5;
    function observePosition(target, threshold = POSITION_CHANGE_THRESHOLD, originalRect, callback) {
      // retrieve current bounding client rect of target element
      const newBoundingRect = target.getBoundingClientRect();
      const newLeft = newBoundingRect.left;
      const newTop = newBoundingRect.top;

      // old bounding rect values
      const oldLeft = originalRect.left;
      const oldTop = originalRect.top;

      // if we have a position change (horizontal or vertical) equal or greater to the threshold then execute the callback
      const horizontalShiftDelta = Math.abs(newLeft - oldLeft);
      const verticalShiftDelta = Math.abs(newTop - oldTop);
      if (horizontalShiftDelta >= threshold || verticalShiftDelta >= threshold) {
        callback();
      }
    }

    const ALLOWED_DOMAINS = new Set(['www.youtube.com', 'www.youtube-nocookie.com', 'www.youtube.ca', 'www.youtube.jp', 'www.youtube.com.br', 'www.youtube.co.uk', 'www.youtube.nl', 'www.youtube.pl', 'www.youtube.es', 'www.youtube.ie', 'www.youtube.fr', 'player.vimeo.com', 'play.vidyard.com', 'players.brightcove.net', 'bcove.video', 'player.cloudinary.com', 'fast.wistia.net', 'i1.adis.ws', 's1.adis.ws', 'scormanywhere.secure.force.com', 'appiniummastertrial.secure.force.com', 'embed.app.guidde.com', 'cdnapisec.kaltura.com']);
    // In addition to:
    //   vimeo.com/showcase/*/embed
    //   *.my.site.com
    //   *.lightning.force.com
    //   *.my.salesforce-sites.com

    function hasOnlyAllowedVideoIframes(htmlString) {
      if (htmlString && htmlString.indexOf('<iframe') > -1) {
        const parsedHtml = new DOMParser().parseFromString(htmlString, 'text/html');
        const iframesList = Array.prototype.slice.call(parsedHtml.querySelectorAll('iframe'));
        return iframesList.length > 0 && !iframesList.some(iframe => !isUrlAllowed(iframe.src));
      }
      return false;
    }
    function isUrlAllowed(url) {
      const anchor = document.createElement('a');
      anchor.href = url;
      if (anchor.protocol !== 'https:') {
        return false;
      }
      if (anchor.hostname === 'vimeo.com') {
        const path = anchor.pathname;
        const regex = /^\/showcase\/\d+\/embed$/;
        return path.match(regex) !== null;
      }
      if (anchor.hostname === 'www.my.salesforce-sites.com') {
        return false;
      }
      if (anchor.hostname.match(/^[\w-]+\.my\.salesforce-sites\.com$/)) {
        return true;
      }
      if (anchor.hostname.match(/^[\w-]+\.sandbox\.my\.salesforce-sites\.com$/)) {
        return true;
      }
      if (anchor.hostname === 'www.lightning.force.com') {
        return false;
      }
      if (anchor.hostname.match(/^[\w-]+\.lightning\.force\.com$/)) {
        return true;
      }
      if (anchor.hostname.match(/^[\w-]+\.sandbox\.lightning\.force\.com$/)) {
        return true;
      }
      if (anchor.hostname === 'www.my.site.com') {
        return false;
      }
      if (anchor.hostname.match(/^[\w-]+\.my\.site\.com$/)) {
        return true;
      }
      if (anchor.hostname.match(/^[\w-]+\.sandbox\.my\.site\.com$/)) {
        return true;
      }
      return ALLOWED_DOMAINS.has(anchor.hostname);
    }

    /*
     * Regex was taken from aura lib and refactored
     */
    const linkRegex = new RegExp(`(${newLineRegexString})|${urlRegexString}|${emailRegexString}`, 'gi');
    const linkRegexNoNewLine = new RegExp(`${urlRegexString}|${emailRegexString}`, 'gi');
    const emailRegex = new RegExp(`^${emailRegexString}$`, 'gi');
    const newLineRegex = new RegExp(newLineRegexString, 'gi');
    function getTextPart(text) {
      return {
        isText: true,
        value: text
      };
    }
    function getUrlPart(url, index) {
      return {
        isLink: true,
        value: url,
        href: createHttpHref(url),
        key: `${url}-${index}`
      };
    }
    function getEmailPart(email, index) {
      return {
        isLink: true,
        value: email,
        href: createEmailHref(email),
        key: `${email}-${index}`
      };
    }
    function getNewlinePart(index) {
      return {
        isNewline: true,
        key: index
      };
    }
    function getLinkPart(link, index, ignoreNewLines) {
      if (!ignoreNewLines && link.match(newLineRegex)) {
        return getNewlinePart(index);
      } else if (link.match(emailRegex)) {
        return getEmailPart(link, index);
      }
      return getUrlPart(link, index);
    }

    /**
     * Parse text into parts of text, links, emails, new lines
     * @param text {string} Text to parse into linkified parts
     * @param ignoreNewLines {boolean} Boolean indicating whether to return new line parts or not
     * if true new lines are included in text/url/email parts otherwise they are returned in their
     * own parts by default
     * @returns {[]}
     */
    function parseToFormattedLinkifiedParts(text, ignoreNewLines = false) {
      const parts = [];
      const re = ignoreNewLines ? linkRegexNoNewLine : linkRegex;
      let match;
      let index = 0;
      while ((match = re.exec(text)) !== null) {
        let link = match[0];
        const endsWithQuote = link && link.endsWith('&quot');
        // If we found an email or url match, then create a text part for everything
        // up to the match and then create the part for the email or url
        if (match.index > 0) {
          parts.push(getTextPart(text.slice(0, match.index)));
        }
        if (endsWithQuote) {
          link = link.slice(0, link.lastIndexOf('&quot'));
        }
        parts.push(getLinkPart(link, index, ignoreNewLines));
        if (endsWithQuote) {
          parts.push(getTextPart('&quot'));
        }
        text = text.substring(re.lastIndex);
        re.lastIndex = 0;
        index = index + 1;
      }
      if (text != null && text !== '') {
        parts.push(getTextPart(text));
      }
      return parts;
    }

    /**
     * Parse text into parts of text and new lines
     * @param text {string} Text to parse into parts
     * @returns {[]}
     */
    function parseToFormattedParts(text) {
      return text.split(newLineRegex).map((part, index) => {
        return index % 2 === 0 ? getTextPart(part) : getNewlinePart(index);
      });
    }

    const VALID_PAGE_REFERENCE_PROPERTIES = new Set(['type', 'attributes', 'state']);
    function isValidPageReference(object) {
      return object && object.type && typeof object.type === 'string' && object.attributes && typeof object.attributes === 'object' && Object.keys(object).every(prop => VALID_PAGE_REFERENCE_PROPERTIES.has(prop));
    }

    /**
     * Verify if user is using MAC OS or not
     * @returns {boolean} - true if Mac OS
     */
    const isMacOSTest = ({
      userAgent
    }) => {
      return /(macintosh|macintel|macppc|mac68k|macos)/i.test(userAgent);
    };

    /**
     * Verify if user is using iOS or not
     * @returns {boolean} - true, if iOS
     */
    const isiOSTest = ({
      userAgent
    }) => {
      return /(iphone|ipad|ipod)/i.test(userAgent);
    };

    /**
     * Verify if user is using Windows OS or not
     * @returns {boolean} - true, if Windows OS
     */
    const isWindowsOSTest = ({
      userAgent
    }) => {
      return /(win32|win64|windows)/i.test(userAgent);
    };

    /**
     * Verify if user is using Android OS or not
     * @returns {boolean} - true, if Android OS
     */
    const isAndroidOSTest = ({
      userAgent
    }) => {
      return /android/i.test(userAgent);
    };
    const isMacOS = isCSR && isMacOSTest(navigator);
    const isWindowsOS = isCSR && isWindowsOSTest(navigator);
    const isiOS = isCSR && isiOSTest(navigator);
    const isAndroidOS = isCSR && isAndroidOSTest(navigator);

    /**
     * These are all values that can be set to "aria-level" attribute of h2 tag for the card's title.
     */
    const VALID_HEADING_LEVELS = ['1', '2', '3', '4', '5', '6'];
    function isHeadingLevelValid(level) {
      return (typeof level === 'string' || typeof level === 'number') && VALID_HEADING_LEVELS.includes(level.toString());
    }

    const MAX_LONGITUDE = 180.0;
    const MAX_LATITUDE = 90.0;

    /**
     * Determine if a value is a valid date.
     *
     * @param {any} value The value to validate.
     * @returns {boolean} Whether the provided value is a valid date or not.
     */
    function isValidDate(value) {
      if (value === null || value === undefined || value === '') {
        return false;
      }
      return isFinite(value) || iso8601Utils.isValidISODateTimeString(value);
    }

    /**
     * Determine if a value is a valid latitude.
     *
     * @param {any} value The value to validate.
     * @returns {boolean} Whether the provided value is a valid latitude or not.
     */
    function isValidLatitude(value) {
      return value !== null && value !== undefined && value !== '' && isFinite(value) && Math.abs(value) <= MAX_LATITUDE;
    }

    /**
     * Determine if a value is a valid longitude.
     *
     * @param {any} value The value to validate.
     * @returns {boolean} Whether the provided value is a valid longitude or not.
     */
    function isValidLongitude(value) {
      return value !== null && value !== undefined && value !== '' && isFinite(value) && Math.abs(value) <= MAX_LONGITUDE;
    }

    /**
     * Determine if a value is a valid phone value.
     *
     * @param {any} value The value to validate.
     * @returns {boolean} Whether the provided value is a valid phone value or not.
     */
    function isValidPhone(value) {
      return typeof value === 'string' && value !== '';
    }

    /**
     * Convert a LightningFormattedDate instance (or similar) to a dateTimeFormat
     * options object.
     *
     * @param {LightningFormattedDateLike} instance
     *      An instance of the LightningFormattedDate class,
     *      or config object matching the public API.
     * @returns {object} The dateTimeFormat options object.
     */
    function toDateTimeFormatOptions(instance) {
      const options = {
        weekday: instance.weekday,
        era: instance.era,
        year: instance.year,
        month: instance.month,
        day: instance.day,
        hour: instance.hour,
        hourCycle: undefined,
        hour12: undefined,
        minute: instance.minute,
        second: instance.second,
        timeZoneName: instance.timeZoneName,
        timeZone: instance.timeZone
      };
      const {
        hour12
      } = instance;
      // If hour12 is set, then we use it, otherwise locale defaults will be used
      if (instance._hour12Set) {
        // TODO: W-7787708: Remove hourCycle workaround below when possible.
        // W-7583911: Temporarily works around an hourCycle spec bug that only Chrome has
        // implemented causing the default hourCycle to be 'h24' rather than 'h23' when hour12 is
        // false in 12-hour locales. Chrome ends up displaying times like '24:45'. Spec bug fix PR:
        // https://github.com/tc39/ecma402/pull/436/files
        if (hour12 === false) {
          options.hourCycle = 'h23';
        } else {
          options.hour12 = hour12;
        }
      }
      return options;
    }

    /**
     * Convert a LightningFormattedDate instance (or similar) to a string.
     * Allows for formatting a date without the overhead of instantiating a whole
     * component.
     *
     * @param {LightningFormattedDateLike} instance
     *      An instance of the LightningFormattedDate class,
     *      or config object matching the public API.
     * @returns {string} The date as a string.
     */
    function toFormattedDate(instance, dateTimeFormat) {
      const {
        value
      } = instance;
      if (isValidDate(value)) {
        const formatted = dateTimeFormat(toDateTimeFormatOptions(instance)).format(value);
        if (formatted) {
          return formatted;
        }
      }
      // eslint-disable-line no-console
      console.warn(`<lightning-formatted-date-time> The value attribute accepts either a Date object, a timestamp, or a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`);
      return '';
    }

    /**
     * Convert a LightningFormattedLocation instance (or similar) to a string.
     * Allows for formatting a location without the overhead of instantiating a whole
     * component.
     *
     * @param {LightningFormattedLocationLike} instance
     *      An instance of the LightningFormattedLocation class,
     *      or config object matching the public API.
     * @returns {string} The latitude and longitude as a string.
     */
    function toFormattedLocation(instance) {
      const {
        latitude,
        longitude
      } = instance;
      if (isValidLatitude(latitude) && isValidLongitude(longitude)) {
        return `${latitude}, ${longitude}`;
      }
      // eslint-disable-next-line no-console
      console.warn(`<lightning-formatted-location> expects latitude in range [-90.0, 90.0], longitude in range [-180.0, 180.0].`);
      return '';
    }

    /**
     * Convert a LightningFormattedNumber instance (or similar) to a string.
     * Allows for formatting a number without the overhead of instantiating a whole
     * component.
     *
     * @param {LightningFormattedNumberLike} instance
     *      An instance of the LightningFormattedNumber class,
     *      or config object matching the public API.
     * @returns {string} The number as a string.
     */
    function toFormattedNumber(instance, numberFormat) {
      const {
        value
      } = instance;
      if (value !== null && value !== undefined && value !== '' && isFinite(value)) {
        const {
          formatStyle
        } = instance;
        const options = {
          style: formatStyle,
          currency: instance.currencyCode,
          currencyDisplay: instance.currencyDisplayAs,
          minimumIntegerDigits: instance.minimumIntegerDigits,
          minimumFractionDigits: instance.minimumFractionDigits,
          maximumFractionDigits: instance.maximumFractionDigits,
          minimumSignificantDigits: instance.minimumSignificantDigits,
          maximumSignificantDigits: instance.maximumSignificantDigits
        };
        const valueAsString = String(value);
        let valueToFormat = valueAsString;

        // percent-fixed just divides the value by 100
        // before passing to the library, this is to deal with the
        // fact that percentages in salesforce are 0-100, not 0-1
        if (formatStyle === 'percent-fixed') {
          options.style = 'percent';
          valueToFormat = parseFloat(value) / 100;

          // If the number contains fraction digits and is not in an exponent format
          if (valueAsString.indexOf('.') > 0 && valueAsString.indexOf('e') < 0) {
            // Depending on the input number, division by 100 may lead to rounding errors
            // (e.g 0.785 / 100 is 0.007850000000000001), so we need to round back
            // to the correct precision, that is - existing number of fractional digits
            // plus extra 2 for division by 100.
            valueToFormat = valueToFormat.toFixed(valueAsString.split('.')[1].length + 2);
          }
        }
        return numberFormat(options).format(valueToFormat);
      }
      return '';
    }

    const hexColorCodesRegExp = /^#[0-9abcdef]{6}$/i;

    /**
     * Determine if a value should ignore RTL text formatting.
     *
     * @param {any} value The value to check.
     * @returns {boolean} Whether the provided value should ignore RTL text formatting.
     */
    function isTextIgnoreRTL(value) {
      return typeof value === 'string' && value !== '' &&
      // Ignoring RTL for hex color codes
      hexColorCodesRegExp.test(value);
    }

    var _tmpl = void 0;

    class Observable {
      constructor() {
        this._observers = [];
      }
      subscribe(func) {
        const unsubscribe = fn => this._observers = this._observers.filter(observer => observer !== fn);
        this._observers.push(func);
        return () => unsubscribe(func);
      }
      notify(data) {
        this._observers.forEach(observer => observer(data));
      }
    }
    const __lwc_component_class_internal = lwc.registerComponent(Observable, {
      tmpl: _tmpl,
      sel: "lightning-utils-private",
      apiVersion: 62
    });

    const LIGHTNING_TAG_REGEXP = /^LIGHTNING/i;
    const LIGHTNING_DASH_NAME_REGEXP = /-\w/g;
    function dashWordCharReplacement(dashWordCharMatch) {
      return dashWordCharMatch[1].toUpperCase();
    }
    function synchronizeHTMLElementAttrs(element, attrs) {
      const attrNames = Object.keys(attrs);
      for (let i = 0, {
          length
        } = attrNames; i < length; i += 1) {
        const attrName = attrNames[i];
        const attrValue = attrs[attrName];
        if (attrValue) {
          element.setAttribute(attrName, attrValue);
        } else {
          element.removeAttribute(attrName);
        }
      }
    }
    function synchronizeLightningElementAttrs(element, attrs) {
      const attrNames = Object.keys(attrs);
      for (let i = 0, {
          length
        } = attrNames; i < length; i += 1) {
        const attrName = attrNames[i];
        const attrValue = attrs[attrName];
        const normalizedName = attrName.replace(LIGHTNING_DASH_NAME_REGEXP, dashWordCharReplacement);
        element[normalizedName] = attrValue || null;
      }
    }

    /**
     * @param {HTMLElement} element Element to act on
     * @param {Object} values values and attributes to set, if the value is
     *                        falsy it the attribute will be removed
     */
    function synchronizeAttrs(element, attrs) {
      if (element) {
        if (LIGHTNING_TAG_REGEXP.test(element.tagName)) {
          synchronizeLightningElementAttrs(element, attrs);
        } else {
          synchronizeHTMLElementAttrs(element, attrs);
        }
      }
    }

    /**
     * Update the element's attribute with given value.
     * If value is false, the attribute is removed from the element.
     *
     * @param {Object} element - Element
     * @param {string} attrName - Attribute name
     * @param {string|boolean} value - Attribute value
     */
    function reflectAttribute(element, attrName, value) {
      if (!element) {
        return;
      }
      if (typeof value === 'string') {
        element.setAttribute(attrName, value);
      } else if (value === true) {
        element.setAttribute(attrName, '');
      } else if (!value) {
        element.removeAttribute(attrName);
      } else {
        console.warn(`Invalid attribute value for "${attrName}": ${value}`);
      }
    }

    /**
     * Get the actual DOM id for an element
     * @param {HTMLElement|String} el The element to get the id for (string will just be returned)
     *
     * @returns {String} The DOM id or null
     */
    function getRealDOMId(el) {
      if (typeof el === 'string') {
        return el.length > 0 ? el : null;
      }
      return typeof el === 'object' && el !== null ? el.getAttribute('id') : null;
    }

    /**
     * Returns the active element traversing shadow roots
     * @returns {Element} Active Element inside shadow
     */
    function getShadowActiveElement() {
      let activeElement = document.activeElement;
      while (activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
        activeElement = activeElement.shadowRoot.activeElement;
      }
      return activeElement;
    }

    /**
     * Returns the active elements at each shadow root level
     * @returns {Array} Active Elements  at each shadow root level
     */
    function getShadowActiveElements() {
      let activeElement = document.activeElement;
      const shadowActiveElements = [];
      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
        shadowActiveElements.push(activeElement);
        activeElement = activeElement.shadowRoot.activeElement;
      }
      if (activeElement) {
        shadowActiveElements.push(activeElement);
      }
      return shadowActiveElements;
    }
    function isRTL() {
      // document does not exist on server and MRT does not support RTL below the root component (https://gus.lightning.force.com/lightning/r/ADM_Epic__c/a3QEE000000KEOb2AO/view)
      return isCSR && document.dir === 'rtl';
    }
    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }
    function isNotUndefinedOrNull(value) {
      return !isUndefinedOrNull(value);
    }
    const DEFAULT_MODAL_ZINDEX = 9000;
    const DEFAULT_ZINDEX_OFFSET = 100;
    const DEFAULT_ZINDEX_BASELINE = DEFAULT_MODAL_ZINDEX + DEFAULT_ZINDEX_OFFSET;
    /**
     * Returns the zIndex baseline from slds zIndex variable --lwc-zIndexModal.
     * @returns {Number} zIndex baseline
     */
    function getZIndexBaseline() {
      // When SLDS styles are present, typically on Core
      // this currently resolves to: '9000' (string)
      // If function is called in server context, use default as window and document are not available.
      const modalZindexValueLwc = isCSR ? (window.getComputedStyle(document.documentElement) || document.documentElement.style).getPropertyValue('--lwc-zIndexModal') : DEFAULT_MODAL_ZINDEX;
      const baseZindexModalLwc = parseInt(modalZindexValueLwc, 10);
      return isNaN(baseZindexModalLwc) ? DEFAULT_ZINDEX_BASELINE : baseZindexModalLwc + DEFAULT_ZINDEX_OFFSET;
    }
    function timeout(interval) {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(resolve, interval);
      });
    }
    function animationFrame() {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        window.requestAnimationFrame(resolve);
      });
    }

    /**
     *
     * Decorates an input element to fire an "input"
     * event when the value is directly set.
     *
     * @param {HTMLElement} element The element to decorate.
     *
     */
    function decorateInputForDragon(element) {
      const valuePropertyDescriptor = getInputValuePropertyDescriptor(element);
      Object.defineProperty(element, 'value', {
        set(value) {
          valuePropertyDescriptor.set.call(this, value);
          this.dispatchEvent(new CustomEvent('input'));
        },
        get: valuePropertyDescriptor.get,
        enumerable: true,
        configurable: true
      });
    }
    function getInputValuePropertyDescriptor(element) {
      return Object.getOwnPropertyDescriptor(Object.getPrototypeOf(element), 'value');
    }
    function setDecoratedDragonInputValueWithoutEvent(element, value) {
      const valuePropertyDescriptor = getInputValuePropertyDescriptor(element);
      return valuePropertyDescriptor.set.call(element, value);
    }

    /**
     * Escape HTML string
     * @param {String} html An html string
     * @returns {String} The escaped html string
     */
    function escapeHTML(html) {
      return html.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
    }
    const BUTTON_GROUP_ORDER = {
      FIRST: 'first',
      MIDDLE: 'middle',
      LAST: 'last',
      ONLY: 'only'
    };

    /**
     * returns the SLDS class for the given group order
     * @param groupOrder
     * @returns {string}
     */
    function buttonGroupOrderClass(groupOrder) {
      return {
        [BUTTON_GROUP_ORDER.FIRST]: 'slds-button_first',
        [BUTTON_GROUP_ORDER.MIDDLE]: 'slds-button_middle',
        [BUTTON_GROUP_ORDER.LAST]: 'slds-button_last',
        [BUTTON_GROUP_ORDER.ONLY]: 'single-button'
      }[groupOrder];
    }

    /**
     * Checks if the given lightning component is native
     * @param {Object} cmp LightningElement instance
     * @returns {Boolean} Whether the lightning component is native
     */
    function isNativeComponent(cmp) {
      return cmp?.template && !cmp.template.synthetic;
    }

    /**
     * Determine if event is of type FocusEvent (blur or focus). This is required
     * in some cases to prevent these events from bubbling to ensure parity between synthetic
     * and native shadow.
     *
     * 'focus' and 'blur' events that have been propagated manually via CustomEvents are not considered
     * FocusEvents.
     *
     * Corresponding LWC issue: https://github.com/salesforce/lwc/issues/1244
     * Corresponding LBC bug: @W-13236327
     *
     */
    function isBubblingFocusEvent(event) {
      const focusEvents = ['focus', 'blur'];
      return event instanceof FocusEvent && focusEvents.includes(event.type);
    }

    /**
     * Checks if a desktop browser is being used in the enviroment
     * @returns {Boolean} is a desktop browser being used
     */
    function isDesktopBrowser() {
      return formFactor__default.default === 'Large';
    }
    const {
      hasOwn: ObjectHasOwn
    } = Object;
    const {
      hasOwnProperty: ObjectProtoHasOwnProperty
    } = Object.prototype;

    /**
     * Determines if a given object has the specified key as a direct property.
     *
     * @param {Object} object The object to check
     * @param {string} key The property key
     * @returns {Boolean} Whether the given key is a direct property of the object.
     */
    const hasOwn = typeof ObjectHasOwn === 'function' ? ObjectHasOwn : function hasOwn(object, key) {
      return ObjectProtoHasOwnProperty.call(object, key);
    };

    /**
     * Determines if a given object has any direct properties.
     *
     * @param {Object} object The object to check
     * @returns {Boolean} Whether the object has direct properties.
     */
    function hasOwnProperties(object) {
      for (let key in object) {
        if (hasOwn(object, key)) {
          return true;
        }
      }
      return false;
    }

    exports.ARIA = ARIA;
    exports.ARIA_TO_CAMEL = ARIA_TO_CAMEL;
    exports.ArraySlice = ArraySlice;
    exports.BUTTON_GROUP_ORDER = BUTTON_GROUP_ORDER;
    exports.EventEmitter = EventEmitter;
    exports.FALLBACK_URL = FALLBACK_URL;
    exports.Observable = __lwc_component_class_internal;
    exports.VALID_HEADING_LEVELS = VALID_HEADING_LEVELS;
    exports.animationFrame = animationFrame;
    exports.arraysEqual = arraysEqual;
    exports.assert = assert;
    exports.buttonGroupOrderClass = buttonGroupOrderClass;
    exports.classListMutation = classListMutation;
    exports.classSetToString = classSetToString;
    exports.computeAriaInvalid = computeAriaInvalid;
    exports.createEmailHref = createEmailHref;
    exports.createHttpHref = createHttpHref;
    exports.decorateInputForDragon = decorateInputForDragon;
    exports.deepCopy = deepCopy;
    exports.emailRegexString = emailRegexString;
    exports.escapeHTML = escapeHTML;
    exports.getRealDOMId = getRealDOMId;
    exports.getShadowActiveElement = getShadowActiveElement;
    exports.getShadowActiveElements = getShadowActiveElements;
    exports.getZIndexBaseline = getZIndexBaseline;
    exports.guid = guid;
    exports.hasAnimation = hasAnimation;
    exports.hasOnlyAllowedVideoIframes = hasOnlyAllowedVideoIframes;
    exports.hasOwn = hasOwn;
    exports.hasOwnProperties = hasOwnProperties;
    exports.isAbsoluteUrl = isAbsoluteUrl;
    exports.isAndroidOS = isAndroidOS;
    exports.isAriaDescriptionSupported = isAriaDescriptionSupported;
    exports.isBubblingFocusEvent = isBubblingFocusEvent;
    exports.isCSR = isCSR;
    exports.isChrome = isChrome;
    exports.isDesktopBrowser = isDesktopBrowser;
    exports.isHeadingLevelValid = isHeadingLevelValid;
    exports.isIE11 = isIE11;
    exports.isMacOS = isMacOS;
    exports.isNativeComponent = isNativeComponent;
    exports.isNotUndefinedOrNull = isNotUndefinedOrNull;
    exports.isRTL = isRTL;
    exports.isSafari = isSafari;
    exports.isShiftMetaOrControlKey = isShiftMetaOrControlKey;
    exports.isTextIgnoreRTL = isTextIgnoreRTL;
    exports.isUndefinedOrNull = isUndefinedOrNull;
    exports.isValidDate = isValidDate;
    exports.isValidLatitude = isValidLatitude;
    exports.isValidLongitude = isValidLongitude;
    exports.isValidPageReference = isValidPageReference;
    exports.isValidPhone = isValidPhone;
    exports.isWindowsOS = isWindowsOS;
    exports.isiOS = isiOS;
    exports.keyCodes = keyCodes;
    exports.makeAbsoluteUrl = makeAbsoluteUrl;
    exports.makeEverythingExceptElementInert = makeEverythingExceptElementInert;
    exports.newLineRegexString = newLineRegexString;
    exports.normalizeAriaAttribute = normalizeAriaAttribute;
    exports.normalizeArray = normalizeArray;
    exports.normalizeBoolean = normalizeBoolean;
    exports.normalizeKeyValue = normalizeKeyValue;
    exports.normalizeNumber = normalizeNumber;
    exports.normalizeString = normalizeString;
    exports.observePosition = observePosition;
    exports.parseToFormattedLinkifiedParts = parseToFormattedLinkifiedParts;
    exports.parseToFormattedParts = parseToFormattedParts;
    exports.raf = raf;
    exports.reflectAttribute = reflectAttribute;
    exports.restoreInertness = restoreInertness;
    exports.runActionOnBufferedTypedCharacters = runActionOnBufferedTypedCharacters;
    exports.sanitizeURL = sanitizeURL;
    exports.setDecoratedDragonInputValueWithoutEvent = setDecoratedDragonInputValueWithoutEvent;
    exports.synchronizeAttrs = synchronizeAttrs;
    exports.tagRegexString = tagRegexString;
    exports.timeout = timeout;
    exports.toDateTimeFormatOptions = toDateTimeFormatOptions;
    exports.toFormattedDate = toFormattedDate;
    exports.toFormattedLocation = toFormattedLocation;
    exports.toFormattedNumber = toFormattedNumber;
    exports.toNorthAmericanPhoneNumber = toNorthAmericanPhoneNumber;
    exports.updateAriaInvalidOnElement = updateAriaInvalidOnElement;
    exports.urlRegexString = urlRegexString;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/formattedText', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/shadowBaseClassPrivate', 'lightning/utilsPrivate'], (function (exports, lwc, stylesheet0$1, LightningShadowBaseClass, utilsPrivate) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

    var stylesheet0 = [stylesheet0__default.default];

    var _implicitStylesheets = [stylesheet0];

    const $fragment1 = lwc.parseFragment`<a target="_blank"${"a0:href"} rel="noopener"${3}>${"t1"}</a>`;
    const $fragment2 = lwc.parseFragment`<br${3}>`;
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {k: api_key, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment, t: api_text, i: api_iterator} = $api;
      return api_iterator($cmp.formattedParts, function (part) {
        return [part.isLink ? api_static_fragment($fragment1, api_key(1, part.key), [api_static_part(0, {
          attrs: {
            "href": part.href
          }
        }, null), api_static_part(1, null, api_dynamic_text(part.value))]) : null, part.isText ? api_text(api_dynamic_text(part.value)) : null, part.isNewline ? api_static_fragment($fragment2, api_key(3, part.key)) : null];
      });
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-f6gbo863ml";
    tmpl.legacyStylesheetToken = "lightning-formattedText_formattedText";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    /**
     * Displays text, replaces newlines with line breaks, and linkifies if requested.
     */
    class FormattedText extends LightningShadowBaseClass__default.default {
      constructor(...args) {
        super(...args);
        /**
         * Sets the text to display.
         * @type {string}
         *
         */
        this.value = '';
        this._linkify = false;
      }
      /**
       * If present, URLs and email addresses are displayed in anchor tags.
       * They are displayed in plain text by default.
       * @type {boolean}
       * @default false
       */
      get linkify() {
        return this._linkify;
      }
      set linkify(value) {
        this._linkify = utilsPrivate.normalizeBoolean(value);
      }
      get formattedParts() {
        if (!this.value || typeof this.value !== 'string') {
          return [];
        }
        return this.linkify ? utilsPrivate.parseToFormattedLinkifiedParts(this.value) : utilsPrivate.parseToFormattedParts(this.value);
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(FormattedText, {
      publicProps: {
        value: {
          config: 0
        },
        linkify: {
          config: 3
        }
      },
      track: {
        _linkify: 1
      }
    });
    const __lwc_component_class_internal = lwc.registerComponent(FormattedText, {
      tmpl: _tmpl,
      sel: "lightning-formatted-text",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/sldsUtilsThemes', ['exports'], (function (exports) {

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_default" + shadowSelector + ",:host([data-interactive-dialog]) .slds-theme_default" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_default" + shadowSelector + "," + hostSelector + "[data-interactive-dialog] .slds-theme_default")) + shadowSelector + " {background-color: var(--slds-g-color-neutral-base-100, #fff);color: var(--slds-g-color-neutral-base-10, #181818);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_shade" + shadowSelector + ",:host([data-interactive-dialog]) .slds-theme_shade" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_shade" + shadowSelector + "," + hostSelector + "[data-interactive-dialog] .slds-theme_shade")) + shadowSelector + " {background-color: var(--slds-g-color-neutral-base-95, #f3f3f3);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_inverse" + shadowSelector + ",:host([data-interactive-dialog]) .slds-theme_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_inverse" + shadowSelector + "," + hostSelector + "[data-interactive-dialog] .slds-theme_inverse")) + shadowSelector + " {color: var(--slds-g-color-neutral-base-100, #fff);background-color: var(--slds-g-color-brand-base-10, #001639);border-color: var(--slds-g-color-brand-base-10, #001639);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_alt-inverse" + shadowSelector + ",:host([data-interactive-dialog]) .slds-theme_alt-inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_alt-inverse" + shadowSelector + "," + hostSelector + "[data-interactive-dialog] .slds-theme_alt-inverse")) + shadowSelector + " {color: var(--slds-g-color-neutral-base-100, #fff);background-color: var(--slds-g-color-brand-base-20, #032d60);border-color: var(--slds-g-color-brand-base-20, #032d60);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_success" + shadowSelector + ",:host([data-interactive-dialog]) .slds-theme_success" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_success" + shadowSelector + "," + hostSelector + "[data-interactive-dialog] .slds-theme_success")) + shadowSelector + " {color: var(--slds-g-color-neutral-base-100, #fff);background-color: var(--slds-g-color-success-base-50, #2e844a);--slds-g-link-color: var(--slds-g-color-neutral-base-100, #fff);--slds-g-link-color-active: var(--slds-g-color-neutral-100-opacity-50, rgb(255 255 255 / 50%));--slds-g-link-color-hover: var(--slds-g-color-neutral-base-100, #fff);--_slds-g-font-decoration: underline;--_slds-g-font-decoration-hover: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_info" + shadowSelector + ",:host([data-interactive-dialog]) .slds-theme_info" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_info" + shadowSelector + "," + hostSelector + "[data-interactive-dialog] .slds-theme_info")) + shadowSelector + " {color: var(--slds-g-color-neutral-base-100, #fff);background-color: var(--slds-g-color-neutral-base-50, #747474);--slds-g-link-color: var(--slds-g-color-neutral-base-100, #fff);--slds-g-link-color-active: var(--slds-g-color-neutral-100-opacity-50, rgb(255 255 255 / 50%));--slds-g-link-color-hover: var(--slds-g-color-neutral-base-100, #fff);--_slds-g-font-decoration: underline;--_slds-g-font-decoration-hover: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_warning" + shadowSelector + ",:host([data-interactive-dialog]) .slds-theme_warning" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_warning" + shadowSelector + "," + hostSelector + "[data-interactive-dialog] .slds-theme_warning")) + shadowSelector + " {background-color: var(--slds-g-color-warning-base-60, #fe9339);color: var(--slds-g-color-neutral-base-10, #181818);--slds-g-link-color: var(--slds-g-color-neutral-base-10, #181818);--slds-g-link-color-active: var(--slds-g-color-neutral-base-30, #514f4d);--slds-g-link-color-hover: var(--slds-g-color-neutral-base-10, #181818);--_slds-g-font-decoration: underline;--_slds-g-font-decoration-hover: none;--_slds-g-shadow: 0 0 3px var(--slds--g-color-neutral-base-30, #514f4d);--_slds-g-style-border: solid;--_slds-g-sizing-border: var(--sds-g-sizing-border-1);--_slds-g-color-border: var(--slds-g-color-neutral-base-30, #514f4d);--_slds-g-color-outline: transparent;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_warning" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_warning")) + shadowSelector + " " + shadowSelector + "::part(button) {color: var(--slds-g-color-on-warning-1);text-decoration: underline;--slds-c-icon-color-foreground: var(--slds-g-color-on-warning-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_warning" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_warning")) + shadowSelector + " ::part(button):hover" + shadowSelector + " {color: color-mix(in oklab, currentColor, transparent 25%);--slds-c-icon-color-foreground: color-mix(in oklab, var(--slds-g-color-on-warning-1), transparent 25%);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_warning" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_warning")) + shadowSelector + " ::part(button):focus" + shadowSelector + " {color: var(--slds-g-color-neutral-base-30, #514f4d);box-shadow: 0 0 3px var(--slds-g-color-neutral-base-30, #514f4d);border: 1px solid var(--slds-g-color-neutral-base-30, #514f4d);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_warning" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_warning")) + shadowSelector + " ::part(button):active" + shadowSelector + " {color: var(--slds-g-color-neutral-base-50, #706e6b);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_warning" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_warning")) + shadowSelector + " " + shadowSelector + "::part(boundary) {--slds-c-icon-color-foreground: var(--slds-g-color-neutral-base-30, #514f4d);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_error" + shadowSelector + ",:host([data-interactive-dialog]) .slds-theme_error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_error" + shadowSelector + "," + hostSelector + "[data-interactive-dialog] .slds-theme_error")) + shadowSelector + " {color: var(--slds-g-color-neutral-base-100, #fff);background-color: var(--slds-g-color-error-base-40, #ea001e);--slds-g-link-color: var(--slds-g-color-neutral-base-100, #fff);--slds-g-link-color-active: var(--slds-g-color-neutral-100-opacity-50, rgb(255 255 255 / 50%));--slds-g-link-color-hover: var(--slds-g-color-neutral-base-100, #fff);--_slds-g-font-decoration: underline;--_slds-g-font-decoration-hover: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_offline" + shadowSelector + ",:host([data-interactive-dialog]) .slds-theme_offline" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_offline" + shadowSelector + "," + hostSelector + "[data-interactive-dialog] .slds-theme_offline")) + shadowSelector + " {color: var(--slds-g-color-neutral-base-100, #fff);background-color: var(--slds-g-color-neutral-base-30, #444);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_alert-texture" + shadowSelector + ",:host([data-interactive-dialog]) .slds-theme_alert-texture" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_alert-texture" + shadowSelector + "," + hostSelector + "[data-interactive-dialog] .slds-theme_alert-texture")) + shadowSelector + " {background-image: linear-gradient(45deg, rgb(0 0 0 / 2.5%) 25%, transparent 25%, transparent 50%, rgb(0 0 0 / 2.5%) 50%, rgb(0 0 0 / 2.5%) 75%, transparent 75%, transparent);background-size: 64px 64px;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-theme_inverse-text" + shadowSelector + ",:host([data-interactive-dialog]) .slds-theme_inverse-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-theme_inverse-text" + shadowSelector + "," + hostSelector + "[data-interactive-dialog] .slds-theme_inverse-text")) + shadowSelector + " {color: var(--slds-g-color-neutral-base-100, #fff);}";
      /*LWC compiler v7.1.5*/
    }
    var sldsUtilsThemes = [stylesheet];

    exports.default = sldsUtilsThemes;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/routingService', ['exports', '@salesforce/client/formFactor', 'lightning/utilsPrivate'], (function (exports, formFactor, utilsPrivate) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var formFactor__default = /*#__PURE__*/_interopDefaultCompat(formFactor);

    const FORM_FACTOR_PHONE = 'Small';
    function shouldDispatchToApp(target, formFactor) {
      const isMobile = formFactor === FORM_FACTOR_PHONE;

      // No target is treated like it were '_self'
      return !target || target === '_self' ||
      // On mobile (hybrid), most resources should be kept inside the app, so we treat _blank as _self in a mobile hybrid app
      isMobile && target === '_blank' ||
      // When _top should be identical to _self.
      // This fixes a number of issues such as unnecessary page reloading in an SPA
      //      and communities URLs not getting handled in the community because
      //      the input URL doesn't have the communities prefix added on
      //      until _self is handled at runtime
      target === '_top' && window.top === window || target === '_parent' && window.parent === window;
    }

    const GET_LINK_INFO_EVENT = 'lightningroutingservicegetlinkinfo';
    const LINK_PROVIDERS = new WeakMap();
    const urlTypes = {
      standard: 'standard_webPage'
    };
    class LinkInfo {
      constructor(url, dispatcher) {
        this.url = url;
        this.dispatcher = dispatcher;
        Object.freeze(this);
      }
    }
    function hasLinkProvider(element) {
      let {
        parentNode
      } = element;
      while (parentNode) {
        if (LINK_PROVIDERS.has(parentNode)) {
          return true;
        }
        parentNode = parentNode.parentNode;
      }
      return false;
    }
    function isLinkProvider(element) {
      return LINK_PROVIDERS.has(element);
    }
    function registerLinkProvider(element, providerFn) {
      let listeners = LINK_PROVIDERS.get(element);
      if (listeners === undefined) {
        listeners = new Set();
        LINK_PROVIDERS.set(element, listeners);
      }
      listeners.add(providerFn);
      element.addEventListener(GET_LINK_INFO_EVENT, providerFn);
    }
    function unregisterLinkProvider(element, providerFn) {
      let listeners = LINK_PROVIDERS.get(element);
      if (listeners) {
        listeners.delete(providerFn);
        if (!listeners.size) {
          LINK_PROVIDERS.delete(element);
        }
      }
      element.removeEventListener(GET_LINK_INFO_EVENT, providerFn);
    }

    /*
     * Mock getLinkInfo
     *
     * @returns {Promise[LinkInfo]}
     */
    function getLinkInfo(element, stateRef) {
      return new Promise((resolve, reject) => {
        // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments
        const getLinkInfoEvent = new CustomEvent(GET_LINK_INFO_EVENT, {
          detail: {
            stateRef,
            callback: (err, linkInfo) => {
              if (err) {
                reject(err);
              } else {
                resolve(linkInfo);
              }
            }
          },
          bubbles: true,
          composed: true,
          cancelable: true
        });
        element.dispatchEvent(getLinkInfoEvent);
      });
    }

    /**
     * Determines the route for the given url and updates the element
     * state with the correct url and dispatcher.
     *
     * @param {HTMLElement} element Element from which to dispatch the routing event
     * @param {Object} url Link to route, target Target of the link
     * @param {function} callback on the returned LinkInfo
     *
     * @returns {Promise} Promise[LinkInfo]
     */
    function updateRawLinkInfo(element, {
      url,
      target
    }) {
      if (url === null || url === undefined) {
        // eslint-disable-next-line no-console
        console.error('url must be specified');
      }
      if (utilsPrivate.isCSR && shouldDispatchToApp(target, formFactor__default.default)) {
        return getLinkInfo(element, {
          stateType: urlTypes.standard,
          attributes: {
            url,
            target
          }
        });
      }

      // Return a no-op dispatcher for targets that should be handled by the browser
      return new Promise(resolve => {
        resolve({
          url,
          dispatcher: () => {}
        });
      });
    }

    exports.LinkInfo = LinkInfo;
    exports.getLinkInfo = getLinkInfo;
    exports.hasLinkProvider = hasLinkProvider;
    exports.isLinkProvider = isLinkProvider;
    exports.registerLinkProvider = registerLinkProvider;
    exports.unregisterLinkProvider = unregisterLinkProvider;
    exports.updateRawLinkInfo = updateRawLinkInfo;
    exports.urlTypes = urlTypes;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/formattedRichText', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/sldsUtilsThemes', 'lightning/shadowBaseClassPrivate', 'lightning/purifyLib', 'lightning/routingService', 'lightning/utilsPrivate'], (function (exports, lwc, stylesheet0$1, stylesheet2, LightningShadowBaseClass, sanitizeHTML, routingService, utilsPrivate) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var stylesheet2__default = /*#__PURE__*/_interopDefaultCompat(stylesheet2);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);
  var sanitizeHTML__default = /*#__PURE__*/_interopDefaultCompat(sanitizeHTML);

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) {" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] {")), "line-height: var(--slds-g-font-lineheight);overflow-wrap: break-word;word-wrap: break-word;hyphens: manual;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h1" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h1")), shadowSelector, " {font-size: var(--slds-g-font-scale-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h2" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h2")), shadowSelector, " {font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-7);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h3" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h3")), shadowSelector, " {font-size: var(--slds-g-font-scale-neg-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h4" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h4")), shadowSelector, " {font-size: var(--slds-g-font-scale-neg-3);font-weight: var(--slds-g-font-weight-7);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h5" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h5")), shadowSelector, " {font-size: var(--slds-g-font-scale-neg-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h6" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h6")), shadowSelector, " {font-size: var(--slds-g-font-scale-neg-4);font-weight: var(--slds-g-font-weight-7);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h1" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h2" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h3" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h4" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h5" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) h6" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ul" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ol" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) dl" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) img" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h1" + shadowSelector + "," + hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h2" + shadowSelector + "," + hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h3" + shadowSelector + "," + hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h4" + shadowSelector + "," + hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h5" + shadowSelector + "," + hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] h6" + shadowSelector + "," + hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ul" + shadowSelector + "," + hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ol" + shadowSelector + "," + hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] dl" + shadowSelector + "," + hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] img")), shadowSelector, " {margin-block-end: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) blockquote" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] blockquote")), shadowSelector, " {margin: var(--slds-g-spacing-6) var(--slds-g-spacing-5);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ins" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ins")), shadowSelector, " {color: var(--slds-g-color-success-base-50, var(--slds-g-color-success-base-50));text-decoration: underline;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) del" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] del")), shadowSelector, " {color: var(--slds-g-color-error-base-30, var(--slds-g-color-error-base-50));text-decoration: line-through;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ul" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ul")), shadowSelector, " {margin-inline-start: var(--slds-g-spacing-5);list-style: disc;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ul" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ul")), shadowSelector, " ul", shadowSelector, " {list-style: circle;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ul" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ul")), shadowSelector, " ul", shadowSelector, " ul", shadowSelector, " {list-style: square;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ul" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ul")), shadowSelector, " ul", shadowSelector, " ul", shadowSelector, " ul", shadowSelector, " {list-style: disc;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ul" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ul")), shadowSelector, " ul", shadowSelector, " ul", shadowSelector, " ul", shadowSelector, " ul", shadowSelector, " {list-style: circle;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ul" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ul")), shadowSelector, " ol", shadowSelector, " {margin-inline-start: var(--slds-g-spacing-5);list-style: decimal;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ol" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ol")), shadowSelector, " {margin-inline-start: var(--slds-g-spacing-5);list-style: decimal;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ol" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ol")), shadowSelector, " ol", shadowSelector, " {list-style: lower-alpha;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ol" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ol")), shadowSelector, " ol", shadowSelector, " ol", shadowSelector, " {list-style: lower-roman;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ol" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ol")), shadowSelector, " ol", shadowSelector, " ol", shadowSelector, " ol", shadowSelector, " {list-style: decimal;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ol" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ol")), shadowSelector, " ol", shadowSelector, " ol", shadowSelector, " ol", shadowSelector, " ol", shadowSelector, " {list-style: lower-alpha;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) ol" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] ol")), shadowSelector, " ul", shadowSelector, " {margin-inline-start: var(--slds-g-spacing-5);list-style: disc;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) dd" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] dd")), shadowSelector, " {margin-inline-start: var(--slds-g-spacing-7);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) abbr[title]" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) acronym[title]" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] abbr[title]" + shadowSelector + "," + hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] acronym[title]")), shadowSelector, " {border-bottom: var(--slds-g-sizing-border-1) dotted;cursor: help;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) table" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] table")), shadowSelector, " {overflow-wrap: normal;word-wrap: normal;word-break: normal;width: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) table" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] table")), shadowSelector, " caption", shadowSelector, " {text-align: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) th" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) td" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] th" + shadowSelector + "," + hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] td")), shadowSelector, " {padding: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .sans-serif" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .sans-serif")), shadowSelector, " {font-family: sans-serif;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .courier" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .courier")), shadowSelector, " {font-family: courier;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .verdana" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .verdana")), shadowSelector, " {font-family: verdana;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .tahoma" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .tahoma")), shadowSelector, " {font-family: tahoma;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .garamond" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .garamond")), shadowSelector, " {font-family: garamond;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .serif" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .serif")), shadowSelector, " {font-family: serif;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-1:not(.ql-direction-rtl)" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-1:not(.ql-direction-rtl)")), shadowSelector, " {padding-inline-start: var(--slds-g-spacing-8);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-1.ql-direction-rtl.ql-align-right" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-1.ql-direction-rtl.ql-align-right")), shadowSelector, " {padding-inline-end: var(--slds-g-spacing-8);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-2:not(.ql-direction-rtl)" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-2:not(.ql-direction-rtl)")), shadowSelector, " {padding-inline-start: calc(var(--slds-g-spacing-8) * 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-2.ql-direction-rtl.ql-align-right" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-2.ql-direction-rtl.ql-align-right")), shadowSelector, " {padding-inline-end: calc(var(--slds-g-spacing-8) * 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-3:not(.ql-direction-rtl)" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-3:not(.ql-direction-rtl)")), shadowSelector, " {padding-inline-start: calc(var(--slds-g-spacing-8) * 3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-3.ql-direction-rtl.ql-align-right" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-3.ql-direction-rtl.ql-align-right")), shadowSelector, " {padding-inline-end: calc(var(--slds-g-spacing-8) * 3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-4:not(.ql-direction-rtl)" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-4:not(.ql-direction-rtl)")), shadowSelector, " {padding-inline-start: calc(var(--slds-g-spacing-8) * 4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-4.ql-direction-rtl.ql-align-right" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-4.ql-direction-rtl.ql-align-right")), shadowSelector, " {padding-inline-end: calc(var(--slds-g-spacing-8) * 4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-5:not(.ql-direction-rtl)" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-5:not(.ql-direction-rtl)")), shadowSelector, " {padding-inline-start: calc(var(--slds-g-spacing-8) * 5);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-5.ql-direction-rtl.ql-align-right" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-5.ql-direction-rtl.ql-align-right")), shadowSelector, " {padding-inline-end: calc(var(--slds-g-spacing-8) * 5);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-6:not(.ql-direction-rtl)" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-6:not(.ql-direction-rtl)")), shadowSelector, " {padding-inline-start: calc(var(--slds-g-spacing-8) * 6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-6.ql-direction-rtl.ql-align-right" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-6.ql-direction-rtl.ql-align-right")), shadowSelector, " {padding-inline-end: calc(var(--slds-g-spacing-8) * 6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-7:not(.ql-direction-rtl)" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-7:not(.ql-direction-rtl)")), shadowSelector, " {padding-inline-start: calc(var(--slds-g-spacing-8) * 7);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-7.ql-direction-rtl.ql-align-right" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-7.ql-direction-rtl.ql-align-right")), shadowSelector, " {padding-inline-end: calc(var(--slds-g-spacing-8) * 7);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-8:not(.ql-direction-rtl)" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-8:not(.ql-direction-rtl)")), shadowSelector, " {padding-inline-start: calc(var(--slds-g-spacing-8) * 8);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-8.ql-direction-rtl.ql-align-right" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-8.ql-direction-rtl.ql-align-right")), shadowSelector, " {padding-inline-end: calc(var(--slds-g-spacing-8) * 8);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-9:not(.ql-direction-rtl)" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-9:not(.ql-direction-rtl)")), shadowSelector, " {padding-inline-start: calc(var(--slds-g-spacing-8) * 9);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-rich-text-editor__output) .ql-indent-9.ql-direction-rtl.ql-align-right" : hostSelector + ".slds-rich-text-editor__output[data-render-mode=\"shadow\"] .ql-indent-9.ql-direction-rtl.ql-align-right")), shadowSelector, " {padding-inline-end: calc(var(--slds-g-spacing-8) * 9);}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1, stylesheet2__default.default];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<span part="formatted-rich-text"${3}>${"t1"}</span>`;
  const stc0 = {
    "part": "formatted-rich-text"
  };
  const stc1 = {
    lwc: {
      dom: "manual"
    }
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {d: api_dynamic_text, sp: api_static_part, st: api_static_fragment, fr: api_fragment, shc: api_sanitize_html_content, h: api_element} = $api;
    return [$cmp.rawTextIfSanitizerThrewError ? api_fragment(0, [api_static_fragment($fragment1, 2, [api_static_part(1, null, api_dynamic_text($cmp.rawTextIfSanitizerThrewError))])], 0) : api_fragment(0, [api_element("span", {
      attrs: stc0,
      props: {
        innerHTML: $ctx._rawHtml$0 !== ($ctx._rawHtml$0 = $cmp.richText) ? $ctx._sanitizedHtml$0 = api_sanitize_html_content($cmp.richText) : $ctx._sanitizedHtml$0
      },
      context: stc1,
      key: 3
    })], 0)];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-4nfn2rc40ch";
  tmpl.legacyStylesheetToken = "lightning-formattedRichText_formattedRichText";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  const tagsWhitelist = Object.freeze(['a', 'abbr', 'acronym', 'address', 'b', 'br', 'big', 'blockquote', 'caption', 'cite', 'code', 'col', 'colgroup', 'del', 'div', 'dl', 'dd', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'li', 'ol', 'mark', 'p', 'param', 'pre', 'q', 's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'strike', 'font']);
  const attrWhitelist = Object.freeze(['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'part', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'span', 'srclang', 'start', 'src', 'step', 'style', 'summary', 'tabindex', 'target', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'data-fileid']);
  const uriAllowList = Object.freeze(['ftp', 'ftps', 'http', 'https', 'mailto', 'tel', 'callto', 'cid', 'xmpp', 'ciscotel', 'navision']);
  const uriAllowListString = uriAllowList.join('|');
  // eslint-disable-next-line no-useless-escape
  const allowedUriRegString = `^(?:(?:${uriAllowListString}):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))`;
  const allowedUriRegEx = new RegExp(allowedUriRegString, 'i');
  const richTextConfig = Object.freeze({
    ALLOWED_TAGS: tagsWhitelist,
    ALLOWED_ATTR: attrWhitelist,
    ALLOWED_URI_REGEXP: allowedUriRegEx,
    ALLOW_UNKNOWN_PROTOCOLS: false
  });

  function linkTextNodes(container) {
    const urlRegex = new RegExp(`^${utilsPrivate.urlRegexString}/?$`, 'i');
    const emailRegex = new RegExp(`^${utilsPrivate.emailRegexString}$`, 'i');
    const toReplace = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
    while (walker.nextNode()) {
      const currentNode = walker.currentNode;
      const parent = walker.currentNode.parentNode;
      if (parent.nodeName === 'A') {
        // Do not add double a tags
        continue;
      }
      // &quot; = legacy supported edge case for docs
      // ; = urls cannot have semicolons
      // ["'] = common to quote links in docs
      const items = walker.currentNode.nodeValue.split(/(&quot;|;|["']?\s+["']?|["'])/g);
      const fragment = document.createDocumentFragment();
      let hasLink = false;
      items.forEach((text, i) => {
        if (i % 2 === 0) {
          if (text.match(urlRegex)) {
            const a = document.createElement('a');
            a.href = utilsPrivate.createHttpHref(text);
            a.target = '_blank';
            a.rel = 'noopener';
            a.appendChild(document.createTextNode(text));
            fragment.appendChild(a);
            hasLink = true;
          } else if (text.match(emailRegex)) {
            const a = document.createElement('a');
            a.href = utilsPrivate.createEmailHref(text);
            a.appendChild(document.createTextNode(text));
            fragment.appendChild(a);
            hasLink = true;
          } else if (text) {
            fragment.appendChild(document.createTextNode(text));
          }
        } else if (text) {
          fragment.appendChild(document.createTextNode(text));
        }
      });
      if (hasLink) {
        toReplace.push({
          parent,
          fragment,
          currentNode
        });
      }
    }
    toReplace.forEach(({
      parent,
      fragment,
      currentNode
    }) => {
      parent.replaceChild(fragment, currentNode);
    });
  }

  const linkRegex = new RegExp(`${utilsPrivate.tagRegexString}|${utilsPrivate.emailRegexString}|${utilsPrivate.urlRegexString}`, 'gi');
  const createHttpLink = function (match) {
    const href = utilsPrivate.createHttpHref(match);
    return `<a href="${href}" target="_blank" rel="noopener">${match}</a>`;
  };
  const createEmailLink = function (match) {
    const href = utilsPrivate.createEmailHref(match);
    return `<a href="${href}">${match}</a>`;
  };

  // SSR is not impacted by security vunerabilities and cannot use the DOM (see W-14765820)
  const linkTextNodesSSR = function (text) {
    if (typeof text !== 'string') {
      return '';
    }
    return text.replace(linkRegex, (match, tagMatch, emailMatch, hrefMatch) => {
      if (tagMatch) {
        return tagMatch;
      } else if (hrefMatch) {
        const endsWithQuote = hrefMatch.endsWith('&quot');
        let href = hrefMatch;
        if (endsWithQuote) {
          href = hrefMatch.slice(0, hrefMatch.lastIndexOf('&quot'));
        }
        return createHttpLink(href) + (endsWithQuote ? '&quot' : '');
      } else if (emailMatch) {
        return createEmailLink(emailMatch);
      }
      return match;
    });
  };

  // Overriding default sanitization hook to disable it.
  // Content is conditionally sanitized within the component
  // https://lwc.dev/guide/html_templates#override-the-sanitizehtmlcontent(content)-method
  // W-16437378 - Remove this section once setHooks has been removed globally
  try {
    lwc.setHooks({
      sanitizeHtmlContent(rawHTMLString) {
        return rawHTMLString;
      }
    });
  } catch (e) {
    // Do nothing because setHooks is getting
    // called at the app/framework level.
  }

  /**
   * Displays rich text that's formatted with allowed tags and attributes.
   * Other tags and attributes are removed and only their text content is displayed.
   */

  /**
   * W-15751242 resulted in major updates to formatted-rich-text depending on render mode.
   * If loaded in CSR, content gets sanitized. This is rendered as text.
   * If loaded in SSR, content does not get sanitized until it reaches the client.
   */
  class LightningFormattedRichText extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      this.rendered = false;
      this._value = '';
      this._disableLinkify = false;
      this.connected = false;
      this.richText = null;
      this.rawTextIfSanitizerThrewError = null;
      this.serverRenderedContent = null;
      this.linkingRequired = false;
    }
    /**
     * If present, the component does not create links in the rich text.
     * @type {boolean}
     * @default false
     */
    get disableLinkify() {
      return this._disableLinkify;
    }
    set disableLinkify(val) {
      this._disableLinkify = utilsPrivate.normalizeBoolean(val);
      this.renderRichText();
    }

    /**
     * Sets the rich text to display.
     * @type {string}
     *
     */
    get value() {
      return this._value;
    }
    set value(val) {
      this._value = val === undefined || val === null ? '' : String(val);
      this.renderRichText();
    }
    renderedCallback() {
      if (this.linkingRequired) {
        this.linkRichText();
      }
      if (!this.rendered) {
        this.rendered = true;
        this.renderRichText();
      }
    }
    connectedCallback() {
      super.connectedCallback();
      this.classList.add('slds-rich-text-editor__output');
      this.connected = true;

      // Checks if CSR currently & previously rendered in SSR.
      // This checks if markup already exists in the DOM.
      if (utilsPrivate.isCSR) {
        // eslint-disable-next-line @lwc/lwc/no-inner-html
        this.serverRenderedContent = this.container?.innerHTML;
        if (this.serverRenderedContent) {
          // Syncing server rendered DOM and client component state
          // ensures we render server side non-sanitized content, instead
          // of client side sanitized content, on first paint.
          this.richText = this.serverRenderedContent;
        }
      }
    }
    disconnectedCallback() {
      this.removeLinkClickListeners();
      this.connected = false;
    }
    sanitize(value) {
      if (!value) {
        return value;
      }
      let computedRichTextConfig = richTextConfig;
      if (utilsPrivate.hasOnlyAllowedVideoIframes(value)) {
        // richTextConfig is shared across all formatted-rich-text components;
        // so create and modify copy of richTextConfig to allow iframes for each component
        computedRichTextConfig = {
          ...richTextConfig,
          ALLOWED_TAGS: richTextConfig.ALLOWED_TAGS.concat(['iframe']),
          ALLOWED_ATTR: richTextConfig.ALLOWED_ATTR.concat(['allowfullscreen'])
        };
      }
      try {
        return sanitizeHTML__default.default(value, computedRichTextConfig);
      } catch {
        // If sanitize failed, throw the unsanitized value to be rendered as text
        throw new Error(`
                <lightning-formatted-rich-text> Exception caught when attempting to sanitize: ${value}`, {
          cause: {
            unsanitizedRawText: value
          }
        });
      }
    }
    handleClick(event) {
      const anchor = event.currentTarget;
      if (anchor === null) {
        return;
      }
      const target = anchor.target;
      const url = anchor.href;
      // Grab the link info onclick and dispatch
      routingService.updateRawLinkInfo(this, {
        url,
        target
      }).then(linkInfo => {
        anchor.href = linkInfo.url;
        linkInfo.dispatcher(event);
      });
    }
    renderRichText() {
      if (!utilsPrivate.isCSR) {
        // If SSR, do not sanitize the value on server, just link if required.
        this.richText = this.disableLinkify ? this.value : linkTextNodesSSR(this.value);
      }
      if (this.rendered) {
        try {
          // Sanitizer did not throw an error, so this value is cleared
          this.rawTextIfSanitizerThrewError = null;

          // Render richText if the value changes or if previously set in SSR
          this.richText = this.sanitize(this.value);

          // Linking needs to be added in a second tick as the DOM has not been updated yet
          this.linkingRequired = true;
        } catch (e) {
          // eslint-disable-next-line no-console
          console.warn(e.message);
          this.richText = null;

          // If sanitizer throws an error & the value was not sanitized,
          // render it as an unsanitized text value
          this.rawTextIfSanitizerThrewError = e.cause.unsanitizedRawText;
        }
      }
    }
    linkRichText() {
      if (!this.disableLinkify) {
        linkTextNodes(this.container);
      }
      this.links.forEach(link => {
        link.addEventListener('click', this.handleClick.bind(this));
      });
      this.linkingRequired = false;
    }
    removeLinkClickListeners() {
      this.links.forEach(link => {
        link.removeEventListener('click', this.handleClick.bind(this));
      });
    }
    get links() {
      return this.container ? [...this.container.querySelectorAll('a')] : [];
    }
    get container() {
      return this.template.querySelector('span');
    }
    /*LWC compiler v7.1.5*/
  }
  LightningFormattedRichText.validationOptOut = ['class'];
  lwc.registerDecorators(LightningFormattedRichText, {
    publicProps: {
      disableLinkify: {
        config: 3
      },
      value: {
        config: 3
      }
    },
    fields: ["rendered", "_value", "_disableLinkify", "connected", "richText", "rawTextIfSanitizerThrewError", "serverRenderedContent", "linkingRequired"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningFormattedRichText, {
    tmpl: _tmpl,
    sel: "lightning-formatted-rich-text",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('community_login/loginError', ['exports', 'lwc', 'lightning/formattedRichText'], (function (exports, lwc, _lightningFormattedRichText) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var _lightningFormattedRichText__default = /*#__PURE__*/_interopDefaultCompat(_lightningFormattedRichText);

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      return ".comm-login-error__container" + shadowSelector + " {outline: none;}.comm-login-error__text" + shadowSelector + " {color: var(--lwc-errorTextColor, var(--dxp-g-destructive));}";
      /*LWC compiler v7.1.5*/
    }
    var _implicitStylesheets = [stylesheet];

    const stc0 = {
      classMap: {
        "comm-login-error__container": true,
        "slds-form-element__control": true
      },
      attrs: {
        "tabindex": "-1"
      },
      key: 0
    };
    const stc1 = {
      "comm-login-error__text": true,
      "slds-text-color_error": true
    };
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {c: api_custom_element, h: api_element} = $api;
      return [api_element("div", stc0, [api_custom_element("lightning-formatted-rich-text", _lightningFormattedRichText__default.default, {
        classMap: stc1,
        props: {
          "value": $cmp.error,
          "role": "alert"
        },
        key: 1
      })])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-p64rnn22h3";
    tmpl.legacyStylesheetToken = "community_login-loginError_loginError";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    class LoginError extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        /**
         * Error message to be displayed
         * @type {string}
         */
        this.error = void 0;
      }
      connectedCallback() {
        this.classList.add('comm-login-error');
      }
      renderedCallback() {
        this.setFocus();
      }

      /**
       * Set focus on the login error message element
       */
      setFocus() {
        this.template.querySelector('.comm-login-error__container').focus();
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(LoginError, {
      publicProps: {
        error: {
          config: 0
        }
      },
      publicMethods: ["setFocus"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(LoginError, {
      tmpl: _tmpl,
      sel: "community_login-login-error",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/label/LightningColorPicker.a11yTriggerText', ['@view/forgotPassword/labels'], m => m[6]);
LWR.define('@salesforce/label/LightningControl.activeCapitalized', ['@view/forgotPassword/labels'], m => m[7]);
LWR.define('@salesforce/label/LightningControl.inactiveCapitalized', ['@view/forgotPassword/labels'], m => m[8]);
LWR.define('@salesforce/label/LightningControl.required', ['@view/forgotPassword/labels'], m => m[9]);
LWR.define('@salesforce/label/LightningControl.clear', ['@view/forgotPassword/labels'], m => m[10]);
LWR.define('@salesforce/label/LightningControl.loading', ['@view/forgotPassword/labels'], m => m[11]);
LWR.define('@salesforce/label/LightningInputNumber.incrementCounter', ['@view/forgotPassword/labels'], m => m[12]);
LWR.define('@salesforce/label/LightningInputNumber.decrementCounter', ['@view/forgotPassword/labels'], m => m[13]);
LWR.define('@salesforce/label/LightningInput.helptextAlternativeText', ['@view/forgotPassword/labels'], m => m[14]);
(function() { LWR.define('@salesforce/i18n/timeZone', ['exports', 'lwc'], (function (exports, lwc) {

	var _tmpl = void 0;

	const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
	const __lwc_component_class_internal = lwc.registerComponent(timeZone, {
	  tmpl: _tmpl,
	  sel: "@salesforce-mg0gxt27b8l1hrutfi3p",
	  apiVersion: 62
	});

	exports.default = __lwc_component_class_internal;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/label/LightningDateTimePicker.dateLabel', ['@view/forgotPassword/labels'], m => m[15]);
LWR.define('@salesforce/label/LightningDateTimePicker.rangeOverflow', ['@view/forgotPassword/labels'], m => m[16]);
LWR.define('@salesforce/label/LightningDateTimePicker.rangeUnderflow', ['@view/forgotPassword/labels'], m => m[17]);
LWR.define('@salesforce/label/LightningDateTimePicker.timeLabel', ['@view/forgotPassword/labels'], m => m[18]);
LWR.define('@salesforce/label/LightningDateTimePicker.valueMissingWithDateFormat', ['@view/forgotPassword/labels'], m => m[19]);
LWR.define('@salesforce/label/LightningDateTimePicker.customErrorWithDateFormat', ['@view/forgotPassword/labels'], m => m[20]);
LWR.define('@salesforce/label/LightningHelptext.buttonAlternativeText', ['@view/forgotPassword/labels'], m => m[21]);
(function() { LWR.define('lightning/ariaObserver', ['exports', 'lwc', 'lightning/utilsPrivate'], (function (exports, lwc, utilsPrivate) {

  var _tmpl = void 0;

  // borrowed from bootstrap
  const screenReaderOnlyStyles = `
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
`;
  let microtaskQueued = false;
  const queue = [];
  function flushQueue() {
    const sortedQueue = [...queue].sort((a, b) => a.priority - b.priority);
    queue.length = 0;
    microtaskQueued = false;
    sortedQueue.forEach(({
      callback
    }) => callback());
  }

  // Queue a microtask, but execute with the given priority (lower priority runs first)
  function queueMicrotaskWithPriority(priority, callback) {
    queue.push({
      callback,
      priority
    });
    if (microtaskQueued) {
      return;
    }
    microtaskQueued = true;
    Promise.resolve().then(flushQueue);
  }

  // borrowed from https://github.com/salesforce/kagekiri/blob/cfd0699/src/index.js#L18-L31
  function getChildNodesIgnoringShadowRoot(node) {
    if (node.shadowRoot) {
      // shadow host
      return node.shadowRoot.childNodes;
    } else if (typeof node.assignedNodes === 'function') {
      // slot
      // If the slot has assigned elements, then those
      // should be shown. Otherwise the (default) children should be shown.
      const assigned = node.assignedNodes();
      return assigned.length ? assigned : node.childNodes;
    }
    // regular element
    return node.childNodes;
  }

  // borrowed from https://github.com/salesforce/kagekiri/blob/cfd0699/src/index.js#L72-L87
  function getParentIgnoringShadowRoot(element) {
    // If an element is slotted, ignore the "real" parent and use the shadow DOM parent.
    // Unless the slot is also slotted; just return the parent element in this case.
    if (typeof element.assignedNodes !== 'function' && element.assignedSlot && element.assignedSlot.parentElement) {
      return element.assignedSlot.parentElement;
    }
    if (element.parentElement) {
      return element.parentElement;
    }
    // if an element is inside the shadow DOM, break outside of it
    const rootNode = element.getRootNode();
    /* istanbul ignore else */
    if (rootNode !== document) {
      return rootNode.host;
    }
    return null;
  }
  function isAncestor(node, possibleAncestor) {
    let ancestor = node;
    while (ancestor !== null && ancestor !== undefined) {
      ancestor = getParentIgnoringShadowRoot(ancestor);
      if (ancestor === possibleAncestor) {
        return true;
      }
    }
    return false;
  }

  // MutationObserver that deeply observes open shadow roots

  class DeepMutationObserver {
    constructor(rootNode) {
      this._observers = [];
      this._callbacks = [];
      const observedNodes = [];

      // Avoid adding a mutation observer to a node when its ancestor is already being observed
      // When we cross shadow boundaries, Node.contains() will automatically return false because
      // it's not an ancestor-descendant relationship in the same shadow root
      const alreadyObserved = node => {
        return observedNodes.some(otherNode => otherNode.contains(node));
      };
      const observe = node => {
        if (!alreadyObserved(node)) {
          observedNodes.push(node);
          const observer = new MutationObserver(() => this._mutationCallback());
          observer.observe(node, {
            subtree: true,
            attributes: true,
            childList: true,
            characterData: true
          });
          this._observers.push(observer);
        }
        getChildNodesIgnoringShadowRoot(node).forEach(child => observe(child));
      };
      observe(rootNode);
    }
    onMutation(callback) {
      this._callbacks.push(callback);
    }
    _mutationCallback() {
      queueMicrotaskWithPriority(/* priority */0, () => this._callbacks.forEach(callback => callback()));
    }
    disconnect() {
      this._observers.forEach(observer => observer.disconnect());
      this._observers = undefined;
      this._callbacks = undefined;
    }
  }

  // Figure out what tasks we actually need to do, based on the minimal

  function collateTasks(tasks) {
    const mapOfFromRootsToTasks = new Map();
    tasks.forEach(task => {
      // TODO: fast path if both nodes have the same shadow root
      const {
        fromNode
      } = task;
      const fromRoot = fromNode.getRootNode();
      let collatedTask = mapOfFromRootsToTasks.get(fromRoot);
      if (!collatedTask) {
        collatedTask = {
          relationships: [],
          redundantChildNodes: new Set()
        };
        mapOfFromRootsToTasks.set(fromRoot, collatedTask);
      }
      collatedTask.relationships.push(task);
    });

    // find the common ancestor for all toNodes
    mapOfFromRootsToTasks.forEach(value => {
      const {
        relationships,
        redundantChildNodes
      } = value;
      const allToNodes = relationships.map(relationship => relationship.toNodes).flat();
      for (let i = 0; i < allToNodes.length; i++) {
        for (let j = i + 1; j < allToNodes.length; j++) {
          const toNodeA = allToNodes[i];
          const toNodeB = allToNodes[j];
          if (toNodeA && toNodeB && i !== j) {
            if (isAncestor(toNodeA, toNodeB)) {
              // B is an ancestor of A
              redundantChildNodes.add(toNodeA);
            } else if (isAncestor(toNodeB, toNodeA)) {
              // A is an ancestor of B
              redundantChildNodes.add(toNodeB);
            }
          }
        }
      }
    });
    return mapOfFromRootsToTasks;
  }
  function getAttributes(node) {
    const res = {};
    const {
      attributes
    } = node;
    for (let i = 0; i < attributes.length; i++) {
      const attribute = attributes[i];
      res[attribute.name] = attribute.value;
    }
    return res;
  }
  const stableIds = new WeakMap();
  function generateId() {
    return 'shadow-aria-' + Math.floor(Math.random() * 1000000000).toString(16);
  }
  function getStableId(referenceNode) {
    let id = stableIds.get(referenceNode);
    if (!id) {
      id = generateId();
      stableIds.set(referenceNode, id);
    }
    return id;
  }

  // Loosely based on https://github.com/focus-trap/tabbable/blob/67452d0/src/index.js#L1-L13
  // We don't actually need to support the full list; only the things that actually get mirrored (e.g. tag name)
  // Also we are fine with false positives.

  const TABBABLE_TAG_NAMES = new Set(['a', 'audio', 'button', 'details', 'input', 'select', 'summary', 'textarea', 'video']);
  function redirectEvents(fromNode, toNode) {
    if (fromNode && toNode) {
      redirectFocusEvent(fromNode, toNode);
    }
  }
  function redirectFocusEvent(fromNode, toNode) {
    fromNode.addEventListener('focus', event => {
      event.preventDefault();
      event.stopImmediatePropagation();
      toNode.dispatchEvent(new event.constructor(event.type, event));
      toNode.focus();
    });
  }

  // These styles have an impact on accessibility (e.g. accessible name calculation, DOM hierarchy calculation),
  // so they must be mirrored
  const STYLE_PROPS_TO_MIRROR = ['display', 'visibility'];
  function mirrorNode(node, existingNode) {
    if (node.nodeType === Node.TEXT_NODE) {
      if (existingNode && existingNode.nodeType === Node.TEXT_NODE) {
        if (existingNode.textContent !== node.textContent) {
          existingNode.textContent = node.textContent;
        }
        return existingNode;
      }
      return node.cloneNode();
    }
    if (node.nodeType !== Node.ELEMENT_NODE) {
      // comment or other unsupported node
      return document.createComment('shadow-aria-deleted');
    }
    let {
      tagName
    } = node;
    if (['style', 'link', 'script'].includes(tagName.toLowerCase())) {
      // semantically useless
      return document.createComment('shadow-aria-deleted');
    }
    // For custom elements and slots, just render a <div> The problem with custom elements
    // is that they may bring their own shadow DOM, which we don't want. The problem
    // with slots is that they will try to render slot content since we're inside a shadow root.
    if (tagName.includes('-') || tagName.toLowerCase() === 'slot') {
      tagName = 'div';
    }
    let oldAttributes;
    let mirroredNode;
    if (existingNode && existingNode.nodeType === Node.ELEMENT_NODE && existingNode.tagName.toLowerCase() === tagName.toLowerCase()) {
      // reuse existing node
      mirroredNode = existingNode;
      oldAttributes = getAttributes(mirroredNode);
    } else {
      // create a brand-new node
      mirroredNode = document.createElement(tagName);
    }
    const newAttributes = Object.fromEntries([...Object.entries(getAttributes(node))].filter(([name]) => name.toLowerCase().startsWith('aria-') || name.toLowerCase() === 'role'));
    const computedStyle = getComputedStyle(node);
    let newStyle = '';
    STYLE_PROPS_TO_MIRROR.forEach(prop => newStyle += `${prop}:${computedStyle[prop]};`);
    if (computedStyle?.display !== 'contents') {
      // Firefox gets confused by IDs on elements with `display:contents`
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1762999
      newAttributes.id = getStableId(node);
    }
    newAttributes.style = newStyle;
    if (TABBABLE_TAG_NAMES.has(tagName.toLowerCase())) {
      newAttributes.tabindex = '-1';
    }
    Object.entries(newAttributes).forEach(([name, value]) => {
      if (!oldAttributes || oldAttributes[name] !== value) {
        mirroredNode.setAttribute(name, value);
      }
    });
    if (oldAttributes) {
      Object.keys(oldAttributes).forEach(name => {
        if (!(name in newAttributes)) {
          mirroredNode.removeAttribute(name);
        }
      });
    }
    redirectEvents(mirroredNode, node);
    return mirroredNode;
  }
  function patchMirrorDomTree(root, existingRoot, trackedNodes) {
    const trackedNodesToMirroredNodes = new Map();
    const mirrorNodeRecursive = (node, existingNode) => {
      const mirroredNode = mirrorNode(node, existingNode);
      if (mirroredNode.nodeType === Node.COMMENT_NODE) {
        // ignore child nodes of comments; we don't care
        return mirroredNode;
      }
      if (trackedNodes.has(node)) {
        trackedNodesToMirroredNodes.set(node, mirroredNode);
      }
      const childNodes = getChildNodesIgnoringShadowRoot(node);
      if (existingNode && existingNode.childNodes.length === childNodes.length) {
        // patch
        for (let i = 0; i < childNodes.length; i++) {
          const existingChild = existingNode.childNodes[i];
          const child = childNodes[i];
          const newChild = mirrorNodeRecursive(child, existingChild);
          if (newChild !== existingChild) {
            existingNode.replaceChild(newChild, existingChild);
          }
        }
      } else {
        // clear and overwrite
        if (existingNode) {
          while (existingNode.childNodes.length) {
            existingNode.childNodes[existingNode.childNodes.length - 1].remove();
          }
        }
        childNodes.forEach(childNode => {
          const mirrorChild = mirrorNodeRecursive(childNode, null);
          mirroredNode.appendChild(mirrorChild);
        });
      }
      return mirroredNode;
    };
    const mirroredDomTree = mirrorNodeRecursive(root, existingRoot);
    return {
      mirroredNode: mirroredDomTree,
      trackedNodesToMirroredNodes
    };
  }
  function updateAttribute(fromNode, toNodes, relationship) {
    const newIds = toNodes.map(toNode => toNode.getAttribute('id'));
    const existingIds = splitIds$1(fromNode.getAttribute(relationship));
    const linkedNodeIds = newIds.filter(newId => !existingIds.includes(newId));
    const unlinkedNodeIds = existingIds.filter(existingId => !newIds.includes(existingId));
    fromNode.setAttribute(relationship, newIds.join(' '));
    return {
      linkedNodeIds,
      unlinkedNodeIds
    };
  }
  function splitIds$1(ids) {
    if (!ids) {
      return [];
    }
    return ids.trim().split(/\s+/);
  }

  // Certain ARIA relationships only support one target, not multiple.
  const SINGLE_TARGET_ARIA_RELATIONSHIPS = ['aria-activedescendant', 'aria-errormessage'];
  const mirroredEnvironments = new WeakMap();
  const taskQueue = [];
  function processTask(fromRoot, task) {
    const mirroredEnvironment = getMirroredEnvironment(fromRoot);
    mirrorNodes(mirroredEnvironment, task);
    linkAndObserveNodes(mirroredEnvironment, task);
  }
  function getMirroredEnvironment(fromRoot) {
    let mirroredEnvironment = mirroredEnvironments.get(fromRoot);
    if (!mirroredEnvironment) {
      const mirrorRoot = document.createElement('div');
      mirrorRoot.setAttribute('class', 'aria-element-reflection-mirror');
      mirrorRoot.setAttribute('style', screenReaderOnlyStyles);
      const fromAnchorRoot = fromRoot.body || fromRoot; // for document, append to body
      fromAnchorRoot.appendChild(mirrorRoot);
      mirroredEnvironment = {
        redundantChildNodes: new Set(),
        nodesToMirroredNodes: new Map(),
        mirrorRoot
      };
      mirroredEnvironments.set(fromRoot, mirroredEnvironment);
    }
    return mirroredEnvironment;
  }
  function mirrorNodes(mirroredEnvironment, task) {
    const {
      redundantChildNodes,
      nodesToMirroredNodes,
      mirrorRoot
    } = mirroredEnvironment;
    task.redundantChildNodes.forEach(node => redundantChildNodes.add(node));
    const rootToNodes = new Set(task.relationships.map(({
      toNodes
    }) => toNodes).flat().filter(Boolean) // skip nulls
    .filter(_ => !redundantChildNodes.has(_)) // skip redundant child nodes
    );
    rootToNodes.forEach(toNode => {
      const trackedNodes = new Set([...redundantChildNodes, toNode]);
      const {
        node: existingMirroredNode = null,
        usage = 0
      } = nodesToMirroredNodes.get(toNode) || {};
      const {
        mirroredNode,
        trackedNodesToMirroredNodes
      } = patchMirrorDomTree(toNode, existingMirroredNode, trackedNodes);
      if (mirroredNode !== existingMirroredNode) {
        // The following line should never happen, but I feel safer having it in
        /* istanbul ignore if */
        if (existingMirroredNode) {
          mirrorRoot.removeChild(existingMirroredNode);
        }
        mirrorRoot.appendChild(mirroredNode);
      }
      trackedNodesToMirroredNodes.forEach((trackedMirroredNode, trackedNode) => nodesToMirroredNodes.set(trackedNode, {
        node: trackedMirroredNode,
        usage
      }));
    });
  }
  function linkAndObserveNodes(mirroredEnvironment, task) {
    const {
      nodesToMirroredNodes
    } = mirroredEnvironment;
    task.relationships.forEach(collatedRelationship => {
      const {
        fromNode,
        toNodes,
        relationship,
        track,
        signal,
        mirrorOnly
      } = collatedRelationship;
      if (toNodes?.length) {
        if (!mirrorOnly) {
          const mirroredNodes = toNodes.map(toNode => nodesToMirroredNodes.get(toNode).node);
          const {
            linkedNodeIds,
            unlinkedNodeIds
          } = updateAttribute(fromNode, mirroredNodes, relationship);
          updateNodeUsage(mirroredEnvironment, unlinkedNodeIds, linkedNodeIds);
          if (track) {
            observeNode(fromNode, toNodes, signal);
          }
        }
      } else {
        // toNodes not existing indicates the relationship is severed
        const {
          unlinkedNodeIds
        } = updateAttribute(fromNode, [], relationship);
        updateNodeUsage(mirroredEnvironment, unlinkedNodeIds);
        fromNode.removeAttribute(relationship);
      }
    });
  }
  function updateNodeUsage(mirroredEnvironment, unlinkedNodes, linkedNodes = []) {
    const {
      nodesToMirroredNodes,
      mirrorRoot
    } = mirroredEnvironment;
    nodesToMirroredNodes.forEach((mirroredNode, node) => {
      if (linkedNodes.includes(mirroredNode.node.id)) {
        mirroredNode.usage++;
      } else if (unlinkedNodes.includes(mirroredNode.node.id) && --mirroredNode.usage <= 0) {
        // If mirrored node is no longer used, remove it from the mirrored environment
        nodesToMirroredNodes.delete(node);
        // If the mirrored node's parent is not the root, then its parent node
        // is being mirrored. Only that parent node can be removed at the top level
        if (mirroredNode.node.parentElement === mirrorRoot) {
          mirrorRoot.removeChild(mirroredNode.node);
        }
      }
    });
  }
  function observeNode(fromNode, toNodes, signal) {
    toNodes.forEach(toNode => {
      const mutationObserver = new DeepMutationObserver(toNode);
      mutationObserver.onMutation(() => {
        updateAriaRelationship(fromNode, [toNode]);
      });
      if (signal) {
        signal.addEventListener('abort', () => {
          mutationObserver.disconnect();
        });
      }
    });
  }
  function processQueue() {
    // Process multiple tasks together so we can collate
    const mapOfFromRootsToTasks = collateTasks(taskQueue);
    taskQueue.length = 0;
    mapOfFromRootsToTasks.forEach((task, fromRoot) => processTask(fromRoot, task));
  }
  function updateAriaRelationship(fromNode, toNodes) {
    queueTask({
      fromNode,
      toNodes,
      mirrorOnly: true
    });
  }
  function queueTask(task) {
    taskQueue.push(task);
    queueMicrotaskWithPriority(/* priority */1, processQueue);
  }

  // We accept an Element, null, or an Array of Elements
  function massageToNodes(toNodes, relationship) {
    if (!Array.isArray(toNodes)) {
      toNodes = [toNodes];
    }
    toNodes = toNodes.filter(Boolean); // remove falsy values

    if (toNodes.length > 1 && SINGLE_TARGET_ARIA_RELATIONSHIPS.includes(relationship)) {
      // Certain ARIA relationships only support one target, not multiple. For those, we should warn
      // when someone tries to set multiple, and only take the first element.
      // See: https://w3c.github.io/aria/#ARIAMixin
      console.warn(`Multiple targets passed to aria relationship "${relationship}". ` + 'This API only accepts a single target. Ignoring elements beyond the first one.');
      toNodes = toNodes.slice(0, 1);
    }
    return toNodes;
  }
  function setAriaRelationship(fromNode, toNodes, relationship, options = {}) {
    const {
      track,
      signal
    } = options;
    toNodes = massageToNodes(toNodes, relationship);
    queueTask({
      fromNode,
      toNodes,
      relationship,
      track,
      signal
    });
  }

  // via https://wicg.github.io/aom/spec/aria-reflection.html#attribute-reflection
  // limited to just those that define an idref relationship

  function setAriaActiveDescendant(fromNode, toNodes, options) {
    setAriaRelationship(fromNode, toNodes, 'aria-activedescendant', options);
  }
  function setAriaControls(fromNode, toNodes, options) {
    setAriaRelationship(fromNode, toNodes, 'aria-controls', options);
  }
  function setAriaDescribedBy(fromNode, toNodes, options) {
    setAriaRelationship(fromNode, toNodes, 'aria-describedby', options);
  }
  function setAriaDetails(fromNode, toNodes, options) {
    setAriaRelationship(fromNode, toNodes, 'aria-details', options);
  }
  function setAriaErrorMessage(fromNode, toNodes, options) {
    setAriaRelationship(fromNode, toNodes, 'aria-errormessage', options);
  }
  function setAriaLabelledBy(fromNode, toNodes, options) {
    setAriaRelationship(fromNode, toNodes, 'aria-labelledby', options);
  }

  const SUPPORTED_ATTRIBUTES_ARRAY = [['aria-controls', {
    ariaReflection: 'ariaControlsElements',
    polyfill: setAriaControls
  }], ['aria-labelledby', {
    ariaReflection: 'ariaLabelledByElements',
    polyfill: setAriaLabelledBy
  }], ['aria-describedby', {
    ariaReflection: 'ariaDescribedByElements',
    polyfill: setAriaDescribedBy
  }], ['aria-errormessage', {
    ariaReflection: 'ariaErrorMessageElements',
    polyfill: setAriaErrorMessage
  }], ['aria-activedescendant', {
    ariaReflection: 'ariaActiveDescendantElement',
    polyfill: setAriaActiveDescendant
  }], ['aria-details', {
    ariaReflection: 'ariaDetailsElements',
    polyfill: setAriaDetails
  }]];

  /*
      Aria Reflection is used if supported by browser.
      If Aria Reflection is not available, fallback to polyfill
      Aria Reflection: https://wicg.github.io/aom/aria-reflection-explainer.html
      Polyfill: https://git.soma.salesforce.com/lwc/aria-element-reflection
  */
  const SUPPORTED_ATTRIBUTES_MAP = new Map(SUPPORTED_ATTRIBUTES_ARRAY);

  // Sniff for ARIA element reflection
  let BROWSER_SUPPORTS_ARIA_ELEMENT_REFLECTION;
  if (utilsPrivate.isCSR) {
    BROWSER_SUPPORTS_ARIA_ELEMENT_REFLECTION = [...SUPPORTED_ATTRIBUTES_MAP.values()].every(({
      ariaReflection
    }) => ariaReflection in Element.prototype);
  }
  function extractElements(root, ids) {
    if (typeof ids !== 'string' || ids === '') {
      return [];
    }
    // We must query the elements in the order of ids, so that
    // the content will be extracted in the correct order.
    return splitIds(ids).map(id => root.querySelector(`[id*="${id}"]`)).filter(el => !!el);
  }
  function splitIds(ids) {
    return ids ? (ids + '').trim().split(/\s+/) : [];
  }
  class AriaObserver {
    constructor(component) {
      this.component = component;
      this.template = component.template;
      this.isNativeShadow = utilsPrivate.isNativeComponent(component);
      this.state = {};
      this.liveIds = {};
      this.guid = utilsPrivate.guid();
      this.placeholderContainer = null;
      this.ariaReflectionMap = new Map();
      this.nodeMap = new Map();
    }
    connectLiveIdRef(refs, callback) {
      const selector = (refs + '').trim().split(/\s+/).map(ref => `[id*="${ref}"]`).join(',');
      let liveId;
      if (this.liveIds[refs]) {
        this.liveIds[refs].callbacks.push(callback);
      } else {
        liveId = {
          refs,
          selector,
          callbacks: [callback]
        };
        this.liveIds[refs] = liveId;
      }
    }

    /**
     * Connects the internal element and the external reference. It takes an options object with the following keys:
     * @param {String} attribute The name of the aria attribute. Supported values: `aria-labelledby`, `aria-describedby`, `aria-activedescendant` and `aria-controls`.
     * @param {String} targetSelector The selector to the internal element where the aria attribute should be attached.
     * @param {HTMLElement} targetNode The element where the aria attribute should be attached. If not provided, the `targetSelector` is used.
     * @param {String|Array[String]} relatedNodeIds ID(s) of the external element(s) to which the `targetNode` will be related. Passed as a space separated string `id1 id2 id3`. Combined with `relatedNodes` if both are present.
     * @param {Array[HTMLElement]} relatedNodes an Array of HTMLElement element(s) to which the `targetNode` will be related. Combined with `relatedNodeIds` if both are present.
     */
    connect({
      attribute,
      targetSelector,
      targetNode,
      relatedNodeIds,
      relatedNodes
    }) {
      this.state[attribute] = this.state[attribute] || {};
      const attrState = this.state[attribute];
      attrState.targetNode = targetNode;
      attrState.targetSelector = targetSelector;
      attrState.relatedNodes = (!Array.isArray(relatedNodes) ? [relatedNodes] : relatedNodes).filter(Boolean);
      attrState.relatedNodeIds = Array.isArray(relatedNodeIds) ? relatedNodeIds.join(' ') : relatedNodeIds;
      if (this.component.isConnected) {
        this.privateUpdate(attribute);
      }
    }

    /**
     * Connects the MutationObserver when in native shadow mode and connects the
     * appropriate aria attributes to the correct elements
     * @param {Boolean} isNativeShadow - This flag is used when a subcomponent
     * (like lightning-primitive-input-simple) is in native shadow mode and the parent
     * (lightning-input) that was passed on AriaObserver instantiation is not.
     */
    sync(isNativeShadow) {
      if (isNativeShadow != null) {
        this.isNativeShadow = isNativeShadow;
      }
      if (!this.component.isConnected) {
        throw new Error(`Invalid sync invocation. It can only be invoked during renderedCallback().`);
      }
      if (!this.root) {
        this.root = this.template && this.template.host ? this.template.host.getRootNode() : null;
      }
      this.privateUpdateLiveIds();
      for (const attrName in this.state) {
        if (Object.prototype.hasOwnProperty.call(this.state, attrName)) {
          this.privateUpdate(attrName);
        }
      }
    }
    get privateIsMoRequired() {
      return this.isNativeShadow || Object.keys(this.liveIds).length !== 0;
    }
    get root() {
      return this._root;
    }

    /**
     * Sets the specified root element and observes it. The root element should contain
     * Observes the root element. The root element should contain
     * the related node elements. By default, this is the template host's root node, but can be
     * overridden where required.
     */
    set root(root) {
      this._root = root;
      if (this._root && this.privateIsMoRequired) {
        this.privateCreateMutationObserver();
      }
    }
    privateUpdate(attrName) {
      const {
        targetSelector,
        targetNode = this.template.querySelector(targetSelector),
        relatedNodeIds,
        relatedNodes
      } = this.state[attrName];
      if (!targetNode) {
        return; // nothing to update
      }
      const attribute = SUPPORTED_ATTRIBUTES_MAP.get(attrName);
      if (!attribute) {
        throw new Error(`${attrName} is not supported by AriaObserver. Supported attributes: ${Array.from(SUPPORTED_ATTRIBUTES_MAP.keys())}`);
      }
      if (this.isNativeShadow) {
        const allRelatedNodes = [...relatedNodes, ...extractElements(this.root, relatedNodeIds)];
        if (BROWSER_SUPPORTS_ARIA_ELEMENT_REFLECTION) {
          // This browser supports native ARIA element reflection
          // Use Aria Reflection to manage relationships
          targetNode[attribute.ariaReflection] = relatedNodes;
        } else {
          attribute.polyfill(targetNode, allRelatedNodes, attrName);
        }
        // check related nodes for nested references and ensure
        // the div with reflected nodes is updated accordingly
        const rootNode = targetNode.getRootNode();
        for (let i = 0; i < allRelatedNodes.length; i++) {
          this.privateAddNestedReferences(rootNode, allRelatedNodes[i]);
        }
      } else {
        const attributeValue = [...splitIds(relatedNodeIds), ...relatedNodes.map(n => n.id)].join(' ');
        if (attributeValue) {
          targetNode.setAttribute(attrName, attributeValue);
        } else {
          targetNode.removeAttribute(attrName);
        }
      }
    }
    privateExtractCorrectElements(selector = '', elements) {
      // Example: 'foo' + '-1'
      const selectors = selector.split(/\s/g);
      const matchSelectors = `(${selectors.join('|')})`;
      const regex = new RegExp(`^${matchSelectors}(-[0-9]+)$`);
      return [...elements].filter(element => {
        return regex.test(element.id);
      });
    }

    /**
     * Observes the root element. The root element should contain
     * the related node elements. By default, this is the template host's root node, but can be
     * overridden where required.
     */
    privateCreateMutationObserver() {
      this.disconnect();
      this.mo = new MutationObserver(() => {
        if (!this.component.isConnected) {
          return; // do nothing when the template is not connected
        }
        this.sync();
      });
      this.mo.observe(this.root, {
        characterData: true,
        childList: true,
        subtree: true
      });
    }
    privateExtractIds(elements) {
      return elements.map(el => {
        return el.getAttribute('id');
      }).join(' ');
    }
    privateUpdateLiveIds() {
      const root = this.template && this.template.host ? this.template.host.getRootNode() : null;

      // if not connected do nothing
      if (!root) {
        return;
      }
      for (const liveId in this.liveIds) {
        if (Object.prototype.hasOwnProperty.call(this.liveIds, liveId)) {
          const thisId = this.liveIds[liveId];
          if (!thisId.elements || !thisId.elements.length) {
            const splitRefIds = splitIds(liveId);
            try {
              // element refs are cached
              const refElements = [...root.querySelectorAll(thisId.selector)];
              thisId.elements = refElements.sort((a, b) => {
                const idA = a.getAttribute('id')?.replace(/-[0-9]+$/g, '');
                const idB = b.getAttribute('id')?.replace(/-[0-9]+$/g, '');
                return splitRefIds.indexOf(idA) - splitRefIds.indexOf(idB);
              });
            } catch (error) {
              if (error instanceof DOMException) {
                console.warn(`lightning/ariaObserver could not find elements to connect live IDs due to an invalid id selector.\n\n${error}`);
              }
              return;
            }
          }
          const newThisId = this.privateExtractCorrectElements(thisId.refs, thisId.elements);
          const newIds = this.privateExtractIds(newThisId);

          // only fire callback if the value changed and the root node has been rendered
          if (newIds.length && newIds !== thisId.ids) {
            // thisId.callback(newIds);
            for (let i = 0; i < thisId.callbacks.length; i++) {
              thisId.callbacks[i](newIds);
            }
            thisId.ids = newIds;
          }
        }
      }
    }

    /**
     * Check nodes being reflected to see if there are any nested references
     * then finds the mirrored node and reflects it accordingly.
     * Maintains a map of nodes to their mirrors, and root nodes to the div
     * containing all reflected elements for increased efficiency.
     * @param {Node} rootNode - the root node where the mirrored nodes are attached
     * @param {Node} relatedNode - the node to check for nested references
     */
    privateAddNestedReferences(rootNode, relatedNode) {
      for (let i = 0; i < SUPPORTED_ATTRIBUTES_ARRAY.length; i++) {
        const [attrName, {
          polyfill
        }] = SUPPORTED_ATTRIBUTES_ARRAY[i];
        const attrValue = relatedNode.getAttribute(attrName);
        // if attrValue is truthy, another attribute needs reflecting
        if (attrValue) {
          // if we don't know the corresponding mirrored node, find it
          let mirroredNode = this.nodeMap.get(relatedNode);
          if (!mirroredNode) {
            let ariaReflection = this.ariaReflectionMap.get(rootNode);
            if (!ariaReflection) {
              ariaReflection = rootNode.querySelector('.aria-element-reflection-mirror');
              this.ariaReflectionMap.set(rootNode, ariaReflection);
            }
            if (ariaReflection) {
              mirroredNode = ariaReflection.querySelector(`[${attrName}='${attrValue}']`);
              this.nodeMap.set(relatedNode, mirroredNode);
            }
          }
          if (mirroredNode) {
            const nestedReferenceNodes = extractElements(this.root, attrValue);
            polyfill(mirroredNode, nestedReferenceNodes, attrName);
          }
        }
      }
    }
    disconnect() {
      // MutationObservers must be disconnected manually when using @lwc/synthetic-shadow
      // https://lwc.dev/guide/composition#:~:text=memory%20leak
      if (this.mo) {
        this.mo.disconnect();
        this.mo = undefined;
      }
    }
  }
  const __lwc_component_class_internal = lwc.registerComponent(AriaObserver, {
    tmpl: _tmpl,
    sel: "lightning-aria-observer",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/utils', ['exports'], (function (exports) {

    function classNamesHash(hash, classes) {
      if (typeof classes === 'string') {
        const array = classes.trim().split(/\s+/);
        for (let i = 0, {
            length
          } = array; i < length; i += 1) {
          hash[array[i]] = true;
        }
        return hash;
      }
      return Object.assign(hash, classes);
    }
    const proto = Object.defineProperties(Object.create(null), {
      add: {
        value(className) {
          return classNamesHash(this, className);
        }
      },
      invert: {
        value() {
          const keys = Object.keys(this);
          for (let i = 0, {
              length
            } = keys; i < length; i += 1) {
            const key = keys[i];
            this[key] = !this[key];
          }
          return this;
        }
      },
      toString: {
        value() {
          let string = '';
          const keys = Object.keys(this);
          for (let i = 0, {
              length
            } = keys; i < length; i += 1) {
            const key = keys[i];
            if (this[key]) {
              string += (string.length ? ' ' : '') + key;
            }
          }
          return string;
        }
      }
    });
    function classSet(config) {
      return classNamesHash(Object.create(proto), config);
    }

    // Matches lower cased tag names of standard inputable elements as well as
    // custom elements whose tag names contain inputable names.
    const inputableNode = /input|select|textarea|button|object/;
    function visible(element) {
      // Check computed style visibility first because it doesn't cause a layout
      // reflow/recalculation.
      if (window.getComputedStyle(element).visibility === 'hidden') {
        return false;
      }
      // Perform the performance heavier `getBoundingClientRect()` last because
      // it causes a page layout reflow/recalculation.
      const {
        width,
        height
      } = element.getBoundingClientRect();
      return width > 0 || height > 0;
    }
    function focusable(element) {
      const tagName = element.tagName.toLowerCase();
      if (tagName === 'a' && element.href || !element.disabled && inputableNode.test(tagName)) {
        return visible(element);
      }
      return false;
    }
    function tabbable(element) {
      // Perform the "isDataActionable" first as `focusable()` is potentially
      // performance heavy.
      return element.dataset.navigation === 'enable' || element.tabIndex >= 0 && focusable(element);
    }
    function queryFocusable(element) {
      const childElements = element.querySelectorAll('*');
      const focusables = [];
      for (let i = 0, {
          length
        } = childElements; i < length; i += 1) {
        const child = childElements[i];
        if (tabbable(child)) {
          focusables.push(child);
        }
      }
      return focusables;
    }

    /**
     * Takes label strings with placeholder params (`{0}`) and updates the label with given `args`
     * @param {string} str - any label string requiring injections of other strings/params (e.g., 'foo {0}')
     * @param  {string|array} arguments - string(s) to be injected into the `string` param
     * @returns {string} fully replaced string, e.g., '{0} is a {1}' -> 'Hal Jordan is a Green Lantern'
     */

    function formatLabel(str) {
      const args = Array.prototype.slice.call(arguments, 1);
      let replacements = args;
      if (Array.isArray(args[0])) {
        [replacements] = args;
      }
      return str.replace(/{(\d+)}/g, (match, i) => {
        const replacement = replacements[i];
        return replacement !== null && replacement !== undefined ? replacement : '';
      });
    }

    exports.classSet = classSet;
    exports.formatLabel = formatLabel;
    exports.queryFocusable = queryFocusable;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/primitiveButton', ['exports', 'lwc', 'lightning/shadowBaseClassPrivate', 'lightning/utilsPrivate', 'lightning/utils', 'lightning/ariaObserver'], (function (exports, lwc, LightningShadowBaseClass, utilsPrivate, utils, AriaObserver) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);
    var AriaObserver__default = /*#__PURE__*/_interopDefaultCompat(AriaObserver);

    const stc0 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      return stc0;
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-50rp014c9i6";
    tmpl.legacyStylesheetToken = "lightning-primitiveButton_primitiveButton";
    lwc.freezeTemplate(tmpl);

    const BUTTON = 'button';
    const ROLE = 'role';

    /**
     * Primitive for button, buttonIcon and buttonIconStateful
     * We try to have those components to set their aria attributes on their template as much as possible
     * to avoid setting those manually, however there are a few instances
     * in which manual setting is still required:
     *
     *  - aria-disabled: Since it dependes on the disabled state, which is controlled by primitive button.
     *  - aria-controls: Abstracts the logic of setting the id-reference on the host element
     *  - aria-cetails: Role that depeneds on AriaObserver for native shadow.
     *  - aria-describedBy: Role that depeneds on AriaObserver for native shadow.
     *  - aria-flowTo: Abstracts the logic of setting the id-reference on the host element.
     *  - aria-labelledby: Role that depeneds on AriaObserver for native shadow.
     *  - aria-owns: Abstracts the logic of setting the id-reference on the host element.
     */
    class LightningPrimitiveButton extends LightningShadowBaseClass__default.default {
      /**** COMPONENT PUBLIC APIS ****/
      /**
       * Specifies whether this button should be displayed in a disabled state.
       * Disabled buttons can't be clicked. This value defaults to false.
       *
       * @type {boolean}
       * @default false
       */
      set disabled(value) {
        this.originalDisabledValue = value;
        this.state.disabled = utilsPrivate.normalizeBoolean(value);
      }
      get disabled() {
        return this.state.disabled;
      }

      /**
       * Specifies a shortcut key to activate or focus an element.
       *
       * @type {string}
       */

      /**
       * Specifies the ID or list of IDs of the element or elements that
       * contain visible descriptive text to describe the button.
       */
      set ariaLabelledBy(value) {
        this.originalAriaLabelledBy = value;
        this.ariaObserver.connect({
          targetSelector: 'button',
          attribute: 'aria-labelledby',
          relatedNodeIds: value
        });
      }
      get ariaLabelledBy() {
        return this.originalAriaLabelledBy;
      }

      /**
       * A space-separated list of element IDs that provide descriptive labels for the button.
       *
       * @type {string}
       */
      set ariaDescribedBy(value) {
        this.originalAriaDescribedBy = value;
        this.ariaObserver.connect({
          targetSelector: 'button',
          attribute: 'aria-describedby',
          relatedNodeIds: value
        });
      }
      get ariaDescribedBy() {
        return this.originalAriaDescribedBy;
      }

      /**
       * A space-separated list of element IDs whose presence or content is controlled by this button.
       *
       * @type {string}
       */
      set ariaControls(value) {
        this.originalAriaControls = value;
        this.setAttribute('aria-controls', value);
        this.setHostRoleAttribute(BUTTON);
      }
      get ariaControls() {
        return this.originalAriaControls;
      }

      /**
       * A space-separated list of element IDs whose presence or content is controlled by this button.
       *
       * @type {string}
       */
      set ariaOwns(value) {
        this.originalAriaOwns = value;
        this.setAttribute('aria-owns', value);
        this.setHostRoleAttribute(BUTTON);
      }
      get ariaOwns() {
        return this.originalAriaOwns;
      }

      /**
       * A space-separated list of element IDs whose presence or content is controlled by this button.
       *
       * @type {string}
       */
      set ariaDetails(value) {
        this.originalAriaDetails = value;
        this.setAttribute('aria-details', value);
        this.setHostRoleAttribute(BUTTON);
      }
      get ariaDetails() {
        return this.originalAriaDetails;
      }

      /**
       * A space-separated list of element IDs whose presence or content is controlled by this button.
       *
       * @type {string}
       */
      set ariaFlowTo(value) {
        this.originalAriaFlowTo = value;
        this.setAttribute('aria-flowto', value);
        this.setHostRoleAttribute(BUTTON);
      }
      get ariaFlowTo() {
        return this.originalAriaFlowTo;
      }

      /**
       * Indicates whether an element that the button controls is expanded or collapsed.
       * Valid values are 'true' or 'false'. The default value is undefined.
       *
       * @type {string}
       * @default undefined
       */
      get ariaExpanded() {
        return this.originalAriaExpanded;
      }
      set ariaExpanded(value) {
        this.originalAriaExpanded = value;
        this.state.ariaExpanded = utilsPrivate.normalizeString(value, {
          fallbackValue: null,
          validValues: ['true', 'false']
        });
      }
      get computedAriaExpanded() {
        return this.state.ariaExpanded;
      }

      /**
       * Indicates the current "pressed" state of toggle buttons.
       * Valid values are 'true' or 'false'. The default value is undefined.
       *
       * @type {string}
       * @default undefined
       */
      set ariaPressed(value) {
        this.originalAriaPressed = value;
        this.state.ariaPressed = utilsPrivate.normalizeString(value, {
          fallbackValue: null,
          validValues: ['true', 'false']
        });
      }
      get ariaPressed() {
        return this.originalAriaPressed;
      }
      get computedAriaPressed() {
        return this.state.ariaPressed;
      }

      /**
       * Indicates whether an element that the button controls is expanded or collapsed.
       * Valid values are 'true' or 'false'. The default value is undefined.
       *
       * @type {string}
       * @default undefined
       */
      set ariaHidden(value) {
        this.originalAriaHidden = value;
        this.state.ariaHidden = utilsPrivate.normalizeString(value, {
          fallbackValue: null,
          validValues: ['true', 'false']
        });
      }
      get ariaHidden() {
        return this.originalAriaHidden;
      }
      get computedAriaHidden() {
        return this.state.ariaHidden;
      }

      /**
       * Indicates the element that represents the current item within a container or set of related elements.
       * For example:
       *   - A page token used to indicate a link within a set of pagination links, where the link is visually styled to
       *   represent the currently-displayed page.
       *   - A step token used to indicate a link within a step indicator for a step-based process, where
       *   the link is visually styled to represent the current step.
       *   - A location token used to indicate the image that is visually highlighted as the current component
       *   of a flow chart.
       *   - A date token used to indicate the current date within a calendar.
       *   - A time token used to indicate the current time within a timetable.
       *
       * @type {string}
       * @default undefined
       */

      /**
       * Indicates that the button has an interactive popup element.
       * Valid values are 'true', 'dialog', 'menu', 'listbox', 'tree', and 'grid' based on ARIA 1.1 specifications.
       * The default value is undefined.
       *
       * @type {string}
       * @default undefined
       */
      set ariaHasPopup(value) {
        this.originalAriaHasPopup = value;
        this.state.ariaHasPopup = utilsPrivate.normalizeString(value, {
          fallbackValue: null,
          validValues: ['true', 'dialog', 'menu', 'listbox', 'tree', 'grid']
        });
      }
      get ariaHasPopup() {
        return this.originalAriaHasPopup;
      }
      get computedAriaHasPopup() {
        return this.state.ariaHasPopup;
      }

      /**
       * Indicates that the button has an interactive popup element.
       * Valid values are 'true', 'dialog', 'menu', 'listbox', 'tree', and 'grid' based on ARIA 1.1 specifications.
       * The default value is undefined.
       *
       * @type {string}
       * @default undefined
       */
      set ariaRelevant(value) {
        this.originalAriaRelevant = value;
        this.state.ariaRelevant = utilsPrivate.normalizeString(value, {
          fallbackValue: null,
          validValues: ['additions', 'removals', 'text', 'all']
        });
      }
      get ariaRelevant() {
        return this.originalAriaRelevant;
      }
      get computedAriaRelevant() {
        return this.state.ariaRelevant;
      }

      /**
       * Indicates that the button can be updated when it doesn't have focus.
       * Valid values are 'polite', 'assertive', or 'off'. The polite value causes assistive
       * technologies to notify users of updates at a low priority, generally without interrupting.
       * The assertive value causes assistive technologies to notify users immediately,
       * potentially clearing queued speech updates.
       *
       * @type {string}
       */
      set ariaLive(value) {
        this.originalAriaLive = value;
        this.state.ariaLive = utilsPrivate.normalizeString(value, {
          fallbackValue: null,
          validValues: ['polite', 'assertive', 'off']
        });
      }
      get ariaLive() {
        return this.originalAriaLive;
      }
      get computedAriaLive() {
        return this.state.ariaLive;
      }

      /**
       * Indicates whether assistive technologies present all, or only parts of,
       * the changed region. Valid values are 'true' or 'false'.
       *
       * @type {string}
       */
      set ariaAtomic(value) {
        this.originalAriaAtomic = value;
        this.state.ariaAtomic = utilsPrivate.normalizeString(value, {
          fallbackValue: null,
          validValues: ['true', 'false']
        });
      }
      get ariaAtomic() {
        return this.originalAriaAtomic;
      }
      get computedAriaAtomic() {
        return this.state.ariaAtomic;
      }

      /**
       * Indicates an element is being modified and that assistive technologies MAY want to wait
       * until the modifications are complete before exposing them to the user.
       * Refer to W3C aria-busy for more
       *
       * @type {string}
       */
      set ariaBusy(value) {
        this.originalAriaBusy = value;
        this.state.ariaBusy = utilsPrivate.normalizeString(value, {
          fallbackValue: null,
          validValues: ['true', 'false']
        });
      }
      get ariaBusy() {
        return this.originalAriaBusy;
      }
      get computedAriaBusy() {
        return this.state.ariaBusy;
      }
      get computedButtonClass() {
        const classes = utils.classSet('slds-button');
        classes.add(utilsPrivate.buttonGroupOrderClass(this.groupOrder));
        return classes.toString();
      }

      /**
       * Sets focus on the element.
       */
      focus() {}

      /**
       * Reserved for internal use only.
       * Describes the order of this element (first, middle or last) inside lightning-button-group.
       * @type {string}
       */

      /**** COMPONENT LIFECYCLE EVENTS ****/

      constructor() {
        super();
        /**** COMPONENT PRIVATE PROPERTIES ****/
        this._initialized = false;
        this.state = {
          ariaAtomic: null,
          ariaBusy: null,
          ariaControls: null,
          ariaDetails: null,
          ariaDescribedBy: null,
          ariaExpanded: null,
          ariaFlowTo: null,
          ariaHasPopup: null,
          ariaHidden: null,
          ariaLabelledBy: null,
          ariaLive: null,
          ariaOwns: null,
          ariaPressed: null,
          ariaRelevant: null,
          disabled: false
        };
        this.originalAriaAtomic = void 0;
        this.originalAriaBusy = void 0;
        this.originalAriaControls = void 0;
        this.originalAriaDetails = void 0;
        this.originalAriaDescribedBy = void 0;
        this.originalAriaExpanded = void 0;
        this.originalAriaFlowTo = void 0;
        this.originalAriaHasPopup = void 0;
        this.originalAriaHidden = void 0;
        this.originalAriaLabelledBy = void 0;
        this.originalAriaLive = void 0;
        this.originalAriaOwns = void 0;
        this.originalAriaPressed = void 0;
        this.originalAriaRelevant = void 0;
        this.originalDisabledValue = void 0;
        this.accessKey = void 0;
        /**
         * Displays tooltip text when the mouse cursor moves over the element.
         *
         * @type {string}
         */
        this.title = void 0;
        /**
         * Label describing the button to assistive technologies.
         *
         * @type {string}
         */
        this.ariaLabel = void 0;
        this.ariaCurrent = void 0;
        /**
         * Indicates keyboard shortcuts that an author has implemented to activate or give focus to an element.
         *
         * @type {string}
         * @default undefined
         */
        this.ariaKeyShortcuts = void 0;
        this.groupOrder = '';
        this.ariaObserver = new AriaObserver__default.default(this);
        // Workaround for an IE11 bug where click handlers on button ancestors
        // receive the click event even if the button element has the `disabled`
        // attribute set.
        if (utilsPrivate.isIE11 && utilsPrivate.isCSR) {
          this.template.addEventListener('click', event => {
            if (this.disabled) {
              event.stopImmediatePropagation();
            }
          });
        }
      }
      connectedCallback() {
        super.connectedCallback();
        if (!this.ariaObserver) {
          this.ariaObserver = new AriaObserver__default.default(this);
        }
      }
      renderedCallback() {
        if (this.isConnected) {
          this.ariaObserver.sync();
        }
      }
      disconnectedCallback() {
        if (this.ariaObserver) {
          this.ariaObserver.disconnect();
          this.ariaObserver = undefined;
        }
      }

      /**
       * Utility function to set aria roles on the host element.
       * This is used mainly for native-shadow use cases for aria attributes that
       * depenend on ID references.
       *
       * If the role attribute is present we will respect that, otherwise it will be set to
       * an specific role, in this case button.
       *
       * @type {string}
       * @default undefined
       */
      setHostRoleAttribute(value) {
        let ariaRoleValue = this.getAttribute(ROLE) || value;
        this.setAttribute(ROLE, ariaRoleValue);
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(LightningPrimitiveButton, {
      publicProps: {
        disabled: {
          config: 3
        },
        accessKey: {
          config: 0
        },
        title: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        ariaLabelledBy: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        ariaControls: {
          config: 3
        },
        ariaOwns: {
          config: 3
        },
        ariaDetails: {
          config: 3
        },
        ariaFlowTo: {
          config: 3
        },
        ariaExpanded: {
          config: 3
        },
        ariaPressed: {
          config: 3
        },
        ariaHidden: {
          config: 3
        },
        ariaCurrent: {
          config: 0
        },
        ariaKeyShortcuts: {
          config: 0
        },
        ariaHasPopup: {
          config: 3
        },
        ariaRelevant: {
          config: 3
        },
        ariaLive: {
          config: 3
        },
        ariaAtomic: {
          config: 3
        },
        ariaBusy: {
          config: 3
        },
        groupOrder: {
          config: 0
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      },
      fields: ["_initialized", "originalAriaAtomic", "originalAriaBusy", "originalAriaControls", "originalAriaDetails", "originalAriaDescribedBy", "originalAriaExpanded", "originalAriaFlowTo", "originalAriaHasPopup", "originalAriaHidden", "originalAriaLabelledBy", "originalAriaLive", "originalAriaOwns", "originalAriaPressed", "originalAriaRelevant", "originalDisabledValue"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(LightningPrimitiveButton, {
      tmpl: _tmpl,
      sel: "lightning-primitive-button",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/primitiveBubble', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/shadowBaseClassPrivate', 'lightning/utils'], (function (exports, lwc, stylesheet0$1, LightningShadowBaseClass, utils) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

    function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      return ".fix-popover_tooltip_alignment" + shadowSelector + " {min-width: inherit;}";
      /*LWC compiler v7.1.5*/
    }
    var stylesheet0 = [stylesheet$1];

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='overlay']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='overlay']")), shadowSelector, " {--slds-c-tooltip-sizing-width-max: var(--slds-c-tooltip-sizing-max-width);--slds-c-tooltip-position-zindex: var(--slds-c-popover-position-zindex);background-color: var(--slds-c-tooltip-color-background, #032d60);color: var(--slds-c-tooltip-text-color, #fff);border-radius: 0.25rem;border-width: 0;box-shadow: 0 2px 3px 0 rgb(0 0 0 / 16%);padding-inline-start: 0.75rem;padding-inline-end: 0.75rem;padding-block-start: 0.5rem;padding-block-end: 0.5rem;z-index: var(--slds-c-tooltip-position-zindex);font-size: var(--slds-c-tooltip-font-size, 0.75rem);max-width: var(--slds-c-tooltip-sizing-width-max, 20rem);position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='overlay']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='overlay']")), shadowSelector, "::after {box-shadow: -1px -1px 0 0 rgba(0, 0, 0, 16%);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, "::after {left: 1.5rem;top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, "::after {left: auto;right: 1.5rem;top: -0.5rem;margin-right: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom")), shadowSelector, "::after {box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 16%);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, "::after {box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 16%);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, "::after {left: 1.5rem;top: 100%;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, "::after {box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 16%);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, "::after {left: auto;right: 1.5rem;top: 100%;margin-top: -0.5rem;margin-right: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left")), shadowSelector, "::after {box-shadow: -1px 1px 2px 0 rgba(0, 0, 0, 16%);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, "::after {box-shadow: -1px 1px 2px 0 rgba(0, 0, 0, 16%);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, "::after {top: 1.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::before {margin-bottom: -1px;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::after {box-shadow: -1px 2px 3px 0 rgba(0, 0, 0, 16%);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::after {top: auto;bottom: 1rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right")), shadowSelector, "::after {box-shadow: 1px -1px 2px 0 rgba(0, 0, 0, 16%);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, "::after {box-shadow: 1px -1px 2px 0 rgba(0, 0, 0, 16%);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, "::after {top: 1.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::before {margin-bottom: -1px;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::after {box-shadow: 2px -1px 3px 0 rgba(0, 0, 0, 16%);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::after {top: auto;bottom: 1rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, " {border-radius: 0.125rem 0.25rem 0.25rem 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, "::after {left: 0.75rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, " {border-radius: 0.25rem 0.25rem 0.25rem 0.125rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, "::after {left: 0.75rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, " {border-radius: 0.25rem 0.125rem 0.25rem 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, "::after {right: 0.75rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, " {border-radius: 0.25rem 0.25rem 0.125rem 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, "::after {right: 0.75rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, " {border-radius: 0.125rem 0.25rem 0.25rem 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, "::after {top: 0.75rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, " {border-radius: 0.25rem 0.125rem 0.25rem 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, "::after {top: 0.75rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, " {border-radius: 0.25rem 0.25rem 0.25rem 0.125rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::after {bottom: 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, " {border-radius: 0.25rem 0.25rem 0.125rem 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::after {bottom: 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-rise-from-ground" : hostSelector + "[data-render-mode=\"shadow\"] .slds-rise-from-ground")), shadowSelector, " {visibility: visible;opacity: 1;transform: translate(0%, 0%);transition: opacity 0.1s linear, visibility 0.1s linear, transform 0.1s linear;will-change: transform;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-fall-into-ground" : hostSelector + "[data-render-mode=\"shadow\"] .slds-fall-into-ground")), shadowSelector, " {visibility: hidden;opacity: 0;transform: translate(0%, 0%);transition: opacity 0.1s linear, visibility 0.1s linear, transform 0.1s linear;will-change: transform;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-slide-from-bottom-to-top" : hostSelector + "[data-render-mode=\"shadow\"] .slds-slide-from-bottom-to-top")), shadowSelector, " {transform: translateY(10%);will-change: transform;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-slide-from-top-to-bottom" : hostSelector + "[data-render-mode=\"shadow\"] .slds-slide-from-top-to-bottom")), shadowSelector, " {transform: translateY(-10%);will-change: transform;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-slide-from-right-to-left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-slide-from-right-to-left")), shadowSelector, " {transform: translateX(5%);will-change: transform;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-slide-from-left-to-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-slide-from-left-to-right")), shadowSelector, " {transform: translateX(-5%);will-change: transform;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-hide" : hostSelector + "[data-render-mode=\"shadow\"] .slds-hide")), shadowSelector, " {display: none;}"].join('');
      /*LWC compiler v7.1.5*/
    }
    var stylesheet1$1 = [stylesheet];

    var stylesheet1 = [stylesheet0__default.default, stylesheet1$1];

    var _implicitStylesheets = [stylesheet0, stylesheet1];

    const stc0 = {
      "part": "overlay"
    };
    const stc1 = {
      "slds-popover__body": true
    };
    const stc2 = {
      lwc: {
        dom: "manual"
      }
    };
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {ncls: api_normalize_class_name, b: api_bind, h: api_element} = $api;
      const {_m0, _m1} = $ctx;
      return [api_element("div", {
        className: api_normalize_class_name($cmp.computedPopoverClass),
        attrs: stc0,
        key: 0,
        on: {
          "transitionend": _m0 || ($ctx._m0 = api_bind($cmp.handleTransitionEnd))
        }
      }, [api_element("div", {
        classMap: stc1,
        context: stc2,
        key: 1,
        on: {
          "mouseleave": _m1 || ($ctx._m1 = api_bind($cmp.handleMouseLeave))
        }
      })])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-5fnnbdvmu3k";
    tmpl.legacyStylesheetToken = "lightning-primitiveBubble_primitiveBubble";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    const DEFAULT_ALIGN = {
      horizontal: 'left',
      vertical: 'bottom'
    };

    // Set to px units for easier calculation
    const POPOVER_MIN_HEIGHT = 32;
    const DEFAULT_INVISIBLE_DIV_STYLES = {
      height: '1rem',
      position: 'absolute',
      left: '0',
      marginLeft: '0'
    };
    class LightningPrimitiveBubble extends LightningShadowBaseClass__default.default {
      constructor(...args) {
        super(...args);
        this.state = {
          // tracks the `visibility` of the tooltip
          visible: false,
          // tracks the `display` of the tooltip
          hidden: true,
          contentId: ''
        };
        /*
            Tooltip manages the visibility state of the PrimitiveBubble element
            to ensure there are no differences beteween TooltipLibrary._visible and
            LightningPrimitiveBubble.state.visible. See @W-12512833
        */
        this.disableVisibilityChangeOnLeave = void 0;
      }
      get contentId() {
        return this.state.contentId;
      }
      set contentId(value) {
        this.state.contentId = value;
        if (this.state.inDOM) {
          this.divEl.setAttribute('id', this.state.contentId);
        }
      }
      connectedCallback() {
        super.connectedCallback();
        this.setAttribute('role', 'tooltip');
        this.setAttribute('aria-hidden', true);
        // W-15856720 - slds-scope class is added to fix styling issue with lightning-out
        this.setAttribute('class', 'slds-scope');
        this.state.inDOM = true;
      }
      disconnectedCallback() {
        this.state.inDOM = false;
      }
      renderedCallback() {
        // set content manually once rendered
        // - this is required to avoid the content update being in the wrong 'tick'
        this.setContentManually();
        this.setIdManually();
        this.createInvisibleDivManually();
      }
      set content(value) {
        this.state.content = value;
        if (this.state.inDOM) {
          this.setContentManually();
        }
      }
      get content() {
        return this.state.content || '';
      }
      get align() {
        return this.state.align || DEFAULT_ALIGN;
      }
      set align(value) {
        this.state.align = value;
      }
      get visible() {
        return this.state.visible;
      }
      set visible(value) {
        this.state.visible = value;
        if (this.state.visible) {
          // Show the tooltip before css animation
          this.state.hidden = false;
        }
        if (this.state.hidden) {
          this.setAttribute('aria-hidden', true);
        } else {
          this.removeAttribute('aria-hidden');
        }
      }
      handleTransitionEnd() {
        // Hide the tooltip after css animation
        if (!this.state.visible) {
          this.state.hidden = true;
          this.setAttribute('aria-hidden', true);
        }
      }
      setIdManually() {
        this.setAttribute('id', this.state.contentId);
      }

      // manually set the content value
      setContentManually() {
        /* manipulate DOM directly */
        this.template.querySelector('.slds-popover__body').textContent = this.state.content;
      }

      // manually create <div>, add positional styling, and append as child to bubble
      createInvisibleDivManually() {
        if (this.state.visible) {
          // for native shadow, we need to get styles from popover parent and append
          // to popover body so that it is added/removed from DOM depending on tooltip visibility
          const popoverParent = this.template.querySelector('.slds-popover');
          const popoverBody = this.template.querySelector('.slds-popover__body');
          const invisibleDiv = document.createElement('div');
          const {
            vertical
          } = this.align;
          let computedStyle = null;
          if (window && popoverParent && popoverBody) {
            computedStyle = window.getComputedStyle(popoverParent);
            invisibleDiv.style.width = computedStyle.getPropertyValue('width');

            /*
                Position the <div> based on vertical alignment of tooltip.
                When vertically aligned to the bottom (nubbin below tooltip), position the <div> to
                the max of the popover min-height or the popover offset height. This is necessary so that
                it always positions right below the popover, so that changes to line-height or other
                distance related properties do not affect the positioning.
            */
            if (vertical === 'bottom') {
              invisibleDiv.style.top = Math.max(POPOVER_MIN_HEIGHT, popoverParent.offsetHeight) + 'px';
            } else {
              invisibleDiv.style.top = '-1rem';
            }
          }
          invisibleDiv.style.height = DEFAULT_INVISIBLE_DIV_STYLES.height;
          invisibleDiv.style.position = DEFAULT_INVISIBLE_DIV_STYLES.position;
          invisibleDiv.style.left = DEFAULT_INVISIBLE_DIV_STYLES.left;
          invisibleDiv.style.marginLeft = DEFAULT_INVISIBLE_DIV_STYLES.marginLeft;
          popoverBody.appendChild(invisibleDiv);
        }
      }

      // compute class value for this bubble
      get computedPopoverClass() {
        const classes = utils.classSet('slds-popover').add('slds-popover_tooltip').add('fix-popover_tooltip_alignment'); // fix for W-11677142

        // show or hide bubble
        classes.add({
          'slds-rise-from-ground': this.visible,
          'slds-fall-into-ground': !this.visible,
          'slds-hide': this.state.hidden
        });

        // apply the proper nubbin CSS class
        const {
          horizontal,
          vertical
        } = this.align;
        classes.add({
          'slds-nubbin_top-left': horizontal === 'left' && vertical === 'top',
          'slds-nubbin_top-right': horizontal === 'right' && vertical === 'top',
          'slds-nubbin_bottom-left': horizontal === 'left' && vertical === 'bottom',
          'slds-nubbin_bottom-right': horizontal === 'right' && vertical === 'bottom',
          'slds-nubbin_bottom': horizontal === 'center' && vertical === 'bottom',
          'slds-nubbin_top': horizontal === 'center' && vertical === 'top',
          'slds-nubbin_left': horizontal === 'left' && vertical === 'center',
          'slds-nubbin_right': horizontal === 'right' && vertical === 'center'
        });
        return classes.toString();
      }
      handleMouseLeave() {
        /**
         * This causes a number of issues when primitive-bubble is managed through tooltipLibrary, due to the fact
         * that changing the visibility inside the primitive bubble creates a mismatch with the tooltipLibrary Tooltip._visible state.
         * This contributes to a number of problems and can result in the tooltip being made visible again in unwanted situations.
         * (W-12512833). Remove this completely if no longer required by other consumers.
         */
        if (!this.disableVisibilityChangeOnLeave) {
          this.visible = false;
        }
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(LightningPrimitiveBubble, {
      publicProps: {
        disableVisibilityChangeOnLeave: {
          config: 0
        },
        contentId: {
          config: 3
        },
        content: {
          config: 3
        },
        align: {
          config: 3
        },
        visible: {
          config: 3
        }
      },
      track: {
        state: 1
      }
    });
    const __lwc_component_class_internal = lwc.registerComponent(LightningPrimitiveBubble, {
      tmpl: _tmpl,
      sel: "lightning-primitive-bubble",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/i18n/dir', [], function() { return "ltr"; });
(function() { LWR.define('lightning/positionLibrary', ['exports', 'lightning/utilsPrivate', '@salesforce/i18n/dir'], (function (exports, utilsPrivate, dir) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var dir__default = /*#__PURE__*/_interopDefaultCompat(dir);

    const POSITION_ATTR_NAME = 'data-position-id';
    class BrowserWindow {
      get window() {
        if (!this._window) {
          this._window = window;

          // JTEST/Ingtegration: getComputedStyle may be null
          if (!this.window.getComputedStyle) {
            this.window.getComputedStyle = node => {
              return node.style;
            };
          }
        }
        return this._window;
      }
      mockWindow(value) {
        // For test, allow mock window.
        this._window = value;
      }
      get documentElement() {
        utilsPrivate.assert(this.window.document, 'Missing window.document');
        return this.window.document.documentElement;
      }
      get MutationObserver() {
        return this.window.MutationObserver;
      }
      isWindow(element) {
        return element && element.toString() === '[object Window]';
      }
    }
    const WindowManager = new BrowserWindow();
    function isShadowRoot(node) {
      return node && node.nodeType === 11;
    }
    function enumerateParent(elem, stopEl, checker) {
      // document.body is not necessarily a body tag, because of the (very rare)
      // case of a frameset.
      if (!elem || elem === stopEl || elem === document.body) {
        return null;
      }
      // if overflow is auto and overflow-y is also auto,
      // however in firefox the opposite is not true
      try {
        // getComputedStyle throws an exception
        // if elem is not an element
        // (can happen during unrender)
        const computedStyle = WindowManager.window.getComputedStyle(elem);
        if (!computedStyle) {
          return null;
        }
        if (checker(computedStyle)) {
          return elem;
        }
        return enumerateParent(isShadowRoot(elem.parentNode) ? elem.parentNode.host : elem.parentNode, stopEl, checker);
      } catch (e) {
        return null;
      }
    }
    function getScrollableParent(elem, stopEl) {
      return enumerateParent(elem, stopEl, computedStyle => {
        const overflow = computedStyle['overflow-y'];
        return overflow === 'auto' || overflow === 'scroll';
      });
    }
    function getScrollableParentFromEventPath(eventPath) {
      var computedStyle;
      var overflow;
      for (let i = 0; i < eventPath.length; i++) {
        let element = eventPath[i];
        if (element instanceof HTMLElement) {
          computedStyle = WindowManager.window.getComputedStyle(element);
          overflow = computedStyle['overflow-y'];
          if (overflow === 'auto' || overflow === 'scroll') {
            return element;
          }
        }
      }
      return null;
    }
    function queryOverflowHiddenParent(elem, stopEl) {
      return enumerateParent(elem, stopEl, computedStyle => {
        return computedStyle['overflow-x'] === 'hidden' || computedStyle['overflow-y'] === 'hidden';
      });
    }
    function isInDom(el) {
      if (el === WindowManager.window) {
        return true;
      }
      if (!isShadowRoot(el.parentNode) && el.parentNode && el.parentNode.tagName && el.parentNode.tagName.toUpperCase() === 'BODY') {
        return true;
      }
      if (isShadowRoot(el.parentNode) && el.parentNode.host) {
        return isInDom(el.parentNode.host);
      }
      if (el.parentNode) {
        return isInDom(el.parentNode);
      }
      return false;
    }
    function isDomNode(obj) {
      return obj.nodeType && (obj.nodeType === 1 || obj.nodeType === 11);
    }
    function timeout(time) {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          resolve();
        }, time);
      });
    }
    function getPositionTarget(element) {
      return element.tagName === 'TEXTAREA' ? isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode : element;
    }
    let lastId = 1000000;
    function generateUniqueSelector() {
      return `lgcp-${lastId++}`;
    }
    function normalizeElement(element) {
      const selector = generateUniqueSelector();
      element.setAttribute(POSITION_ATTR_NAME, selector);
      element =
      // eslint-disable-next-line @lwc/lwc/no-document-query
      document.querySelector(`[${POSITION_ATTR_NAME}="${selector}"]`) || element;
      return element;
    }
    function normalizePosition(element, overlay, nextIndex, target, alignWidth) {
      // Set element position to fixed
      // 1. element is inside overlay
      // or 2. When element isn't align with target's width, and target's parent has overflow-x:hidden setting.
      const isFixed = overlay.isInside || !alignWidth && queryOverflowHiddenParent(target, WindowManager.window);
      element.style.position = isFixed ? 'fixed' : 'absolute';
      element.style.zIndex = nextIndex || 0;

      // W-8042285 For RTL, left is positive value instead of negative.
      element.style.left = dir__default.default === 'rtl' ? '99999px' : '-9999px'; // Avoid flicker
      // we always position from the left, but in RTL mode Omakase swaps left and right properties.
      // To always allow positioning from the left we set right to auto so position library can do its work.
      element.style.right = 'auto';
      element.style.top = '0px'; // Avoid flicker

      return {
        element,
        overlay
      };
    }
    function requestAnimationFrameAsPromise() {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => resolve());
      });
    }
    function isPx(value) {
      return value.slice(-2) === 'px';
    }
    function pxToFloat(value) {
      return value && isPx(value) ? parseFloat(value) : 0;
    }

    const Direction = {
      Center: 'center',
      Middle: 'middle',
      Right: 'right',
      Left: 'left',
      Bottom: 'bottom',
      Top: 'top',
      Default: 'default'
    };
    const VerticalMap = {
      top: Direction.Top,
      bottom: Direction.Bottom,
      center: Direction.Middle
    };
    const HorizontalMap = {
      left: Direction.Left,
      right: Direction.Right,
      center: Direction.Center
    };
    const FlipMap = {
      left: Direction.Right,
      right: Direction.Left,
      top: Direction.Bottom,
      bottom: Direction.Top,
      center: Direction.Center,
      default: Direction.Right
    };
    function getContainerSize(parent) {
      if (parent) {
        return parent.getBoundingClientRect();
      }
      const rect = {
        width: WindowManager.window.innerWidth || document.body.clientWidth || 0,
        height: WindowManager.window.innerHeight || document.body.clientHeight || 0,
        top: 0,
        left: 0
      };
      rect.bottom = rect.height;
      rect.right = rect.width;
      return rect;
    }
    function normalizeDirection(direction, defaultValue) {
      return utilsPrivate.normalizeString(direction, {
        fallbackValue: defaultValue || Direction.Default,
        validValues: [Direction.Center, Direction.Right, Direction.Left, Direction.Bottom, Direction.Top, Direction.Middle, Direction.Default]
      });
    }
    function mapToHorizontal(value) {
      value = normalizeDirection(value, Direction.Left);
      return HorizontalMap[value];
    }
    function mapToVertical(value) {
      value = normalizeDirection(value, Direction.Left);
      return VerticalMap[value];
    }
    function flipDirection(value) {
      value = normalizeDirection(value, Direction.Left);
      return FlipMap[value];
    }
    function checkFlipPossibility(parent, element, target, leftAsBoundary) {
      const viewPort = getContainerSize(parent);
      const windowViewPort = getContainerSize();
      const elemRect = element.getBoundingClientRect();
      const referenceElemRect = target.getBoundingClientRect();
      const height = typeof elemRect.height !== 'undefined' ? elemRect.height : elemRect.bottom - elemRect.top;
      const width = typeof elemRect.width !== 'undefined' ? elemRect.width : elemRect.right - elemRect.left;

      // TODO: We'll need to revisit the leftAsBoundary config property. Either we'll need a better
      // name to cover the RTL language cases and maybe open up the possibility of bounding the
      // element to the target in both the horizontal and vertical directions.

      // The boundary shrinks the available area to the edge of the target rather than the viewport.
      let rightAsBoundary = false;
      let isRTL = false;
      if (document.dir === 'rtl') {
        rightAsBoundary = leftAsBoundary;
        leftAsBoundary = false;
        isRTL = true;
      }

      // Bug Fix for https://gus.lightning.force.com/lightning/r/ADM_Work__c/a07B0000008DxOhIAK/view
      // If viewport is scrollableParent, then should count the top of scrollerParent,
      // otherwise, window top is 0. no change to original logic.
      // When used in console app, console's viewport is not window, but a scrollable div, then popup can be cut off easily.
      // scrollable parent => if any parent element set overflow-y:auto, then inner element won't popup, unless use position:fix.
      let aboveSpace = referenceElemRect.top - viewPort.top - height;
      let belowSpace = viewPort.height - referenceElemRect.bottom - height;

      // If there is scrollable parent, always check aboveSpace > 0
      let hasSpaceAbove = aboveSpace >= 0 || parent == null && belowSpace < 0 && aboveSpace > belowSpace;
      let hasSpaceBelow = belowSpace >= 0 || aboveSpace < 0 && belowSpace > aboveSpace;

      // Assuming left alignment is specified this tests if:
      // - there's room to accommodate the element with right alignment
      //      - within the viewport, if parent present
      // - there's not enough room to accommodate the element with left alignment
      let shouldAlignToRight = false;
      if (parent) {
        shouldAlignToRight = referenceElemRect.right - viewPort.left >= width && referenceElemRect.left + width > (rightAsBoundary ? referenceElemRect.right : viewPort.width);
      } else {
        shouldAlignToRight = referenceElemRect.right >= width && referenceElemRect.left + width > (rightAsBoundary ? referenceElemRect.right : viewPort.width);
      }

      // Assuming right alignment is specified this tests if:
      // - there's room to accommodate the element with left alignment
      //      - within the viewport if parent present
      // - there's not enough room to accommodate the element with right alignment
      let shouldAlignToLeft = false;
      if (parent) {
        shouldAlignToLeft = referenceElemRect.left + width <= viewPort.right && referenceElemRect.right - viewPort.left - width < (leftAsBoundary ? referenceElemRect.left : 0);
      } else {
        shouldAlignToLeft = referenceElemRect.left + width <= viewPort.width && referenceElemRect.right - width < (leftAsBoundary ? referenceElemRect.left : 0);
      }
      const spaceRemainingRight = viewPort.width - referenceElemRect.left;
      const spaceRemainingLeft = referenceElemRect.right;
      if (!shouldAlignToLeft && !shouldAlignToRight && parent) {
        shouldAlignToRight = (referenceElemRect.right - viewPort.left >= width || referenceElemRect.right >= width) && referenceElemRect.left + width > (rightAsBoundary ? referenceElemRect.right : viewPort.width);
        shouldAlignToLeft = (referenceElemRect.left + width <= viewPort.right || referenceElemRect.left + width <= windowViewPort.width) && referenceElemRect.right - width < (leftAsBoundary ? referenceElemRect.left : 0);
      }
      // W-13716578 W-14991047
      // Align to side with maximum available space only if:
      //  - it cannot align to left based on previous checks
      //  - it cannot align to right based on previous checks
      //  - the available space on either side does not fully fit element width
      // Check #3 is for when there is space on both sides, then both shouldAlignToLeft and shouldAlignToRight
      // are false, but we want it to use the default alignment instead of max available space
      else if (!shouldAlignToLeft && !shouldAlignToRight && spaceRemainingRight < width && spaceRemainingLeft < width) {
        shouldAlignToRight = spaceRemainingLeft > spaceRemainingRight;
        shouldAlignToLeft = spaceRemainingLeft < spaceRemainingRight;
      }

      /* W-15328389 RTL is one area where there have been bugs since long ago, the following change is an impactful in
      nature and spans multiple components, given the history of the impact this library creates we
      wanted to localize the change to tooltip where this bug was reported, but going forward when we add multiple other
      components we will remove this check provided we have similar bugs on other components */

      if (isRTL && !shouldAlignToLeft && !shouldAlignToRight && element.tagName === 'LIGHTNING-PRIMITIVE-BUBBLE') {
        shouldAlignToRight = spaceRemainingLeft > spaceRemainingRight;
        shouldAlignToLeft = spaceRemainingLeft < spaceRemainingRight;
      }

      // If there is no space above and below, recalculate space based on window
      // when there is still no space above and below based on window then select the maximum available space

      if (!hasSpaceAbove && !hasSpaceBelow && parent && element.style && element.style.position === 'fixed') {
        hasSpaceAbove = referenceElemRect.top - windowViewPort.top - height > 0;
        hasSpaceBelow = windowViewPort.height - referenceElemRect.bottom - height > 0;
      }

      // Assuming center alignment, does the viewport have space to fit half of the element around
      // the target?
      const centerOverflow = {
        left: referenceElemRect.left - width * 0.5 < 0,
        right: referenceElemRect.right + width * 0.5 > viewPort.width,
        top: referenceElemRect.top - height * 0.5 < 0,
        bottom: referenceElemRect.bottom + height * 0.5 > viewPort.height
      };
      return {
        shouldAlignToLeft,
        shouldAlignToRight,
        hasSpaceAbove,
        hasSpaceBelow,
        centerOverflow
      };
    }

    class Transformer {
      constructor(pad, boxDirections, transformX, transformY) {
        this.pad = pad || 0;
        this.boxDirections = boxDirections || {
          left: true,
          right: true
        };
        this.transformX = transformX || function () {};
        this.transformY = transformY || function () {};
      }
      transform() {
        // no-op
      }
    }
    class TopTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: Math.floor(this.transformY(targetBox.top, targetBox, elementBox) + this.pad)
        };
      }
      /*LWC compiler v7.1.5*/
    }
    class BottomTransFormer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: Math.floor(this.transformY(targetBox.top, targetBox, elementBox) - elementBox.height - this.pad)
        };
      }
      /*LWC compiler v7.1.5*/
    }
    class CenterTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: Math.floor(this.transformX(targetBox.left, targetBox, elementBox) - 0.5 * elementBox.width)
        };
      }
      /*LWC compiler v7.1.5*/
    }
    class MiddleTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: Math.floor(0.5 * (2 * targetBox.top + targetBox.height - elementBox.height))
        };
      }
      /*LWC compiler v7.1.5*/
    }
    class LeftTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: Math.floor(this.transformX(targetBox.left, targetBox, elementBox) + this.pad)
        };
      }
      /*LWC compiler v7.1.5*/
    }
    class RightTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: Math.floor(this.transformX(targetBox.left, targetBox, elementBox) - elementBox.width - this.pad)
        };
      }
      /*LWC compiler v7.1.5*/
    }
    class BelowTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const top = targetBox.top + targetBox.height + this.pad;
        return elementBox.top < top ? {
          top
        } : {};
      }
      /*LWC compiler v7.1.5*/
    }
    const MIN_HEIGHT = 36; // Minimum Line Height
    const MIN_WIDTH = 36;
    class ShrinkingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};
        if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
          retBox.top = targetBox.top + this.pad;
          retBox.height = Math.max(elementBox.height - (retBox.top - elementBox.top), MIN_HEIGHT);
        }
        if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
          retBox.left = targetBox.left + this.pad;
          retBox.width = Math.max(elementBox.width - (retBox.left - elementBox.left), MIN_WIDTH);
        }
        if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
          retBox.right = targetBox.left + targetBox.width - this.pad;
          retBox.width = Math.max(retBox.right - (retBox.left || elementBox.left), MIN_WIDTH);
        }
        if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
          retBox.bottom = targetBox.top + targetBox.height - this.pad;
          retBox.height = Math.max(retBox.bottom - (retBox.top || elementBox.top), MIN_HEIGHT);
        }
        return retBox;
      }
      /*LWC compiler v7.1.5*/
    }
    class BoundingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};
        if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
          retBox.top = targetBox.top + this.pad;
        }
        if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
          retBox.left = targetBox.left + this.pad;
        }
        if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
          retBox.left = targetBox.left + targetBox.width - elementBox.width - this.pad;
        }
        if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
          retBox.top = targetBox.top + targetBox.height - elementBox.height - this.pad;
        }
        return retBox;
      }
      /*LWC compiler v7.1.5*/
    }
    class InverseBoundingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};
        if (this.boxDirections.left && targetBox.left - this.pad < elementBox.left) {
          retBox.left = targetBox.left - this.pad;
        }
        if (this.boxDirections.right && elementBox.left + elementBox.width < targetBox.left + targetBox.width + this.pad) {
          retBox.left = targetBox.width + this.pad - elementBox.width + targetBox.left;
        }
        if (this.boxDirections.top && targetBox.top < elementBox.top + this.pad) {
          retBox.top = targetBox.top - this.pad;
        }
        if (this.boxDirections.bottom && elementBox.top + elementBox.height < targetBox.top + targetBox.height + this.pad) {
          retBox.top = targetBox.height + this.pad - elementBox.height + targetBox.top;
        }
        return retBox;
      }
      /*LWC compiler v7.1.5*/
    }
    const TransformFunctions = {
      center(input, targetBox) {
        return Math.floor(input + 0.5 * targetBox.width);
      },
      right(input, targetBox) {
        return input + targetBox.width;
      },
      left(input) {
        return input;
      },
      bottom(input, targetBox) {
        return input + targetBox.height;
      }
    };
    const Transformers = {
      top: TopTransformer,
      bottom: BottomTransFormer,
      center: CenterTransformer,
      middle: MiddleTransformer,
      left: LeftTransformer,
      right: RightTransformer,
      below: BelowTransformer,
      'bounding box': BoundingBoxTransformer,
      'shrinking box': ShrinkingBoxTransformer,
      'inverse bounding box': InverseBoundingBoxTransformer,
      default: Transformer
    };
    function toTransformFunctions(value) {
      return TransformFunctions[value] || TransformFunctions.left;
    }

    class TransformBuilder {
      type(value) {
        this._type = value;
        return this;
      }
      align(horizontal, vertical) {
        this._transformX = toTransformFunctions(horizontal);
        this._transformY = toTransformFunctions(vertical);
        return this;
      }
      pad(value) {
        this._pad = parseInt(value, 10);
        return this;
      }
      boxDirections(value) {
        this._boxDirections = value;
        return this;
      }
      build() {
        const AConstructor = Transformers[this._type] ? Transformers[this._type] : Transformers[Direction.Default];
        return new AConstructor(this._pad || 0, this._boxDirections || {}, this._transformX || toTransformFunctions(Direction.left), this._transformY || toTransformFunctions(Direction.left));
      }
    }

    class Constraint {
      constructor(type, config) {
        const {
          target,
          element,
          pad,
          boxDirections
        } = config;
        const {
          horizontal,
          vertical
        } = config.targetAlign;
        this._element = element;
        this._targetElement = target;
        this.destroyed = false;
        this._transformer = new TransformBuilder().type(type).align(horizontal, vertical).pad(pad).boxDirections(boxDirections).build();
      }
      detach() {
        this._disabled = true;
      }
      attach() {
        this._disabled = false;
      }
      computeDisplacement() {
        if (!this._disabled) {
          this._targetElement.refresh();
          this._element.refresh();
          this._pendingBox = this._transformer.transform(this._targetElement, this._element);
        }
        return this;
      }
      computePosition() {
        const el = this._element;
        if (!this._disabled) {
          Object.keys(this._pendingBox).forEach(key => {
            el.setDirection(key, this._pendingBox[key]);
          });
        }
        return this;
      }
      destroy() {
        this._element.release();
        this._targetElement.release();
        this._disabled = true;
        this.destroyed = true;
      }
    }

    class ElementProxy {
      constructor(el, id) {
        this.id = id;
        this.width = 0;
        this.height = 0;
        this.left = 0;
        this.top = 0;
        this.right = 0;
        this.bottom = 0;
        this._dirty = false;
        this._node = null;
        this._releaseCb = null;
        if (!el) {
          throw new Error('Element missing');
        }

        // W-3262919
        // for some reason I cannot figure out sometimes the
        // window, which clearly a window object, is not the window object
        // this will correct that. It might be related to locker
        if (WindowManager.isWindow(el)) {
          el = WindowManager.window;
        }
        this._node = el;
        this.setupObserver();
        this.refresh();
      }
      setupObserver() {
        // this check is because phantomjs does not support
        // mutation observers. The consqeuence here
        // is that any browser without mutation observers will
        // fail to update dimensions if they changwe after the proxy
        // is created and the proxy is not not refreshed
        if (WindowManager.MutationObserver && !this._node.isObserved) {
          // Use mutation observers to invalidate cache. It's magic!
          this._observer = new WindowManager.MutationObserver(this.refresh.bind(this));

          // do not observe the window
          if (!WindowManager.isWindow(this._node)) {
            this._observer.observe(this._node, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });
            this._node.isObserved = true;
          }
        }
      }
      setReleaseCallback(cb, scope) {
        const scopeObj = scope || this;
        this._releaseCb = cb.bind(scopeObj);
      }
      checkNodeIsInDom() {
        // if underlying DOM node is gone,
        // this proxy should be released
        if (!isInDom(this._node)) {
          return false;
        }
        return true;
      }
      refresh() {
        const w = WindowManager.window;
        if (!this.isDirty()) {
          if (!this.checkNodeIsInDom()) {
            return this.release();
          }
          let box, x, scrollTop, scrollLeft;
          if (typeof w.pageYOffset !== 'undefined') {
            scrollTop = w.pageYOffset;
            scrollLeft = w.pageXOffset;
          } else {
            scrollTop = w.scrollY;
            scrollLeft = w.scrollX;
          }
          if (!WindowManager.isWindow(this._node)) {
            // force paint
            // eslint-disable-next-line no-unused-vars
            this._node.offsetHeight;
            box = this._node.getBoundingClientRect();

            // not using integers causes weird rounding errors
            // eslint-disable-next-line guard-for-in
            for (x in box) {
              this[x] = Math.floor(box[x]);
            }
            this.top = Math.floor(this.top + scrollTop);
            this.bottom = Math.floor(this.top + box.height);
            this.left = Math.floor(this.left + scrollLeft);
            this.right = Math.floor(this.left + box.width);
          } else {
            box = {};
            this.width = WindowManager.documentElement.clientWidth;
            this.height = WindowManager.documentElement.clientHeight;
            this.left = scrollLeft;
            this.top = scrollTop;
            this.right = WindowManager.documentElement.clientWidth + scrollLeft;
            this.bottom = WindowManager.documentElement.clientHeight;
          }
          this._dirty = false;
        }
        return this._dirty;
      }
      getNode() {
        return this._node;
      }
      isDirty() {
        return this._dirty;
      }
      bake() {
        const w = WindowManager.window;
        const absPos = this._node.getBoundingClientRect();
        const style = w.getComputedStyle(this._node) || this._node.style;
        const hasPageOffset = typeof w.pageYOffset !== 'undefined';
        const scrollTop = hasPageOffset ? w.pageYOffset : w.scrollY;
        const scrollLeft = hasPageOffset ? w.pageXOffset : w.scrollX;
        const originalLeft = style.left.match(/auto|fixed/) ? '0' : pxToFloat(style.left);
        const originalTop = style.top.match(/auto|fixed/) ? '0' : pxToFloat(style.top);

        //since this.top dosent consist of marginTop and marginBottom, we need to subtract the margin to the top or bottom from absTop dependending on where the popup is positioned wrt the element
        const adjustedAbsPosTop = absPos.top - (this.top < absPos.top ? pxToFloat(style.marginBottom) : -1 * pxToFloat(style.marginTop));
        const marginOffset = this.top < adjustedAbsPosTop ? pxToFloat(style.marginBottom) : pxToFloat(style.marginTop) * -1;
        let leftDif = Math.round(this.left - (absPos.left + scrollLeft));
        const topDif = Math.round(this.top - (absPos.top + marginOffset + scrollTop));
        const viewPortWidth = w.innerWidth || document.body.clientWidth;
        let rightPos = parseInt(style.right, 10);
        if (originalLeft + leftDif + parseInt(style.width, 10) > viewPortWidth && rightPos <= 0) {
          rightPos = rightPos < 0 ? -rightPos : leftDif;
          this._node.style.right = -rightPos + 'px';
          leftDif = 0;
        }
        this._node.style.left = `${originalLeft + leftDif}px`;
        this._node.style.top = `${originalTop + topDif}px`;
        if (this._restoreSize) {
          // Only store the first height/width which is the original height/width.
          if (this.originalHeight === undefined) {
            this.originalHeight = this._node.style.height;
          }
          if (this.originalWidth === undefined) {
            this.originalWidth = this._node.style.width;
          }
          this._node.style.width = `${this.width}px`;
          this._node.style.height = `${this.height}px`;
        }
        this._dirty = false;
      }
      setDirection(direction, val) {
        this[direction] = val;
        this._dirty = true;
        // if size is changed, should restore the original size.
        if (direction === 'height' || direction === 'width') {
          this._restoreSize = true;
        }
      }
      release() {
        if (this._restoreSize) {
          this._node.style.width = this.originalWidth;
          this._node.style.height = this.originalHeight;
          if (this._removeMinHeight) {
            this._node.style.minHeight = '';
          }
        }
        if (this._releaseCb) {
          this._releaseCb(this);
        }

        // Due to https://github.com/salesforce/lwc/pull/1423
        // require to call disconnect explicitly.
        if (this._observer) {
          this._observer.disconnect();
          this._observer = null;
        }
      }
      querySelectorAll(selector) {
        return this._node.querySelectorAll(selector);
      }
    }

    class ProxyCache {
      constructor() {
        this.proxyCache = {};
      }
      get count() {
        return Object.keys(this.proxyCache).length;
      }
      releaseOrphanProxies() {
        for (const proxy in this.proxyCache) {
          if (!this.proxyCache[proxy].el.checkNodeIsInDom()) {
            this.proxyCache[proxy].el.release();
          }
        }
      }
      bakeOff() {
        for (const proxy in this.proxyCache) {
          if (this.proxyCache[proxy].el.isDirty()) {
            this.proxyCache[proxy].el.bake();
          }
        }
      }
      getReferenceCount(proxy) {
        const id = proxy.id;
        if (!id || !this.proxyCache[id]) {
          return 0;
        }
        return this.proxyCache[id].refCount;
      }
      release(proxy) {
        const proxyInstance = this.proxyCache[proxy.id];
        if (proxyInstance) {
          --proxyInstance.refCount;
        }
        if (proxyInstance && proxyInstance.refCount <= 0) {
          delete this.proxyCache[proxy.id];
        }
      }
      reset() {
        this.proxyCache = {};
      }
      create(element) {
        let key = 'window';
        if (!WindowManager.isWindow(element)) {
          key = element ? element.getAttribute(POSITION_ATTR_NAME) : null;
          // 1 - Node.ELEMENT_NODE, 11 - Node.DOCUMENT_FRAGMENT_NODE
          utilsPrivate.assert(key && element.nodeType && (element.nodeType !== 1 || element.nodeType !== 11), `Element Proxy requires an element and has property ${POSITION_ATTR_NAME}`);
        }
        if (this.proxyCache[key]) {
          this.proxyCache[key].refCount++;
          return this.proxyCache[key].el;
        }
        const newProxy = new ElementProxy(element, key);
        newProxy.setReleaseCallback(release, newProxy);
        this.proxyCache[key] = {
          el: newProxy,
          refCount: 1
        };

        // run GC
        timeout(0).then(() => {
          this.releaseOrphanProxies();
        });
        return this.proxyCache[key].el;
      }
    }
    const elementProxyCache = new ProxyCache();
    function bakeOff() {
      elementProxyCache.bakeOff();
    }
    function release(proxy) {
      return elementProxyCache.release(proxy);
    }
    function createProxy(element) {
      return elementProxyCache.create(element);
    }

    class RepositionQueue {
      constructor() {
        this.callbacks = [];
        this.repositionScheduled = false;
        this._constraints = [];
        this.timeoutId = 0;
        this.lastIndex = utilsPrivate.getZIndexBaseline();
        this.eventsBound = false;
      }
      get nextIndex() {
        return this.lastIndex++;
      }
      get constraints() {
        return this._constraints;
      }
      set constraints(value) {
        this._constraints = this._constraints.concat(value);
      }
      dispatchRepositionCallbacks() {
        while (this.callbacks.length > 0) {
          this.callbacks.shift()();
        }
      }
      add(callback) {
        if (typeof callback === 'function') {
          this.callbacks.push(callback);
          return true;
        }
        return false;
      }
      scheduleReposition(callback) {
        if (this.timeoutId === 0) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          this.timeoutId = setTimeout(() => {
            this.reposition(callback);
          }, 10);
        }
      }
      reposition(callback) {
        // all the callbacks will be called
        if (typeof callback === 'function') {
          this.callbacks.push(callback);
        }
        // this is for throttling
        clearTimeout(this.timeoutId);
        this.timeoutId = 0;

        // this semaphore is to make sure
        // if reposition is called twice within one frame
        // we only run this once
        if (!this.repositionScheduled) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            this.repositionScheduled = false;
            // this must be executed in order or constraints
            // will behave oddly
            this._constraints = this._constraints.filter(constraint => {
              if (!constraint.destroyed) {
                constraint.computeDisplacement().computePosition();
                return true;
              }
              return false;
            });
            bakeOff();
            this.dispatchRepositionCallbacks();
          });
          this.repositionScheduled = true;
        }
      }
      get repositioning() {
        if (!this._reposition) {
          this._reposition = this.scheduleReposition.bind(this);
        }
        return this._reposition;
      }
      bindEvents() {
        if (!this.eventsBound) {
          window.addEventListener('resize', this.repositioning);
          window.addEventListener('scroll', this.repositioning);
          this.eventsBound = true;
        }
      }
      detachEvents() {
        window.removeEventListener('resize', this.repositioning);
        window.removeEventListener('scroll', this.repositioning);
        this.eventsBound = false;
      }
      rebase(index) {
        if (this.lastIndex <= index) {
          this.lastIndex = index + 1;
        }
      }
    }
    const positionQueue = new RepositionQueue();
    function scheduleReposition(callback) {
      positionQueue.scheduleReposition(callback);
    }
    function bindEvents() {
      positionQueue.bindEvents();
    }
    function addConstraints(list) {
      positionQueue.constraints = list;
    }
    function reposition(callback) {
      positionQueue.reposition(callback);
    }
    function nextIndex() {
      return positionQueue.nextIndex;
    }
    function rebaseIndex(index) {
      return positionQueue.rebase(index);
    }

    class Relationship {
      constructor(config, constraintList, scrollableParent, observer) {
        this.config = config;
        this.constraintList = constraintList;
        this.scrollableParent = scrollableParent;
        this.observer = observer;
      }
      disable() {
        this.constraintList.forEach(constraintToDisable => {
          constraintToDisable.detach();
        });
      }
      enable() {
        this.constraintList.forEach(constraintToEnable => {
          constraintToEnable.attach();
        });
      }
      destroy() {
        if (this.config.removeListeners) {
          this.config.removeListeners();
          this.config.removeListeners = undefined;
        }
        while (this.constraintList.length > 0) {
          this.constraintList.pop().destroy();
        }

        // Clean up node appended to body of dom
        if (this.config.appendToBody && this.config.element) {
          // eslint-disable-next-line @lwc/lwc/no-document-query
          const nodeToRemove = document.querySelector(`[${POSITION_ATTR_NAME}="${this.config.element.getAttribute(POSITION_ATTR_NAME)}"]`);
          if (nodeToRemove) {
            nodeToRemove.parentNode.removeChild(nodeToRemove);
          }
        }

        // Due to https://github.com/salesforce/lwc/pull/1423
        // require to call disconnect explicitly.
        if (this.observer) {
          this.observer.disconnect();
          this.observer = null;
        }
      }
      reposition() {
        return new Promise(resolve => {
          reposition(() => {
            resolve();
          });
        });
      }
    }

    const OVERLAY_TYPE = {
      NONE: 'none',
      MODAL: 'uiModal',
      DIALOG: 'lightning-dialog',
      POPOVER: 'lightning-popover',
      PANEL: 'uiPanel',
      SLDSMODAL: 'slds-modal'
    };
    function isOverlay(element) {
      const isDialog = element.localName === OVERLAY_TYPE.DIALOG;
      if (isDialog) {
        return OVERLAY_TYPE.DIALOG;
      }
      const isPopover = element.localName === OVERLAY_TYPE.POPOVER;
      if (isPopover) {
        return OVERLAY_TYPE.POPOVER;
      }
      const isModal = element.classList && element.classList.contains(OVERLAY_TYPE.MODAL);
      if (isModal) {
        return OVERLAY_TYPE.MODAL;
      }
      const isPanel = element.classList && element.classList.contains(OVERLAY_TYPE.PANEL);
      if (isPanel) {
        return OVERLAY_TYPE.PANEL;
      }
      const isSldsModal = element.classList && element.classList.contains(OVERLAY_TYPE.SLDSMODAL);
      if (isSldsModal) {
        return OVERLAY_TYPE.SLDSMODAL;
      }
      return OVERLAY_TYPE.NONE;
    }
    function isInsideOverlay(element) {
      if (!element) {
        return {
          isInside: false,
          type: null,
          overlay: null
        };
      }
      const type = isOverlay(element);
      if (type !== OVERLAY_TYPE.NONE) {
        return {
          isInside: true,
          type,
          overlay: element
        };
      }
      if (!element.parentNode) {
        return {
          isInside: false,
          type: null,
          overlay: null
        };
      }
      return isInsideOverlay(isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode);
    }
    class OverlayDetector {
      constructor(element) {
        this._element = element;
        this._detection = isInsideOverlay(this._element) || {
          isInside: false,
          overlay: null
        };
      }
      get isInsideModal() {
        return this.isInside && (this._detection.type === OVERLAY_TYPE.MODAL || this._detection.type === OVERLAY_TYPE.DIALOG || this._detection.type === OVERLAY_TYPE.SLDSMODAL);
      }
      get isInside() {
        return this._detection.isInside;
      }
      get overlay() {
        return this._detection.overlay;
      }
    }

    const DEFAULT_MIN_HEIGHT = '1.875rem';
    function setupObserver(config, scrollableParent) {
      const observedElement = config.element;
      let observer = null;
      if (WindowManager.MutationObserver && !observedElement.isObserved) {
        observer = new WindowManager.MutationObserver(() => {});
        observer.observe(observedElement, {
          attributes: true,
          subtree: true,
          childList: true
        });
        observedElement.isObserved = true;
      }
      if (scrollableParent) {
        scrollableParent.addEventListener('scroll', scheduleReposition);
        config.removeListeners = () => {
          scrollableParent.removeEventListener('scroll', scheduleReposition);
        };
      }
      return observer;
    }
    function validateConfig(config) {
      utilsPrivate.assert(config.element && isDomNode(config.element), 'Element is undefined or missing, or not a Dom Node');
      utilsPrivate.assert(config.target && (WindowManager.isWindow(config.target) || isDomNode(config.target)), 'Target is undefined or missing');
    }
    function createRelationship(originalConfig, disableReposition, eventComposedPath) {
      bindEvents();
      let scrollableParent = getScrollableParent(getPositionTarget(originalConfig.target), WindowManager.window);
      if (!scrollableParent && eventComposedPath) {
        scrollableParent = getScrollableParentFromEventPath(eventComposedPath);
      }
      const config = normalizeConfig(scrollableParent, originalConfig);
      if (config.alignWidth && config.element.style.position === 'fixed') {
        config.element.style.width = config.target.getBoundingClientRect().width + 'px';
      }
      const constraintList = [];

      // This observer and the test for scrolling children
      // is so that if a panel contains a scroll we do not
      // proxy the events to the "parent"  (actually the target's parent)
      const observer = setupObserver(config, scrollableParent);
      if (config.appendToBody) {
        document.body.appendChild(config.element);
      }
      config.element = createProxy(config.element);
      config.target = createProxy(config.target);

      // Add horizontal constraint.
      const horizontalConfig = Object.assign({}, config);
      if (horizontalConfig.padLeft !== undefined) {
        horizontalConfig.pad = horizontalConfig.padLeft;
      }

      // Add vertical constraint.
      const verticalConfig = Object.assign({}, config);
      if (verticalConfig.padTop !== undefined) {
        verticalConfig.pad = verticalConfig.padTop;
      }
      constraintList.push(new Constraint(mapToHorizontal(config.align.horizontal), horizontalConfig));
      constraintList.push(new Constraint(mapToVertical(config.align.vertical), verticalConfig));
      const autoShrink = config.autoShrink.height || config.autoShrink.width;
      if (config.scrollableParentBound && scrollableParent) {
        const parent = normalizeElement(scrollableParent);
        const boxConfig = {
          element: config.element,
          enabled: config.enabled,
          target: createProxy(parent),
          align: {},
          targetAlign: {},
          pad: 3,
          boxDirections: {
            top: true,
            bottom: true,
            left: true,
            right: true
          }
        };
        if (autoShrink) {
          const style = boxConfig.element.getNode().style;
          if (!style.minHeight) {
            style.minHeight = config.minHeight;
            boxConfig.element._removeMinHeight = true;
          }
          boxConfig.boxDirections = {
            top: !!config.autoShrink.height,
            bottom: !!config.autoShrink.height,
            left: !!config.autoShrink.width,
            right: !!config.autoShrink.width
          };
          constraintList.push(new Constraint('shrinking box', boxConfig));
        } else {
          constraintList.push(new Constraint('bounding box', boxConfig));
        }
      }
      if (config.keepInViewport) {
        constraintList.push(new Constraint('bounding box', {
          element: config.element,
          enabled: config.enabled,
          target: createProxy(window),
          align: {},
          targetAlign: {},
          pad: 3,
          boxDirections: {
            top: true,
            bottom: true,
            left: true,
            right: true
          }
        }));
      }
      addConstraints(constraintList);
      if (!disableReposition) {
        reposition();
      }
      return new Relationship(config, constraintList, scrollableParent, observer);
    }
    function isAutoFlipHorizontal(config) {
      return config.autoFlip || config.autoFlipHorizontal;
    }
    function isAutoFlipVertical(config) {
      return config.autoFlip || config.autoFlipVertical;
    }
    function normalizeAlignments(config, flipConfig) {
      const align = {
        horizontal: config.align.horizontal,
        vertical: config.align.vertical
      };
      const targetAlign = {
        horizontal: config.targetAlign.horizontal,
        vertical: config.targetAlign.vertical
      };

      // Horizontal alignments flip for RTL languages.
      if (document.dir === 'rtl') {
        align.horizontal = flipDirection(align.horizontal);
        targetAlign.horizontal = flipDirection(targetAlign.horizontal);
      }

      // When using the autoFlip flags with center alignment, we change the element alignment to fit
      // within the viewport when it's detected that it overflows the edge of the viewport.

      let vFlip = false;
      if (isAutoFlipVertical(config)) {
        if (align.vertical === Direction.Bottom) {
          vFlip = !flipConfig.hasSpaceAbove && flipConfig.hasSpaceBelow;
        } else if (align.vertical === Direction.Top) {
          vFlip = flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow;
        } else if (align.vertical === Direction.Center) {
          if (flipConfig.centerOverflow.top && !flipConfig.centerOverflow.bottom) {
            align.vertical = targetAlign.vertical = Direction.Top;
          } else if (flipConfig.centerOverflow.bottom && !flipConfig.centerOverflow.top) {
            align.vertical = targetAlign.vertical = Direction.Bottom;
          }
        }
      }
      let hFlip = false;
      if (isAutoFlipHorizontal(config)) {
        if (align.horizontal === Direction.Left) {
          hFlip = flipConfig.shouldAlignToRight && !flipConfig.shouldAlignToLeft;
        } else if (align.horizontal === Direction.Right) {
          hFlip = flipConfig.shouldAlignToLeft && !flipConfig.shouldAlignToRight;
        } else if (align.horizontal === Direction.Center) {
          if (flipConfig.centerOverflow.left && !flipConfig.centerOverflow.right) {
            align.horizontal = targetAlign.horizontal = Direction.Left;
          } else if (flipConfig.centerOverflow.right && !flipConfig.centerOverflow.left) {
            align.horizontal = targetAlign.horizontal = Direction.Right;
          }
        }
      }
      return {
        align: {
          horizontal: hFlip ? flipDirection(align.horizontal) : normalizeDirection(align.horizontal, Direction.Left),
          vertical: vFlip ? flipDirection(align.vertical) : normalizeDirection(align.vertical, Direction.Top)
        },
        targetAlign: {
          horizontal: hFlip ? flipDirection(targetAlign.horizontal) : normalizeDirection(targetAlign.horizontal, Direction.Left),
          vertical: vFlip ? flipDirection(targetAlign.vertical) : normalizeDirection(targetAlign.vertical, Direction.Bottom)
        }
      };
    }
    function normalizeConfig(parent, config) {
      config.align = config.align || {};
      config.targetAlign = config.targetAlign || {};
      const flipConfig = checkFlipPossibility(config.overlay.isInside ? null : parent,
      // For modal/panel, dialog/popover, should always popup.
      // And consider window is the viewport, ignore scrollable parent.
      // Otherwise, when stay on flat page, should use scrollable parent as viewpoint.
      config.element, config.target, config.leftAsBoundary);
      const {
        align,
        targetAlign
      } = normalizeAlignments(config, flipConfig);

      // When inside modal, element may expand out of the viewport and be cut off.
      // So if inside modal, and don't have enough space above or below, will add bounding box rule.
      // IMPORTANT: config.isInsideModal is for element, not target.
      if (config.isInsideModal && !flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow) {
        config.scrollableParentBound = true;
      }
      return {
        target: config.target,
        element: config.element,
        align,
        targetAlign,
        alignWidth: config.alignWidth,
        scrollableParentBound: config.scrollableParentBound,
        keepInViewport: config.keepInViewport,
        pad: config.pad,
        padTop: config.padTop,
        padLeft: config.padLeft,
        autoShrink: {
          height: config.autoShrink || config.autoShrinkHeight,
          width: config.autoShrink || config.autoShrinkWidth
        },
        minHeight: config.minHeight || DEFAULT_MIN_HEIGHT
      };
    }
    function toElement(root, target) {
      if (target && typeof target === 'string') {
        return root.querySelector(target);
      } else if (target && typeof target === 'function') {
        return target();
      }
      return target;
    }
    function startPositioning(root, config, disableReposition) {
      utilsPrivate.assert(root, 'Root is undefined or missing');
      utilsPrivate.assert(config, 'Config is undefined or missing');
      const node = normalizeElement(root);
      const target = toElement(node, config.target);
      const element = toElement(node, config.element);

      // when target/element is selector, there is chance, dom isn't present anymore.
      if (!target || !element) {
        return null;
      }
      config.target = normalizeElement(target);
      config.element = normalizeElement(element);

      // Check if element is inside modal overlay.
      const result = new OverlayDetector(config.element);

      // IMPORTANT: config.isInsideModal will be used to decide if element should use modal as viewport.
      config.isInsideModal = result.isInsideModal;

      // stackManager will increase the zIndex too.
      // if detect inside modal, read modal zIndex and rebase to it.
      if (config.isInsideModal && result.overlay) {
        const index = parseInt(result.overlay.style.zIndex, 10);
        rebaseIndex(index);
      }

      // Also should check if target inside modal too.

      const targetResult = new OverlayDetector(config.target);

      // if detect target is inside modal, read modal zindex and rebase to it.
      // for example, lightning-helptext, lightning-primitive-bubble by default is global.
      // So it won't be in any modal. For other use case, target and element is inside same modal.
      if (targetResult.isInsideModal && targetResult.overlay) {
        const index = parseInt(targetResult.overlay.style.zIndex, 10);
        rebaseIndex(index);
      }

      // Element absolute / fixed must be set prior to getBoundingClientRect call or
      // the scrollable parent (usually due to uiModal/uiPanel) will push the page down.
      const overlayCheck = normalizePosition(config.element, result, nextIndex(), config.target, config.alignWidth);
      config.element = overlayCheck.element;
      config.overlay = overlayCheck.overlay;
      validateConfig(config);
      const relationship = createRelationship(config, disableReposition);

      // Scroll regions within a shadowRoot are skipped while traversing parent nodes.
      // Components that contain a scroll region in their template
      // must handle the `privatescrollablecontainer` event and execute the callback with the event path.

      // The event path is used to find the scrollable parent and the constraints
      // for positioning are set according to this element.

      // Usage in parent component with scroll region:
      // addEventListener('privatescrollablecontainer', (event) => {
      //     const { callback } = event.detail;
      //     callback(event.composedPath());
      //     event.stopPropagation();
      // });
      root.dispatchEvent(new CustomEvent('privatescrollablecontainer', {
        composed: true,
        bubbles: true,
        detail: {
          callback: eventComposedPath => {
            var updatedReltnWrtoScrollParent = createRelationship(config, disableReposition, eventComposedPath);
            relationship.config.align.horizontal = updatedReltnWrtoScrollParent.config.align.horizontal;
            relationship.config.align.vertical = updatedReltnWrtoScrollParent.config.align.vertical;
          }
        }
      }));
      return relationship;
    }
    function stopPositioning(relationship) {
      if (relationship) {
        relationship.destroy();
      }
    }
    class AutoPosition {
      constructor(root) {
        this._autoPositionUpdater = null;
        this._root = root;
      }
      start(config) {
        return requestAnimationFrameAsPromise().then(() => {
          let promise = Promise.resolve();
          if (!this._autoPositionUpdater) {
            this._autoPositionUpdater = startPositioning(this._root, config);
          } else {
            promise = promise.then(() => {
              return this._autoPositionUpdater.reposition();
            });
          }
          return promise.then(() => {
            return this._autoPositionUpdater;
          });
        });
      }
      stop() {
        if (this._autoPositionUpdater) {
          stopPositioning(this._autoPositionUpdater);
          this._autoPositionUpdater = null;
        }
        return Promise.resolve();
      }
    }

    exports.AutoPosition = AutoPosition;
    exports.Direction = Direction;
    exports.startPositioning = startPositioning;
    exports.stopPositioning = stopPositioning;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/tooltipLibrary', ['exports', 'lwc', 'lightning/positionLibrary', 'lightning/utilsPrivate', 'lightning/primitiveBubble', 'lightning/ariaObserver'], (function (exports, lwc, positionLibrary, utilsPrivate, LightningPrimitiveBubble, AriaObserver) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var LightningPrimitiveBubble__default = /*#__PURE__*/_interopDefaultCompat(LightningPrimitiveBubble);
    var AriaObserver__default = /*#__PURE__*/_interopDefaultCompat(AriaObserver);

    const BUBBLE_PREFIX = `salesforce-lightning-tooltip-bubble`;
    const BUBBLE_ID = `${BUBBLE_PREFIX}_${utilsPrivate.guid()}`;
    function isResizeObserverSupported() {
      return window.ResizeObserver != null;
    }

    /**
     * Shared instance of a primitive bubble used as a tooltip by most components. This was originally
     * defined in the helptext component which is where the minWidth style came from.
     * TODO: We may want to revisit the minWidth style with the PO and/or UX.
     */
    let CACHED_BUBBLE_ELEMENT;
    let activeTooltip;
    function getCachedBubbleElement() {
      if (!CACHED_BUBBLE_ELEMENT) {
        CACHED_BUBBLE_ELEMENT = lwc.createElement('lightning-primitive-bubble', {
          is: LightningPrimitiveBubble__default.default
        });
        CACHED_BUBBLE_ELEMENT.contentId = BUBBLE_ID;
        CACHED_BUBBLE_ELEMENT.style.position = 'absolute';
        CACHED_BUBBLE_ELEMENT.style.minWidth = '75px';
        CACHED_BUBBLE_ELEMENT.disableVisibilityChangeOnLeave = true;
      }
      return CACHED_BUBBLE_ELEMENT;
    }
    const ARIA_DESCRIBEDBY = 'aria-describedby';

    /**
     * Used as a position offset to compensate for the nubbin. The dimensions of the nubbin are not
     * included in the position library bounding box calculations. This is the size in pixels of the
     * nubbin.
     * TODO: We may want to measure this instead in cases it changes.
     */
    const NUBBIN_SIZE = 16;

    /**
     * Used in the calculation that moves the tooltip to a location that places the nubbin at the
     * center of the target element. This is the nubbin offset from the edge of the bubble in pixels
     * when using slds-nubbin_bottom-left or slds-nubbin_bottom-right.
     * TODO: We may want to measure this instead in case it changes.
     */
    const NUBBIN_OFFSET = 24;

    /**
     * Known tooltip types:
     * - info: used in cases where target already has click handlers such as button-icon
     * - toggle: used in cases where target only shows a tooltip such as helptext
     */
    const TooltipType = {
      Info: 'info',
      Toggle: 'toggle'
    };

    /**
     * Allows us to attach a tooltip to components. Typical usage is as follows:
     * - Create an instance of Tooltip
     * - Call Tooltip.initialize() to add the appropriate listeners to the element that needs a tooltip
     * See buttonIcon and buttonMenu for example usage.
     */
    class Tooltip {
      /**
       * A shared instance of primitiveBubble is used when an element is not specified in the config
       * object.
       * @param {string} value the content of the tooltip
       * @param {object} config specifies the root component, target element of the tooltip
       */
      constructor(value, config) {
        this._autoPosition = null;
        this._disabled = true;
        this._initialized = false;
        this._visible = false;
        this._isFocusEvent = false;
        this._initialResize = true;
        this._ariaObserver = null;
        this._config = {};
        utilsPrivate.assert(config.target, 'target for tooltip is undefined or missing');
        this.value = value;
        this._root = config.root;
        this._target = config.target;
        this._config = {
          ...config
        };
        this._config.align = config.align || {};
        this._config.targetAlign = config.targetAlign || {};
        this._config.disableAriaDescribedBy = config.disableAriaDescribedBy || false;
        this._type = utilsPrivate.normalizeString(config.type, {
          fallbackValue: TooltipType.Info,
          validValues: Object.values(TooltipType)
        });

        // If a tooltip element is not given, fall back on the globally shared instance.
        this._element = config.element;
        if (utilsPrivate.isCSR && !this._element) {
          this._element = getCachedBubbleElement;
          const bubbleElement = getCachedBubbleElement();
          if (bubbleElement.parentNode === null) {
            document.body.appendChild(bubbleElement);
          }
        }
        this.handleDocumentTouch = this.handleDocumentTouch.bind(this);
        this.handleEscape = this.handleEscape.bind(this);
        this.hide = this.hide.bind(this);
      }

      /**
       * Disables the tooltip.
       */
      detach() {
        this._disabled = true;
      }

      /**
       * Enables the tooltip.
       */
      attach() {
        this._disabled = false;
      }

      /**
       * Adds the appropriate event listeners to the target element to make the tooltip appear. Also
       * links the tooltip and target element via the aria-describedby attribute for screen readers.
       */
      initialize() {
        const target = this._target();
        if (!this._initialized && target) {
          switch (this._type) {
            case TooltipType.Toggle:
              this.addToggleListeners();
              break;
            case TooltipType.Info:
            default:
              this.addInfoListeners();
              break;
          }
          if (!this._config.disableAriaDescribedBy) {
            this._ariaObserver = new AriaObserver__default.default(this._root);
            this._ariaObserver.connect({
              attribute: ARIA_DESCRIBEDBY,
              targetNode: this._target(),
              relatedNodes: this._element()
            });
          }
          this._initialized = true;
        }
      }
      disconnect() {
        if (this._ariaObserver) this._ariaObserver.disconnect();
      }
      addInfoListeners() {
        const target = this._target();
        if (!this._initialized && target) {
          ['mouseenter', 'focus'].forEach(name => target.addEventListener(name, () => this.show()));
          // Unlike the tooltip in Aura, we want clicks and keys to dismiss the tooltip.
          ['mouseleave', 'blur', 'click', 'keydown'].forEach(name => target.addEventListener(name, event => {
            if (!this._visible) {
              return;
            }
            this.hideIfNotSelfCover(event);
            if (event.key === 'Escape') {
              event.stopPropagation();
            }
          }));
        }
      }
      hideIfNotSelfCover(event) {
        /*
            If the tooltip is already hidden, do not try to hide it. The primitive bubble is shared and we don't want to
            hide a tooltip that does not belong to this instance.
        */
        if (!this._visible) {
          return;
        }
        const tooltip = this._element();
        if (event.type === 'mouseleave' && event.clientX && event.clientY) {
          // In any chance, if mouseleave is caused by tooltip itself, it would means
          // tooltip cover the target which mostly caused by dynamic resize of tooltip by CSS or JS.
          try {
            const yOffset = tooltip.align.vertical === 'top' ? 1 : 0;
            const elementMouseIsOver = document.elementFromPoint ? document.elementFromPoint(event.clientX, event.clientY + yOffset) : null;
            if (elementMouseIsOver === this._element()) {
              if (!isResizeObserverSupported()) {
                this.startPositioning();
              }
              return;
            }
          } catch (ex) {
            // Jest Throw Exception
          }
        }
        this.hide();
      }
      handleDocumentTouch() {
        if (this._visible) {
          this.hide();
        }
      }
      addToggleListeners() {
        const target = this._target();
        if (!this._initialized && target) {
          ['touchstart', 'click'].forEach(eventName => target.addEventListener(eventName, event => this.toggleIfTouchOrClick(event)));
          ['mouseenter', 'focus'].forEach(eventName => target.addEventListener(eventName, event => this.show(event)));
          ['mouseleave', 'blur'].forEach(eventName => target.addEventListener(eventName, event => this.hideIfNotSelfCover(event)));
          target.addEventListener('keydown', event => {
            if (event.key === 'Escape' && this._visible) {
              this.hideIfNotSelfCover(event);
              event.stopPropagation();
            }
          });
        }
      }

      /* mobile listens for both 'click' and 'touchstart', but we only want to listen to
         either 'touchstart' and not 'click', otherwise it will double toggle. Call preventDefault() to prevent the
         'click' event from bubbling after a 'touchstart' is detected on mobile.
      */
      toggleIfTouchOrClick(e) {
        e.preventDefault();
        e.stopPropagation();
        this.toggle();
      }
      handleEscape(e) {
        if (e.key === 'Escape' && this._isFocusEvent) {
          e.stopPropagation();
          this.hideIfNotSelfCover(e);
        }
      }
      get resizeObserver() {
        if (!this._resizeObserver) {
          this._resizeObserver = this._buildResizeObserver(() => {
            if (this._visible && this._autoPosition) {
              const tooltip = this._element();
              /**
               * There are some cases where the tooltip hide event does not trigger. For example,
               * if a tab triggers a focus event on element A and then a pointer triggers mouseenter on element B.
               * In this case, the content of the cached tooltip does not match the value of this Tooltip object and
               * we know that this tooltip should be hidden. See @W-12512833
               */
              if (activeTooltip !== this) {
                this.hide(false);
                return;
              }
              this.startPositioning().then(() => {
                /*
                 * Once positioning is complete, add the listener to react when the mouse leaves the tooltip.
                 * Cannot be added before, or the tooltip will flicker and hide if the mouse is in the same
                 * position as the tooltip and the user tabs onto the tooltip. This cannot be managed inside
                 * the primitive-bubble, or the ResizeObserver will not be reset correctly.
                 */
                if (this._initialResize) {
                  tooltip.addEventListener('mouseleave', this.hide);
                  this._initialResize = false;
                }
              });
            }
          });
        }
        return this._resizeObserver;
      }
      show(ev) {
        if (this._disabled || this._visible) {
          return;
        }
        if (activeTooltip && activeTooltip !== this && activeTooltip._visible) {
          activeTooltip.hide(false);
        }
        activeTooltip = this;
        this._isFocusEvent = ev && (ev.type === 'focus' ? true : false);
        this._visible = true;
        this._initialResize = true;
        const tooltip = this._element();
        tooltip.visible = this._visible;
        tooltip.content = this._value;
        if (this._ariaObserver && this._root && this._root.isConnected) {
          this._ariaObserver.sync();
        }
        this.startPositioning();
        document.addEventListener('keydown', this.handleEscape);
        document.addEventListener('touchstart', this.handleDocumentTouch);
        this.resizeObserver.observe(tooltip);
      }

      /**
       * Hides the tooltip
       *
       * @param {*} hideBubble the primitive bubble is a shared instance, it may not be desirable to hide it
       * if the current tooltip is no longer using it.
       */
      hide(hideBubble = true) {
        this._visible = false;
        const tooltip = this._element();
        if (hideBubble) {
          tooltip.visible = this._visible;
        }
        this.stopPositioning();
        document.removeEventListener('touchstart', this.handleDocumentTouch);
        document.removeEventListener('keydown', this.handleEscape);
        tooltip.removeEventListener('mouseleave', this.hide);
        this.resizeObserver.unobserve(tooltip);
        activeTooltip = null;
      }
      toggle() {
        if (this._visible) {
          this.hide();
        } else {
          this.show();
        }
      }
      get value() {
        return this._value;
      }
      set value(value) {
        this._value = value;
        this._disabled = !value;
      }
      get initialized() {
        return this._initialized;
      }
      get visible() {
        return this._visible;
      }
      startPositioning() {
        if (!this._autoPosition) {
          this._autoPosition = new positionLibrary.AutoPosition(this._root);
        }

        // The lightning-helptext component was originally left aligned.
        const align = {
          horizontal: this._config.align.horizontal || positionLibrary.Direction.Left,
          vertical: this._config.align.vertical || positionLibrary.Direction.Bottom
        };
        const targetAlign = {
          horizontal: this._config.targetAlign.horizontal || positionLibrary.Direction.Left,
          vertical: this._config.targetAlign.vertical || positionLibrary.Direction.Top
        };

        // Pads the tooltip so its nubbin is at the center of the target element.
        const targetBox = this._target().getBoundingClientRect();
        const padLeft = targetBox.width * 0.5 - NUBBIN_OFFSET;
        return this._autoPosition.start({
          target: this._target,
          element: this._element,
          align,
          targetAlign,
          autoFlip: true,
          padTop: NUBBIN_SIZE,
          padLeft
        }).then(autoPositionUpdater => {
          // The calculation above may have flipped the alignment of the tooltip. When the
          // tooltip changes alignment we need to update the nubbin class to have it draw in
          // the appropriate place.
          if (autoPositionUpdater) {
            const tooltip = this._element();
            tooltip.align = autoPositionUpdater.config.align;
            tooltip.visible = this._visible;
          }
        });
      }
      stopPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }
      _buildResizeObserver(callback) {
        if (isResizeObserverSupported()) {
          return new ResizeObserver(callback);
        }
        return {
          observe() {},
          unobserve() {}
        };
      }
    }

    Object.defineProperty(exports, 'Direction', {
        enumerable: true,
        get: function () { return positionLibrary.Direction; }
    });
    exports.BUBBLE_PREFIX = BUBBLE_PREFIX;
    exports.Tooltip = Tooltip;
    exports.TooltipType = TooltipType;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/iconUtils', ['exports', 'lightning/configProvider'], (function (exports, configProvider) {

    const iconColors = {
      "standard": {
        "header_discounts": "rgb(92, 92, 92)",
        "contact": "rgb(150, 2, 199)",
        "prep_flow": "rgb(255, 83, 138)",
        "crypto_transaction": "rgb(255, 93, 45)",
        "multi_select_checkbox": "rgb(147, 147, 147)",
        "work_order": "rgb(6, 165, 154)",
        "post": "rgb(27, 150, 255)",
        "global_constant": "rgb(16, 124, 173)",
        "change_request": "rgb(5, 103, 100)",
        "indicator_performance_period": "rgb(3, 45, 96)",
        "data_cloud": "rgb(90, 27, 169)",
        "carousel": "rgb(59, 167, 85)",
        "account_score": "rgb(88, 103, 232)",
        "work_contract": "rgb(27, 150, 255)",
        "impact_strategy_assignment": "rgb(6, 165, 154)",
        "resource_skill": "rgb(59, 167, 85)",
        "system_and_global_variable": "rgb(16, 124, 173)",
        "segments": "rgb(255, 93, 45)",
        "account_info": "rgb(88, 103, 232)",
        "prompt_builder": "rgb(47, 44, 183)",
        "goals": "rgb(27, 150, 255)",
        "tour_check": "rgb(144, 80, 233)",
        "adjust_value": "rgb(59, 167, 85)",
        "case_wrap_up": "rgb(255, 93, 45)",
        "investment_account": "rgb(59, 167, 85)",
        "store": "rgb(57, 101, 71)",
        "slider": "rgb(147, 147, 147)",
        "output": "rgb(16, 124, 173)",
        "medication_ingredient": "rgb(6, 165, 154)",
        "store_group": "rgb(27, 150, 255)",
        "all": "rgb(16, 124, 173)",
        "service_territory_policy": "rgb(27, 150, 255)",
        "slack_conversations": "rgb(72, 26, 84)",
        "picklist_choice": "rgb(16, 124, 173)",
        "choice": "rgb(16, 124, 173)",
        "funding_requirement": "rgb(57, 101, 71)",
        "your_account": "rgb(1, 68, 134)",
        "app": "rgb(255, 93, 45)",
        "default": "rgb(147, 147, 147)",
        "case_milestone": "rgb(255, 93, 45)",
        "operation_plan": "rgb(90, 27, 169)",
        "today": "rgb(255, 83, 138)",
        "buyer_account": "rgb(57, 101, 71)",
        "lead_list": "rgb(255, 93, 45)",
        "list_rate": "rgb(57, 101, 71)",
        "work_plan_template": "rgb(6, 165, 154)",
        "tableau": "rgb(15, 30, 60)",
        "shift": "rgb(255, 83, 138)",
        "people_score": "rgb(88, 103, 232)",
        "product_item_transaction": "rgb(255, 93, 45)",
        "person_language": "rgb(6, 165, 154)",
        "apex": "rgb(16, 124, 173)",
        "reply_text": "rgb(255, 83, 138)",
        "answer_private": "rgb(255, 93, 45)",
        "immunization": "rgb(255, 83, 138)",
        "asset_downtime_period": "rgb(16, 124, 173)",
        "opportunity_contact role": "rgb(88, 103, 232)",
        "retail_banking_console": "rgb(6, 165, 154)",
        "channel_program_members": "rgb(6, 165, 154)",
        "apps_admin": "rgb(88, 103, 232)",
        "metric_definition": "rgb(16, 124, 173)",
        "datadotcom": "rgb(27, 150, 255)",
        "settings": "rgb(57, 101, 71)",
        "network_contract": "rgb(59, 167, 85)",
        "crypto_transaction_envelope_item": "rgb(16, 124, 173)",
        "product_item": "rgb(27, 150, 255)",
        "metrics": "rgb(27, 150, 255)",
        "topic2": "rgb(27, 150, 255)",
        "partner_fund_allocation": "rgb(6, 165, 154)",
        "care_request_reviewer": "rgb(59, 167, 85)",
        "indicator_definition": "rgb(3, 45, 96)",
        "crypto_transaction_envelope_change_snapshot": "rgb(203, 101, 255)",
        "operation_plan_step_execution": "rgb(90, 27, 169)",
        "approval": "rgb(59, 167, 85)",
        "work_queue": "rgb(16, 124, 173)",
        "iot_orchestrations": "rgb(16, 124, 173)",
        "visualforce_page": "rgb(255, 93, 45)",
        "person_account": "rgb(88, 103, 232)",
        "entity": "rgb(255, 93, 45)",
        "dynamic_highlights_panel": "rgb(59, 167, 85)",
        "service_territory_location": "rgb(88, 103, 232)",
        "qualifications": "rgb(57, 101, 71)",
        "document_preview": "rgb(182, 5, 84)",
        "tax_treatment": "rgb(57, 101, 71)",
        "entitlement_policy": "rgb(57, 101, 71)",
        "form": "rgb(59, 167, 85)",
        "query_editor": "rgb(126, 38, 0)",
        "visualization": "rgb(27, 150, 255)",
        "products": "rgb(90, 27, 169)",
        "prompt": "rgb(6, 165, 154)",
        "order_item": "rgb(27, 150, 255)",
        "read_receipts": "rgb(59, 167, 85)",
        "javascript_button": "rgb(255, 93, 45)",
        "maintenance_asset": "rgb(16, 124, 173)",
        "work_plan_rule": "rgb(6, 165, 154)",
        "loop": "rgb(255, 93, 45)",
        "portal_roles_and_subordinates": "rgb(27, 150, 255)",
        "work_capacity_limit": "rgb(16, 124, 173)",
        "employee_organization": "rgb(27, 150, 255)",
        "workforce_engagement": "rgb(182, 5, 84)",
        "constant": "rgb(16, 124, 173)",
        "marketing_actions": "rgb(59, 167, 85)",
        "case_transcript": "rgb(255, 93, 45)",
        "list_fee": "rgb(47, 44, 183)",
        "timesheet_entry": "rgb(59, 167, 85)",
        "key_dates": "rgb(27, 150, 255)",
        "multi_picklist": "rgb(147, 147, 147)",
        "facility_bed": "rgb(255, 83, 138)",
        "product_workspace": "rgb(57, 101, 71)",
        "visit_templates": "rgb(27, 150, 255)",
        "restriction_policy": "rgb(27, 150, 255)",
        "task": "rgb(59, 167, 85)",
        "scheduling_workspace_territory": "rgb(255, 83, 138)",
        "answer_best": "rgb(255, 93, 45)",
        "attach": "rgb(144, 80, 233)",
        "asset_action": "rgb(16, 124, 173)",
        "section": "rgb(147, 147, 147)",
        "service_request": "rgb(27, 150, 255)",
        "orders": "rgb(27, 150, 255)",
        "propagation_policy": "rgb(27, 150, 255)",
        "budget": "rgb(16, 124, 173)",
        "report_type": "rgb(59, 167, 85)",
        "past_chat": "rgb(255, 93, 45)",
        "crypto_transaction_envelope_change_log": "rgb(8, 73, 104)",
        "feedback": "rgb(27, 150, 255)",
        "action_list_component": "rgb(16, 124, 173)",
        "opportunity_splits": "rgb(255, 93, 45)",
        "location_permit": "rgb(6, 165, 154)",
        "app_form_product_participant": "rgb(126, 38, 0)",
        "messaging_user": "rgb(6, 165, 154)",
        "filter_criteria": "rgb(16, 124, 173)",
        "tax_policy": "rgb(57, 101, 71)",
        "trailhead": "rgb(3, 45, 96)",
        "entitlements": "rgb(144, 80, 233)",
        "checkout": "rgb(57, 101, 71)",
        "formula": "rgb(16, 124, 173)",
        "case_log_a_call": "rgb(255, 93, 45)",
        "shift_pattern_entry": "rgb(255, 83, 138)",
        "thanks_loading": "rgb(147, 147, 147)",
        "job_family": "rgb(27, 150, 255)",
        "service_appointment_capacity_usage": "rgb(16, 124, 173)",
        "inbox": "rgb(16, 124, 173)",
        "channel_program_levels": "rgb(6, 165, 154)",
        "letterhead": "rgb(27, 150, 255)",
        "promotions_workspace": "rgb(57, 101, 71)",
        "nft_settings": "rgb(255, 83, 138)",
        "asset_hierarchy": "rgb(16, 124, 173)",
        "email_chatter": "rgb(255, 93, 45)",
        "custody_chain_entry": "rgb(6, 165, 154)",
        "document_reference": "rgb(16, 124, 173)",
        "announcement": "rgb(27, 150, 255)",
        "field_sales": "rgb(144, 80, 233)",
        "bot": "rgb(16, 124, 173)",
        "macros": "rgb(6, 165, 154)",
        "dashboard_ea": "rgb(88, 103, 232)",
        "job_profile": "rgb(255, 83, 138)",
        "steps": "rgb(16, 124, 173)",
        "snippet_alt": "rgb(16, 124, 173)",
        "asset_relationship": "rgb(255, 93, 45)",
        "high_velocity_sales": "rgb(6, 165, 154)",
        "brand": "rgb(88, 103, 232)",
        "historical_adherence": "rgb(6, 165, 154)",
        "visits": "rgb(27, 150, 255)",
        "einstein_replies": "rgb(255, 83, 138)",
        "coaching": "rgb(255, 83, 138)",
        "record_lookup": "rgb(255, 83, 138)",
        "product_service_campaign_item": "rgb(16, 124, 173)",
        "scheduling_constraint": "rgb(255, 83, 138)",
        "lightning_component": "rgb(147, 147, 147)",
        "search": "rgb(27, 150, 255)",
        "connected_apps": "rgb(88, 103, 232)",
        "swarm_request": "rgb(255, 83, 138)",
        "work_type_group": "rgb(16, 124, 173)",
        "education": "rgb(27, 150, 255)",
        "work_type": "rgb(16, 124, 173)",
        "travel_mode": "rgb(59, 167, 85)",
        "environment_hub": "rgb(16, 124, 173)",
        "identifier": "rgb(255, 93, 45)",
        "cms": "rgb(59, 167, 85)",
        "call_coaching": "rgb(27, 150, 255)",
        "salesforce_cms": "rgb(16, 124, 173)",
        "price_sheet": "rgb(59, 167, 85)",
        "thanks": "rgb(255, 83, 138)",
        "service_territory_member": "rgb(88, 103, 232)",
        "work_forecast": "rgb(255, 93, 45)",
        "crypto_product_category_wallet_role": "rgb(5, 103, 100)",
        "program_cohort_member": "rgb(27, 150, 255)",
        "holiday_operating_hours": "rgb(27, 150, 255)",
        "uploaded_model": "rgb(6, 165, 154)",
        "user_role": "rgb(59, 167, 85)",
        "observation_component": "rgb(88, 103, 232)",
        "orchestrator": "rgb(16, 124, 173)",
        "work_capacity_usage": "rgb(16, 124, 173)",
        "record_create": "rgb(255, 83, 138)",
        "campaign_members": "rgb(255, 93, 45)",
        "retail_banking": "rgb(6, 165, 154)",
        "product_service_campaign": "rgb(16, 124, 173)",
        "portal_roles": "rgb(255, 93, 45)",
        "operation_plan_step": "rgb(90, 27, 169)",
        "calibration": "rgb(6, 165, 154)",
        "answer_public": "rgb(255, 93, 45)",
        "robot": "rgb(47, 44, 183)",
        "display_text": "rgb(147, 147, 147)",
        "product_consumed_state": "rgb(6, 165, 154)",
        "budget_category_value": "rgb(27, 150, 255)",
        "scheduling_workspace": "rgb(255, 83, 138)",
        "unmatched": "rgb(27, 150, 255)",
        "partners": "rgb(6, 165, 154)",
        "email_iq": "rgb(88, 103, 232)",
        "mulesoft": "rgb(27, 150, 255)",
        "service_crew": "rgb(255, 93, 45)",
        "payment_gateway": "rgb(5, 103, 100)",
        "voice_call": "rgb(59, 167, 85)",
        "cancel_checkout": "rgb(147, 147, 147)",
        "asset_warranty": "rgb(16, 124, 173)",
        "resource_capacity": "rgb(59, 167, 85)",
        "repeaters": "rgb(6, 165, 154)",
        "setup_modal": "rgb(16, 124, 173)",
        "channel_programs": "rgb(6, 165, 154)",
        "quip": "rgb(255, 93, 45)",
        "quip_sheet": "rgb(59, 167, 85)",
        "timeslot": "rgb(255, 93, 45)",
        "live_chat": "rgb(255, 93, 45)",
        "service_request_detail": "rgb(6, 165, 154)",
        "med_rec_statement_recommendation": "rgb(88, 103, 232)",
        "job_position": "rgb(27, 150, 255)",
        "sobject_collection": "rgb(16, 124, 173)",
        "user": "rgb(16, 124, 173)",
        "client": "rgb(6, 165, 154)",
        "screen": "rgb(27, 150, 255)",
        "portal": "rgb(59, 167, 85)",
        "partner_fund_request": "rgb(6, 165, 154)",
        "asset_audit": "rgb(144, 80, 233)",
        "resource_preference": "rgb(59, 167, 85)",
        "record_consent": "rgb(255, 83, 138)",
        "first_non_empty": "rgb(255, 83, 138)",
        "rate_adjustment": "rgb(182, 5, 84)",
        "impact_strategy": "rgb(6, 165, 154)",
        "customer_360": "rgb(3, 45, 96)",
        "employee_job": "rgb(27, 150, 255)",
        "resource_absence": "rgb(59, 167, 85)",
        "registered_model": "rgb(59, 167, 85)",
        "panel_detail": "rgb(8, 73, 104)",
        "text_template": "rgb(16, 124, 173)",
        "entitlement_template": "rgb(88, 103, 232)",
        "lightning_usage": "rgb(88, 103, 232)",
        "volume_discounts": "rgb(255, 93, 45)",
        "indicator_result": "rgb(3, 45, 96)",
        "product_transfer_state": "rgb(255, 93, 45)",
        "medication_dispense": "rgb(27, 150, 255)",
        "entitlement": "rgb(88, 103, 232)",
        "empty": "rgb(147, 147, 147)",
        "text": "rgb(147, 147, 147)",
        "delegated_account": "rgb(57, 101, 71)",
        "fulfillment_order": "rgb(147, 147, 147)",
        "case_email": "rgb(255, 93, 45)",
        "account": "rgb(88, 103, 232)",
        "coupon_codes": "rgb(57, 101, 71)",
        "assignment": "rgb(255, 93, 45)",
        "wealth_management_console": "rgb(6, 165, 154)",
        "task2": "rgb(59, 167, 85)",
        "patient_medication_dosage": "rgb(6, 165, 154)",
        "code_playground": "rgb(16, 124, 173)",
        "social": "rgb(255, 83, 138)",
        "endorsement": "rgb(88, 103, 232)",
        "folder": "rgb(88, 103, 232)",
        "service_crew_member": "rgb(88, 103, 232)",
        "variation_attribute_setup": "rgb(57, 101, 71)",
        "real_time": "rgb(255, 93, 45)",
        "connect_wallet": "rgb(182, 5, 84)",
        "flow": "rgb(16, 124, 173)",
        "recipe": "rgb(16, 124, 173)",
        "expense_report_entry": "rgb(47, 44, 183)",
        "employee": "rgb(27, 150, 255)",
        "omni_supervisor": "rgb(88, 103, 232)",
        "capacity_plan": "rgb(255, 83, 138)",
        "asset_object": "rgb(16, 124, 173)",
        "product": "rgb(144, 80, 233)",
        "crypto_transaction_envelope": "rgb(5, 103, 100)",
        "topic": "rgb(27, 150, 255)",
        "product_required": "rgb(255, 83, 138)",
        "dynamic_record_choice": "rgb(16, 124, 173)",
        "aggregation_policy": "rgb(27, 150, 255)",
        "warranty_term": "rgb(16, 124, 173)",
        "process": "rgb(16, 124, 173)",
        "swarm_session": "rgb(255, 83, 138)",
        "people": "rgb(6, 165, 154)",
        "medication": "rgb(59, 167, 85)",
        "reward": "rgb(255, 83, 138)",
        "employee_contact": "rgb(27, 150, 255)",
        "bundle_policy": "rgb(27, 150, 255)",
        "performance": "rgb(255, 93, 45)",
        "promotions": "rgb(57, 101, 71)",
        "case_comment": "rgb(255, 93, 45)",
        "price_book_entries": "rgb(57, 101, 71)",
        "sales_channel": "rgb(16, 124, 173)",
        "apex_plugin": "rgb(16, 124, 173)",
        "party_profile": "rgb(90, 27, 169)",
        "campaign": "rgb(144, 80, 233)",
        "contact_request": "rgb(255, 93, 45)",
        "business_hours": "rgb(59, 167, 85)",
        "metric": "rgb(6, 165, 154)",
        "evernote": "rgb(59, 167, 85)",
        "variation_products": "rgb(57, 101, 71)",
        "program_cohort": "rgb(27, 150, 255)",
        "trailhead_alt": "rgb(3, 45, 96)",
        "service_territory": "rgb(88, 103, 232)",
        "customer_lifecycle_analytics": "rgb(88, 103, 232)",
        "code_set": "rgb(16, 124, 173)",
        "case": "rgb(255, 83, 138)",
        "slack": "rgb(74, 21, 75)",
        "currency": "rgb(147, 147, 147)",
        "record": "rgb(59, 167, 85)",
        "code_set_bundle": "rgb(16, 124, 173)",
        "queue": "rgb(16, 124, 173)",
        "schedule_objective": "rgb(16, 124, 173)",
        "contract_line_item": "rgb(59, 167, 85)",
        "skill_entity": "rgb(88, 103, 232)",
        "funding_award_adjustment": "rgb(27, 150, 255)",
        "skill": "rgb(255, 93, 45)",
        "operating_hours": "rgb(27, 150, 255)",
        "crypto_product": "rgb(144, 80, 233)",
        "taxonomy": "rgb(27, 150, 255)",
        "operation_plan_request": "rgb(90, 27, 169)",
        "custom": "rgb(147, 147, 147)",
        "related_list": "rgb(6, 165, 154)",
        "bot_training": "rgb(16, 124, 173)",
        "case_change_status": "rgb(255, 93, 45)",
        "insurance_console": "rgb(6, 165, 154)",
        "dashboard_component": "rgb(88, 103, 232)",
        "incident": "rgb(182, 5, 84)",
        "contract": "rgb(57, 101, 71)",
        "policy": "rgb(6, 165, 154)",
        "sobject": "rgb(147, 147, 147)",
        "whatsapp": "rgb(59, 167, 85)",
        "sales_cadence_target": "rgb(16, 124, 173)",
        "photo": "rgb(147, 147, 147)",
        "apps": "rgb(27, 150, 255)",
        "timesheet": "rgb(88, 103, 232)",
        "drafts": "rgb(27, 150, 255)",
        "outcome": "rgb(255, 93, 45)",
        "discounts": "rgb(57, 101, 71)",
        "work_order_item": "rgb(27, 150, 255)",
        "pricebook": "rgb(144, 80, 233)",
        "scan_card": "rgb(255, 93, 45)",
        "note": "rgb(182, 5, 84)",
        "serialized_product_transaction": "rgb(27, 150, 255)",
        "shift_pattern": "rgb(255, 83, 138)",
        "buyer_group": "rgb(57, 101, 71)",
        "price_adjustment_schedule": "rgb(255, 83, 138)",
        "product_quantity_rules": "rgb(57, 101, 71)",
        "medication_reconciliation": "rgb(16, 124, 173)",
        "procedure": "rgb(27, 150, 255)",
        "opportunity": "rgb(255, 93, 45)",
        "news": "rgb(88, 103, 232)",
        "sort_policy": "rgb(27, 150, 255)",
        "display_rich_text": "rgb(147, 147, 147)",
        "strategy": "rgb(59, 167, 85)",
        "time_period": "rgb(3, 45, 96)",
        "call_history": "rgb(255, 93, 45)",
        "webcart": "rgb(57, 101, 71)",
        "serialized_product": "rgb(27, 150, 255)",
        "tax_rate": "rgb(57, 101, 71)",
        "report": "rgb(6, 165, 154)",
        "customer_workspace": "rgb(57, 101, 71)",
        "groups": "rgb(27, 150, 255)",
        "data_model": "rgb(255, 83, 138)",
        "dashboard": "rgb(47, 44, 183)",
        "generic_loading": "rgb(147, 147, 147)",
        "number_input": "rgb(147, 147, 147)",
        "toggle": "rgb(147, 147, 147)",
        "address": "rgb(59, 167, 85)",
        "price_books": "rgb(57, 101, 71)",
        "entity_milestone": "rgb(255, 93, 45)",
        "contract_line_outcome": "rgb(57, 101, 71)",
        "wealth_management": "rgb(6, 165, 154)",
        "customers": "rgb(6, 165, 154)",
        "disclosure_and_compliance": "rgb(6, 165, 154)",
        "workspace": "rgb(255, 93, 45)",
        "story": "rgb(16, 124, 173)",
        "service_appointment": "rgb(88, 103, 232)",
        "maintenance_plan": "rgb(16, 124, 173)",
        "contract_line_outcome_data": "rgb(57, 101, 71)",
        "data_integration_hub": "rgb(16, 124, 173)",
        "person_name": "rgb(88, 103, 232)",
        "work_plan_template_entry": "rgb(6, 165, 154)",
        "hierarchy": "rgb(6, 165, 154)",
        "custom_component_task": "rgb(88, 103, 232)",
        "partner_marketing_budget": "rgb(6, 165, 154)",
        "asset_action_source": "rgb(16, 124, 173)",
        "skill_requirement": "rgb(255, 93, 45)",
        "filter_criteria_rule": "rgb(16, 124, 173)",
        "no_code_model": "rgb(27, 150, 255)",
        "location": "rgb(59, 167, 85)",
        "promotion_tiers": "rgb(57, 101, 71)",
        "radio_button": "rgb(147, 147, 147)",
        "avatar_loading": "rgb(147, 147, 147)",
        "article": "rgb(255, 93, 45)",
        "custody_entry_verification": "rgb(6, 165, 154)",
        "learner_program": "rgb(255, 93, 45)",
        "invocable_action": "rgb(16, 124, 173)",
        "device": "rgb(88, 103, 232)",
        "app_form_participant": "rgb(5, 103, 100)",
        "proposition": "rgb(27, 150, 255)",
        "snippets": "rgb(6, 165, 154)",
        "customer_portal_users": "rgb(27, 150, 255)",
        "cost_model": "rgb(3, 45, 96)",
        "path_experiment": "rgb(221, 122, 1)",
        "actions_and_buttons": "rgb(255, 93, 45)",
        "record_update": "rgb(255, 83, 138)",
        "shift_type": "rgb(255, 83, 138)",
        "water": "rgb(88, 103, 232)",
        "log_a_call": "rgb(6, 165, 154)",
        "crypto_wallet": "rgb(57, 101, 71)",
        "crypto_wallet_group": "rgb(16, 124, 173)",
        "quotes": "rgb(59, 167, 85)",
        "data_governance": "rgb(57, 101, 71)",
        "question_feed": "rgb(255, 93, 45)",
        "attribute_based_pricing": "rgb(182, 5, 84)",
        "walkthroughs": "rgb(6, 165, 154)",
        "kanban": "rgb(27, 150, 255)",
        "work_plan": "rgb(6, 165, 154)",
        "shift_template": "rgb(255, 83, 138)",
        "merge": "rgb(255, 93, 45)",
        "expense": "rgb(47, 44, 183)",
        "dataset": "rgb(144, 80, 233)",
        "work_summary": "rgb(182, 5, 84)",
        "shift_preference": "rgb(255, 83, 138)",
        "product_consumed": "rgb(6, 165, 154)",
        "canvas": "rgb(147, 147, 147)",
        "bundles_pricing": "rgb(27, 150, 255)",
        "forecasts": "rgb(59, 167, 85)",
        "relationship": "rgb(27, 150, 255)",
        "tour": "rgb(144, 80, 233)",
        "service_resource": "rgb(88, 103, 232)",
        "filter": "rgb(47, 44, 183)",
        "sales_path": "rgb(16, 124, 173)",
        "shift_scheduling_operation": "rgb(255, 83, 138)",
        "data_graph": "rgb(6, 165, 154)",
        "data_lake_objects": "rgb(90, 27, 169)",
        "events": "rgb(27, 150, 255)",
        "data_mapping": "rgb(3, 45, 96)",
        "sms": "rgb(59, 167, 85)",
        "impact_outcome": "rgb(6, 165, 154)",
        "rtc_presence": "rgb(6, 165, 154)",
        "avatar": "rgb(27, 150, 255)",
        "record_delete": "rgb(255, 83, 138)",
        "solution": "rgb(59, 167, 85)",
        "nft_studio": "rgb(88, 103, 232)",
        "manual_discounts": "rgb(16, 124, 173)",
        "agent_home": "rgb(3, 45, 96)",
        "linked": "rgb(6, 165, 154)",
        "partner_fund_claim": "rgb(6, 165, 154)",
        "individual": "rgb(27, 150, 255)",
        "custom_notification": "rgb(27, 150, 255)",
        "contract_payment": "rgb(144, 80, 233)",
        "date_input": "rgb(147, 147, 147)",
        "catalog": "rgb(57, 101, 71)",
        "template": "rgb(27, 150, 255)",
        "activation_target": "rgb(203, 101, 255)",
        "selling_model": "rgb(144, 80, 233)",
        "shipment": "rgb(88, 103, 232)",
        "budget_allocation": "rgb(16, 124, 173)",
        "custody_override": "rgb(6, 165, 154)",
        "record_signature_task": "rgb(255, 83, 138)",
        "event": "rgb(203, 101, 255)",
        "insurance": "rgb(6, 165, 154)",
        "live_chat_visitor": "rgb(255, 93, 45)",
        "textarea": "rgb(147, 147, 147)",
        "work_step": "rgb(6, 165, 154)",
        "picklist_type": "rgb(147, 147, 147)",
        "survey": "rgb(16, 124, 173)",
        "operation_plan_execution": "rgb(90, 27, 169)",
        "link": "rgb(27, 150, 255)",
        "messaging_session": "rgb(6, 165, 154)",
        "video": "rgb(144, 80, 233)",
        "list_email": "rgb(147, 147, 147)",
        "med_rec_recommendation": "rgb(6, 165, 154)",
        "crypto_wallet_group_item": "rgb(144, 80, 233)",
        "recycle_bin": "rgb(27, 150, 255)",
        "document": "rgb(147, 147, 147)",
        "product_transfer": "rgb(255, 93, 45)",
        "instore_locations": "rgb(16, 124, 173)",
        "recent": "rgb(27, 150, 255)",
        "practitioner_role": "rgb(255, 83, 138)",
        "password": "rgb(147, 147, 147)",
        "datashare_target": "rgb(255, 83, 138)",
        "expense_report": "rgb(47, 44, 183)",
        "branch_merge": "rgb(255, 83, 138)",
        "ai_accelerator_card": "rgb(16, 124, 173)",
        "insights": "rgb(203, 101, 255)",
        "budget_period": "rgb(150, 2, 199)",
        "market": "rgb(57, 101, 71)",
        "dropbox": "rgb(27, 150, 255)",
        "unified_health_score": "rgb(88, 103, 232)",
        "bill_of_materials": "rgb(255, 93, 45)",
        "calculated_insights": "rgb(27, 150, 255)",
        "employee_job_position": "rgb(27, 150, 255)",
        "file": "rgb(147, 147, 147)",
        "outcome_activity": "rgb(6, 165, 154)",
        "currency_input": "rgb(147, 147, 147)",
        "data_transforms": "rgb(88, 103, 232)",
        "variable": "rgb(16, 124, 173)",
        "team_member": "rgb(255, 93, 45)",
        "pricing_workspace": "rgb(57, 101, 71)",
        "agent_session": "rgb(255, 93, 45)",
        "guidance_center": "rgb(88, 103, 232)",
        "crypto_category_wallet_group": "rgb(182, 5, 84)",
        "group_loading": "rgb(147, 147, 147)",
        "lead": "rgb(27, 150, 255)",
        "email": "rgb(147, 147, 147)",
        "service_contract": "rgb(88, 103, 232)",
        "decision": "rgb(255, 93, 45)",
        "promotion_segments": "rgb(57, 101, 71)",
        "duration_downscale": "rgb(27, 150, 255)",
        "snippet": "rgb(88, 103, 232)",
        "entitlement_process": "rgb(88, 103, 232)",
        "price_adjustment_matrix": "rgb(6, 165, 154)",
        "contact_list": "rgb(88, 103, 232)",
        "planogram": "rgb(27, 150, 255)",
        "activations": "rgb(144, 80, 233)",
        "scheduling_policy": "rgb(255, 83, 138)",
        "channel_program_history": "rgb(6, 165, 154)",
        "question_best": "rgb(255, 93, 45)",
        "omni_channel": "rgb(16, 124, 173)",
        "collection_variable": "rgb(16, 124, 173)",
        "indicator_assignment": "rgb(3, 45, 96)",
        "procedure_detail": "rgb(6, 165, 154)",
        "sales_value": "rgb(27, 150, 255)",
        "knowledge": "rgb(203, 101, 255)",
        "datashares": "rgb(150, 2, 199)",
        "date_time": "rgb(147, 147, 147)",
        "category": "rgb(57, 101, 71)",
        "maintenance_work_rule": "rgb(16, 124, 173)",
        "data_streams": "rgb(255, 83, 138)",
        "textbox": "rgb(147, 147, 147)",
        "lead_insights": "rgb(27, 150, 255)",
        "waits": "rgb(255, 93, 45)",
        "concur": "rgb(6, 165, 154)",
        "feed": "rgb(27, 150, 255)",
        "sort": "rgb(47, 44, 183)",
        "messaging_conversation": "rgb(6, 165, 154)",
        "service_report": "rgb(88, 103, 232)",
        "iot_context": "rgb(16, 124, 173)",
        "price_adjustment_tier": "rgb(3, 45, 96)",
        "asset_state_period": "rgb(16, 124, 173)",
        "call": "rgb(255, 93, 45)",
        "collection": "rgb(255, 93, 45)",
        "stage": "rgb(255, 93, 45)",
        "sales_cadence": "rgb(16, 124, 173)",
        "product_request_line_item": "rgb(59, 167, 85)",
        "return_order_line_item": "rgb(6, 165, 154)",
        "chart": "rgb(6, 165, 154)",
        "customer": "rgb(57, 101, 71)",
        "buyer_group_qualifier": "rgb(57, 101, 71)",
        "quick_text": "rgb(27, 150, 255)",
        "home": "rgb(255, 83, 138)",
        "sossession": "rgb(16, 124, 173)",
        "digital_verification_config": "rgb(47, 44, 183)",
        "aggregate": "rgb(27, 150, 255)",
        "bundle_config": "rgb(27, 150, 255)",
        "title_party": "rgb(5, 103, 100)",
        "employee_asset": "rgb(27, 150, 255)",
        "process_exception": "rgb(255, 93, 45)",
        "product_warranty_term": "rgb(144, 80, 233)",
        "problem": "rgb(255, 93, 45)",
        "stage_collection": "rgb(255, 93, 45)",
        "product_request": "rgb(59, 167, 85)",
        "logging": "rgb(16, 124, 173)",
        "digital_verification_config_group": "rgb(47, 44, 183)",
        "assigned_resource": "rgb(59, 167, 85)",
        "return_order": "rgb(6, 165, 154)",
        "poll": "rgb(27, 150, 255)",
        "household": "rgb(6, 165, 154)",
        "work_step_template": "rgb(6, 165, 154)",
        "medication_statement": "rgb(27, 150, 255)",
        "labels": "rgb(59, 167, 85)"
      },
      "custom": {
        "custom110": "rgb(242, 139, 0)",
        "custom100": "rgb(225, 93, 118)",
        "custom111": "rgb(242, 139, 0)",
        "custom1": "rgb(255, 123, 132)",
        "custom101": "rgb(242, 139, 0)",
        "custom112": "rgb(242, 139, 0)",
        "custom2": "rgb(207, 208, 92)",
        "custom102": "rgb(242, 139, 0)",
        "custom113": "rgb(242, 139, 0)",
        "custom90": "rgb(34, 164, 138)",
        "custom3": "rgb(236, 180, 108)",
        "custom103": "rgb(242, 139, 0)",
        "custom80": "rgb(101, 154, 213)",
        "custom91": "rgb(191, 123, 102)",
        "custom4": "rgb(225, 217, 81)",
        "custom104": "rgb(242, 139, 0)",
        "custom70": "rgb(231, 105, 180)",
        "custom81": "rgb(218, 98, 127)",
        "custom92": "rgb(81, 126, 130)",
        "custom5": "rgb(159, 219, 102)",
        "custom105": "rgb(242, 139, 0)",
        "custom60": "rgb(191, 90, 136)",
        "custom71": "rgb(227, 110, 227)",
        "custom82": "rgb(209, 91, 151)",
        "custom93": "rgb(144, 77, 76)",
        "custom6": "rgb(84, 196, 115)",
        "custom106": "rgb(242, 139, 0)",
        "custom50": "rgb(73, 188, 211)",
        "custom61": "rgb(245, 115, 118)",
        "custom72": "rgb(141, 155, 251)",
        "custom83": "rgb(231, 128, 111)",
        "custom94": "rgb(67, 156, 186)",
        "custom7": "rgb(106, 137, 229)",
        "custom107": "rgb(242, 139, 0)",
        "custom40": "rgb(131, 199, 94)",
        "custom51": "rgb(216, 199, 96)",
        "custom62": "rgb(107, 146, 220)",
        "custom73": "rgb(103, 158, 240)",
        "custom84": "rgb(246, 112, 123)",
        "custom95": "rgb(139, 207, 106)",
        "custom8": "rgb(80, 206, 185)",
        "custom108": "rgb(242, 139, 0)",
        "custom30": "rgb(245, 159, 113)",
        "custom41": "rgb(67, 181, 181)",
        "custom52": "rgb(238, 142, 111)",
        "custom63": "rgb(124, 207, 96)",
        "custom74": "rgb(65, 200, 160)",
        "custom85": "rgb(242, 104, 145)",
        "custom96": "rgb(109, 157, 227)",
        "custom9": "rgb(107, 158, 226)",
        "custom109": "rgb(242, 139, 0)",
        "custom20": "rgb(72, 199, 200)",
        "custom31": "rgb(235, 104, 127)",
        "custom42": "rgb(207, 208, 91)",
        "custom53": "rgb(243, 110, 131)",
        "custom64": "rgb(97, 143, 216)",
        "custom75": "rgb(205, 159, 101)",
        "custom86": "rgb(226, 96, 171)",
        "custom97": "rgb(221, 96, 133)",
        "custom10": "rgb(100, 136, 227)",
        "custom21": "rgb(138, 122, 237)",
        "custom32": "rgb(56, 195, 147)",
        "custom43": "rgb(127, 147, 249)",
        "custom54": "rgb(234, 112, 177)",
        "custom65": "rgb(242, 121, 171)",
        "custom76": "rgb(219, 109, 122)",
        "custom87": "rgb(216, 118, 229)",
        "custom98": "rgb(225, 190, 92)",
        "custom11": "rgb(135, 132, 234)",
        "custom22": "rgb(139, 133, 249)",
        "custom33": "rgb(151, 207, 93)",
        "custom44": "rgb(200, 202, 88)",
        "custom55": "rgb(214, 110, 224)",
        "custom66": "rgb(216, 190, 95)",
        "custom77": "rgb(181, 93, 91)",
        "custom88": "rgb(153, 111, 230)",
        "custom99": "rgb(240, 133, 110)",
        "custom12": "rgb(220, 113, 209)",
        "custom23": "rgb(176, 112, 230)",
        "custom34": "rgb(213, 138, 106)",
        "custom45": "rgb(217, 88, 121)",
        "custom56": "rgb(113, 141, 235)",
        "custom67": "rgb(248, 125, 118)",
        "custom78": "rgb(90, 149, 221)",
        "custom89": "rgb(62, 153, 190)",
        "custom13": "rgb(223, 97, 132)",
        "custom24": "rgb(229, 103, 152)",
        "custom35": "rgb(233, 99, 126)",
        "custom46": "rgb(103, 165, 231)",
        "custom57": "rgb(90, 156, 221)",
        "custom68": "rgb(242, 105, 121)",
        "custom79": "rgb(142, 211, 99)",
        "custom14": "rgb(60, 194, 179)",
        "custom25": "rgb(228, 111, 190)",
        "custom36": "rgb(212, 114, 212)",
        "custom47": "rgb(95, 204, 100)",
        "custom58": "rgb(52, 181, 157)",
        "custom69": "rgb(237, 99, 135)",
        "custom15": "rgb(247, 126, 117)",
        "custom26": "rgb(118, 152, 240)",
        "custom37": "rgb(140, 137, 242)",
        "custom48": "rgb(239, 105, 127)",
        "custom59": "rgb(227, 208, 103)",
        "custom16": "rgb(233, 175, 103)",
        "custom27": "rgb(90, 176, 210)",
        "custom38": "rgb(83, 182, 215)",
        "custom49": "rgb(226, 92, 128)",
        "custom17": "rgb(172, 211, 96)",
        "custom28": "rgb(137, 192, 89)",
        "custom39": "rgb(79, 190, 117)",
        "custom18": "rgb(77, 202, 118)",
        "custom29": "rgb(189, 210, 95)",
        "custom19": "rgb(58, 190, 177)"
      },
      "action": {
        "new_custom18": "rgb(59, 167, 85)",
        "new_custom29": "rgb(59, 167, 85)",
        "edit_groups": "rgb(6, 165, 154)",
        "new_custom9": "rgb(27, 150, 255)",
        "log_a_call": "rgb(6, 165, 154)",
        "new_custom19": "rgb(6, 165, 154)",
        "filter": "rgb(255, 83, 138)",
        "user_activation": "rgb(16, 124, 173)",
        "opportunity_competitor": "rgb(255, 93, 45)",
        "canvas": "rgb(16, 124, 173)",
        "change_record_type": "rgb(16, 124, 173)",
        "new_notebook": "rgb(255, 93, 45)",
        "docusign": "rgb(27, 150, 255)",
        "share_link": "rgb(88, 103, 232)",
        "add_file": "rgb(88, 103, 232)",
        "edit_relationship": "rgb(6, 165, 154)",
        "notebook": "rgb(255, 93, 45)",
        "new_lead": "rgb(255, 93, 45)",
        "new_custom_object": "rgb(59, 167, 85)",
        "new_account": "rgb(88, 103, 232)",
        "question_post_action": "rgb(59, 167, 85)",
        "share_file": "rgb(147, 147, 147)",
        "default_custom_object": "rgb(16, 124, 173)",
        "opportunity_team_member": "rgb(255, 93, 45)",
        "add_photo_video": "rgb(6, 165, 154)",
        "sort": "rgb(59, 167, 85)",
        "call": "rgb(6, 165, 154)",
        "concur": "rgb(6, 165, 154)",
        "reject": "rgb(6, 165, 154)",
        "share_poll": "rgb(27, 150, 255)",
        "scan_enabled": "rgb(27, 150, 255)",
        "following": "rgb(59, 167, 85)",
        "defer": "rgb(255, 83, 138)",
        "opportunity_line_item": "rgb(255, 93, 45)",
        "social_post": "rgb(255, 83, 138)",
        "share_post": "rgb(27, 150, 255)",
        "view_relationship": "rgb(27, 150, 255)",
        "adjust_value": "rgb(59, 167, 85)",
        "upload": "rgb(16, 124, 173)",
        "remove_relationship": "rgb(255, 83, 138)",
        "freeze_user": "rgb(16, 124, 173)",
        "new_person_account": "rgb(88, 103, 232)",
        "bug": "rgb(255, 83, 138)",
        "apex": "rgb(92, 92, 92)",
        "new_opportunity": "rgb(255, 93, 45)",
        "fallback": "rgb(88, 103, 232)",
        "dial_in": "rgb(88, 103, 232)",
        "approval": "rgb(6, 165, 154)",
        "change_owner": "rgb(16, 124, 173)",
        "new_task": "rgb(59, 167, 85)",
        "priority": "rgb(255, 93, 45)",
        "remove": "rgb(16, 124, 173)",
        "web_link": "rgb(27, 150, 255)",
        "leave_group": "rgb(255, 93, 45)",
        "manage_perm_sets": "rgb(16, 124, 173)",
        "close": "rgb(255, 83, 138)",
        "google_news": "rgb(255, 83, 138)",
        "announcement": "rgb(255, 93, 45)",
        "back": "rgb(6, 165, 154)",
        "new_custom90": "rgb(6, 165, 154)",
        "download": "rgb(16, 124, 173)",
        "new_custom80": "rgb(27, 150, 255)",
        "new_custom91": "rgb(147, 147, 147)",
        "search": "rgb(27, 150, 255)",
        "new_event": "rgb(255, 83, 138)",
        "new_custom70": "rgb(255, 83, 138)",
        "new_custom81": "rgb(255, 83, 138)",
        "new_custom92": "rgb(5, 103, 100)",
        "refresh": "rgb(16, 124, 173)",
        "share_thanks": "rgb(255, 83, 138)",
        "update": "rgb(16, 124, 173)",
        "email": "rgb(16, 124, 173)",
        "join_group": "rgb(88, 103, 232)",
        "new_custom60": "rgb(255, 83, 138)",
        "new_custom71": "rgb(203, 101, 255)",
        "new_custom82": "rgb(255, 83, 138)",
        "new_custom93": "rgb(92, 92, 92)",
        "edit": "rgb(6, 165, 154)",
        "quote": "rgb(59, 167, 85)",
        "dropbox": "rgb(27, 150, 255)",
        "description": "rgb(59, 167, 85)",
        "map": "rgb(27, 150, 255)",
        "user": "rgb(27, 150, 255)",
        "reset_password": "rgb(16, 124, 173)",
        "new_custom50": "rgb(27, 150, 255)",
        "new_custom61": "rgb(255, 83, 138)",
        "new_custom72": "rgb(88, 103, 232)",
        "new_custom83": "rgb(255, 83, 138)",
        "new_custom94": "rgb(6, 165, 154)",
        "clone": "rgb(27, 150, 255)",
        "script": "rgb(16, 124, 173)",
        "delete": "rgb(255, 83, 138)",
        "new_custom40": "rgb(59, 167, 85)",
        "new_custom51": "rgb(255, 93, 45)",
        "new_custom62": "rgb(88, 103, 232)",
        "new_custom73": "rgb(27, 150, 255)",
        "new_custom84": "rgb(255, 83, 138)",
        "new_custom95": "rgb(59, 167, 85)",
        "scan_disabled": "rgb(147, 147, 147)",
        "share": "rgb(16, 124, 173)",
        "new_custom30": "rgb(255, 93, 45)",
        "new_custom41": "rgb(6, 165, 154)",
        "new_custom52": "rgb(255, 83, 138)",
        "new_custom63": "rgb(59, 167, 85)",
        "new_custom74": "rgb(6, 165, 154)",
        "new_custom85": "rgb(255, 83, 138)",
        "new_custom96": "rgb(27, 150, 255)",
        "log_event": "rgb(27, 150, 255)",
        "new_group": "rgb(27, 150, 255)",
        "new_custom20": "rgb(6, 165, 154)",
        "new_custom31": "rgb(255, 83, 138)",
        "new_custom42": "rgb(59, 167, 85)",
        "info": "rgb(16, 124, 173)",
        "new_custom53": "rgb(255, 83, 138)",
        "new_custom64": "rgb(88, 103, 232)",
        "new_custom75": "rgb(147, 147, 147)",
        "new_custom86": "rgb(255, 83, 138)",
        "flow": "rgb(16, 124, 173)",
        "new_custom97": "rgb(255, 83, 138)",
        "submit_for_approval": "rgb(59, 167, 85)",
        "new": "rgb(27, 150, 255)",
        "new_campaign": "rgb(255, 93, 45)",
        "new_custom10": "rgb(88, 103, 232)",
        "new_custom21": "rgb(88, 103, 232)",
        "new_custom32": "rgb(6, 165, 154)",
        "new_custom43": "rgb(88, 103, 232)",
        "new_custom54": "rgb(255, 83, 138)",
        "new_custom65": "rgb(255, 83, 138)",
        "new_custom76": "rgb(255, 83, 138)",
        "new_custom87": "rgb(203, 101, 255)",
        "new_custom98": "rgb(255, 93, 45)",
        "new_case": "rgb(255, 93, 45)",
        "new_custom100": "rgb(255, 83, 138)",
        "new_custom1": "rgb(255, 83, 138)",
        "new_contact": "rgb(144, 80, 233)",
        "office_365": "rgb(255, 93, 45)",
        "new_custom11": "rgb(88, 103, 232)",
        "new_custom22": "rgb(88, 103, 232)",
        "new_custom33": "rgb(59, 167, 85)",
        "new_custom44": "rgb(59, 167, 85)",
        "new_custom55": "rgb(203, 101, 255)",
        "new_custom66": "rgb(255, 93, 45)",
        "new_custom77": "rgb(255, 83, 138)",
        "new_custom88": "rgb(144, 80, 233)",
        "new_custom99": "rgb(255, 83, 138)",
        "add_contact": "rgb(144, 80, 233)",
        "evernote": "rgb(59, 167, 85)",
        "new_custom2": "rgb(59, 167, 85)",
        "lead_convert": "rgb(255, 93, 45)",
        "new_custom12": "rgb(203, 101, 255)",
        "new_custom23": "rgb(203, 101, 255)",
        "new_custom34": "rgb(255, 93, 45)",
        "new_custom45": "rgb(255, 83, 138)",
        "new_custom56": "rgb(88, 103, 232)",
        "new_custom67": "rgb(255, 83, 138)",
        "recall": "rgb(8, 73, 104)",
        "new_custom78": "rgb(27, 150, 255)",
        "new_custom89": "rgb(16, 124, 173)",
        "follow": "rgb(27, 150, 255)",
        "record": "rgb(59, 167, 85)",
        "new_custom3": "rgb(255, 93, 45)",
        "new_note": "rgb(255, 93, 45)",
        "new_custom13": "rgb(255, 83, 138)",
        "new_custom24": "rgb(255, 83, 138)",
        "new_custom35": "rgb(255, 83, 138)",
        "new_custom46": "rgb(27, 150, 255)",
        "new_custom57": "rgb(27, 150, 255)",
        "new_custom68": "rgb(255, 83, 138)",
        "new_custom79": "rgb(59, 167, 85)",
        "new_child_case": "rgb(255, 93, 45)",
        "new_custom4": "rgb(255, 93, 45)",
        "new_custom14": "rgb(6, 165, 154)",
        "new_custom25": "rgb(255, 83, 138)",
        "new_custom36": "rgb(203, 101, 255)",
        "new_custom47": "rgb(59, 167, 85)",
        "new_custom58": "rgb(6, 165, 154)",
        "new_custom69": "rgb(255, 83, 138)",
        "new_custom5": "rgb(59, 167, 85)",
        "goal": "rgb(27, 150, 255)",
        "new_custom15": "rgb(255, 83, 138)",
        "new_custom26": "rgb(88, 103, 232)",
        "new_custom37": "rgb(88, 103, 232)",
        "new_custom48": "rgb(255, 83, 138)",
        "new_custom59": "rgb(255, 93, 45)",
        "new_custom6": "rgb(59, 167, 85)",
        "log_this_event": "rgb(255, 83, 138)",
        "new_custom16": "rgb(255, 93, 45)",
        "new_custom27": "rgb(27, 150, 255)",
        "new_custom38": "rgb(27, 150, 255)",
        "new_custom49": "rgb(255, 83, 138)",
        "new_custom7": "rgb(88, 103, 232)",
        "more": "rgb(27, 150, 255)",
        "add_relationship": "rgb(27, 150, 255)",
        "new_custom17": "rgb(59, 167, 85)",
        "new_custom28": "rgb(59, 167, 85)",
        "new_custom39": "rgb(59, 167, 85)",
        "password_unlock": "rgb(16, 124, 173)",
        "check": "rgb(16, 124, 173)",
        "update_status": "rgb(6, 165, 154)",
        "preview": "rgb(88, 103, 232)",
        "new_custom8": "rgb(6, 165, 154)"
      }
    };

    /**
    This polyfill is no longer needed, since we no longer
    support IE or the non-Chromium versions of Edge
    However, since it's exported to customers we can't
    remove it from our repo entirely
    **/

    function polyfill() {}

    const validNameRe = /^([a-zA-Z]+):([a-zA-Z]\w*)$/;
    const underscoreRe = /_/g;
    let pathPrefix;
    const tokenNameMap = Object.assign(Object.create(null), {
      action: 'lightning.actionSprite',
      custom: 'lightning.customSprite',
      doctype: 'lightning.doctypeSprite',
      standard: 'lightning.standardSprite',
      utility: 'lightning.utilitySprite'
    });
    const tokenNameMapRtl = Object.assign(Object.create(null), {
      action: 'lightning.actionSpriteRtl',
      custom: 'lightning.customSpriteRtl',
      doctype: 'lightning.doctypeSpriteRtl',
      standard: 'lightning.standardSpriteRtl',
      utility: 'lightning.utilitySpriteRtl'
    });
    const defaultTokenValueMap = Object.assign(Object.create(null), {
      'lightning.actionSprite': '/assets/icons/action-sprite/svg/symbols.svg',
      'lightning.actionSpriteRtl': '/assets/icons/action-sprite/svg/symbols.svg',
      'lightning.customSprite': '/assets/icons/custom-sprite/svg/symbols.svg',
      'lightning.customSpriteRtl': '/assets/icons/custom-sprite/svg/symbols.svg',
      'lightning.doctypeSprite': '/assets/icons/doctype-sprite/svg/symbols.svg',
      'lightning.doctypeSpriteRtl': '/assets/icons/doctype-sprite/svg/symbols.svg',
      'lightning.standardSprite': '/assets/icons/standard-sprite/svg/symbols.svg',
      'lightning.standardSpriteRtl': '/assets/icons/standard-sprite/svg/symbols.svg',
      'lightning.utilitySprite': '/assets/icons/utility-sprite/svg/symbols.svg',
      'lightning.utilitySpriteRtl': '/assets/icons/utility-sprite/svg/symbols.svg'
    });
    const getDefaultBaseIconPath = (category, nameMap) => defaultTokenValueMap[nameMap[category]];
    const getBaseIconPath = (category, direction) => {
      const nameMap = direction === 'rtl' ? tokenNameMapRtl : tokenNameMap;
      return configProvider.getToken(nameMap[category]) || getDefaultBaseIconPath(category, nameMap);
    };
    const getMatchAtIndex = index => iconName => {
      const result = validNameRe.exec(iconName);
      return result ? result[index] : '';
    };
    const getCategory = getMatchAtIndex(1);
    const getName = getMatchAtIndex(2);
    const isValidName = iconName => validNameRe.test(iconName);
    const getIconPath = (iconName, direction = 'ltr') => {
      pathPrefix = pathPrefix !== undefined ? pathPrefix : configProvider.getPathPrefix();
      if (isValidName(iconName)) {
        const baseIconPath = getBaseIconPath(getCategory(iconName), direction);
        if (baseIconPath) {
          return `${pathPrefix}${baseIconPath}#${getName(iconName)}`;
        }
      }
      return '';
    };
    const computeSldsClass = iconName => {
      if (isValidName(iconName)) {
        const category = getCategory(iconName);
        const name = getName(iconName).replace(underscoreRe, '-');
        return `slds-icon-${category}-${name}`;
      }
      return '';
    };
    const getIconColor = iconName => {
      if (isValidName(iconName)) {
        const category = getCategory(iconName);
        const name = getName(iconName);
        return iconColors[category] && iconColors[category][name] || null;
      }
      return null;
    };

    exports.computeSldsClass = computeSldsClass;
    exports.getCategory = getCategory;
    exports.getIconColor = getIconColor;
    exports.getIconPath = getIconPath;
    exports.getName = getName;
    exports.isValidName = isValidName;
    exports.polyfill = polyfill;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/primitiveIcon', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/shadowBaseClassPrivate', 'lightning/utils', 'lightning/utilsPrivate', 'lightning/iconUtils', '@salesforce/i18n/dir', '@salesforce/loader'], (function (exports, lwc, stylesheet0$1, LightningShadowBaseClass, utils, utilsPrivate, iconUtils, dir, loader) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);
  var dir__default = /*#__PURE__*/_interopDefaultCompat(dir);

  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) {" : hostSelector + "[data-render-mode=\"shadow\"] {")) + "display: inline-flex;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='boundary']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='boundary']")) + shadowSelector + " {padding-block-start: var(\n --sds-c-icon-spacing-blockstart,\n var(--sds-c-icon-spacing-block, var(--sds-c-icon-spacing, var(--sds-s-icon-spacing)))\n );padding-block-end: var(\n --sds-c-icon-spacing-blockend,\n var(--sds-c-icon-spacing-block, var(--sds-c-icon-spacing, var(--sds-s-icon-spacing)))\n );padding-inline-start: var(\n --sds-c-icon-spacing-inlinestart,\n var(--sds-c-icon-spacing-inline, var(--sds-c-icon-spacing, var(--sds-s-icon-spacing)))\n );padding-inline-end: var(\n --sds-c-icon-spacing-inlineend,\n var(--sds-c-icon-spacing-inline, var(--sds-c-icon-spacing, var(--sds-s-icon-spacing)))\n );border-radius: var(--sds-c-icon-radius-border, var(--sds-s-icon-radius-border));border-width: var(--sds-c-icon-sizing-border, var(--sds-s-icon-sizing-border));border-style: solid;border-color: var(--sds-c-icon-color-border, var(--sds-s-icon-color-border, transparent));background-color: var(--sds-c-icon-color-background, var(--sds-s-icon-color-background));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='icon']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='icon']")) + shadowSelector + " {display: flex;height: var(--sds-c-icon-sizing-height, var(--sds-c-icon-sizing, var(--sds-s-icon-sizing)));width: var(--sds-c-icon-sizing-width, var(--sds-c-icon-sizing, var(--sds-s-icon-sizing)));color: var(--sds-c-icon-color-foreground, var(--sds-s-icon-color-foreground));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) svg" : hostSelector + "[data-render-mode=\"shadow\"] svg")) + shadowSelector + " {width: 100%;height: 100%;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xxx-small']) {" : hostSelector + "[size='xxx-small'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-sizing: var(--slds-g-sizing-3);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) {" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-sizing: calc(var(--slds-g-sizing-1) + var(--slds-g-sizing-4));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) {" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-sizing: var(--slds-g-sizing-5);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) {" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-sizing: var(--slds-g-sizing-7);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) {" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-sizing: var(--slds-g-sizing-10);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='warning']) {" : hostSelector + "[variant='warning'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-color-foreground: var(--slds-g-color-warning-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='success']) {" : hostSelector + "[variant='success'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-color-foreground: var(--slds-g-color-success-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='error']) {" : hostSelector + "[variant='error'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='light']) {" : hostSelector + "[variant='light'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-color-foreground: var(--slds-g-color-neutral-base-70);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='boundary']" : hostSelector + "[data-render-mode=\"shadow\"] [part='boundary']")) + shadowSelector + " {--sds-c-icon-radius-border: var(--slds-c-icon-radius-border, var(--slds-g-radius-border-2));--sds-c-icon-sizing-border: var(--slds-c-icon-sizing-border);--sds-c-icon-color-border: var(--slds-c-icon-color-border);--sds-c-icon-spacing-block-start: var(\n --slds-c-icon-spacing-blockstart,\n var(--slds-c-icon-spacing-block)\n );--sds-c-icon-spacing-block-end: var(--slds-c-icon-spacing-blockend, var(--slds-c-icon-spacing-block));--sds-c-icon-spacing-inline-start: var(\n --slds-c-icon-spacing-inlinestart,\n var(--slds-c-icon-spacing-inline)\n );--sds-c-icon-spacing-inline-end: var(--slds-c-icon-spacing-inlineend, var(--slds-c-icon-spacing-inline));display: inline-flex;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='icon']" : hostSelector + "[data-render-mode=\"shadow\"] [part='icon']")) + shadowSelector + " {--sds-c-icon-color-foreground: var(--slds-c-icon-color-foreground, var(--slds-g-color-on-accent-1));--sds-c-icon-sizing-height: var(--slds-c-icon-sizing-height, var(--slds-c-icon-sizing, var(--slds-g-sizing-9)));--sds-c-icon-sizing-width: var(--slds-c-icon-sizing-width, var(--slds-c-icon-sizing, var(--slds-g-sizing-9)));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][icon-name*='action']) {" : hostSelector + "[icon-name*='action'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-spacing-block: var(--slds-g-sizing-3);--slds-c-icon-spacing-inline: var(--slds-g-sizing-3);--slds-c-icon-radius-border: calc(var(--slds-g-radius-border-circle) / 2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-icon-text-default" : hostSelector + "[data-render-mode=\"shadow\"] .slds-icon-text-default")) + shadowSelector + " {--slds-c-icon-color-foreground: var(\n --slds-c-icon-color-foreground-default,\n var(--sds-c-icon-color-foreground-default, var(\n --slds-g-color-on-surface-1))\n );}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-icon-text-default.slds-is-disabled" : hostSelector + "[data-render-mode=\"shadow\"] .slds-icon-text-default.slds-is-disabled")) + shadowSelector + " {fill: var(--slds-g-color-disabled-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")) + shadowSelector + " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-icon_disabled" : hostSelector + "[data-render-mode=\"shadow\"] .slds-icon_disabled")) + shadowSelector + " {background-color: currentcolor;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input__icon")) + shadowSelector + " {--slds-c-icon-sizing: calc(var(--slds-g-sizing-1) + var(--slds-g-sizing-4));position: absolute;top: 50%;margin-block-start: -0.4375rem;line-height: var(--slds-g-font-lineheight-1);border: 0;z-index: 2;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-input-pill-search-primicon]) .slds-icon" : hostSelector + "[data-input-pill-search-primicon][data-render-mode=\"shadow\"] .slds-icon")) + shadowSelector + " {--sds-c-icon-sizing-height: 1.25rem;--sds-c-icon-sizing-width: 1.25rem;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-input-pill-close-primicon]) [part=\"icon\"]" : hostSelector + "[data-input-pill-close-primicon][data-render-mode=\"shadow\"] [part=\"icon\"]")) + shadowSelector + " {--sds-c-icon-color-foreground: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-input-pill-close-primicon]) [part=\"icon\"]:hover" : hostSelector + "[data-input-pill-close-primicon][data-render-mode=\"shadow\"] [part=\"icon\"]:hover")) + shadowSelector + " {--sds-c-icon-color-foreground: var(--slds-g-color-accent-4);}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet$1];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1];

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    return ".private-dt-sort-icon" + shadowSelector + " {display: inline-block;}";
    /*LWC compiler v7.1.5*/
  }
  var iconStylesheets = [stylesheet0, stylesheet];

  const $fragment1 = lwc.parseFragment`<svg${"c0"} focusable="false"${"a0:data-key"} aria-hidden="true" part="icon"${2}><use${"a1:xlink:href"}${3}/></svg>`;
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {ncls: api_normalize_class_name, fid: api_scoped_frag_id, sp: api_static_part, st: api_static_fragment} = $api;
    return [api_static_fragment($fragment1, 1, [api_static_part(0, {
      className: api_normalize_class_name($cmp.computedClass),
      attrs: {
        "data-key": $cmp.name
      }
    }, null), api_static_part(1, {
      attrs: {
        "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", api_scoped_frag_id($cmp.href))
      }
    }, null)])];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-25f9lgh55ct";
  tmpl.legacyStylesheetToken = "lightning-primitiveIcon_primitiveIcon";
  if (iconStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, iconStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  // Cache for promises that import icon templates
  const importPromises = {};
  const iconTemplateCache = {};
  function hasIconLibrary(dir, category) {
    const cacheKey = makeCacheKey(dir, category);
    return !!iconTemplateCache[cacheKey];
  }
  function getIconLibrary(dir, category) {
    const cacheKey = makeCacheKey(dir, category);
    return iconTemplateCache[cacheKey] || null;
  }
  function fetchIconLibrary(dir, category) {
    const cacheKey = makeCacheKey(dir, category);

    // If icon template is being requested, return the cached promise
    if (importPromises[cacheKey]) {
      return importPromises[cacheKey];
    }
    const promise = fetchIconTemplate(dir, category);
    promise.then(tmpl => {
      iconTemplateCache[cacheKey] = tmpl;
      delete importPromises[cacheKey];
    }).catch(() => {
      delete importPromises[cacheKey];
    });

    // Cache the promise to import
    importPromises[cacheKey] = promise;
    return promise;
  }
  function makeCacheKey(dir, category) {
    return `${category}${dir}`;
  }

  // eslint-disable-next-line @lwc/lwc/no-async-await
  async function fetchIconTemplate(dir, category) {
    if (dir === 'rtl') {
      switch (category) {
        case 'utility':
          {
            // eslint-disable-next-line @lwc/lwc/no-async-await
            const {
              default: Lib
            } = await loader.load('lightning/iconSvgTemplatesUtilityRtl');
            return Lib;
          }
        case 'action':
          {
            // eslint-disable-next-line @lwc/lwc/no-async-await
            const {
              default: Lib
            } = await loader.load('lightning/iconSvgTemplatesActionRtl');
            return Lib;
          }
        case 'standard':
          {
            // eslint-disable-next-line @lwc/lwc/no-async-await
            const {
              default: Lib
            } = await loader.load('lightning/iconSvgTemplatesStandardRtl');
            return Lib;
          }
        case 'doctype':
          {
            // eslint-disable-next-line @lwc/lwc/no-async-await
            const {
              default: Lib
            } = await loader.load('lightning/iconSvgTemplatesDoctypeRtl');
            return Lib;
          }
        case 'custom':
          {
            // eslint-disable-next-line @lwc/lwc/no-async-await
            const {
              default: Lib
            } = await loader.load('lightning/iconSvgTemplatesCustomRtl');
            return Lib;
          }
        default:
          return null;
      }
    } else {
      switch (category) {
        case 'utility':
          {
            // eslint-disable-next-line @lwc/lwc/no-async-await
            const {
              default: Lib
            } = await loader.load('lightning/iconSvgTemplatesUtility');
            return Lib;
          }
        case 'action':
          {
            // eslint-disable-next-line @lwc/lwc/no-async-await
            const {
              default: Lib
            } = await loader.load('lightning/iconSvgTemplatesAction');
            return Lib;
          }
        case 'standard':
          {
            // eslint-disable-next-line @lwc/lwc/no-async-await
            const {
              default: Lib
            } = await loader.load('lightning/iconSvgTemplatesStandard');
            return Lib;
          }
        case 'doctype':
          {
            // eslint-disable-next-line @lwc/lwc/no-async-await
            const {
              default: Lib
            } = await loader.load('lightning/iconSvgTemplatesDoctype');
            return Lib;
          }
        case 'custom':
          {
            // eslint-disable-next-line @lwc/lwc/no-async-await
            const {
              default: Lib
            } = await loader.load('lightning/iconSvgTemplatesCustom');
            return Lib;
          }
        default:
          return null;
      }
    }
  }

  class LightningPrimitiveIcon extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      // stylesheets that apply to every rendered template
      this.src = void 0;
      this.svgClass = void 0;
      this._size = 'medium';
      this._variant = '';
      this._iconLibrary = null;
      this._iconName = null;
    }
    get size() {
      return this._size;
    }
    set size(val) {
      this._size = val;
      this.setAttribute('size', this.normalizeSize(this._size));
    }
    get variant() {
      return this._variant;
    }
    set variant(val) {
      this._variant = val;
      this.setAttribute('variant', this.normalizeVariant(this._variant));
    }
    get iconName() {
      return this._iconName;
    }
    set iconName(value) {
      if (value !== this._iconName) {
        this._iconName = value;
        this.requestIconTemplates();
      }
    }
    get category() {
      if (iconUtils.isValidName(this._iconName)) {
        const [spriteName] = this._iconName.split(':');
        return spriteName;
      }
      return null;
    }
    get isReady() {
      return !!this._iconLibrary;
    }

    // eslint-disable-next-line @lwc/lwc/no-async-await
    async requestIconTemplates() {
      if (hasIconLibrary(dir__default.default, this.category)) {
        this._iconLibrary = getIconLibrary(dir__default.default, this.category);
        return;
      }
      if (this.category) {
        try {
          this._iconLibrary = null;
          if (utilsPrivate.isCSR) {
            this._iconLibrary = await fetchIconLibrary(dir__default.default, this.category);
          }
        } catch (e) {
          // eslint-disable-next-line no-console
          console.warn(`<lightning-primitive-icon> failed to dynamically import icon templates for ${this.category}: ${e.message}`);
        }
      }
    }
    renderedCallback() {
      if (this.isReady || this.iconName !== this.prevIconName) {
        this.prevIconName = this.iconName;
      }
    }
    render() {
      if (this.isReady) {
        // If src is present, should use default template reply on given svg src
        if (!this.src) {
          const name = this.iconName;
          if (iconUtils.isValidName(name)) {
            const [spriteName, iconName] = name.split(':');
            const template = this._iconLibrary[`${spriteName}_${iconName}`];
            if (template) {
              return template;
            }
          }
        }
      }
      return _tmpl;
    }
    get href() {
      return this.src || '';
    }
    get name() {
      return iconUtils.getName(this.iconName);
    }
    normalizeSize(val) {
      return utilsPrivate.normalizeString(val, {
        fallbackValue: 'medium',
        validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
      });
    }
    normalizeVariant(val) {
      // NOTE: Leaving a note here because I just wasted a bunch of time
      // investigating why both 'bare' and 'inverse' are supported in
      // lightning-primitive-icon. lightning-icon also has a deprecated
      // 'bare', but that one is synonymous to 'inverse'. This 'bare' means
      // that no classes should be applied. So this component needs to
      // support both 'bare' and 'inverse' while lightning-icon only needs to
      // support 'inverse'.
      return utilsPrivate.normalizeString(val, {
        fallbackValue: '',
        validValues: ['bare', 'error', 'inverse', 'warning', 'success']
      });
    }
    get computedClass() {
      const classes = utils.classSet(this.svgClass);
      if (this._variant !== 'bare') {
        classes.add('slds-icon');
      }
      switch (this._variant) {
        case 'error':
          classes.add('slds-icon-text-error');
          break;
        case 'warning':
          classes.add('slds-icon-text-warning');
          break;
        case 'success':
          classes.add('slds-icon-text-success');
          break;
        case 'inverse':
        case 'bare':
          break;
        default:
          // if custom icon is set, we don't want to set
          // the text-default class
          if (!this.src) {
            classes.add('slds-icon-text-default');
          }
      }
      if (this._size !== 'medium') {
        classes.add(`slds-icon_${this._size}`);
      }
      return classes.toString();
    }
    /*LWC compiler v7.1.5*/
  }
  LightningPrimitiveIcon.validationOptOut = ['class'];
  LightningPrimitiveIcon.stylesheets = [iconStylesheets];
  lwc.registerDecorators(LightningPrimitiveIcon, {
    publicProps: {
      src: {
        config: 0
      },
      svgClass: {
        config: 0
      },
      size: {
        config: 3
      },
      variant: {
        config: 3
      },
      iconName: {
        config: 3
      }
    },
    fields: ["_size", "_variant", "_iconLibrary", "_iconName"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningPrimitiveIcon, {
    tmpl: _tmpl,
    sel: "lightning-primitive-icon",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/buttonIcon', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/primitiveIcon', 'lightning/utils', 'lightning/utilsPrivate', 'lightning/tooltipLibrary', 'lightning/primitiveButton'], (function (exports, lwc, stylesheet0$1, _lightningPrimitiveIcon, utils, utilsPrivate, tooltipLibrary, LightningPrimitiveButton) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningPrimitiveIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveIcon);
  var LightningPrimitiveButton__default = /*#__PURE__*/_interopDefaultCompat(LightningPrimitiveButton);

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ["*", shadowSelector, ",*", shadowSelector, "::before,*", shadowSelector, "::after {box-sizing: border-box;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {display: inline-flex;gap: var(--sds-c-button-spacing-gap, var(--sds-s-button-spacing-gap));background: var(--sds-c-button-color-background, var(--sds-s-button-color-background));color: var(--sds-c-button-text-color, var(--sds-s-button-color));font-weight: var(--sds-c-button-font-weight, var(--sds-s-button-font-weight));font-size: var(--sds-c-button-font-size, var(--sds-s-button-font-size, inherit));line-height: var(--sds-c-button-font-lineheight);height: var(--sds-c-button-sizing-height);width: var(--sds-c-button-sizing-width);padding-inline-start: var(\n --sds-c-button-spacing-inlinestart,\n var(\n --sds-c-button-spacing-inline,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-inline, var(--sds-s-button-spacing)))\n )\n );padding-inline-end: var(\n --sds-c-button-spacing-inlineend,\n var(\n --sds-c-button-spacing-inline,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-inline, var(--sds-s-button-spacing)))\n )\n );padding-block-start: var(\n --sds-c-button-spacing-blockstart,\n var(\n --sds-c-button-spacing-block,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-block, var(--sds-s-button-spacing)))\n )\n );padding-block-end: var(\n --sds-c-button-spacing-blockend,\n var(\n --sds-c-button-spacing-block,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-block, var(--sds-s-button-spacing)))\n )\n );border-width: var(--sds-c-button-sizing-border, var(--sds-s-button-sizing-border, 1px));border-style: solid;border-color: var(--sds-c-button-color-border, var(--sds-s-button-color-border, currentColor));border-start-start-radius: var(\n --sds-c-button-radius-border-startstart,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-startstart, var(--sds-s-button-radius-border))\n )\n );border-start-end-radius: var(\n --sds-c-button-radius-border-startend,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-startend, var(--sds-s-button-radius-border))\n )\n );border-end-start-radius: var(\n --sds-c-button-radius-border-endstart,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-endstart, var(--sds-s-button-radius-border))\n )\n );border-end-end-radius: var(\n --sds-c-button-radius-border-endend,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-endend, var(--sds-s-button-radius-border))\n )\n );box-shadow: var(--sds-c-button-shadow, var(--sds-s-button-shadow));text-decoration: var(--sds-c-button-font-decoration);white-space: normal;user-select: none;align-items: center;justify-content: center;appearance: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:hover" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:hover")), shadowSelector, " {--sds-c-button-text-color: var(--sds-c-button-text-color-hover, var(--sds-s-button-color-hover, revert));--sds-c-button-color-background: var(\n --sds-c-button-color-background-hover,\n var(--sds-s-button-color-background-hover, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-hover,\n var(--sds-s-button-color-border-hover, revert)\n );--sds-c-button-shadow: var(--sds-c-button-shadow-hover, var(--sds-s-button-shadow-hover, revert));cursor: pointer;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:focus")), shadowSelector, " {--sds-c-button-color-background: var(\n --sds-c-button-color-background-focus,\n var(--sds-s-button-color-background-focus, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-focus,\n var(--sds-s-button-color-border-focus, revert)\n );--sds-c-button-text-color: var(--sds-c-button-text-color-focus, var(--sds-s-button-color-focus, revert));--sds-c-button-shadow: var(--sds-c-button-shadow-focus, var(--sds-s-button-shadow-focus, revert));outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:active")), shadowSelector, " {--sds-c-button-text-color: var(--sds-c-button-text-color-active, var(--sds-s-button-color-active, revert));--sds-c-button-color-background: var(\n --sds-c-button-color-background-active,\n var(--sds-s-button-color-background-active, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-active,\n var(--sds-s-button-color-border-active, revert)\n );--sds-c-button-shadow: var(--sds-c-button-shadow-active, var(--sds-s-button-shadow-active, revert));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " {--sds-c-button-text-color: var(--sds-c-button-text-color-disabled);--sds-c-button-color-background: var(--sds-c-button-color-background-disabled);--sds-c-button-color-border: var(--sds-c-button-color-border-disabled);--sds-c-button-shadow: var(--sds-c-button-shadow-disabled);pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " *", shadowSelector, " {pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='button'][aria-pressed='true']" : hostSelector + "[data-render-mode=\"shadow\"] [part='button'][aria-pressed='true']")), shadowSelector, " {--sds-c-button-color-background: var(--sds-c-button-color-background-pressed, revert);--sds-c-button-color-border: var(--sds-c-button-color-border-pressed, revert);--sds-c-button-text-color: var(--sds-c-button-text-color-pressed, revert);--sds-c-button-shadow: var(--sds-c-button-shadow-pressed, revert);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {gap: var(--slds-g-spacing-2);--slds-c-icon-sizing-border: 0;--slds-c-icon-sizing: 0.875rem;--slds-c-icon-color-foreground: currentcolor;--sds-c-button-font-lineheight: var(\n --slds-c-button-neutral-font-lineheight,\n var(--slds-s-button-font-lineheight, 1.875rem)\n );--sds-c-button-spacing-inline: var(\n --slds-c-button-neutral-spacing-inline,\n var(--slds-s-button-spacing-inline, var(--slds-g-spacing-4));\n );--sds-c-button-spacing-block: var(--slds-c-button-neutral-spacing-block);--sds-c-button-radius-border-startstart: var(\n --slds-c-button-radius-border-startstart,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-startstart, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-endstart: var(\n --slds-c-button-radius-border-endstart,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-endstart, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-startend: var(\n --slds-c-button-radius-border-startend,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-startend, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-endend: var(\n --slds-c-button-radius-border-endend,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-endend, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-color-background: var(\n --slds-c-button-neutral-color-background,\n var(--slds-g-color-surface-container-1)\n );--sds-c-button-color-background-hover: var(\n --slds-c-button-neutral-color-background-hover,\n var(--slds-g-color-surface-container-2)\n );--sds-c-button-color-background-focus: var(--slds-c-button-neutral-color-background-focus, var(--slds-g-color-surface-container-2));--sds-c-button-color-background-active: var(\n --slds-c-button-neutral-color-background-active,\n var(--slds-g-color-surface-container-2)\n );--sds-c-button-color-border: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-2));--sds-c-button-color-border-hover: var(\n --slds-c-button-neutral-color-border-hover,\n var(--slds-g-color-border-2)\n );--sds-c-button-color-border-focus: var(\n --slds-c-button-neutral-color-border-focus,\n var(--slds-g-color-border-2)\n );--sds-c-button-color-border-active: var(\n --slds-c-button-neutral-color-border-active,\n var(--slds-g-color-border-2)\n );--sds-c-button-text-color: var(--slds-c-button-neutral-text-color, var(--slds-g-color-accent-2));--sds-c-button-text-color-hover: var(--slds-c-button-neutral-text-color-hover, var(--slds-s-button-color-hover, var(--slds-g-color-accent-3)));--sds-c-button-text-color-focus: var(--slds-c-button-neutral-text-color-focus, var(--slds-g-color-accent-3));--sds-c-button-text-color-active: var(\n --slds-c-button-neutral-text-color-active,\n var(--slds-g-color-accent-3)\n );--sds-c-button-shadow: var(--slds-c-button-neutral-shadow);--sds-c-button-shadow-focus: var(--slds-c-button-neutral-shadow-focus);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " {--sds-c-button-color-border-disabled: var(--slds-g-color-border-disabled-1);--sds-c-button-text-color-disabled: var(--slds-g-color-on-disabled-1);--sds-c-button-color-background-disabled: var(--slds-g-color-disabled-container-1);pointer-events: auto;cursor: default;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-color-background: var(\n --slds-c-button-brand-color-background,\n var(--slds-g-color-accent-container-1)\n );--slds-c-button-neutral-color-background-hover: var(\n --slds-c-button-brand-color-background-hover,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-background-focus: var(\n --slds-c-button-brand-color-background-focus,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-background-active: var(\n --slds-c-button-brand-color-background-active,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-border: var(\n --slds-c-button-brand-color-border,\n var(--slds-g-color-border-accent-1)\n );--slds-c-button-neutral-color-border-hover: var(\n --slds-c-button-brand-color-border-hover,\n var(--slds-g-color-border-accent-2)\n );--slds-c-button-neutral-color-border-focus: var(\n --slds-c-button-brand-color-border-focus,\n var(--slds-g-color-border-accent-2)\n );--slds-c-button-neutral-color-border-active: var(\n --slds-c-button-brand-color-border-active,\n var(--slds-g-color-border-accent-2)\n );--sds-c-button-text-color: var(--slds-c-button-brand-text-color, var(--slds-g-color-on-accent-1));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand-outline']) [part~='button']" : hostSelector + "[variant='brand-outline'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-color-border: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']" : hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-color-background: transparent;--slds-c-button-neutral-color-background-hover: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-active: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-text-color: var(--slds-g-color-on-accent-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-accent-2);--slds-c-button-neutral-text-color-active: var(--slds-g-color-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']:disabled" : hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " {--sds-c-button-color-background: transparent;--sds-c-button-color-border: var(--slds-g-color-border-disabled-2);--sds-c-button-text-color: var(--slds-g-color-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']" : hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-color-background: var(--slds-g-color-error-container-1);--slds-c-button-neutral-color-background-hover: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-border-error-1);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-error-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-error-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-error-2);--sds-c-button-text-color: var(--slds-g-color-on-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='success']) [part~='button']" : hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-color-background: var(--slds-g-color-success-container-1);--slds-c-button-neutral-color-background-hover: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-border-success-1);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-success-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-success-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-success-2);--slds-c-button-neutral-text-color: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-focus: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-active: var(--slds-g-color-on-success-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='destructive-text']) [part~='button']" : hostSelector + "[variant='destructive-text'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-text-color: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-focus: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-active: var(--slds-g-color-error-1);--slds-c-button-neutral-color-border-hover: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));--slds-c-button-neutral-color-border-focus: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));--slds-c-button-neutral-color-border-active: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='success']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']:disabled" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " {--sds-c-button-color-background: var(--slds-g-color-disabled-container-2);--sds-c-button-color-border: var(--slds-g-color-border-disabled-1);--sds-c-button-text-color: var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='base']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='text']) [part~='button']" : hostSelector + "[variant='base'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='text'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, "{--sds-c-button-spacing-inline: 0;--slds-c-button-neutral-text-color: var(--slds-g-color-accent-2);--slds-c-button-neutral-color-border: transparent;--slds-c-button-neutral-color-border-hover: transparent;--slds-c-button-neutral-color-border-focus: transparent;--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-background: transparent;--slds-c-button-neutral-color-background-hover: transparent;--slds-c-button-neutral-color-background-focus: transparent;--slds-c-button-neutral-color-background-active: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='base']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='text']) [part~='button']:disabled" : hostSelector + "[variant='base'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='text'][data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " {--sds-c-button-color-background: transparent;--sds-c-button-color-border: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][stretch]) [part~='button']" : hostSelector + "[stretch][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--sds-c-button-sizing-width: 100%;justify-content: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='brand-outline']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='success']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive-text']) [part~='button']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='brand-outline'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='destructive-text'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {justify-content: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='start']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='start']")), shadowSelector, " {display: inline-flex;padding-inline-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='end']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='end']")), shadowSelector, " {display: inline-flex;padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button_reset" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button_reset")), shadowSelector, " {font-size: inherit;color: inherit;line-height: inherit;padding: 0;background: transparent;border: 0;text-align: inherit;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button-icon']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {display: inline-flex;--slds-c-icon-sizing-border: 0;--slds-c-icon-sizing: 0.875rem;--slds-c-icon-color-foreground: var(--slds-c-buttonicon-color-foreground, var(--slds-g-color-on-surface-1));--sds-c-button-spacing-inline: 0;--sds-c-button-sizing-height: var(--slds-g-sizing-9);--sds-c-button-sizing-width: var(--slds-g-sizing-9);--slds-c-button-neutral-color-background: transparent;--slds-c-button-neutral-color-background-hover: transparent;--slds-c-button-neutral-color-background-focus: transparent;--slds-c-button-neutral-color-background-active: transparent;--slds-c-button-neutral-color-border: var(--slds-g-color-border-2);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-2);--sds-c-button-color-background-disabled: var(--slds-g-color-surface-container-1);--sds-c-button-color-border-disabled: var(--slds-g-color-border-disabled-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button-icon']:hover" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button-icon']:hover")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-buttonicon-color-foreground-hover, \n var(--slds-g-color-accent-3)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button-icon']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button-icon']:focus")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-buttonicon-color-foreground-focus,\n var(--slds-g-color-accent-3)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button-icon']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button-icon']:active")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-buttonicon-color-foreground-active,\n var(--slds-g-color-accent-3)\n );--sds-c-button-shadow-active: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button-icon']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button-icon']:disabled")), shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-disabled-1);--sds-c-button-color-background-disabled: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='bare']) [part~='button-icon']" : hostSelector + "[variant='bare'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: auto;--sds-c-button-sizing-width: auto;--slds-c-button-neutral-color-border: transparent;--slds-c-button-neutral-color-border-hover: transparent;--slds-c-button-neutral-color-border-focus: transparent;--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-3);--sds-c-button-color-background-disabled: transparent;--sds-c-button-color-border-disabled: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='container']) [part~='button-icon']" : hostSelector + "[variant='container'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-button-neutral-color-border: transparent;--slds-c-button-neutral-color-border-hover: transparent;--slds-c-button-neutral-color-border-focus: transparent;--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-3);--sds-c-button-color-background-disabled: transparent;--sds-c-button-color-border-disabled: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button-icon']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-on-accent-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='bare-inverse']) [part~='button-icon']" : hostSelector + "[variant='bare-inverse'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: auto;--sds-c-button-sizing-width: auto;--slds-c-button-neutral-color-border: transparent;--slds-c-button-neutral-color-border-hover: transparent;--slds-c-button-neutral-color-border-focus: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-active: var(--slds-g-color-neutral-base-100);--sds-c-button-shadow-focus: 0 0 3px var(--slds-g-color-neutral-base-100);--slds-c-buttonicon-color-foreground: var(--slds-g-color-neutral-base-100);--slds-c-buttonicon-color-foreground-hover: color-mix(in oklab, var(--slds-g-color-on-surface-inverse-1), transparent 25%);--slds-c-buttonicon-color-foreground-focus: var(--slds-g-color-neutral-base-95);--slds-c-buttonicon-color-foreground-active: var(--slds-g-color-neutral-base-90);--sds-c-button-color-background-disabled: transparent;--sds-c-button-color-border-disabled: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='border-inverse']) [part~='button-icon']" : hostSelector + "[variant='border-inverse'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-button-neutral-color-border: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-active: var(--slds-g-color-neutral-base-100);--sds-c-button-shadow-focus: 0 0 3px var(--slds-g-color-neutral-base-100);--slds-c-buttonicon-color-foreground: var(--slds-g-color-neutral-base-100);--slds-c-buttonicon-color-foreground-hover: var(--slds-g-color-neutral-base-95);--slds-c-buttonicon-color-foreground-focus: var(--slds-g-color-neutral-base-95);--slds-c-buttonicon-color-foreground-active: var(--slds-g-color-neutral-base-90);--sds-c-button-color-background-disabled: transparent;--sds-c-button-color-border-disabled: var(--slds-g-color-border-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='border-filled']) [part~='button-icon']" : hostSelector + "[variant='border-filled'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-button-neutral-color-background: var(--slds-g-color-surface-container-1);--slds-c-button-neutral-color-background-hover: var(--slds-g-color-surface-container-1);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-surface-container-1);--slds-c-button-neutral-color-background-active: var(--slds-g-color-surface-container-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='border-filled']) [part~='button-icon']:disabled" : hostSelector + "[variant='border-filled'][data-render-mode=\"shadow\"] [part~='button-icon']:disabled")), shadowSelector, " {--sds-c-button-color-background-disabled: var(--slds-g-color-disabled-container-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) [part~='button-icon']" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: var(--slds-g-sizing-5);--sds-c-button-sizing-width: var(--slds-g-sizing-5);--slds-c-icon-sizing: var(--slds-g-sizing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) [part~='button-icon']" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: var(--slds-g-sizing-6);--sds-c-button-sizing-width: var(--slds-g-sizing-6);--slds-c-icon-sizing: var(--slds-g-sizing-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) [part~='button-icon']" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: var(--slds-g-sizing-7);--sds-c-button-sizing-width: var(--slds-g-sizing-7);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) [part~='button-icon']" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: var(--slds-g-sizing-10);--sds-c-button-sizing-width: var(--slds-g-sizing-10);--slds-c-icon-sizing: var(--slds-g-sizing-7);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small'][variant='bare']) [part~='button-icon']" : hostSelector + "[variant='bare'][size='x-small'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-buttonicon-spacing-block: 0;--slds-c-buttonicon-spacing-inline: 0;--slds-c-icon-sizing: var(--slds-g-sizing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small'][variant='bare']) [part~='button-icon']" : hostSelector + "[variant='bare'][size='small'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-buttonicon-spacing-block: 0;--slds-c-buttonicon-spacing-inline: 0;--slds-c-icon-sizing: var(--slds-g-sizing-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large'][variant='bare']) [part~='button-icon']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][size='large'][variant='bare-inverse']) [part~='button-icon']" : hostSelector + "[variant='bare'][size='large'][data-render-mode=\"shadow\"] [part~='button-icon']" + shadowSelector + "," + hostSelector + "[variant='bare-inverse'][size='large'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: auto;--sds-c-button-sizing-width: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='end']" : hostSelector + "[data-render-mode=\"shadow\"] [part='end']")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<span class="slds-assistive-text${0}"${2}>${"t1"}</span>`;
  const stc0 = {
    "exportparts": "icon"
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {ncls: api_normalize_class_name, ti: api_tab_index, b: api_bind, c: api_custom_element, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment, h: api_element} = $api;
    const {_m0, _m1} = $ctx;
    return [api_element("button", {
      className: api_normalize_class_name($cmp.computedButtonClass),
      attrs: {
        "disabled": $cmp.disabled ? "" : null,
        "name": $cmp.name,
        "title": $cmp.computedTitle,
        "accesskey": $cmp.accessKey,
        "type": $cmp.normalizedType,
        "value": $cmp.value,
        "aria-label": $cmp.ariaLabel,
        "aria-expanded": $cmp.computedAriaExpanded,
        "aria-live": $cmp.computedAriaLive,
        "aria-atomic": $cmp.computedAriaAtomic,
        "aria-haspopup": $cmp.computedAriaHasPopup,
        "part": "button button-icon",
        "tabindex": api_tab_index($cmp.tabIndex)
      },
      key: 0,
      on: {
        "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
        "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur))
      }
    }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon__default.default, {
      attrs: stc0,
      props: {
        "iconName": $cmp.iconName,
        "svgClass": $cmp.computedIconClass,
        "variant": "bare"
      },
      key: 1
    }), $cmp.alternativeText ? api_static_fragment($fragment1, 3, [api_static_part(1, null, api_dynamic_text($cmp.alternativeText))]) : null])];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-3o1g0ksgj78";
  tmpl.legacyStylesheetToken = "lightning-buttonIcon_buttonIcon";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  const DEFAULT_SIZE = 'medium';
  const DEFAULT_VARIANT = 'border';
  const DEFAULT_TYPE = 'button';
  const relatedTarget = Symbol('relatedTarget');

  /**
   * An icon-only HTML button.
   */
  class LightningButtonIcon extends LightningPrimitiveButton__default.default {
    constructor(...args) {
      super(...args);
      /**
       * The name for the button element.
       * This value is optional and can be used to identify the button in a callback.
       *
       * @type {string}
       */
      this.name = void 0;
      /**
       * The value for the button element.
       * This value is optional and can be used when submitting a form.
       *
       * @type {string}
       */
      this.value = void 0;
      /**
       * Reserved for internal use only. Use the global tabindex attribute instead.
       * Set tab index to -1 to prevent focus on the button during tab navigation.
       * The default value is 0, which makes the button focusable during tab navigation.
       * @type {number}
       */
      this.tabIndex = void 0;
      this._variant = DEFAULT_VARIANT;
      /**
       * The Lightning Design System name of the icon.
       * Names are written in the format 'utility:down' where 'utility' is the category,
       * and 'down' is the specific icon to be displayed.
       * Only utility icons can be used in this component.
       *
       * @type {string}
       * @required
       */
      this.iconName = void 0;
      /**
       * The class to be applied to the contained icon element.
       * Only Lightning Design System utility classes are currently supported.
       *
       * @type {string}
       */
      this.iconClass = void 0;
      this._size = DEFAULT_SIZE;
      /**
       * Specifies the type of button. Valid values are button, reset, and submit.
       * This value defaults to button.
       *
       * @type {string}
       * @default button
       */
      this.type = DEFAULT_TYPE;
      /**
       * The alternative text used to describe the icon. This text should describe what
       * happens when you click the button, for example 'Upload File', not what the icon looks like, 'Paperclip'.
       * @type {string}
       */
      this.alternativeText = void 0;
      /**
       * Reserved for internal use only.
       * Specifies the type of tooltip to be used.
       * Use info in cases where target already has click handlers.
       * Use toggle in cases where target only shows a tooltip, such as helptext.
       * @type {string}
       * @default info
       */
      this.tooltipType = tooltipLibrary.TooltipType.Info;
      /**
       * Reserved for internal use only.
       * Disables the alternative text being used for the button title when the title has not been provided.
       * @type {boolean}
       * @default false
       */
      this.disableAlternativeTextTitle = false;
      // remove-next-line-for-c-namespace
      this._tooltip = null;
      this.tooltipValue = null;
      this.rendered = false;
    }
    /**
     * The variant changes the appearance of button-icon.
     * Accepted variants include bare, container, brand, border, border-filled, bare-inverse, and border-inverse.
     * This value defaults to border.
     *
     * @type {string}
     * @default border
     */
    get variant() {
      return this._originalVariant;
    }
    set variant(val) {
      this._originalVariant = val;
      this._variant = this.normalizeVariant(val);
      // set the variant attribute on the host
      this.setAttribute('variant', this._variant);
    }
    /**
     * The size of the button-icon. For the bare variant, options include x-small, small, medium, and large.
     * For non-bare variants, options include xx-small, x-small, small, and medium.
     * This value defaults to medium.
     *
     * @type {string}
     * @default medium
     */
    get size() {
      return this._originalSize;
    }
    set size(val) {
      this._originalSize = val;
      this._size = this.normalizeSize(val);
      // set the size attribute on the host
      this.setAttribute('size', this._size);
    }
    // remove-next-line-for-c-namespace
    /**
     * Text to display when the user mouses over or focuses on the button.
     * The tooltip is auto-positioned relative to the button and screen space.
     * @type {string}
     * @param {string} value - The plain text string for the tooltip
     */
    get tooltip() {
      return this._tooltip ? this._tooltip.value : undefined;
    }

    // remove-next-line-for-c-namespace
    set tooltip(value) {
      this.tooltipValue = value;
      if (this._tooltip) {
        this._tooltip.value = value;
      } else if (value && this.rendered) {
        this.createTooltip(value);
      }
    }
    /**
     * Generate a tooltip with the specified value and current tooltip type
     *
     * @param {*} value - The plain text string for the tooltip
     */
    createTooltip(value) {
      this._tooltip = new tooltipLibrary.Tooltip(value, {
        root: this,
        target: () => this.template.querySelector('button'),
        type: this.tooltipType
      });
      this._tooltip.initialize();
    }

    // this is there because raptor currently doesnt support inheritance
    render() {
      return _tmpl;
    }
    get computedTitle() {
      if (this.title) {
        return this.title;
      }
      if (!this.disableAlternativeTextTitle) {
        return this.alternativeText;
      }
      return null;
    }
    normalizeVariant(variant) {
      return utilsPrivate.normalizeString(variant, {
        fallbackValue: DEFAULT_VARIANT,
        validValues: ['bare', 'brand', 'container', 'border', 'border-filled', 'bare-inverse', 'border-inverse']
      });
    }
    get normalizedType() {
      return utilsPrivate.normalizeString(this.type, {
        fallbackValue: DEFAULT_TYPE,
        validValues: ['button', 'reset', 'submit']
      });
    }
    normalizeSize(size) {
      return utilsPrivate.normalizeString(size, {
        fallbackValue: DEFAULT_SIZE,
        validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
      });
    }

    /**
     * Retrieve the base part of the variant
     * Example: for variant "border-inverse", the base is "border".
     */
    get variantBase() {
      return this._variant.split('-')[0];
    }

    /**
     * Retrieve the modifier of the variant
     * Example: for variant "border-inverse", the modifier is "inverse".
     */
    get variantModifier() {
      return this._variant.split('-')[1] || '';
    }
    get computedButtonClass() {
      const classes = utils.classSet(super.computedButtonClass);
      const isBare = this.variantBase === 'bare';
      classes.add('slds-button_icon');
      if (!isBare) {
        // If the variant is not bare, then size the button instead of the icon
        switch (this._size) {
          case 'small':
            classes.add('slds-button_icon-small');
            break;
          case 'x-small':
            classes.add('slds-button_icon-x-small');
            break;
          case 'xx-small':
            classes.add('slds-button_icon-xx-small');
            break;
          case 'large':
            // There is no `large` modifier for buttons so we should drop down one size to `medium`
            console.warn(`<lightning-button-icon> The non-bare variants of buttonIcon do not support a size value of "large". Supported values include "xx-small", "x-small", "small", and "medium". Falling back to size value "medium".`);
        }
      }
      return classes.add({
        'slds-button_icon-bare': isBare,
        'slds-button_icon-container': this._variant === 'container',
        'slds-button_icon-border': this._variant === 'border',
        'slds-button_icon-border-filled': this._variant === 'border-filled',
        'slds-button_icon-border-inverse': this._variant === 'border-inverse',
        'slds-button_icon-inverse': this._variant === 'bare-inverse',
        'slds-button_icon-brand': this._variant === 'brand'
      }).toString();
    }
    get computedIconClass() {
      const isBare = this.variantBase === 'bare';
      const iconClass = this.iconClass || '';
      const classes = utils.classSet('slds-button__icon');
      classes.add(iconClass);
      if (isBare) {
        // If the variant is bare, then size the icon instead of the button
        switch (this._size) {
          case 'large':
            classes.add('slds-button__icon_large');
            break;
          case 'small':
            classes.add('slds-button__icon_small');
            break;
          case 'xx-small':
            // There is no `xx-small` modifier for bare so we should drop down one size to `x-small`
            console.warn(`<lightning-button-icon> The bare variant of buttonIcon does not support a size value of "xx-small". Supported values include "x-small", "small", "medium", and "large". The default is "medium".`);
          /* falls through */
          case 'x-small':
            classes.add('slds-button__icon_x-small');
            break;
        }
      }
      return classes.toString();
    }
    handleFocus(event) {
      event.stopPropagation();
      this.dispatchEvent(new CustomEvent('focus'));
    }
    handleBlur(event) {
      this.dispatchEvent(new CustomEvent('blur', {
        detail: {
          [relatedTarget]: event.relatedTarget
        }
      }));
    }

    /**
     * Sets focus on the button.
     */
    focus() {
      if (this._connected) {
        this.template.querySelector('button').focus();
      }
    }

    /**
     * Simulates a mouse click on the button.
     */
    click() {
      if (this._connected) {
        this.template.querySelector('button').click();
      }
    }

    /**
     * Once we are connected, we fire a register event so the button-group (or other) component can register
     * the buttons.
     */
    connectedCallback() {
      super.connectedCallback();
      this._connected = true;
    }
    renderedCallback() {
      // initialize aria attributes in primitiveButton
      super.renderedCallback();

      // remove-next-line-for-c-namespace
      if (this.tooltipValue && !this._tooltip) {
        this.createTooltip(this.tooltipValue);
      }

      // button inherits from primitiveButton, button.css not working in this case.
      // change host style to disable pointer event.
      this.template.host.style.pointerEvents = this.disabled ? 'none' : '';
      this.rendered = true;
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this._connected = false;
      this.rendered = false;
      if (this._tooltip) {
        this._tooltip.disconnect();
      }
    }
    /*LWC compiler v7.1.5*/
  }
  LightningButtonIcon.delegatesFocus = true;
  lwc.registerDecorators(LightningButtonIcon, {
    publicProps: {
      name: {
        config: 0
      },
      value: {
        config: 0
      },
      tabIndex: {
        config: 0
      },
      variant: {
        config: 3
      },
      iconName: {
        config: 0
      },
      iconClass: {
        config: 0
      },
      size: {
        config: 3
      },
      type: {
        config: 0
      },
      alternativeText: {
        config: 0
      },
      tooltipType: {
        config: 0
      },
      disableAlternativeTextTitle: {
        config: 0
      },
      tooltip: {
        config: 3
      }
    },
    publicMethods: ["focus", "click"],
    fields: ["_variant", "_size", "_tooltip", "tooltipValue", "rendered"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningButtonIcon, {
    tmpl: _tmpl,
    sel: "lightning-button-icon",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;
  exports.relatedTarget = relatedTarget;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/helptext', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/buttonIcon', '@salesforce/label/LightningHelptext.buttonAlternativeText', 'lightning/shadowBaseClassPrivate', 'lightning/iconUtils', 'lightning/utilsPrivate'], (function (exports, lwc, stylesheet0$1, _lightningButtonIcon, labelButtonAlternativeText, LightningShadowBaseClass, iconUtils, utilsPrivate) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningButtonIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningButtonIcon);
  var labelButtonAlternativeText__default = /*#__PURE__*/_interopDefaultCompat(labelButtonAlternativeText);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

  function stylesheet$3(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='help-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='help-text']")) + shadowSelector + " {display: contents;}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet$3];

  function stylesheet$2(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) fieldset" : hostSelector + "[data-render-mode=\"shadow\"] fieldset")), shadowSelector, " {border: 0;margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {position: relative;min-width: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;hyphens: auto;display: inline-block;color: var(--slds-g-color-on-surface-2);font-size: var(--slds-s-label-font-size, var(--slds-g-font-scale-neg-2));padding-inline-end: var(--slds-g-spacing-2);padding-block-start: var(--slds-g-spacing-1);margin-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label:empty")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {clear: inline-start;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-radio", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {display: inline-block;position: relative;padding-block-start: var(--slds-g-spacing-1);vertical-align: top;line-height: var(--slds-g-font-lineheight-1);z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-form-element__helper" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__helper")), shadowSelector, " {font-size: var(--slds-s-helptext-font-size, var(--slds-g-font-scale-neg-2));margin-block-start: calc(var(--slds-g-spacing-1) / 2);display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_edit")), shadowSelector, " .slds-form-element__static", shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " {flex-basis: 0%;border-bottom: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__label", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__legend" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__legend")), shadowSelector, " {font-weight: var(--slds-g-font-weight-7);float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__addon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__addon")), shadowSelector, " {display: inline-block;margin-block-start: 0;margin-block-end: 0;margin-inline-start: var(--slds-g-spacing-2);margin-inline-end: var(--slds-g-spacing-2);align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;word-break: break-word;display: inline-block;font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-neutral-base-10);width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static.slds-text-longform" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static.slds-text-longform")), shadowSelector, " *:last-child", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static:empty")), shadowSelector, " {min-height: calc(var(--slds-g-sizing-6) + 1px);vertical-align: bottom;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static--edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static--edit")), shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-required" : hostSelector + "[data-render-mode=\"shadow\"] .slds-required")), shadowSelector, " {color: var(--slds-g-color-error-1);margin-block-start: 0;margin-block-end: 0;margin-inline-start: calc(var(--slds-g-spacing-1) / 2);margin-inline-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-form-element__help", shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-form-element__help" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) {" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {padding: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__label" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__label" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {width: 100%;flex-basis: 100%;clear: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__icon" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {float: none;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline'].slds-form-element_horizontal) {" : hostSelector + ".slds-form-element_horizontal[variant='label-inline'][data-render-mode=\"shadow\"] {")), "padding: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']).slds-is-edited {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"].slds-is-edited {")), "padding-block-start: var(--slds-g-sizing-6)}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__label" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {float: inline-start;max-width: calc(33% - var(--slds-g-sizing-6));flex-basis: calc(33% - var(--slds-g-sizing-6));flex-grow: 1;margin-block-end: 0;position: relative;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) lightning-helptext" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] lightning-helptext")), shadowSelector, " {float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {margin-inline-start: 33%;clear: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list__column" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list__column")), shadowSelector, " .slds-form-element__label", shadowSelector, " {width: auto;max-width: 100%;flex-basis: auto;float: none;position: relative;padding-inline-start: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__help" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list")), shadowSelector, " {clear: none;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " {display: flex;margin-bottom: var(--slds-g-spacing-1);margin-left: calc(var(--slds-g-spacing-1) * -1);margin-right: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " .slds-form-element__label", shadowSelector, " {padding-top: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element", shadowSelector, " {padding-left: var(--slds-g-spacing-1);padding-right: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_address" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_address")), shadowSelector, " .slds-form-element__row", shadowSelector, " {align-items: flex-end;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-hidden']) .slds-form-element__label" : hostSelector + "[variant='label-hidden'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {display: none}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet2 = [stylesheet$2];

  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ["*", shadowSelector, ",*", shadowSelector, "::before,*", shadowSelector, "::after {box-sizing: border-box;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {display: inline-flex;gap: var(--sds-c-button-spacing-gap, var(--sds-s-button-spacing-gap));background: var(--sds-c-button-color-background, var(--sds-s-button-color-background));color: var(--sds-c-button-text-color, var(--sds-s-button-color));font-weight: var(--sds-c-button-font-weight, var(--sds-s-button-font-weight));font-size: var(--sds-c-button-font-size, var(--sds-s-button-font-size, inherit));line-height: var(--sds-c-button-font-lineheight);height: var(--sds-c-button-sizing-height);width: var(--sds-c-button-sizing-width);padding-inline-start: var(\n --sds-c-button-spacing-inlinestart,\n var(\n --sds-c-button-spacing-inline,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-inline, var(--sds-s-button-spacing)))\n )\n );padding-inline-end: var(\n --sds-c-button-spacing-inlineend,\n var(\n --sds-c-button-spacing-inline,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-inline, var(--sds-s-button-spacing)))\n )\n );padding-block-start: var(\n --sds-c-button-spacing-blockstart,\n var(\n --sds-c-button-spacing-block,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-block, var(--sds-s-button-spacing)))\n )\n );padding-block-end: var(\n --sds-c-button-spacing-blockend,\n var(\n --sds-c-button-spacing-block,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-block, var(--sds-s-button-spacing)))\n )\n );border-width: var(--sds-c-button-sizing-border, var(--sds-s-button-sizing-border, 1px));border-style: solid;border-color: var(--sds-c-button-color-border, var(--sds-s-button-color-border, currentColor));border-start-start-radius: var(\n --sds-c-button-radius-border-startstart,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-startstart, var(--sds-s-button-radius-border))\n )\n );border-start-end-radius: var(\n --sds-c-button-radius-border-startend,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-startend, var(--sds-s-button-radius-border))\n )\n );border-end-start-radius: var(\n --sds-c-button-radius-border-endstart,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-endstart, var(--sds-s-button-radius-border))\n )\n );border-end-end-radius: var(\n --sds-c-button-radius-border-endend,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-endend, var(--sds-s-button-radius-border))\n )\n );box-shadow: var(--sds-c-button-shadow, var(--sds-s-button-shadow));text-decoration: var(--sds-c-button-font-decoration);white-space: normal;user-select: none;align-items: center;justify-content: center;appearance: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:hover" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:hover")), shadowSelector, " {--sds-c-button-text-color: var(--sds-c-button-text-color-hover, var(--sds-s-button-color-hover, revert));--sds-c-button-color-background: var(\n --sds-c-button-color-background-hover,\n var(--sds-s-button-color-background-hover, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-hover,\n var(--sds-s-button-color-border-hover, revert)\n );--sds-c-button-shadow: var(--sds-c-button-shadow-hover, var(--sds-s-button-shadow-hover, revert));cursor: pointer;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:focus")), shadowSelector, " {--sds-c-button-color-background: var(\n --sds-c-button-color-background-focus,\n var(--sds-s-button-color-background-focus, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-focus,\n var(--sds-s-button-color-border-focus, revert)\n );--sds-c-button-text-color: var(--sds-c-button-text-color-focus, var(--sds-s-button-color-focus, revert));--sds-c-button-shadow: var(--sds-c-button-shadow-focus, var(--sds-s-button-shadow-focus, revert));outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:active")), shadowSelector, " {--sds-c-button-text-color: var(--sds-c-button-text-color-active, var(--sds-s-button-color-active, revert));--sds-c-button-color-background: var(\n --sds-c-button-color-background-active,\n var(--sds-s-button-color-background-active, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-active,\n var(--sds-s-button-color-border-active, revert)\n );--sds-c-button-shadow: var(--sds-c-button-shadow-active, var(--sds-s-button-shadow-active, revert));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " {--sds-c-button-text-color: var(--sds-c-button-text-color-disabled);--sds-c-button-color-background: var(--sds-c-button-color-background-disabled);--sds-c-button-color-border: var(--sds-c-button-color-border-disabled);--sds-c-button-shadow: var(--sds-c-button-shadow-disabled);pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " *", shadowSelector, " {pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='button'][aria-pressed='true']" : hostSelector + "[data-render-mode=\"shadow\"] [part='button'][aria-pressed='true']")), shadowSelector, " {--sds-c-button-color-background: var(--sds-c-button-color-background-pressed, revert);--sds-c-button-color-border: var(--sds-c-button-color-border-pressed, revert);--sds-c-button-text-color: var(--sds-c-button-text-color-pressed, revert);--sds-c-button-shadow: var(--sds-c-button-shadow-pressed, revert);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {gap: var(--slds-g-spacing-2);--slds-c-icon-sizing-border: 0;--slds-c-icon-sizing: 0.875rem;--slds-c-icon-color-foreground: currentcolor;--sds-c-button-font-lineheight: var(\n --slds-c-button-neutral-font-lineheight,\n var(--slds-s-button-font-lineheight, 1.875rem)\n );--sds-c-button-spacing-inline: var(\n --slds-c-button-neutral-spacing-inline,\n var(--slds-s-button-spacing-inline, var(--slds-g-spacing-4));\n );--sds-c-button-spacing-block: var(--slds-c-button-neutral-spacing-block);--sds-c-button-radius-border-startstart: var(\n --slds-c-button-radius-border-startstart,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-startstart, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-endstart: var(\n --slds-c-button-radius-border-endstart,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-endstart, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-startend: var(\n --slds-c-button-radius-border-startend,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-startend, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-endend: var(\n --slds-c-button-radius-border-endend,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-endend, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-color-background: var(\n --slds-c-button-neutral-color-background,\n var(--slds-g-color-surface-container-1)\n );--sds-c-button-color-background-hover: var(\n --slds-c-button-neutral-color-background-hover,\n var(--slds-g-color-surface-container-2)\n );--sds-c-button-color-background-focus: var(--slds-c-button-neutral-color-background-focus, var(--slds-g-color-surface-container-2));--sds-c-button-color-background-active: var(\n --slds-c-button-neutral-color-background-active,\n var(--slds-g-color-surface-container-2)\n );--sds-c-button-color-border: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-2));--sds-c-button-color-border-hover: var(\n --slds-c-button-neutral-color-border-hover,\n var(--slds-g-color-border-2)\n );--sds-c-button-color-border-focus: var(\n --slds-c-button-neutral-color-border-focus,\n var(--slds-g-color-border-2)\n );--sds-c-button-color-border-active: var(\n --slds-c-button-neutral-color-border-active,\n var(--slds-g-color-border-2)\n );--sds-c-button-text-color: var(--slds-c-button-neutral-text-color, var(--slds-g-color-accent-2));--sds-c-button-text-color-hover: var(--slds-c-button-neutral-text-color-hover, var(--slds-s-button-color-hover, var(--slds-g-color-accent-3)));--sds-c-button-text-color-focus: var(--slds-c-button-neutral-text-color-focus, var(--slds-g-color-accent-3));--sds-c-button-text-color-active: var(\n --slds-c-button-neutral-text-color-active,\n var(--slds-g-color-accent-3)\n );--sds-c-button-shadow: var(--slds-c-button-neutral-shadow);--sds-c-button-shadow-focus: var(--slds-c-button-neutral-shadow-focus);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " {--sds-c-button-color-border-disabled: var(--slds-g-color-border-disabled-1);--sds-c-button-text-color-disabled: var(--slds-g-color-on-disabled-1);--sds-c-button-color-background-disabled: var(--slds-g-color-disabled-container-1);pointer-events: auto;cursor: default;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-color-background: var(\n --slds-c-button-brand-color-background,\n var(--slds-g-color-accent-container-1)\n );--slds-c-button-neutral-color-background-hover: var(\n --slds-c-button-brand-color-background-hover,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-background-focus: var(\n --slds-c-button-brand-color-background-focus,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-background-active: var(\n --slds-c-button-brand-color-background-active,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-border: var(\n --slds-c-button-brand-color-border,\n var(--slds-g-color-border-accent-1)\n );--slds-c-button-neutral-color-border-hover: var(\n --slds-c-button-brand-color-border-hover,\n var(--slds-g-color-border-accent-2)\n );--slds-c-button-neutral-color-border-focus: var(\n --slds-c-button-brand-color-border-focus,\n var(--slds-g-color-border-accent-2)\n );--slds-c-button-neutral-color-border-active: var(\n --slds-c-button-brand-color-border-active,\n var(--slds-g-color-border-accent-2)\n );--sds-c-button-text-color: var(--slds-c-button-brand-text-color, var(--slds-g-color-on-accent-1));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand-outline']) [part~='button']" : hostSelector + "[variant='brand-outline'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-color-border: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']" : hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-color-background: transparent;--slds-c-button-neutral-color-background-hover: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-active: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-text-color: var(--slds-g-color-on-accent-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-accent-2);--slds-c-button-neutral-text-color-active: var(--slds-g-color-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']:disabled" : hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " {--sds-c-button-color-background: transparent;--sds-c-button-color-border: var(--slds-g-color-border-disabled-2);--sds-c-button-text-color: var(--slds-g-color-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']" : hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-color-background: var(--slds-g-color-error-container-1);--slds-c-button-neutral-color-background-hover: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-border-error-1);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-error-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-error-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-error-2);--sds-c-button-text-color: var(--slds-g-color-on-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='success']) [part~='button']" : hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-color-background: var(--slds-g-color-success-container-1);--slds-c-button-neutral-color-background-hover: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-border-success-1);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-success-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-success-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-success-2);--slds-c-button-neutral-text-color: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-focus: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-active: var(--slds-g-color-on-success-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='destructive-text']) [part~='button']" : hostSelector + "[variant='destructive-text'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--slds-c-button-neutral-text-color: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-focus: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-active: var(--slds-g-color-error-1);--slds-c-button-neutral-color-border-hover: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));--slds-c-button-neutral-color-border-focus: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));--slds-c-button-neutral-color-border-active: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='success']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']:disabled" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " {--sds-c-button-color-background: var(--slds-g-color-disabled-container-2);--sds-c-button-color-border: var(--slds-g-color-border-disabled-1);--sds-c-button-text-color: var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='base']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='text']) [part~='button']" : hostSelector + "[variant='base'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='text'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, "{--sds-c-button-spacing-inline: 0;--slds-c-button-neutral-text-color: var(--slds-g-color-accent-2);--slds-c-button-neutral-color-border: transparent;--slds-c-button-neutral-color-border-hover: transparent;--slds-c-button-neutral-color-border-focus: transparent;--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-background: transparent;--slds-c-button-neutral-color-background-hover: transparent;--slds-c-button-neutral-color-background-focus: transparent;--slds-c-button-neutral-color-background-active: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='base']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='text']) [part~='button']:disabled" : hostSelector + "[variant='base'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='text'][data-render-mode=\"shadow\"] [part~='button']:disabled")), shadowSelector, " {--sds-c-button-color-background: transparent;--sds-c-button-color-border: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][stretch]) [part~='button']" : hostSelector + "[stretch][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {--sds-c-button-sizing-width: 100%;justify-content: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='brand-outline']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='success']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive-text']) [part~='button']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='brand-outline'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='destructive-text'][data-render-mode=\"shadow\"] [part~='button']")), shadowSelector, " {justify-content: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='start']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='start']")), shadowSelector, " {display: inline-flex;padding-inline-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='end']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='end']")), shadowSelector, " {display: inline-flex;padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button_reset" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button_reset")), shadowSelector, " {font-size: inherit;color: inherit;line-height: inherit;padding: 0;background: transparent;border: 0;text-align: inherit;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button-icon']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {display: inline-flex;--slds-c-icon-sizing-border: 0;--slds-c-icon-sizing: 0.875rem;--slds-c-icon-color-foreground: var(--slds-c-buttonicon-color-foreground, var(--slds-g-color-on-surface-1));--sds-c-button-spacing-inline: 0;--sds-c-button-sizing-height: var(--slds-g-sizing-9);--sds-c-button-sizing-width: var(--slds-g-sizing-9);--slds-c-button-neutral-color-background: transparent;--slds-c-button-neutral-color-background-hover: transparent;--slds-c-button-neutral-color-background-focus: transparent;--slds-c-button-neutral-color-background-active: transparent;--slds-c-button-neutral-color-border: var(--slds-g-color-border-2);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-2);--sds-c-button-color-background-disabled: var(--slds-g-color-surface-container-1);--sds-c-button-color-border-disabled: var(--slds-g-color-border-disabled-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button-icon']:hover" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button-icon']:hover")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-buttonicon-color-foreground-hover, \n var(--slds-g-color-accent-3)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button-icon']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button-icon']:focus")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-buttonicon-color-foreground-focus,\n var(--slds-g-color-accent-3)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button-icon']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button-icon']:active")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-buttonicon-color-foreground-active,\n var(--slds-g-color-accent-3)\n );--sds-c-button-shadow-active: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button-icon']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button-icon']:disabled")), shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-disabled-1);--sds-c-button-color-background-disabled: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='bare']) [part~='button-icon']" : hostSelector + "[variant='bare'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: auto;--sds-c-button-sizing-width: auto;--slds-c-button-neutral-color-border: transparent;--slds-c-button-neutral-color-border-hover: transparent;--slds-c-button-neutral-color-border-focus: transparent;--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-3);--sds-c-button-color-background-disabled: transparent;--sds-c-button-color-border-disabled: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='container']) [part~='button-icon']" : hostSelector + "[variant='container'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-button-neutral-color-border: transparent;--slds-c-button-neutral-color-border-hover: transparent;--slds-c-button-neutral-color-border-focus: transparent;--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-3);--sds-c-button-color-background-disabled: transparent;--sds-c-button-color-border-disabled: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button-icon']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-on-accent-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='bare-inverse']) [part~='button-icon']" : hostSelector + "[variant='bare-inverse'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: auto;--sds-c-button-sizing-width: auto;--slds-c-button-neutral-color-border: transparent;--slds-c-button-neutral-color-border-hover: transparent;--slds-c-button-neutral-color-border-focus: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-active: var(--slds-g-color-neutral-base-100);--sds-c-button-shadow-focus: 0 0 3px var(--slds-g-color-neutral-base-100);--slds-c-buttonicon-color-foreground: var(--slds-g-color-neutral-base-100);--slds-c-buttonicon-color-foreground-hover: color-mix(in oklab, var(--slds-g-color-on-surface-inverse-1), transparent 25%);--slds-c-buttonicon-color-foreground-focus: var(--slds-g-color-neutral-base-95);--slds-c-buttonicon-color-foreground-active: var(--slds-g-color-neutral-base-90);--sds-c-button-color-background-disabled: transparent;--sds-c-button-color-border-disabled: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='border-inverse']) [part~='button-icon']" : hostSelector + "[variant='border-inverse'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-button-neutral-color-border: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-active: var(--slds-g-color-neutral-base-100);--sds-c-button-shadow-focus: 0 0 3px var(--slds-g-color-neutral-base-100);--slds-c-buttonicon-color-foreground: var(--slds-g-color-neutral-base-100);--slds-c-buttonicon-color-foreground-hover: var(--slds-g-color-neutral-base-95);--slds-c-buttonicon-color-foreground-focus: var(--slds-g-color-neutral-base-95);--slds-c-buttonicon-color-foreground-active: var(--slds-g-color-neutral-base-90);--sds-c-button-color-background-disabled: transparent;--sds-c-button-color-border-disabled: var(--slds-g-color-border-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='border-filled']) [part~='button-icon']" : hostSelector + "[variant='border-filled'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-button-neutral-color-background: var(--slds-g-color-surface-container-1);--slds-c-button-neutral-color-background-hover: var(--slds-g-color-surface-container-1);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-surface-container-1);--slds-c-button-neutral-color-background-active: var(--slds-g-color-surface-container-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='border-filled']) [part~='button-icon']:disabled" : hostSelector + "[variant='border-filled'][data-render-mode=\"shadow\"] [part~='button-icon']:disabled")), shadowSelector, " {--sds-c-button-color-background-disabled: var(--slds-g-color-disabled-container-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) [part~='button-icon']" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: var(--slds-g-sizing-5);--sds-c-button-sizing-width: var(--slds-g-sizing-5);--slds-c-icon-sizing: var(--slds-g-sizing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) [part~='button-icon']" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: var(--slds-g-sizing-6);--sds-c-button-sizing-width: var(--slds-g-sizing-6);--slds-c-icon-sizing: var(--slds-g-sizing-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) [part~='button-icon']" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: var(--slds-g-sizing-7);--sds-c-button-sizing-width: var(--slds-g-sizing-7);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) [part~='button-icon']" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: var(--slds-g-sizing-10);--sds-c-button-sizing-width: var(--slds-g-sizing-10);--slds-c-icon-sizing: var(--slds-g-sizing-7);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small'][variant='bare']) [part~='button-icon']" : hostSelector + "[variant='bare'][size='x-small'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-buttonicon-spacing-block: 0;--slds-c-buttonicon-spacing-inline: 0;--slds-c-icon-sizing: var(--slds-g-sizing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small'][variant='bare']) [part~='button-icon']" : hostSelector + "[variant='bare'][size='small'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--slds-c-buttonicon-spacing-block: 0;--slds-c-buttonicon-spacing-inline: 0;--slds-c-icon-sizing: var(--slds-g-sizing-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large'][variant='bare']) [part~='button-icon']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][size='large'][variant='bare-inverse']) [part~='button-icon']" : hostSelector + "[variant='bare'][size='large'][data-render-mode=\"shadow\"] [part~='button-icon']" + shadowSelector + "," + hostSelector + "[variant='bare-inverse'][size='large'][data-render-mode=\"shadow\"] [part~='button-icon']")), shadowSelector, " {--sds-c-button-sizing-height: auto;--sds-c-button-sizing-width: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='end']" : hostSelector + "[data-render-mode=\"shadow\"] [part='end']")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet3 = [stylesheet$1];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1, stylesheet2, stylesheet3];

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ((useActualHostSelector ? ":host(.modal_header) .slds-form-element__icon" : hostSelector + ".modal_header .slds-form-element__icon")) + shadowSelector + " {padding-top: unset;padding-left: var(--slds-g-sizing-2);}";
    /*LWC compiler v7.1.5*/
  }
  var _implicitStylesheets = [stylesheet0, stylesheet];

  const stc0 = {
    classMap: {
      "slds-form-element__icon": true
    },
    attrs: {
      "part": "help-text"
    },
    key: 0
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {ti: api_tab_index, c: api_custom_element, h: api_element} = $api;
    return [api_element("div", stc0, [api_custom_element("lightning-button-icon", _lightningButtonIcon__default.default, {
      props: {
        "iconName": $cmp.iconName,
        "iconClass": $cmp.computedIconClass,
        "variant": $cmp.computedButtonVariant,
        "alternativeText": $cmp.alternativeText,
        "disableAlternativeTextTitle": true,
        "tooltip": $cmp.content,
        "tabIndex": api_tab_index($cmp.tabIndex),
        "tooltipType": "toggle"
      },
      key: 1
    })])];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-287jov2qseb";
  tmpl.legacyStylesheetToken = "lightning-helptext_helptext";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  const DEFAULT_BUTTON_ALT_TEXT = labelButtonAlternativeText__default.default;
  const DEFAULT_ICON_NAME = 'utility:info';
  const DEFAULT_ICON_VARIANT = 'bare';

  /**
   * An icon with a text popover used for tooltips.
   */
  class LightningHelptext extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      // TODO: future refactoring to remove this.state convention
      this.state = {
        iconName: DEFAULT_ICON_NAME,
        iconVariant: DEFAULT_ICON_VARIANT,
        alternativeText: DEFAULT_BUTTON_ALT_TEXT
      };
      /**
       * Text to be shown in the popover. For readability, provide a small amount of text.
       * @type {string}
       * @param {string} value - The plain text string for the tooltip
       */
      this.content = void 0;
      /**
       * Reserved for internal use only. Use the global tabindex attribute instead.
       * Set tab index to -1 to prevent focus on the button during tab navigation.
       * The default value is 0, which makes the button focusable during tab navigation.
       * @type {number}
       */
      this.tabIndex = void 0;
    }
    /**
     * The Lightning Design System name of the icon used as the visible element.
     * Names are written in the format 'utility:info' where 'utility' is the category,
     * and 'info' is the specific icon to be displayed.
     * The default is 'utility:info'.
     * @type {string}
     * @param {string} value the icon name to use
     * @default utility:info
     */
    get iconName() {
      if (iconUtils.isValidName(this.state.iconName)) {
        return this.state.iconName;
      }
      return DEFAULT_ICON_NAME;
    }
    set iconName(value) {
      this.state.iconName = value;
    }

    /**
     * Changes the appearance of the icon.
     * Accepted variants include inverse, warning, error.
     * @type {string}
     * @param {string} value the icon variant to use
     * @default bare
     */
    get iconVariant() {
      // NOTE: Leaving a note here because I just wasted a bunch of time
      // investigating why both 'bare' and 'inverse' are supported in
      // lightning-primitive-icon. lightning-icon also has a deprecated
      // 'bare', but that one is synonymous to 'inverse'. This 'bare' means
      // that no classes should be applied. So this component needs to
      // support both 'bare' and 'inverse' while lightning-icon only needs to
      // support 'inverse'.
      return utilsPrivate.normalizeString(this.state.iconVariant, {
        fallbackValue: DEFAULT_ICON_VARIANT,
        validValues: ['bare', 'error', 'inverse', 'warning']
      });
    }
    set iconVariant(value) {
      this.state.iconVariant = value;
    }

    /**
     * The assistive text for the button icon. The default is "Help".
     * Screen readers announce the assistive text and help text content as {alternativeText} button {content}.
     * If not set, screen readers announce "Help button {content}".
     * The text should describe the function of the icon, for example, "Show help text".
     *
     * @type {string}
     * @param {string} value The assistive text to set
     * @default Help
     */
    get alternativeText() {
      return this.state.alternativeText;
    }
    set alternativeText(value) {
      // typeof 'string' check prevents <lightning-helptext alternative-text>
      //   from setting 'true' as the a11y help text
      // lwc treats above alternative-text as: true (typeof 'boolean')
      //   we want to prevent 'true' or empty string as a11y text, instead default to 'Help'
      if (value && typeof value === 'string' && value.trim() !== '') {
        this.state.alternativeText = value;
      } else {
        // warn why they can't unset the value
        // eslint-disable-next-line no-console
        console.warn(`<lightning-helptext> Invalid alternativeText value: ${value}`);
      }
    }

    /**
     * Sets focus on the button.
     */
    focus() {
      this.template.querySelector('lightning-button-icon').focus();
    }

    // Get the variant to be applied to button based on the icon variant
    get computedButtonVariant() {
      switch (this.iconVariant) {
        case 'inverse':
          return 'bare-inverse';
        default:
          return 'bare';
      }
    }

    // Get the class to be applied to icon based on the icon variant
    get computedIconClass() {
      switch (this.iconVariant) {
        case 'error':
          return 'slds-icon-text-error';
        case 'warning':
          return 'slds-icon-text-warning';
        default:
          return '';
      }
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(LightningHelptext, {
    publicProps: {
      content: {
        config: 0
      },
      tabIndex: {
        config: 0
      },
      iconName: {
        config: 3
      },
      iconVariant: {
        config: 3
      },
      alternativeText: {
        config: 3
      }
    },
    publicMethods: ["focus"],
    track: {
      state: 1
    }
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningHelptext, {
    tmpl: _tmpl,
    sel: "lightning-helptext",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/i18n/currency', [], function() { return "INR"; });
(function() { LWR.define('@salesforce/i18n/dateTime.mediumDateFormat', ['exports'], (function (exports) {

	var _1v6zdogapkpugcn79fgc5irvm05vio8q0tfpz7a5fa8vypg = 'MMM d, yyyy';

	exports.default = _1v6zdogapkpugcn79fgc5irvm05vio8q0tfpz7a5fa8vypg;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.numberFormat', ['exports'], (function (exports) {

	var o8surgz3lbd8m2eracwmy3grnrft9adgx8ino = '#,##0.###';

	exports.default = o8surgz3lbd8m2eracwmy3grnrft9adgx8ino;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.percentFormat', ['exports'], (function (exports) {

	var _4sel6rcpljku58x4y1nsi2955c8cy393i41ehkk = '#,##0%';

	exports.default = _4sel6rcpljku58x4y1nsi2955c8cy393i41ehkk;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/i18n/number.currencyFormat', [], function() { return "¤#,##,##0.00"; });
(function() { LWR.define('@salesforce/i18n/dateTime.shortDateFormat', ['exports'], (function (exports) {

	var _9g63m01i7z4ufa0gihhgiycfnbspn51wsltroah0b19is = 'M/d/yyyy';

	exports.default = _9g63m01i7z4ufa0gihhgiycfnbspn51wsltroah0b19is;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/dateTime.longDateFormat', ['exports'], (function (exports) {

	var _1bu3vs4pmhvma0uftll0mwy2vcp6sbukvq02uigxyrn8 = 'MMMM d, yyyy';

	exports.default = _1bu3vs4pmhvma0uftll0mwy2vcp6sbukvq02uigxyrn8;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/dateTime.shortTimeFormat', ['exports'], (function (exports) {

	var _9g63m01i7z4ufa0gihhgiycfnbspn5e8lkf2h6074jhx0 = 'h:mm a';

	exports.default = _9g63m01i7z4ufa0gihhgiycfnbspn5e8lkf2h6074jhx0;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/dateTime.mediumTimeFormat', ['exports'], (function (exports) {

	var _1v6zdogapkpugcn79fgc5irvm05vio8qd58oki30yh2e73o = 'h:mm:ss a';

	exports.default = _1v6zdogapkpugcn79fgc5irvm05vio8qd58oki30yh2e73o;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/i18nCldrOptions', ['exports'], (function (exports) {

    /**
     * Match datetime components in a CLDR pattern, except those in single quotes.
     * This regexp should match all possible fragments described in:
     * http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table 
     */
    var expDTComponents = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;

    /**
     * Analayze individual segments of a CLDR pattern and matches it to
     * the corresponding datatime component option.
     */
    function analyzeSkeltonSegment($0, formatObj) {
      switch ($0.charAt(0)) {
        // --- Era
        case 'G':
          formatObj.era = ['short', 'short', 'short', 'long', 'narrow'][$0.length - 1];
          break;

        // --- Year
        case 'y':
        case 'Y':
        case 'u':
        case 'U':
        case 'r':
          formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';
          break;

        // --- Quarter (not supported in this polyfill)
        case 'Q':
        case 'q':
          formatObj.quarter = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];
          break;

        // --- Month
        case 'M':
        case 'L':
          formatObj.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];
          break;

        // --- Week (not supported in this polyfill)
        case 'w':
          // week of the year
          formatObj.week = $0.length === 2 ? '2-digit' : 'numeric';
          break;
        case 'W':
          // week of the month
          formatObj.week = 'numeric';
          break;

        // --- Day
        case 'd':
          // day of the month
          formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';
          break;
        case 'D': // day of the year
        case 'F': // day of the week
        case 'g':
          // 1..n: Modified Julian day
          formatObj.day = 'numeric';
          break;

        // --- Week Day
        case 'E':
          // day of the week
          formatObj.weekday = ['short', 'short', 'short', 'long', 'narrow', 'short'][$0.length - 1];
          break;
        case 'e':
          // local day of the week
          formatObj.weekday = ['numeric', '2-digit', 'short', 'long', 'narrow', 'short'][$0.length - 1];
          break;
        case 'c':
          // stand alone local day of the week
          formatObj.weekday = ['numeric', undefined, 'short', 'long', 'narrow', 'short'][$0.length - 1];
          break;

        // --- Period
        case 'a': // AM, PM
        case 'b': // am, pm, noon, midnight
        case 'B':
          // flexible day periods
          formatObj.hour12 = true;
          break;

        // --- Hour
        case 'h':
          // 1, 12
          formatObj.hourCycle = "h12";
          formatObj.hour12 = true; // 12-hour-cycle time formats
          formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';
          break;
        case 'H':
          // 0-23
          formatObj.hourCycle = "h23";
          formatObj.hour12 = false; // 23-hour-cycle time formats
          formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';
          break;
        case 'k':
          // 1, 24
          formatObj.hourCycle = "h24";
          formatObj.hour12 = false; // 24-hour-cycle time formats
          formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';
          break;
        case 'K':
          // 0, 11
          formatObj.hourCycle = "h11";
          formatObj.hour12 = true; // 11-hour-cycle time formats
          formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';
          break;

        // --- Minute
        case 'm':
          formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';
          break;

        // --- Second
        case 's':
          formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';
          break;
        case 'S':
        case 'A':
          formatObj.second = 'numeric';
          break;

        // --- Timezone
        case 'z': // 1..3, 4: specific non-location format
        case 'Z': // 1..3, 4, 5: The ISO8601 varios formats
        case 'O': // 1, 4: miliseconds in day short, long
        case 'v': // 1, 4: generic non-location format
        case 'V': // 1, 2, 3, 4: time zone ID or city
        case 'X': // 1, 2, 3, 4: The ISO8601 varios formats
        case 'x':
          // 1, 2, 3, 4: The ISO8601 varios formats
          // this polyfill only supports much, for now, we are just doing something dummy
          formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';
          break;
      }
    }
    var cache = Object.create(null);

    /**
     * Converts CLDR Pattern into a valid Intl.DateTimeFormat options object required by
     * the ECMAScript Internationalization API specification.
     */
    var intlDatetimeformatPattern = function getDateTimeFormatOptions(pattern) {
      if (typeof pattern !== 'string') {
        throw new TypeError();
      }
      var formatObj = cache[pattern];
      if (formatObj) {
        return formatObj;
      }
      formatObj = cache[pattern] = {};
      // Match the skeleton string with the one required by the specification
      // this implementation is based on the Date Field Symbol Table:
      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
      pattern.replace(expDTComponents, function ($0) {
        // See which symbol we're dealing with
        analyzeSkeltonSegment($0, formatObj);
        return '';
      });
      return formatObj;
    };

    exports.default = intlDatetimeformatPattern;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/common.digits', ['exports'], (function (exports) {

  var _8qx2emgm21h3epl3fcmjdpuj93eb = {
    "bhks": "𑱐𑱑𑱒𑱓𑱔𑱕𑱖𑱗𑱘𑱙",
    "talu": "᧐᧑᧒᧓᧔᧕᧖᧗᧘᧙",
    "guru": "੦੧੨੩੪੫੬੭੮੯",
    "arabext": "۰۱۲۳۴۵۶۷۸۹",
    "gujr": "૦૧૨૩૪૫૬૭૮૯",
    "mathdbl": "𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡",
    "fullwide": "０１２３４５６７８９",
    "telu": "౦౧౨౩౪౫౬౭౮౯",
    "mathmono": "𝟶𝟷𝟸𝟹𝟺𝟻𝟼𝟽𝟾𝟿",
    "gong": "𑶠𑶡𑶢𑶣𑶤𑶥𑶦𑶧𑶨𑶩",
    "beng": "০১২৩৪৫৬৭৮৯",
    "knda": "೦೧೨೩೪೫೬೭೮೯",
    "java": "꧐꧑꧒꧓꧔꧕꧖꧗꧘꧙",
    "modi": "𑙐𑙑𑙒𑙓𑙔𑙕𑙖𑙗𑙘𑙙",
    "gonm": "𑵐𑵑𑵒𑵓𑵔𑵕𑵖𑵗𑵘𑵙",
    "segment": "🯰🯱🯲🯳🯴🯵🯶🯷🯸🯹",
    "latn": "0123456789",
    "lepc": "᱀᱁᱂᱃᱄᱅᱆᱇᱈᱉",
    "orya": "୦୧୨୩୪୫୬୭୮୯",
    "takr": "𑛀𑛁𑛂𑛃𑛄𑛅𑛆𑛇𑛈𑛉",
    "sinh": "෦෧෨෩෪෫෬෭෮෯",
    "laoo": "໐໑໒໓໔໕໖໗໘໙",
    "thai": "๐๑๒๓๔๕๖๗๘๙",
    "mymrtlng": "꧰꧱꧲꧳꧴꧵꧶꧷꧸꧹",
    "sund": "᮰᮱᮲᮳᮴᮵᮶᮷᮸᮹",
    "olck": "᱐᱑᱒᱓᱔᱕᱖᱗᱘᱙",
    "tibt": "༠༡༢༣༤༥༦༧༨༩",
    "hmnp": "𞅀𞅁𞅂𞅃𞅄𞅅𞅆𞅇𞅈𞅉",
    "mtei": "꯰꯱꯲꯳꯴꯵꯶꯷꯸꯹",
    "sind": "𑋰𑋱𑋲𑋳𑋴𑋵𑋶𑋷𑋸𑋹",
    "vaii": "꘠꘡꘢꘣꘤꘥꘦꘧꘨꘩",
    "mymrshan": "႐႑႒႓႔႕႖႗႘႙",
    "tamldec": "௦௧௨௩௪௫௬௭௮௯",
    "sora": "𑃰𑃱𑃲𑃳𑃴𑃵𑃶𑃷𑃸𑃹",
    "arab": "٠١٢٣٤٥٦٧٨٩",
    "diak": "𑥐𑥑𑥒𑥓𑥔𑥕𑥖𑥗𑥘𑥙",
    "mlym": "൦൧൨൩൪൫൬൭൮൯",
    "deva": "०१२३४५६७८९",
    "hanidec": "〇一二三四五六七八九",
    "adlm": "𞥐𞥑𞥒𞥓𞥔𞥕𞥖𞥗𞥘𞥙",
    "rohg": "𐴰𐴱𐴲𐴳𐴴𐴵𐴶𐴷𐴸𐴹",
    "osma": "𐒠𐒡𐒢𐒣𐒤𐒥𐒦𐒧𐒨𐒩",
    "hmng": "𖭐𖭑𖭒𖭓𖭔𖭕𖭖𖭗𖭘𖭙",
    "wara": "𑣠𑣡𑣢𑣣𑣤𑣥𑣦𑣧𑣨𑣩",
    "bali": "᭐᭑᭒᭓᭔᭕᭖᭗᭘᭙",
    "brah": "𑁦𑁧𑁨𑁩𑁪𑁫𑁬𑁭𑁮𑁯",
    "lana": "᪀᪁᪂᪃᪄᪅᪆᪇᪈᪉",
    "tirh": "𑓐𑓑𑓒𑓓𑓔𑓕𑓖𑓗𑓘𑓙",
    "saur": "꣐꣑꣒꣓꣔꣕꣖꣗꣘꣙",
    "limb": "᥆᥇᥈᥉᥊᥋᥌᥍᥎᥏",
    "kali": "꤀꤁꤂꤃꤄꤅꤆꤇꤈꤉",
    "mymr": "၀၁၂၃၄၅၆၇၈၉",
    "wcho": "𞋰𞋱𞋲𞋳𞋴𞋵𞋶𞋷𞋸𞋹",
    "mathsans": "𝟢𝟣𝟤𝟥𝟦𝟧𝟨𝟩𝟪𝟫",
    "ahom": "𑜰𑜱𑜲𑜳𑜴𑜵𑜶𑜷𑜸𑜹",
    "mong": "᠐᠑᠒᠓᠔᠕᠖᠗᠘᠙",
    "cakm": "𑄶𑄷𑄸𑄹𑄺𑄻𑄼𑄽𑄾𑄿",
    "nkoo": "߀߁߂߃߄߅߆߇߈߉",
    "khmr": "០១២៣៤៥៦៧៨៩",
    "newa": "𑑐𑑑𑑒𑑓𑑔𑑕𑑖𑑗𑑘𑑙",
    "shrd": "𑇐𑇑𑇒𑇓𑇔𑇕𑇖𑇗𑇘𑇙",
    "mathsanb": "𝟬𝟭𝟮𝟯𝟰𝟱𝟲𝟳𝟴𝟵",
    "lanatham": "᪐᪑᪒᪓᪔᪕᪖᪗᪘᪙",
    "mroo": "𖩠𖩡𖩢𖩣𖩤𖩥𖩦𖩧𖩨𖩩",
    "mathbold": "𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗",
    "tnsa": "𖫀𖫁𖫂𖫃𖫄𖫅𖫆𖫇𖫈𖫉",
    "cham": "꩐꩑꩒꩓꩔꩕꩖꩗꩘꩙"
  };

  exports.default = _8qx2emgm21h3epl3fcmjdpuj93eb;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/common.calendarData', ['exports'], (function (exports) {

	var o8surgz3esowdo66t4p8dkgo03dyh3a9w4h9d = {
	  "buddhist": {
	    "calendarSystem": "solar",
	    "eras": {
	      "0": {
	        "_start": "-542-01-01"
	      }
	    }
	  },
	  "ethiopic-amete-alem": {
	    "eras": {
	      "0": {
	        "_end": "-5492-08-29"
	      }
	    }
	  },
	  "generic": {},
	  "gregorian": {
	    "calendarSystem": "solar",
	    "eras": {
	      "0": {
	        "_end": "0-12-31"
	      },
	      "1": {
	        "_start": "1-01-01"
	      }
	    }
	  },
	  "indian": {
	    "eras": {
	      "0": {
	        "_start": "79-01-01"
	      }
	    }
	  },
	  "japanese": {
	    "calendarSystem": "solar",
	    "eras": {
	      "0": {
	        "_start": "645-6-19"
	      },
	      "1": {
	        "_start": "650-2-15"
	      },
	      "2": {
	        "_start": "672-1-1"
	      },
	      "3": {
	        "_start": "686-7-20"
	      },
	      "4": {
	        "_start": "701-3-21"
	      },
	      "5": {
	        "_start": "704-5-10"
	      },
	      "6": {
	        "_start": "708-1-11"
	      },
	      "7": {
	        "_start": "715-9-2"
	      },
	      "8": {
	        "_start": "717-11-17"
	      },
	      "9": {
	        "_start": "724-2-4"
	      },
	      "10": {
	        "_start": "729-8-5"
	      },
	      "11": {
	        "_start": "749-4-14"
	      },
	      "12": {
	        "_start": "749-7-2"
	      },
	      "13": {
	        "_start": "757-8-18"
	      },
	      "14": {
	        "_start": "765-1-7"
	      },
	      "15": {
	        "_start": "767-8-16"
	      },
	      "16": {
	        "_start": "770-10-1"
	      },
	      "17": {
	        "_start": "781-1-1"
	      },
	      "18": {
	        "_start": "782-8-19"
	      },
	      "19": {
	        "_start": "806-5-18"
	      },
	      "20": {
	        "_start": "810-9-19"
	      },
	      "21": {
	        "_start": "824-1-5"
	      },
	      "22": {
	        "_start": "834-1-3"
	      },
	      "23": {
	        "_start": "848-6-13"
	      },
	      "24": {
	        "_start": "851-4-28"
	      },
	      "25": {
	        "_start": "854-11-30"
	      },
	      "26": {
	        "_start": "857-2-21"
	      },
	      "27": {
	        "_start": "859-4-15"
	      },
	      "28": {
	        "_start": "877-4-16"
	      },
	      "29": {
	        "_start": "885-2-21"
	      },
	      "30": {
	        "_start": "889-4-27"
	      },
	      "31": {
	        "_start": "898-4-26"
	      },
	      "32": {
	        "_start": "901-7-15"
	      },
	      "33": {
	        "_start": "923-4-11"
	      },
	      "34": {
	        "_start": "931-4-26"
	      },
	      "35": {
	        "_start": "938-5-22"
	      },
	      "36": {
	        "_start": "947-4-22"
	      },
	      "37": {
	        "_start": "957-10-27"
	      },
	      "38": {
	        "_start": "961-2-16"
	      },
	      "39": {
	        "_start": "964-7-10"
	      },
	      "40": {
	        "_start": "968-8-13"
	      },
	      "41": {
	        "_start": "970-3-25"
	      },
	      "42": {
	        "_start": "973-12-20"
	      },
	      "43": {
	        "_start": "976-7-13"
	      },
	      "44": {
	        "_start": "978-11-29"
	      },
	      "45": {
	        "_start": "983-4-15"
	      },
	      "46": {
	        "_start": "985-4-27"
	      },
	      "47": {
	        "_start": "987-4-5"
	      },
	      "48": {
	        "_start": "989-8-8"
	      },
	      "49": {
	        "_start": "990-11-7"
	      },
	      "50": {
	        "_start": "995-2-22"
	      },
	      "51": {
	        "_start": "999-1-13"
	      },
	      "52": {
	        "_start": "1004-7-20"
	      },
	      "53": {
	        "_start": "1012-12-25"
	      },
	      "54": {
	        "_start": "1017-4-23"
	      },
	      "55": {
	        "_start": "1021-2-2"
	      },
	      "56": {
	        "_start": "1024-7-13"
	      },
	      "57": {
	        "_start": "1028-7-25"
	      },
	      "58": {
	        "_start": "1037-4-21"
	      },
	      "59": {
	        "_start": "1040-11-10"
	      },
	      "60": {
	        "_start": "1044-11-24"
	      },
	      "61": {
	        "_start": "1046-4-14"
	      },
	      "62": {
	        "_start": "1053-1-11"
	      },
	      "63": {
	        "_start": "1058-8-29"
	      },
	      "64": {
	        "_start": "1065-8-2"
	      },
	      "65": {
	        "_start": "1069-4-13"
	      },
	      "66": {
	        "_start": "1074-8-23"
	      },
	      "67": {
	        "_start": "1077-11-17"
	      },
	      "68": {
	        "_start": "1081-2-10"
	      },
	      "69": {
	        "_start": "1084-2-7"
	      },
	      "70": {
	        "_start": "1087-4-7"
	      },
	      "71": {
	        "_start": "1094-12-15"
	      },
	      "72": {
	        "_start": "1096-12-17"
	      },
	      "73": {
	        "_start": "1097-11-21"
	      },
	      "74": {
	        "_start": "1099-8-28"
	      },
	      "75": {
	        "_start": "1104-2-10"
	      },
	      "76": {
	        "_start": "1106-4-9"
	      },
	      "77": {
	        "_start": "1108-8-3"
	      },
	      "78": {
	        "_start": "1110-7-13"
	      },
	      "79": {
	        "_start": "1113-7-13"
	      },
	      "80": {
	        "_start": "1118-4-3"
	      },
	      "81": {
	        "_start": "1120-4-10"
	      },
	      "82": {
	        "_start": "1124-4-3"
	      },
	      "83": {
	        "_start": "1126-1-22"
	      },
	      "84": {
	        "_start": "1131-1-29"
	      },
	      "85": {
	        "_start": "1132-8-11"
	      },
	      "86": {
	        "_start": "1135-4-27"
	      },
	      "87": {
	        "_start": "1141-7-10"
	      },
	      "88": {
	        "_start": "1142-4-28"
	      },
	      "89": {
	        "_start": "1144-2-23"
	      },
	      "90": {
	        "_start": "1145-7-22"
	      },
	      "91": {
	        "_start": "1151-1-26"
	      },
	      "92": {
	        "_start": "1154-10-28"
	      },
	      "93": {
	        "_start": "1156-4-27"
	      },
	      "94": {
	        "_start": "1159-4-20"
	      },
	      "95": {
	        "_start": "1160-1-10"
	      },
	      "96": {
	        "_start": "1161-9-4"
	      },
	      "97": {
	        "_start": "1163-3-29"
	      },
	      "98": {
	        "_start": "1165-6-5"
	      },
	      "99": {
	        "_start": "1166-8-27"
	      },
	      "100": {
	        "_start": "1169-4-8"
	      },
	      "101": {
	        "_start": "1171-4-21"
	      },
	      "102": {
	        "_start": "1175-7-28"
	      },
	      "103": {
	        "_start": "1177-8-4"
	      },
	      "104": {
	        "_start": "1181-7-14"
	      },
	      "105": {
	        "_start": "1182-5-27"
	      },
	      "106": {
	        "_start": "1184-4-16"
	      },
	      "107": {
	        "_start": "1185-8-14"
	      },
	      "108": {
	        "_start": "1190-4-11"
	      },
	      "109": {
	        "_start": "1199-4-27"
	      },
	      "110": {
	        "_start": "1201-2-13"
	      },
	      "111": {
	        "_start": "1204-2-20"
	      },
	      "112": {
	        "_start": "1206-4-27"
	      },
	      "113": {
	        "_start": "1207-10-25"
	      },
	      "114": {
	        "_start": "1211-3-9"
	      },
	      "115": {
	        "_start": "1213-12-6"
	      },
	      "116": {
	        "_start": "1219-4-12"
	      },
	      "117": {
	        "_start": "1222-4-13"
	      },
	      "118": {
	        "_start": "1224-11-20"
	      },
	      "119": {
	        "_start": "1225-4-20"
	      },
	      "120": {
	        "_start": "1227-12-10"
	      },
	      "121": {
	        "_start": "1229-3-5"
	      },
	      "122": {
	        "_start": "1232-4-2"
	      },
	      "123": {
	        "_start": "1233-4-15"
	      },
	      "124": {
	        "_start": "1234-11-5"
	      },
	      "125": {
	        "_start": "1235-9-19"
	      },
	      "126": {
	        "_start": "1238-11-23"
	      },
	      "127": {
	        "_start": "1239-2-7"
	      },
	      "128": {
	        "_start": "1240-7-16"
	      },
	      "129": {
	        "_start": "1243-2-26"
	      },
	      "130": {
	        "_start": "1247-2-28"
	      },
	      "131": {
	        "_start": "1249-3-18"
	      },
	      "132": {
	        "_start": "1256-10-5"
	      },
	      "133": {
	        "_start": "1257-3-14"
	      },
	      "134": {
	        "_start": "1259-3-26"
	      },
	      "135": {
	        "_start": "1260-4-13"
	      },
	      "136": {
	        "_start": "1261-2-20"
	      },
	      "137": {
	        "_start": "1264-2-28"
	      },
	      "138": {
	        "_start": "1275-4-25"
	      },
	      "139": {
	        "_start": "1278-2-29"
	      },
	      "140": {
	        "_start": "1288-4-28"
	      },
	      "141": {
	        "_start": "1293-8-5"
	      },
	      "142": {
	        "_start": "1299-4-25"
	      },
	      "143": {
	        "_start": "1302-11-21"
	      },
	      "144": {
	        "_start": "1303-8-5"
	      },
	      "145": {
	        "_start": "1306-12-14"
	      },
	      "146": {
	        "_start": "1308-10-9"
	      },
	      "147": {
	        "_start": "1311-4-28"
	      },
	      "148": {
	        "_start": "1312-3-20"
	      },
	      "149": {
	        "_start": "1317-2-3"
	      },
	      "150": {
	        "_start": "1319-4-28"
	      },
	      "151": {
	        "_start": "1321-2-23"
	      },
	      "152": {
	        "_start": "1324-12-9"
	      },
	      "153": {
	        "_start": "1326-4-26"
	      },
	      "154": {
	        "_start": "1329-8-29"
	      },
	      "155": {
	        "_start": "1331-8-9"
	      },
	      "156": {
	        "_start": "1334-1-29"
	      },
	      "157": {
	        "_start": "1336-2-29"
	      },
	      "158": {
	        "_start": "1340-4-28"
	      },
	      "159": {
	        "_start": "1346-12-8"
	      },
	      "160": {
	        "_start": "1370-7-24"
	      },
	      "161": {
	        "_start": "1372-4-1"
	      },
	      "162": {
	        "_start": "1375-5-27"
	      },
	      "163": {
	        "_start": "1379-3-22"
	      },
	      "164": {
	        "_start": "1381-2-10"
	      },
	      "165": {
	        "_start": "1384-4-28"
	      },
	      "166": {
	        "_start": "1387-8-22"
	      },
	      "167": {
	        "_start": "1387-8-23"
	      },
	      "168": {
	        "_start": "1389-2-9"
	      },
	      "169": {
	        "_start": "1390-3-26"
	      },
	      "170": {
	        "_start": "1394-7-5"
	      },
	      "171": {
	        "_start": "1428-4-27"
	      },
	      "172": {
	        "_start": "1429-9-5"
	      },
	      "173": {
	        "_start": "1441-2-17"
	      },
	      "174": {
	        "_start": "1444-2-5"
	      },
	      "175": {
	        "_start": "1449-7-28"
	      },
	      "176": {
	        "_start": "1452-7-25"
	      },
	      "177": {
	        "_start": "1455-7-25"
	      },
	      "178": {
	        "_start": "1457-9-28"
	      },
	      "179": {
	        "_start": "1460-12-21"
	      },
	      "180": {
	        "_start": "1466-2-28"
	      },
	      "181": {
	        "_start": "1467-3-3"
	      },
	      "182": {
	        "_start": "1469-4-28"
	      },
	      "183": {
	        "_start": "1487-7-29"
	      },
	      "184": {
	        "_start": "1489-8-21"
	      },
	      "185": {
	        "_start": "1492-7-19"
	      },
	      "186": {
	        "_start": "1501-2-29"
	      },
	      "187": {
	        "_start": "1504-2-30"
	      },
	      "188": {
	        "_start": "1521-8-23"
	      },
	      "189": {
	        "_start": "1528-8-20"
	      },
	      "190": {
	        "_start": "1532-7-29"
	      },
	      "191": {
	        "_start": "1555-10-23"
	      },
	      "192": {
	        "_start": "1558-2-28"
	      },
	      "193": {
	        "_start": "1570-4-23"
	      },
	      "194": {
	        "_start": "1573-7-28"
	      },
	      "195": {
	        "_start": "1592-12-8"
	      },
	      "196": {
	        "_start": "1596-10-27"
	      },
	      "197": {
	        "_start": "1615-7-13"
	      },
	      "198": {
	        "_start": "1624-2-30"
	      },
	      "199": {
	        "_start": "1644-12-16"
	      },
	      "200": {
	        "_start": "1648-2-15"
	      },
	      "201": {
	        "_start": "1652-9-18"
	      },
	      "202": {
	        "_start": "1655-4-13"
	      },
	      "203": {
	        "_start": "1658-7-23"
	      },
	      "204": {
	        "_start": "1661-4-25"
	      },
	      "205": {
	        "_start": "1673-9-21"
	      },
	      "206": {
	        "_start": "1681-9-29"
	      },
	      "207": {
	        "_start": "1684-2-21"
	      },
	      "208": {
	        "_start": "1688-9-30"
	      },
	      "209": {
	        "_start": "1704-3-13"
	      },
	      "210": {
	        "_start": "1711-4-25"
	      },
	      "211": {
	        "_start": "1716-6-22"
	      },
	      "212": {
	        "_start": "1736-4-28"
	      },
	      "213": {
	        "_start": "1741-2-27"
	      },
	      "214": {
	        "_start": "1744-2-21"
	      },
	      "215": {
	        "_start": "1748-7-12"
	      },
	      "216": {
	        "_start": "1751-10-27"
	      },
	      "217": {
	        "_start": "1764-6-2"
	      },
	      "218": {
	        "_start": "1772-11-16"
	      },
	      "219": {
	        "_start": "1781-4-2"
	      },
	      "220": {
	        "_start": "1789-1-25"
	      },
	      "221": {
	        "_start": "1801-2-5"
	      },
	      "222": {
	        "_start": "1804-2-11"
	      },
	      "223": {
	        "_start": "1818-4-22"
	      },
	      "224": {
	        "_start": "1830-12-10"
	      },
	      "225": {
	        "_start": "1844-12-2"
	      },
	      "226": {
	        "_start": "1848-2-28"
	      },
	      "227": {
	        "_start": "1854-11-27"
	      },
	      "228": {
	        "_start": "1860-3-18"
	      },
	      "229": {
	        "_start": "1861-2-19"
	      },
	      "230": {
	        "_start": "1864-2-20"
	      },
	      "231": {
	        "_start": "1865-4-7"
	      },
	      "232": {
	        "_start": "1868-9-8"
	      },
	      "233": {
	        "_start": "1912-7-30"
	      },
	      "234": {
	        "_start": "1926-12-25"
	      },
	      "235": {
	        "_start": "1989-1-8"
	      },
	      "236": {
	        "_start": "2019-5-1"
	      }
	    }
	  },
	  "persian": {
	    "calendarSystem": "solar",
	    "eras": {
	      "0": {
	        "_start": "622-01-01"
	      }
	    }
	  },
	  "roc": {
	    "eras": {
	      "0": {
	        "_end": "1911-12-31"
	      },
	      "1": {
	        "_start": "1912-01-01"
	      }
	    }
	  }
	};

	exports.default = o8surgz3esowdo66t4p8dkgo03dyh3a9w4h9d;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/defaultCalendar', ['exports'], (function (exports) {

	var cacroce1urcoj61td0rq8h4qpewy0z6 = 'gregorian';

	exports.default = cacroce1urcoj61td0rq8h4qpewy0z6;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/defaultNumberingSystem', ['exports'], (function (exports) {

	var _6q665n5uq53lifmchozdhboaaexo8tgfht4dlszujx = 'latn';

	exports.default = _6q665n5uq53lifmchozdhboaaexo8tgfht4dlszujx;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/calendarData', ['exports'], (function (exports) {

	var _18a9wfj7lnru7mliace11oizqsh = {
	  "gregorian": {
	    "dayPeriods": {
	      "format": {
	        "abbreviated": {
	          "midnight": "midnight",
	          "am": "AM",
	          "am-alt-variant": "am",
	          "noon": "noon",
	          "pm": "PM",
	          "pm-alt-variant": "pm",
	          "morning1": "in the morning",
	          "afternoon1": "in the afternoon",
	          "evening1": "in the evening",
	          "night1": "at night"
	        },
	        "narrow": {
	          "midnight": "mi",
	          "am": "a",
	          "am-alt-variant": "am",
	          "noon": "n",
	          "pm": "p",
	          "pm-alt-variant": "pm",
	          "morning1": "in the morning",
	          "afternoon1": "in the afternoon",
	          "evening1": "in the evening",
	          "night1": "at night"
	        },
	        "wide": {
	          "midnight": "midnight",
	          "am": "AM",
	          "am-alt-variant": "am",
	          "noon": "noon",
	          "pm": "PM",
	          "pm-alt-variant": "pm",
	          "morning1": "in the morning",
	          "afternoon1": "in the afternoon",
	          "evening1": "in the evening",
	          "night1": "at night"
	        }
	      },
	      "stand-alone": {
	        "abbreviated": {
	          "midnight": "midnight",
	          "am": "AM",
	          "am-alt-variant": "am",
	          "noon": "noon",
	          "pm": "PM",
	          "pm-alt-variant": "pm",
	          "morning1": "morning",
	          "afternoon1": "afternoon",
	          "evening1": "evening",
	          "night1": "night"
	        },
	        "narrow": {
	          "midnight": "midnight",
	          "am": "AM",
	          "am-alt-variant": "am",
	          "noon": "noon",
	          "pm": "PM",
	          "pm-alt-variant": "pm",
	          "morning1": "morning",
	          "afternoon1": "afternoon",
	          "evening1": "evening",
	          "night1": "night"
	        },
	        "wide": {
	          "midnight": "midnight",
	          "am": "AM",
	          "am-alt-variant": "am",
	          "noon": "noon",
	          "pm": "PM",
	          "pm-alt-variant": "pm",
	          "morning1": "morning",
	          "afternoon1": "afternoon",
	          "evening1": "evening",
	          "night1": "night"
	        }
	      }
	    },
	    "days": {
	      "format": {
	        "abbreviated": {
	          "sun": "Sun",
	          "mon": "Mon",
	          "tue": "Tue",
	          "wed": "Wed",
	          "thu": "Thu",
	          "fri": "Fri",
	          "sat": "Sat"
	        },
	        "narrow": {
	          "sun": "S",
	          "mon": "M",
	          "tue": "T",
	          "wed": "W",
	          "thu": "T",
	          "fri": "F",
	          "sat": "S"
	        },
	        "short": {
	          "sun": "Su",
	          "mon": "Mo",
	          "tue": "Tu",
	          "wed": "We",
	          "thu": "Th",
	          "fri": "Fr",
	          "sat": "Sa"
	        },
	        "wide": {
	          "sun": "Sunday",
	          "mon": "Monday",
	          "tue": "Tuesday",
	          "wed": "Wednesday",
	          "thu": "Thursday",
	          "fri": "Friday",
	          "sat": "Saturday"
	        }
	      },
	      "stand-alone": {
	        "abbreviated": {
	          "sun": "Sun",
	          "mon": "Mon",
	          "tue": "Tue",
	          "wed": "Wed",
	          "thu": "Thu",
	          "fri": "Fri",
	          "sat": "Sat"
	        },
	        "narrow": {
	          "sun": "S",
	          "mon": "M",
	          "tue": "T",
	          "wed": "W",
	          "thu": "T",
	          "fri": "F",
	          "sat": "S"
	        },
	        "short": {
	          "sun": "Su",
	          "mon": "Mo",
	          "tue": "Tu",
	          "wed": "We",
	          "thu": "Th",
	          "fri": "Fr",
	          "sat": "Sa"
	        },
	        "wide": {
	          "sun": "Sunday",
	          "mon": "Monday",
	          "tue": "Tuesday",
	          "wed": "Wednesday",
	          "thu": "Thursday",
	          "fri": "Friday",
	          "sat": "Saturday"
	        }
	      }
	    },
	    "eras": {
	      "eraNames": {
	        "0": "Before Christ",
	        "1": "Anno Domini",
	        "0-alt-variant": "Before Common Era",
	        "1-alt-variant": "Common Era"
	      },
	      "eraAbbr": {
	        "0": "BC",
	        "1": "AD",
	        "0-alt-variant": "BCE",
	        "1-alt-variant": "CE"
	      },
	      "eraNarrow": {
	        "0": "B",
	        "1": "A",
	        "0-alt-variant": "BCE",
	        "1-alt-variant": "CE"
	      }
	    },
	    "months": {
	      "format": {
	        "abbreviated": {
	          "1": "Jan",
	          "2": "Feb",
	          "3": "Mar",
	          "4": "Apr",
	          "5": "May",
	          "6": "Jun",
	          "7": "Jul",
	          "8": "Aug",
	          "9": "Sep",
	          "10": "Oct",
	          "11": "Nov",
	          "12": "Dec"
	        },
	        "narrow": {
	          "1": "J",
	          "2": "F",
	          "3": "M",
	          "4": "A",
	          "5": "M",
	          "6": "J",
	          "7": "J",
	          "8": "A",
	          "9": "S",
	          "10": "O",
	          "11": "N",
	          "12": "D"
	        },
	        "wide": {
	          "1": "January",
	          "2": "February",
	          "3": "March",
	          "4": "April",
	          "5": "May",
	          "6": "June",
	          "7": "July",
	          "8": "August",
	          "9": "September",
	          "10": "October",
	          "11": "November",
	          "12": "December"
	        }
	      },
	      "stand-alone": {
	        "abbreviated": {
	          "1": "Jan",
	          "2": "Feb",
	          "3": "Mar",
	          "4": "Apr",
	          "5": "May",
	          "6": "Jun",
	          "7": "Jul",
	          "8": "Aug",
	          "9": "Sep",
	          "10": "Oct",
	          "11": "Nov",
	          "12": "Dec"
	        },
	        "narrow": {
	          "1": "J",
	          "2": "F",
	          "3": "M",
	          "4": "A",
	          "5": "M",
	          "6": "J",
	          "7": "J",
	          "8": "A",
	          "9": "S",
	          "10": "O",
	          "11": "N",
	          "12": "D"
	        },
	        "wide": {
	          "1": "January",
	          "2": "February",
	          "3": "March",
	          "4": "April",
	          "5": "May",
	          "6": "June",
	          "7": "July",
	          "8": "August",
	          "9": "September",
	          "10": "October",
	          "11": "November",
	          "12": "December"
	        }
	      }
	    },
	    "quarters": {
	      "format": {
	        "abbreviated": {
	          "1": "Q1",
	          "2": "Q2",
	          "3": "Q3",
	          "4": "Q4"
	        },
	        "narrow": {
	          "1": "1",
	          "2": "2",
	          "3": "3",
	          "4": "4"
	        },
	        "wide": {
	          "1": "1st quarter",
	          "2": "2nd quarter",
	          "3": "3rd quarter",
	          "4": "4th quarter"
	        }
	      },
	      "stand-alone": {
	        "abbreviated": {
	          "1": "Q1",
	          "2": "Q2",
	          "3": "Q3",
	          "4": "Q4"
	        },
	        "narrow": {
	          "1": "1",
	          "2": "2",
	          "3": "3",
	          "4": "4"
	        },
	        "wide": {
	          "1": "1st quarter",
	          "2": "2nd quarter",
	          "3": "3rd quarter",
	          "4": "4th quarter"
	        }
	      }
	    }
	  }
	};

	exports.default = _18a9wfj7lnru7mliace11oizqsh;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.decimalSeparator', ['exports'], (function (exports) {

	var _1bu3vs4pmtmxwlo3zyaynlwegybtqqzg4oybxn9b9x82 = '.';

	exports.default = _1bu3vs4pmtmxwlo3zyaynlwegybtqqzg4oybxn9b9x82;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.groupingSeparator', ['exports'], (function (exports) {

	var _9g63m01iaar53u3gfnxzq4dake7woytdxybrphwhm3gc2 = ',';

	exports.default = _9g63m01iaar53u3gfnxzq4dake7woytdxybrphwhm3gc2;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.percentSign', ['exports'], (function (exports) {

	var _3eqk2qkooxnsrupp7n6uirjsqc49hxzhtgtq = '%';

	exports.default = _3eqk2qkooxnsrupp7n6uirjsqc49hxzhtgtq;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.plusSign', ['exports'], (function (exports) {

	var cacroce1xrx9qi4v1tretene8katx7y = '+';

	exports.default = cacroce1xrx9qi4v1tretene8katx7y;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.minusSign', ['exports'], (function (exports) {

	var _2fdmst43xs6kl8gykszmln0cdpj61n626 = '-';

	exports.default = _2fdmst43xs6kl8gykszmln0cdpj61n626;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.exponentialSign', ['exports'], (function (exports) {

	var _6q665n5ursje5apb8rf09ly9mbw23wwd5jvnqwu3xq = 'E';

	exports.default = _6q665n5ursje5apb8rf09ly9mbw23wwd5jvnqwu3xq;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.superscriptingExponentSign', ['exports'], (function (exports) {

	var _79l7qqxbo7ac1bjuriq3hjjkt7t0hw2v38zf8b2tww46g5syzecsi0tmj5a = '×';

	exports.default = _79l7qqxbo7ac1bjuriq3hjjkt7t0hw2v38zf8b2tww46g5syzecsi0tmj5a;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.perMilleSign', ['exports'], (function (exports) {

	var o8surgz3lbd8m2eracwp1fwpxp2fbgecfg0vi = '‰';

	exports.default = o8surgz3lbd8m2eracwp1fwpxp2fbgecfg0vi;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.infinity', ['exports'], (function (exports) {

	var cacroce1xrx9qi4v1trazlh342gjtkp = '∞';

	exports.default = cacroce1xrx9qi4v1trazlh342gjtkp;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/i18n/number.nan', ['exports'], (function (exports) {

	var viziwko862lzerg9c3xm25q = 'NaN';

	exports.default = viziwko862lzerg9c3xm25q;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/i18n/number.currencySymbol', [], function() { return "₹"; });
(function() { LWR.define('lightning/i18nService', ['exports', '@salesforce/i18n/common.digits', '@salesforce/i18n/common.calendarData', '@salesforce/i18n/defaultCalendar', '@salesforce/i18n/defaultNumberingSystem', '@salesforce/i18n/calendarData', '@salesforce/i18n/number.decimalSeparator', '@salesforce/i18n/number.groupingSeparator', '@salesforce/i18n/number.percentSign', '@salesforce/i18n/number.plusSign', '@salesforce/i18n/number.minusSign', '@salesforce/i18n/number.exponentialSign', '@salesforce/i18n/number.superscriptingExponentSign', '@salesforce/i18n/number.perMilleSign', '@salesforce/i18n/number.infinity', '@salesforce/i18n/number.nan', '@salesforce/i18n/number.currencySymbol'], (function (exports, commonDigits, commonCalendarData, defaultCalendar, defaultNumberingSystem, calendarData, decimalSeparator, groupingSeparator, percentSign, plusSign, minusSign, exponentialSign, superscriptingExponentSign, perMilleSign, infinity, nan, currencySymbol) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var commonDigits__default = /*#__PURE__*/_interopDefaultCompat(commonDigits);
    var commonCalendarData__default = /*#__PURE__*/_interopDefaultCompat(commonCalendarData);
    var defaultCalendar__default = /*#__PURE__*/_interopDefaultCompat(defaultCalendar);
    var defaultNumberingSystem__default = /*#__PURE__*/_interopDefaultCompat(defaultNumberingSystem);
    var calendarData__default = /*#__PURE__*/_interopDefaultCompat(calendarData);
    var decimalSeparator__default = /*#__PURE__*/_interopDefaultCompat(decimalSeparator);
    var groupingSeparator__default = /*#__PURE__*/_interopDefaultCompat(groupingSeparator);
    var percentSign__default = /*#__PURE__*/_interopDefaultCompat(percentSign);
    var plusSign__default = /*#__PURE__*/_interopDefaultCompat(plusSign);
    var minusSign__default = /*#__PURE__*/_interopDefaultCompat(minusSign);
    var exponentialSign__default = /*#__PURE__*/_interopDefaultCompat(exponentialSign);
    var superscriptingExponentSign__default = /*#__PURE__*/_interopDefaultCompat(superscriptingExponentSign);
    var perMilleSign__default = /*#__PURE__*/_interopDefaultCompat(perMilleSign);
    var infinity__default = /*#__PURE__*/_interopDefaultCompat(infinity);
    var nan__default = /*#__PURE__*/_interopDefaultCompat(nan);
    var currencySymbol__default = /*#__PURE__*/_interopDefaultCompat(currencySymbol);

    /**
     * Given an object instance, generate an object with the same properties, with property name ordered alphabetically, and undefined properties removed.
     *
     * @param value Object to process
     * @returns Generated object with properties only
     */
    function extractProperties(value) {
      // Return primitive value as is
      const valueType = typeof value;
      if (valueType === 'string' || valueType === 'number' || valueType === 'boolean' || valueType === 'undefined') {
        return value;
      }
      if (valueType === 'object') {
        // Array is an object
        if (Array.isArray(value)) {
          const newValue = [];
          // Keep sort order
          for (const arrayValue of value) {
            newValue.push(extractProperties(arrayValue));
          }
          return newValue;
        } else {
          const newValue = {};
          // Normalize property order by sorting it before assignment
          const propNames = Object.getOwnPropertyNames(value).sort();
          for (const propName of propNames) {
            const propValue = extractProperties(value[propName]);
            // Normalize property value by assigning only defined values to properties
            if (propValue !== undefined) {
              newValue[propName] = propValue;
            }
          }
          return newValue;
        }
      }
      return undefined;
    }
    /**
     * A Map-like object with normalized key
     */
    class Cache {
      /**
       * Constructs an empty instance.
       *
       * @constructor
       */
      constructor() {
        /** Internal map object */
        this.map = new Map();
      }
      /**
       * Checks whether this cache contains provided key.
       *
       * @param key Cache key
       * @returns 'true' if cache has this key
       */
      has(key) {
        const newKey = this.normalize(key);
        return this.map.has(newKey);
      }
      /**
       * Returns the cached value for provided key, or undefined if key is unavailable
       *
       * @param key Cache key
       * @returns Cache value
       */
      get(key) {
        const newKey = this.normalize(key);
        return this.map.get(newKey);
      }
      /**
       * Sets provided value to provided cache key. Current cached value will be overwritten if cache key exists.
       *
       * @param key Cache key. Examples: {prop: 'prop value', nested: { nestedProp: 'nestedProp value' }}
       * @param value Cache value
       * @returns Current cache instance
       */
      set(key, value) {
        const newKey = this.normalize(key);
        this.map.set(newKey, value);
        return this;
      }
      /**
       * Removes all cached values.
       *
       * @returns void
       */
      clear() {
        return this.map.clear();
      }
      /**
       * Given a cache key, normalize the key to a string.
       *
       * @param key Cache key
       * @returns Normalized cached key string
       */
      normalize(key) {
        const newKey = extractProperties(key);
        return JSON.stringify(newKey);
      }
    }
    const dateTimeFormatCache = new Map();
    /**
     * Clears the cache
     */
    function clearDateTimeFormatCache() {
      dateTimeFormatCache.clear();
    }
    /**
     * Instantiate or returns a cached value of {@link Intl.DateTimeFormat}, instantiated with given options.
     *
     * @param locale {string} Locale
     * @param options {Intl.DateTimeFormatOptions} Formatter options
     * @returns {Intl.DateTimeFormat} Formatter instance
     */
    function getDateTimeFormat(locale = 'en-US', options = {}) {
      if (!dateTimeFormatCache.has(locale)) {
        dateTimeFormatCache.set(locale, new Cache());
      }
      if (!dateTimeFormatCache.get(locale).has(options)) {
        const instance = new Intl.DateTimeFormat(locale, options);
        dateTimeFormatCache.get(locale).set(options, instance);
      }
      return dateTimeFormatCache.get(locale).get(options);
    }

    /**
     * Escapes a string to use in Javascript regular expression
     *
     * @param value String value to include in a regex
     * @returns {string} Escaped value
     */
    function escapeRegex(value) {
      return value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    /** Map of calendar name used on Intl to its CLDR counterpart */
    const intlCalendarMap = {
      gregory: 'gregorian'
    };
    /**
     * Resolves Intl calendar name to CLDR calendar name
     *
     * @param calendar {string} Calendar name for Intl
     * @returns {string} Calendar name for CLDR
     */
    function intlCalendarToCldr(calendar) {
      return Object.prototype.hasOwnProperty.call(intlCalendarMap, calendar) ? intlCalendarMap[calendar] : calendar;
    }
    const eraDateRegex = /^([-]?[0-9]+)-([0-9]{1,2})-([0-9]{1,2})$/;
    /**
     * Parses the date string on CLDR era start/end data to year/month/day property object.
     *
     * @private
     * @param value {string} Era date value to parse
     * @returns Resolved date value
     */
    function parseEraDate(value) {
      if (value && eraDateRegex.test(value)) {
        const matches = value.match(eraDateRegex);
        return {
          year: parseInt(matches[0], 10),
          month: parseInt(matches[0], 10),
          day: parseInt(matches[0], 10)
        };
      }
      return undefined;
    }
    // function compareDate(l: { year: number, month: number, day: number }, r: { year: number, month: number, day: number }): number {
    //     if (l.year < r.year || (l.year === r.year && l.month < r.month) || (l.year === r.year && l.month === r.month && l.day < r.day)) return -1;
    //     if (l.year > r.year || (l.year === r.year && l.month > r.month) || (l.year === r.year && l.month === r.month && l.day > r.day)) return 1;
    //     return 0;
    // }
    /**
     * Resolves a date with year that is indexed to a specific era to its gregorian year value. e.g. Reiwa 3, January 1st for Japanese imperial calendar will resolve to 2021
     *
     * @param eraIndex {number} Era index
     * @param year {number} Year in era
     * @param month {number} Month in era
     * @param day {number} Day in era
     * @param calendarType {string} Calendar type. e.g. "gregorian"
     * @param common {LocaleCommonDataCalendarData} Locale common calendar data
     * @returns {number} Positive gregorian year for AD, negative gregorian year for BC
     */
    function getGregorianYear(eraIndex, year, month, day, calendarType = 'gregorian', calendarData) {
      if (calendarType === 'gregorian') {
        // Fast path for gregorian
        // eraIndex === 0 if BC. A negative BC is a positive AD, vice versa
        return eraIndex === 0 ? -year : year;
      } else if (calendarData && calendarData.calendarSystem === 'solar' && calendarData.eras) {
        // non-gregorian solar calendars
        const eras = Object.keys(calendarData.eras).sort().map(k => calendarData.eras[k]);
        if (eraIndex >= eras.length || eraIndex < 0) {
          // NOTE: Should we start with era that match today, rather than last era if invalid?
          eraIndex = eras.length - 1;
        }
        const era = eras[eraIndex];
        const yearAdjusted = year > 0 ? year - 1 : year < 0 ? year + 1 : 0;
        // We can only have either _start or _end on era
        if (era._end) {
          // This can only be the first era (eras[0]) that counts down (gregorian, coptic, ethiopic)
          const eraEnd = parseEraDate(era._end);
          if (!eraEnd) return undefined; // Report to Unicode
          return eraEnd.year - yearAdjusted;
        } else if (era._start) {
          const eraStart = parseEraDate(era._start);
          if (!eraStart) return undefined; // Report to Unicode
          return eraStart.year + yearAdjusted;
        }
      } else if (calendarData && calendarData.calendarSystem !== 'solar' && calendarData.eras) {
        // TODO: non-gregorian non-solar calendars
        return year;
      }
      return undefined;
    }
    /**
     * Extracts localized digits on a string and convert it to an array of integers
     *
     * @param value {string} String value
     * @param localeDigits {string[]} Array of localized digits. e.g. ["0",...,"9"] for "latn"
     * @returns {number[]} Array of integers from string. e.g. [1,2,3] for "123" for "latn"
     */
    function stringToDigits(value, localeDigits) {
      const digits = [];
      [...value].forEach(char => {
        const digit = localeDigits.indexOf(char);
        if (digit >= 0) {
          digits.push(digit);
        }
      });
      return digits.reverse();
    }
    /**
     * Extracts localized digits on a string and convert it to an integer
     *
     * @param value {string} String value
     * @param digits {string} Localized digits. e.g. "0123456789" for "latn"
     * @returns {number} Integer value. e.g. 123 for "123" for "latn"
     */
    function parseDigits(value, digits) {
      return stringToDigits(value, Array.from(digits)).reduce((int, cur, idx) => int += cur * 10 ** idx, 0);
    }
    /**
     * @private
     */
    function getDigitsRegexPatternInternal(digits, extras = '') {
      // Optimze for sequential codepoints
      if (digits.length > 1 && digits.reduce((sum, digit, idx, arr) => idx === 0 ? true : sum && digit.codePointAt(0) - arr[idx - 1].codePointAt(0) === 1, false)) {
        return '[' + [digits[0], digits[digits.length - 1]].join('-') + escapeRegex(extras) + ']';
      }
      return '[' + digits.join('') + escapeRegex(extras) + ']';
    }
    /**
     * Generates an optimized regular expression for given localized digits.
     * We would want a regular expression of [0-9] instead of [0123456789],
     * or [\u{660}-\u{669}] instead of [\u{660}\u{661}\u{662}\u{663}\u{664}\u{665}\u{666}\u{667}\u{668}\u{669}] for arabic.
     *
     * @param digits {string} Localized digit string. e.g. "0123456789" for "latn"
     * @param extras {string} Extra characters to include in regular expression range
     * @returns {string} Optimized regular expression for given digits
     */
    function getDigitsRegexPattern(digits, extras = '') {
      return getDigitsRegexPatternInternal(Array.from(digits), extras);
    }
    let utcFormat;
    /**
     * This formats to "MM/dd/yyyy, hh:mm" in English (United States) specifically
     */
    function getUtcFormat() {
      if (!utcFormat) {
        utcFormat = new Intl.DateTimeFormat('en-US', {
          timeZone: 'UTC',
          hourCycle: 'h23',
          year: 'numeric',
          month: 'numeric',
          day: 'numeric',
          hour: 'numeric',
          minute: 'numeric'
        });
      }
      return utcFormat;
    }
    /**
     * This matches for "MM/dd/yyyy, hh:mm"
     * Group 0: month
     * Group 1: date
     * Group 2: year
     * Group 3: hour
     * Group 4: minutes
     */
    const EN_US_DATE_REGEXP = /(\d+).(\d+).(\d+),?\s+(\d+).(\d+)(.(\d+))?/;
    const EN_US_DATE_INDEX_DAY = 1;
    const EN_US_DATE_INDEX_HOUR = 3;
    const EN_US_DATE_INDEX_MINUTE = 4;
    const TIMEZONE_DATEFORMATS = new Map();
    /**
     * Parses date string in specific "MM/dd/yyyy, hh:mm" format to its respected parts.
     *
     * @param value Date string value in "MM/dd/yyyy, hh:mm" format
     * @returns Array of parsed strings based on groups defined at EN_US_DATE_REGEXP
     */
    function parseEnUsDate(value) {
      const dateString = value.replace(/[\u200E\u200F]/g, ''); // Cleanse
      return [].slice.call(EN_US_DATE_REGEXP.exec(dateString), 1).map(Math.floor);
    }
    /**
     * Given two date parts parsed by parseEnUsDate, return the difference in minutes.
     *
     * @param date1 Date parts
     * @param date2 Date parts
     * @returns Difference in minutes
     */
    function diffMinutes(date1, date2) {
      let day = date1[EN_US_DATE_INDEX_DAY] - date2[EN_US_DATE_INDEX_DAY];
      const hour = date1[EN_US_DATE_INDEX_HOUR] - date2[EN_US_DATE_INDEX_HOUR];
      const min = date1[EN_US_DATE_INDEX_MINUTE] - date2[EN_US_DATE_INDEX_MINUTE];
      if (day > 15) {
        day = -1;
      }
      if (day < -15) {
        day = 1;
      }
      return 60 * (24 * day + hour) + min;
    }
    /**
     * Return timezone offset of given date in minutes
     *
     * @param timeZoneId Time zone
     * @param date Date object
     * @returns Number of time offset in minutes
     */
    function getTimeZoneOffset(timeZone, date) {
      if (!TIMEZONE_DATEFORMATS.has(timeZone)) {
        // This must be the same locale (English (United States)) and options as getUtcFormat, minus the timeZone difference
        TIMEZONE_DATEFORMATS.set(timeZone, new Intl.DateTimeFormat('en-US', {
          timeZone: timeZone,
          hourCycle: 'h23',
          year: 'numeric',
          month: 'numeric',
          day: 'numeric',
          hour: 'numeric',
          minute: 'numeric'
        }));
      }
      const dateFormat = TIMEZONE_DATEFORMATS.get(timeZone);
      return diffMinutes(parseEnUsDate(getUtcFormat().format(date)), parseEnUsDate(dateFormat.format(date)));
    }
    /**
     * Validates week
     *
     * @param week {Number} Week number
     * @returns {boolean} true if the week is valid
     */
    function isValidWeek(week) {
      return Number.isInteger(week) && week >= 1 /*week starts at 1 */ && week <= 53; /* at most we only have 53 weeks */
    }
    /**
     * Validates day of week
     *
     * @param dayOfWeek {Number} dayOfWeek number
     * @returns {boolean} true if the day of week is valid
     */
    function isValidDayOfWeek(dayOfWeek) {
      return Number.isInteger(dayOfWeek) && dayOfWeek >= 1 /* day of week starts at 1 */ && dayOfWeek <= 7; /* day of week ends at 7 */
    }
    /**
     * Validates month
     *
     * @param month {Number} Month number
     * @returns {boolean} true if the month is valid
     */
    function isValidMonth(month) {
      return is31DayMonth(month) || is30DayMonth(month) || month === 2;
    }
    /**
     * Check if the month has 31 days
     *
     * @param month {Number} Month number
     * @returns {boolean} true if the month has 31 days
     */
    function is31DayMonth(month) {
      return month === 1 || month === 3 || month === 5 || month === 7 || month === 8 || month === 10 || month === 12;
    }
    /**
     * Check if the month has 30 days
     *
     * @param month {Number} Month number
     * @returns {boolean} true if the month has 30 days
     */
    function is30DayMonth(month) {
      return month === 4 || month === 6 || month === 9 || month === 11;
    }
    /**
     * Check if ordinal is valid
     *
     * @param ordinal {Number} Ordinal number
     * @param isLeapYear {boolean}
     * @returns {boolean} true if the ordinal is valid
     */
    function isValidOrdinal(ordinal, isLeapYear) {
      return Number.isInteger(ordinal) && ordinal >= 1 /* ordinal day starts at 1 */ && (isLeapYear && ordinal <= 366 /* at most we only have 366 days for leap year */ || !isLeapYear && ordinal <= 365); /* at most we only have 366 days for leap year */
    }
    /**
     * Validate date
     *
     * @param month {Number} Month number
     * @param day {Number} Day number
     * @param isLeapYear {boolean} Indicates whether its a leap year
     * @returns {boolean} true if the date is valid
     */
    function isValidDate(month, day, isLeapYear) {
      return isValidMonth(month) && Number.isInteger(day) && day >= 1 /* 0 is not a date */ && (day <= 30 && is30DayMonth(month) /* validation for 30 day months */ || day <= 31 && is31DayMonth(month) /* validation for 31 day months */ || isLeapYear && month === 2 && day <= 29 /* february, leap year */ || !isLeapYear && month === 2 && day <= 28); /* february, non leap year */
    }

    /**
     * Calendar holds broken down data of an instance in time to calendar parts (year, month, day, etc). This helps in calendar arithmetic (e.g. change time zones, add days, etc)
     */
    class Calendar {
      /**
       * @constructor
       * @param timeZone {string} Time zone of this instance
       */
      constructor(timeZone) {
        this.year = 0;
        this.month = 1;
        this.day = 1;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        this.millisecond = 0;
        this.timeZone = timeZone;
      }
      /**
       * Clears the data on this calendar instance
       */
      clear() {
        this.year = 0;
        this.month = 1;
        this.day = 1;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        this.millisecond = 0;
      }
      /**
       * Converts this calendar instance to an equivalent Javascript Date instance
       *
       * @param smallYearOffset {number} Offset year to use if this calendar year is a two-digit year
       * @returns {Date} Date instance
       */
      getDate(smallYearOffset = 2000) {
        // Adjust year if two digits and below
        if (this.year < 100 && this.year >= 0) {
          this.year += smallYearOffset;
        }
        // Date is constructed with date & time in local (browser) time zone
        const localDate = new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
        if (this.timeZone) {
          const localOffset = localDate.getTimezoneOffset();
          const timeZoneOffset = getTimeZoneOffset(this.timeZone, localDate);
          const offset = localOffset - timeZoneOffset;
          // Return local date if offset equals, else adjust millisecond and return adjusted date
          if (Math.floor(offset) !== 0) {
            const adjustedDate = new Date(localDate.getTime() - offset * 60 * 1000);
            return adjustedDate;
          }
        }
        return localDate;
      }
    }

    /**
     * Tokenize string value of CLDR date time format string to array of tokens.
     *
     * Ref: https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
     *
     * @param value CLDR date time format pattern
     * @returns Array of tokens
     */
    function tokenizeDateTimePattern(value) {
      // Notes regarding single quote escape:
      // <quote>
      // Literal text, which is output as-is when formatting, and must closely match when parsing. Literal text can include:
      // * Any characters other than A..Z and a..z, including spaces and punctuation.
      // * Any text between single vertical quotes ('xxxx'), which may include A..Z and a..z as literal text.
      // * Two adjacent single vertical quotes (''), which represent a literal single quote, either inside or outside quoted text.
      // </quote>
      // Ref: https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
      // e.g.
      // '' -> [text(')]
      // 'a' -> [text(a)]
      // 'ymd' -> [text(ymd)]
      // ''a -> [text('), token(a)]
      // ''' -> [text(')]
      // '''' -> [text('')]
      // 'a''b' -> [text(a'b)]
      // ' '' ' -> [text( ' )]
      const tokenValues = [...'GyYQqM<wWdDFEecabBhHKkmsSAxXOvVXxZz']; // DateTimePatternToken.type
      const tokens = [];
      let isEscapedText = false;
      let isPrevSingleQuote = false;
      [...value].forEach(char => {
        // tokenValue is defined if it is a known token character.
        const tokenValue = tokenValues.indexOf(char) >= 0 ? char : undefined;
        let isCharText = false;
        // Set single quoted mode
        if ((tokenValue !== undefined || char !== "'") && isPrevSingleQuote) {
          isEscapedText = !isEscapedText;
        }
        // Process
        if (tokenValue !== undefined && !isEscapedText) {
          if (tokens.length > 0 && tokens[tokens.length - 1].type === tokenValue) {
            // Current character is same as previous token. extending token length
            let tokenLength = tokens[tokens.length - 1].length;
            tokenLength = tokenLength === undefined ? 1 : tokenLength + 1;
            tokens[tokens.length - 1].length = tokenLength;
          } else if (tokenValue !== undefined) {
            // Current character is a known token
            tokens.push({
              // @ts-ignore
              type: tokenValue,
              length: 1
            });
          }
          isPrevSingleQuote = false;
        } else if (char === "'" && !isPrevSingleQuote) {
          isPrevSingleQuote = true;
        } else if (char === "'" && isPrevSingleQuote) {
          // Treat two single quotes as one single quote text
          isCharText = true;
          isPrevSingleQuote = false; // Consume current single quote
        } else {
          // Treat others as text
          isCharText = true;
          isPrevSingleQuote = false; // Consumed current single quote
        }
        if (isCharText) {
          // Add as text token
          // Extend last token if it is a text token
          if (tokens.length > 0 && tokens[tokens.length - 1].type === undefined) {
            // Previous token is text, extending token text
            let tokenText = tokens[tokens.length - 1].text;
            tokenText = tokenText === undefined ? char : tokenText + char;
            tokens[tokens.length - 1].text = tokenText;
          } else {
            // Previous token is not text, creating new text token
            tokens.push({
              text: char
            });
          }
        }
      });
      return tokens;
    }
    /**
     * Gets symbols for given CLDR date time format token from CLDR locale data.
     *
     * @param token CLDR date time format token
     * @param calendarData Locale data for calendar
     * @returns Map of symbols from locale data for given token. e.g. {'0':'january','1':'february',...}
     */
    function getSymbols(token, calendarData) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return calendarData.dayPeriods.format.abbreviated;
        case 'aaaa':
          return calendarData.dayPeriods.format.wide;
        case 'aaaaa':
          return calendarData.dayPeriods.format.narrow;
        case 'G':
          return calendarData.eras.eraAbbr;
        case 'GGGG':
          return calendarData.eras.eraNames;
        case 'GGGGG':
          return calendarData.eras.eraNarrow;
        case 'MMM':
          return calendarData.months.format.abbreviated;
        case 'MMMM':
          return calendarData.months.format.wide;
        case 'MMMMM':
          return calendarData.months.format.narrow;
        case 'EEEE':
          return calendarData.days.format.wide;
        case 'EEEEE':
          return calendarData.days.format.narrow;
        case 'EEEEEE':
          return calendarData.days.format.abbreviated;
        default:
          return {};
      }
    }
    /**
     * Gets the token type for CLDR date time format token, whether it is numeric, specific digit numeric, or string
     *
     * @param value CLDR date time format token
     * @returns -1 if token is not numeric, 0 if token is of arbitrary digits, >= 1 if token is of specific digit
     */
    function getTokenDigits(token) {
      switch (token.type) {
        case 'y': // Year
        case 'd': // DayOfMonth
        case 'K': // Hour0011
        case 'H': // Hour0023
        case 'h': // Hour0112
        case 'k': // Hour0124
        case 'm': // Minute
        case 's': // Second
        case 'S': // SecondFractional
        case 'A': // MilliSecond
        // eslint-disable-next-line no-fallthrough
        case 'Q':
          // Quarter
          return token.length === 2 ? 2 : 0;
        case 'M': // Month
        case 'e': // WeekDayLocal
        case 'c':
          // WeekDayLocalStandalone
          switch (token.length) {
            case 1:
              return 0;
            case 2:
              return 2;
            default:
              return -1;
          }
      }
      return -1;
    }
    /** Cache regex */
    const regexps = new Map();
    /**
     * Generates the expression object that contains regex and tokens used on the regex groups based on given pattern and locale data.
     *
     * @param pattern CLDR date time format pattern
     * @param digits Used digits
     * @param calData Locale data for calendar
     * @returns DateTimePattenExpression
     */
    function getExpression$1(pattern, digits, calData) {
      const tokens = tokenizeDateTimePattern(pattern);
      const groups = [];
      const digitsRange = getDigitsRegexPattern(digits);
      let exprValue = '^[\\s]*'; // trim leading whitespace
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if (token.text !== undefined && token.text !== '') {
          // text
          exprValue += '(' + escapeRegex(token.text) + ')';
          groups.push(token);
        } else if (token.type !== undefined) {
          const tokenString = token.type.repeat(token.length);
          const digits = getTokenDigits(token);
          if (digits === -1) {
            if (tokenString === 'z') {
              // time zone is free text w/o whitespace
              exprValue += '([^\\s]+)';
            } else {
              // non-numeric symbols
              const symbols = getSymbols(tokenString, calData);
              exprValue += '(' + Object.keys(symbols).map(k => escapeRegex(symbols[k])).join('|') + ')';
            }
            groups.push(token);
          } else if (digits === 0) {
            // arbitrary digits
            exprValue += '(' + digitsRange + '+)';
            groups.push(token);
          } else if (digits > 0) {
            // exact digits
            exprValue += '(' + digitsRange + '{1,' + digits + '})';
            groups.push(token);
          }
        }
      }
      exprValue += '[\\s]*$'; // trim trailing whitespace
      if (!regexps.has(exprValue)) {
        regexps.set(exprValue, new RegExp(exprValue));
      }
      return {
        regexp: regexps.get(exprValue),
        groups
      };
    }
    /**
     * Utility to return the first key of object property by its value.
     *
     * @param parent Target object
     * @param value Property value to find
     * @returns Property key
     */
    function getKeyByValue(parent, value) {
      for (const key in parent) {
        if (Object.prototype.hasOwnProperty.call(parent, key) && parent[key] === value) {
          return key;
        }
      }
      return undefined;
    }
    /**
     * Utility to return the CLDR locale data key from locale data by its value.
     * e.g. symbol='February', token={type:'M',length:'MMM'} returns '1'
     *
     * @param symbol Value to search
     * @param token CLDR date time format token to search
     * @param data Locale data for calendar
     * @returns CLDR key name
     */
    function getKeyFromSymbol(symbol, token, data) {
      const tokenString = token.type.repeat(token.length);
      switch (token.type) {
        case 'G':
          // Era
          switch (tokenString) {
            case 'G':
              return getKeyByValue(data.eras.eraNames, symbol);
            case 'GGGG':
              return getKeyByValue(data.eras.eraNarrow, symbol);
            case 'GGGGG':
              return getKeyByValue(data.eras.eraAbbr, symbol);
          }
          break;
        case 'M': // Month
        case 'L':
          // MonthStandalone
          switch (tokenString) {
            case 'MMM':
              // abbreviated/short
              return getKeyByValue(data.months.format.abbreviated, symbol);
            case 'MMMM':
              // wide/long
              return getKeyByValue(data.months.format.wide, symbol);
            case 'MMMMM':
              // narrow
              return getKeyByValue(data.months.format.narrow, symbol);
            case 'LLL':
              // abbreviated/short
              return getKeyByValue(data.months['stand-alone'].short, symbol);
            case 'LLLL':
              // wide/long
              return getKeyByValue(data.months['stand-alone'].wide, symbol);
            case 'LLLLL':
              // narrow
              return getKeyByValue(data.months['stand-alone'].narrow, symbol);
          }
          break;
        case 'a': // PeriodAmPm
        case 'b': // PeriodAmPmNoonMidnight
        case 'B':
          // PeriodFlexible
          if (token.length >= 1 && token.length <= 3) return getKeyByValue(data.dayPeriods.format.abbreviated, symbol);
          if (token.length === 4) return getKeyByValue(data.dayPeriods.format.wide, symbol);
          if (token.length === 5) return getKeyByValue(data.dayPeriods.format.narrow, symbol);
          break;
        case 'E': // WeekDay:
        case 'e': // WeekDayLocal // Same keys as WeekDay. But index of monday changes per locale
        case 'c':
          // WeekDayLocalStandalone: // Same keys as WeekDay. But index of monday changes per locale
          switch (tokenString) {
            // abbreviated
            case 'E':
            case 'EE':
            case 'EEE':
            case 'eee':
            case 'ccc':
              return getKeyByValue(data.days.format.abbreviated, symbol);
            // wide/long
            case 'EEEE':
            case 'eeee':
            case 'cccc':
              return getKeyByValue(data.days.format.wide, symbol);
            // narrow
            case 'EEEEE':
            case 'eeeee':
            case 'ccccc':
              return getKeyByValue(data.days.format.abbreviated, symbol);
            // short
            case 'EEEEEE':
            case 'eeeeee':
            case 'cccccc':
              return getKeyByValue(data.days.format.short, symbol);
          }
          break;
      }
      return undefined;
    }

    /*
     * CLDR locale specific types
     */
    /**
     * Keys used on LocaleDataDatesCalendar for months
     */
    const MONTHS_KEYS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];

    /**
     * Date/time parser implementation based on CLDR locale data
     *
     * @author aazizy
     */
    class DateTimeParseImpl {
      /**
       * @constructor
       * @param options {DateTimeParseOptions} Options
       */
      constructor(options) {
        // Build data
        const data = {
          commonDigits: commonDigits__default.default,
          commonCalendarData: commonCalendarData__default.default,
          defaultCalendar: defaultCalendar__default.default,
          defaultNumberingSystem: defaultNumberingSystem__default.default,
          calendarData: calendarData__default.default
        };
        // Resolve options
        this.calendarType = options.calendar ? intlCalendarToCldr(options.calendar) : data.defaultCalendar;
        const numSys = options.numberingSystem ? options.numberingSystem : data.defaultNumberingSystem;
        const timeZone = options.timeZone ? options.timeZone : undefined;
        options.numberingSystem = numSys;
        options.timeZone = timeZone;
        this.options = options;
        this.digits = data.commonDigits[numSys];
        this.commonCalendarData = data.commonCalendarData[this.calendarType];
        this.calendarData = data.calendarData[this.calendarType];
        // Generating expression here becuse we want to do this only once.
        this.expr = getExpression$1(this.options.pattern, this.digits, this.calendarData);
      }
      /**
       * {@inheritdoc}
       */
      parse(value) {
        const matches = value.match(this.expr.regexp);
        if (!matches || matches.length <= this.expr.groups.length) {
          throw new Error("Invalid date: '" + value + "' for pattern: '" + this.options.pattern + "'");
        }
        const cal = new Calendar(this.options.timeZone);
        cal.clear();
        let era;
        let dayPeriod;
        this.expr.groups.forEach((group, groupIndex) => {
          if (group.type === undefined) {
            // Skip text (separators, space etc)
            return;
          }
          const match = matches[groupIndex + 1];
          if (getTokenDigits(group) >= 0) {
            // Parse digits
            // This is lenient parsing right now.
            // We should throw exception for strict parsing, if digits are not in range.
            // e.g.
            // 'K' should validate against 0 <= cal.hour && cal.hour <= 11
            // 'h' should validate against 1 <= cal.hour && cal.hour <= 12
            switch (group.type) {
              case 'y':
                // Year
                cal.year = parseDigits(match, this.digits);
                break;
              case 'M':
                // Month
                cal.month = parseDigits(match, this.digits);
                break;
              case 'd':
                // DayOfMonth
                cal.day = parseDigits(match, this.digits);
                break;
              case 'K':
                // Hour0011
                cal.hour = parseDigits(match, this.digits);
                break;
              case 'H':
                // Hour0023
                cal.hour = parseDigits(match, this.digits);
                break;
              case 'h':
                // Hour0112
                cal.hour = parseDigits(match, this.digits);
                break;
              case 'k':
                // Hour0124
                cal.hour = parseDigits(match, this.digits);
                break;
              case 'm':
                // Minute
                cal.minute = parseDigits(match, this.digits);
                break;
              case 's':
                // Second
                cal.second = parseDigits(match, this.digits);
                break;
              case 'A':
                // MilliSecond
                cal.millisecond = parseDigits(match, this.digits);
                break;
            }
          } else {
            // Parse symbols
            const key = getKeyFromSymbol(match, group, this.calendarData);
            if (key) {
              switch (group.type) {
                case 'G':
                  // Era
                  era = parseInt(key, 10);
                  break;
                case 'M': // Month
                case 'L':
                  // MonthStandalone
                  cal.month = MONTHS_KEYS.indexOf(key) + 1; // Calendar month is one indexed
                  break;
                case 'a': // PeriodAmPm
                case 'b': // PeriodAmPmNoonMidnight
                case 'B':
                  // PeriodFlexible
                  dayPeriod = key;
                  break;
              }
            }
          }
        });
        // Adjust year
        if (era !== undefined && era >= 0) {
          const adjustedYear = getGregorianYear(era, cal.year, cal.month, cal.day, this.calendarType, this.commonCalendarData);
          if (adjustedYear !== undefined) cal.year = adjustedYear;
        }
        // Adjust hours based period
        if (dayPeriod !== undefined) {
          switch (dayPeriod) {
            case 'am':
            case 'morning1':
            case 'morning2':
              // NOOP
              break;
            case 'pm':
            case 'afternoon1':
            case 'afternoon2':
            case 'evening1':
            case 'night1':
              if (cal.hour >= 0 && cal.hour < 12) cal.hour += 12;
              break;
            case 'midnight':
              if (cal.hour === 12) cal.hour = 0;
              break;
          }
        }
        return cal.getDate();
      }
    }
    const cldrParserCache = new Cache();
    /**
     * Clears the cache
     */
    function clearDateTimeCLDRParserCache() {
      cldrParserCache.clear();
    }
    /**
     * Instantiate or returns a cached value of a CLDR-based date time parser, instantiated with given a parser options.
     *
     * @param options {DateTimeParseOptions} Parser options
     * @returns {DateTimeParse} Parser instance
     */
    function getDateTimeCLDRParser(options) {
      if (!cldrParserCache.has(options)) {
        cldrParserCache.set(options, new DateTimeParseImpl(options));
      }
      return cldrParserCache.get(options);
    }
    const intlRelativeTimeFormatCache = new Map();
    /**
     * Clears the cache
     */
    function clearRelativeTimeFormatCache() {
      intlRelativeTimeFormatCache.clear();
    }
    /**
     * Instantiate or returns a cached value of {@see Intl.RelativeTimeFormat}, instantiated with given options.
     *
     * @param options {Intl.RelativeTimeFormatOptions} Formatter options
     * @returns {Intl.RelativeTimeFormat} Formatter instance
     */
    function getRelativeTimeFormat(locale = 'en-US', options = {}) {
      if (!intlRelativeTimeFormatCache.has(locale)) {
        intlRelativeTimeFormatCache.set(locale, new Cache());
      }
      if (!intlRelativeTimeFormatCache.get(locale).has(options)) {
        intlRelativeTimeFormatCache.get(locale).set(options, new Intl.RelativeTimeFormat(locale, options));
      }
      return intlRelativeTimeFormatCache.get(locale).get(options);
    }
    const numberFormatCache = new Map();
    /**
     * Clears the cache
     */
    function clearNumberFormatCache() {
      numberFormatCache.clear();
    }
    /**
     * Instantiate or returns a cached value of {@see Intl.NumberFormat}, instantiated with given options.
     *
     * @param locale {string} Locale
     * @param options {Intl.NumberFornatOptions} Formatter options
     * @returns {Intl.NumberFormat} Formatter instance
     */
    function getNumberFormat(locale = 'en-US', options = {}) {
      if (!numberFormatCache.has(locale)) {
        numberFormatCache.set(locale, new Cache());
      }
      if (!numberFormatCache.get(locale).has(options)) {
        numberFormatCache.get(locale).set(options, new Intl.NumberFormat(locale, options));
      }
      return numberFormatCache.get(locale).get(options);
    }

    /**
     * Calls getExpression and returns either only a positive expression, or a positive and negative expression if the pattern specifies different patterns for negative values
     *
     * @param pattern {string} Number pattern as used on CLDR
     * @param isNegative {boolean} If this pattern is for negative value. Defaults to false
     * @param digits {string} String of 10 characters used as digits. e.g. "0123456789" for latm numbering system
     * @param symbols {LocaleDataNumberSymbol} Symbols used in number pattern. See LocaleDataNumberSymbol
     * @param currencySymbol {string} Currency symbol used. e.g. "$"
     * @returns {NumberParseExpressions} A map value of positive and/or negative expression
     */
    function getExpressions(pattern, digits, symbols, currencySymbol, lenient) {
      const patterns = pattern.split(';');
      if (patterns.length >= 2) {
        return {
          positive: getExpression(patterns[0], false, digits, symbols, currencySymbol, lenient),
          negative: getExpression(patterns[1], true, digits, symbols, currencySymbol, lenient)
        };
      }
      return {
        positive: getExpression(pattern, false, digits, symbols, currencySymbol, lenient)
      };
    }
    /**
     * Given a pattern and locale data, generates the regular expression and its matching group definitions, to be used when parsing a number string value.
     *
     * @param pattern {string} Number pattern as used on CLDR
     * @param isNegative {boolean} If this pattern is for negative value. Defaults to false
     * @param digits {string} String of 10 characters used as digits. e.g. "0123456789" for latm numbering system
     * @param symbols {LocaleDataNumberSymbol} Symbols used in number pattern. See LocaleDataNumberSymbol
     * @param currencySymbol {string} Currency symbol used. e.g. "$"
     * @returns {NumberParseExpression} Generate expression and its matching group definition for parsing given number pattern
     */
    function getExpression(pattern, isNegative = false, digits, symbols, currencySymbol, lenient) {
      const groups = [];
      // Parse pattern
      let fractionalZeros = 0; // TODO: Used when min/max digits is implemented
      let integerZeros = 0; // TODO: Used when min/max digits is implemented
      // const exponentialDigits = 0; // TODO: support exponential
      // const exponentialLeadingZeros = 0; // TODO: support exponential
      const integerSeparatorIntervals = []; // Normal: [3], lakh/crore: [3,2]
      // let fractionalSeparatorRepeat = -1; // Normal: 0 // NOTE: This is used for parsing
      const exponentialPosition = pattern.indexOf('E');
      // TODO: parse exponent
      const decimalPattern = exponentialPosition > 0 ? pattern.slice(0, exponentialPosition) : pattern.slice(0);
      const decimalPosition = decimalPattern.indexOf('.');
      const integerPattern = decimalPosition >= 0 ? decimalPattern.slice(0, decimalPosition) : decimalPattern.slice(0);
      let integerSeparatorInterval = 0;
      let integerDigitsStarted = false;
      let hasPlusSign = false;
      let hasMinusSign = false;
      // Read right to left
      const integerPatternChars = [];
      [...integerPattern].forEach(char => integerPatternChars.push(char));
      integerPatternChars.reverse();
      [...integerPatternChars].forEach(char => {
        switch (char) {
          case '.':
            // Ignore decimal sign
            break;
          case '+':
            hasPlusSign = true;
            groups.push({
              token: 'plusSign'
            });
            break;
          case '-':
            hasMinusSign = true;
            groups.push({
              token: 'minusSign'
            });
            break;
          case '%':
            groups.push({
              token: 'percentSign'
            });
            break;
          case '¤':
            groups.push({
              token: 'currencySign'
            });
            break;
          case '0':
            integerZeros++;
          // Continue as digits (#)
          // eslint-disable-next-line no-fallthrough
          case '#':
            // this.integerDigits++;
            integerSeparatorInterval++;
            if (!integerDigitsStarted) {
              groups.push({
                token: 'integer'
              });
              integerDigitsStarted = true;
            }
            break;
          case ',':
            integerSeparatorIntervals.push(integerSeparatorInterval);
            // integerSeparatorRepeat = integerSeparatorIntervals.length - 1; // repeat the last interval
            integerSeparatorInterval = 0;
            break;
          default:
            groups.push({
              token: 'string',
              value: char
            });
        }
      });
      groups.reverse();
      if (decimalPosition >= 0) {
        groups.push({
          token: 'decimalSign'
        });
        const fractionalPattern = decimalPattern.slice(decimalPosition);
        let fractionalDigitsStarted = false;
        // Read left to right
        [...fractionalPattern].forEach(char => {
          switch (char) {
            case '.':
              // Ignore decimal sign
              break;
            case '+':
              hasPlusSign = true;
              groups.push({
                token: 'plusSign'
              });
              break;
            case '-':
              hasMinusSign = true;
              groups.push({
                token: 'minusSign'
              });
              break;
            case '%':
              groups.push({
                token: 'percentSign'
              });
              break;
            case '¤':
              groups.push({
                token: 'currencySign'
              });
              break;
            case '0':
              fractionalZeros++;
            // Continue as digits (#)
            // eslint-disable-next-line no-fallthrough
            case '#':
              if (!fractionalDigitsStarted) {
                groups.push({
                  token: 'fraction'
                });
                fractionalDigitsStarted = true;
              }
              break;
            case ',':
              break;
            default:
              groups.push({
                token: 'string',
                value: char
              });
          }
        });
      }
      // Generate expression
      let exprValue = '';
      for (let i = 0; i < groups.length; i++) {
        const group = groups[i];
        switch (group.token) {
          case 'integer':
            // Integer part must always has at least one digit (The least is 0)
            exprValue += '(' + getDigitsRegexPattern(digits, integerSeparatorIntervals.length > 0 ? symbols.group : '') + '+)';
            break;
          case 'fraction':
            // Fractional part is optional if lenient, or min fractional digits is 0
            exprValue += '(' + getDigitsRegexPattern(digits, integerSeparatorIntervals.length > 0 ? symbols.group : '') + '+)';
            if (lenient || decimalPosition > 0 && fractionalZeros <= 0) {
              exprValue += '?';
            }
            break;
          case 'decimalSign':
            // Decimal sign is optional if lenient, or if min fractional digits is 0 (fractional is optional)
            exprValue += '(' + escapeRegex(symbols.decimal) + ')';
            if (lenient || decimalPosition > 0 && fractionalZeros <= 0) {
              exprValue += '?';
            }
            break;
          case 'plusSign':
            // Optional
            exprValue += '(' + escapeRegex(symbols.plusSign) + ')?';
            break;
          case 'minusSign':
            // Optional
            exprValue += '(' + escapeRegex(symbols.minusSign) + ')?';
            break;
          case 'percentSign':
            // Optional
            exprValue += '(' + escapeRegex(symbols.percentSign) + ')?';
            break;
          case 'currencySign':
            // Optional
            exprValue += '(' + escapeRegex(currencySymbol) + ')?';
            break;
          case 'string':
            if (group.value !== undefined) {
              // Group to \s if value is all whitespace
              if (/^\s+$/.test(group.value)) {
                exprValue += '(\\s+)' + (lenient ? '?' : '');
              } else {
                exprValue += '(' + escapeRegex(group.value) + ')';
              }
            }
            break;
        }
      }
      // Prepend optional plus/minus sign if not available in pattern
      if (!isNegative) {
        if (!hasPlusSign && !hasMinusSign) {
          exprValue = '(' + escapeRegex(symbols.plusSign) + '|' + escapeRegex(symbols.minusSign) + ')?' + exprValue;
          groups.unshift({
            token: 'plusOrMinusSign'
          });
        } else if (!hasPlusSign) {
          exprValue = '(' + escapeRegex(symbols.plusSign) + ')?' + exprValue;
          groups.unshift({
            token: 'plusSign'
          });
        } else if (!hasMinusSign) {
          exprValue = '(' + escapeRegex(symbols.minusSign) + ')?' + exprValue;
          groups.unshift({
            token: 'minusSign'
          });
        }
      }
      const expr = new RegExp(exprValue);
      return {
        expr,
        groups,
        isNegative,
        minIntegerDigits: integerZeros,
        minFractionalDigits: fractionalZeros
      };
    }
    /**
     *
     * @param value {string} String value to parse
     * @param useNegativeExpr {boolean} Use negativeExpr to parse this value instead of the default positiveExpr
     * @param positiveExpr {NumberParseExpression} Expression to use to parse this value for positive values
     * @param negativeExpr {NumberParseExpression} Expression to use to parse this value for negative values
     * @param digits {string} String of 10 characters used as digits. e.g. "0123456789" for latm numbering system
     * @param symbols {LocaleDataNumberSymbol} Symbols used in number pattern
     */
    function parseNumber(value, useNegativeExpr = false, positiveExpr, negativeExpr, digits, symbols) {
      // Parse with negative expression first if available and return if value is valid
      if (!useNegativeExpr && negativeExpr) {
        const result = parseNumber(value, true, positiveExpr, negativeExpr, digits, symbols);
        if (!isNaN(result)) return result;
      }
      // Parse using provided negative expression if requested
      const expr = useNegativeExpr && negativeExpr ? negativeExpr : positiveExpr;
      const matches = value.match(expr.expr);
      if (!matches) {
        return NaN;
      }
      let hasMinusSign = false;
      let hasPlusSign = false;
      let isPercentPattern = false;
      let integerPart = '';
      let fractionPart = '';
      const groupRegex = new RegExp(escapeRegex(symbols.group), 'g');
      for (let i = 0; i < expr.groups.length; i++) {
        const group = expr.groups[i];
        isPercentPattern = isPercentPattern || group.token === 'percentSign';
        const match = matches[i + 1];
        if (!match) continue;
        switch (group.token) {
          case 'integer':
            integerPart += parseDigits(match.replace(groupRegex, ''), digits);
            break;
          case 'fraction':
            fractionPart += parseDigits(match.replace(groupRegex, ''), digits);
            break;
          case 'plusSign':
            hasPlusSign = true;
            break;
          case 'minusSign':
            hasMinusSign = true;
            break;
          case 'plusOrMinusSign':
            switch (match) {
              case symbols.plusSign:
                hasPlusSign = true;
                break;
              case symbols.minusSign:
                hasMinusSign = true;
                break;
            }
            break;
        }
      }
      // Build number
      if (hasMinusSign && hasPlusSign) {
        throw new Error('String has both plus and minus sign');
      }
      let result = NaN;
      // Remove leading zeros on integer
      integerPart.replace(/\b0+\B/, '');
      if (isPercentPattern) {
        // Shift 2 digits to the right (divide by 100) if pattern contains percent sign
        fractionPart = integerPart.slice(-2).padStart(2, '0') + fractionPart;
        integerPart = integerPart.slice(0, -2).padStart(1, '0');
        let num = (hasMinusSign ? '-' : '') + integerPart;
        if (fractionPart !== '') {
          num += '.' + fractionPart;
        }
        result = Number.parseFloat(num);
      } else {
        let num = (hasMinusSign ? '-' : '') + integerPart;
        if (expr.minFractionalDigits === undefined || expr.minFractionalDigits !== undefined && expr.minFractionalDigits <= 0 && fractionPart === '') {
          // Treat as integer if fraction is optional
          result = Number.parseInt(num);
        } else {
          if (fractionPart !== '') {
            num += '.' + fractionPart;
          }
          result = Number.parseFloat(num);
        }
      }
      // Negate result if negative expression is used
      return useNegativeExpr && negativeExpr ? -result : result;
    }
    /**
     * Number parser implementation
     *
     * @author aazizy
     */
    class NumberParseImpl {
      /**
       * @constructor
       * @param options {NumberParseOptions} Options used for this parser instance
       */
      constructor(options) {
        // Build data
        const data = {
          commonDigits: commonDigits__default.default,
          defaultNumberingSystem: defaultNumberingSystem__default.default,
          currencySymbol: currencySymbol__default.default,
          symbols: {
            decimal: decimalSeparator__default.default,
            group: groupingSeparator__default.default,
            percentSign: percentSign__default.default,
            plusSign: plusSign__default.default,
            minusSign: minusSign__default.default,
            exponential: exponentialSign__default.default,
            superScriptingExponent: superscriptingExponentSign__default.default,
            perMille: perMilleSign__default.default,
            infinity: infinity__default.default,
            nan: nan__default.default
          }
        };
        // Resolve options
        options.numberingSystem = options.numberingSystem ? options.numberingSystem : data.defaultNumberingSystem;
        this.options = options;
        this.digits = data.commonDigits[options.numberingSystem];
        this.symbols = data.symbols;
        this.currencySymbol = data.currencySymbol;
        this.lenient = !(options.lenient === false); // Default is true
        // Generating expression here becuse we want to do this only once.
        const exprs = getExpressions(this.options.pattern, this.digits, this.symbols, this.currencySymbol, this.lenient);
        this.positiveExpr = exprs.positive;
        this.negativeExpr = exprs.negative;
      }
      /**
       * @inheritdoc
       */
      parse(value) {
        return parseNumber(value, true, this.positiveExpr, this.negativeExpr, this.digits, this.symbols);
      }
    }
    const NumberParseCache = new Cache();
    /**
     * Clears the cache
     */
    function clearNumberParserCache() {
      NumberParseCache.clear();
    }
    /**
     * Instantiate or returns a cached value of {@see NumberParse}, instantiated with given options.
     *
     * @param options {NumberParseOptions} Parser options
     * @returns {NumberParse} Parser instance
     */
    function getNumberParser(options) {
      if (!NumberParseCache.has(options)) {
        NumberParseCache.set(options, new NumberParseImpl(options));
      }
      return NumberParseCache.get(options);
    }

    /**
     * Regular expression for parsing ISO-8601 datetime string.
     *
     * RegExp is thread safe so we can reuse this to match across instances.
     *
     * Please group indices accordingly if expression is updated.
     *
     * Ref https://en.wikipedia.org/wiki/ISO_8601
     */
    const EXPR = /^[\s]*(((-|\+)?([0-9]{4})[-]?|--)(([0-9]{2})|([0-9]{2})[-]?([0-9]{2})|(W([0-9]{2})([-]?([0-9]))?)|[-]?([0-9]{3})))(T([0-9]{2})([:]?([0-9]{2})([:]?([0-9]{2})(\.([0-9]{3}))?)?)?(Z|(-|\+)([0-9]{2})([:]?([0-9]{2})?)?)?)?[\s]*$/;
    /** (full string) ((-|+)yyyy-|--)(MM|MM-dd|Www-E|DDD)'T'hh:mm:ss.SSS('Z'|(-|+)xx:yy) */
    /** (date part) ((-|+)yyyy-|--)(MM|MM-dd|Www-E|DDD) */
    const INDEX_DATE = 1;
    /** (year part) (-|+)yyyy-|--) */
    const INDEX_YEAR_OR_NONE = INDEX_DATE + 1;
    /** (-|+)? */
    const INDEX_YEAR_SIGN = INDEX_YEAR_OR_NONE + 1;
    /** yyyy */
    const INDEX_YEAR = INDEX_YEAR_OR_NONE + 2;
    /** (MM|MM-dd|Www-E|MM-dd) */
    const INDEX_MONTH_MONTHDATE_WEEK_ORDINAL = INDEX_YEAR + 1;
    /** MM */
    const INDEX_MONTH = INDEX_MONTH_MONTHDATE_WEEK_ORDINAL + 1;
    /** MM-dd */
    const INDEX_MONTHDATE = INDEX_MONTH_MONTHDATE_WEEK_ORDINAL + 2;
    /** (week part) Www-E */
    const INDEX_WEEK = INDEX_MONTH_MONTHDATE_WEEK_ORDINAL + 4;
    /** (ordinal) DDD */
    const INDEX_ORDINAL = INDEX_MONTH_MONTHDATE_WEEK_ORDINAL + 8;
    /** (time part) 'T'hh:mm:ss.SSS('Z'|(-|+)xx:yy) */
    const INDEX_TIME = INDEX_MONTH_MONTHDATE_WEEK_ORDINAL + 9;
    /** :mm:ss.SSS */
    const INDEX_MINUTE = INDEX_TIME + 2;
    /** :ss.SSS */
    const INDEX_SECOND = INDEX_TIME + 4;
    /** .SSS, (millisecond must be prefixed by a period, even on abbreviated version) */
    const INDEX_MILLISECOND = INDEX_TIME + 6;
    /** (timezone part) 'Z'|(-|+)xx:yy */
    const INDEX_TZ = INDEX_TIME + 8;
    /** :yy */
    const INDEX_TZ_MINUTE = INDEX_TIME + 11;
    const TIME_ONLY_EXPR = /^[\s]*(([0-9]{2})([:]?([0-9]{2})([:]?([0-9]{2})(\.([0-9]{3}))?)?)?(Z|(-|\+)([0-9]{2})([:]?([0-9]{2})?)?)?)[\s]*$/;
    const TIME_ONLY_INDEX_TIME = 1;
    const TIME_ONLY_INDEX_MINUTE = TIME_ONLY_INDEX_TIME + 2;
    const TIME_ONLY_INDEX_SECOND = TIME_ONLY_INDEX_TIME + 4;
    const TIME_ONLY_INDEX_MILLISECOND = TIME_ONLY_INDEX_TIME + 6;
    const TIME_ONLY_INDEX_TZ = TIME_ONLY_INDEX_TIME + 8;
    const TIME_ONLY_INDEX_TZ_MINUTE = TIME_ONLY_INDEX_TIME + 11;
    /**
     * Parse an ISO-8601 datetime string representation to a Date object, or throw on unparseable value.
     *
     * This parser adheres to ISO-8601:2019, where the time separator 'T' is required, and full date part is required, and minute/second/millisecond is optional.
     *
     * Time defaults to 00:00:00.000Z if not specified.
     *
     * Timezone defaults to UTC if not specified.
     *
     * This parser tries to comply with ISO 8601:2004, which implies not supporting some of previously defined representations, such as YYMMDD, --MMDD
     *
     * Provides a more consistent cross-platform parsing for ISO-8601 (only) date strings
     * but behavior is different on each implementation and not recommended, as noted here:
     *
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date#Timestamp_string
     *
     * @param value {string} Value to parse
     * @returns {Date} Date instance
     */
    function parseDateTimeIsoString(value) {
      if (value && EXPR.test(value)) {
        return parseDateTimeString(value);
      } else if (value && TIME_ONLY_EXPR.test(value)) {
        return parseTimeOnlyString(value);
      }
      throw new Error("Unparseable date '" + value + "'");
    }
    function parseTimeOnlyString(value) {
      const matches = value.match(TIME_ONLY_EXPR);
      if (matches) {
        // Time parts
        let hour = 0;
        let minute = 0;
        let second = 0;
        let millisecond = 0;
        if (matches[TIME_ONLY_INDEX_TIME] !== undefined) {
          hour = Number(matches[TIME_ONLY_INDEX_TIME + 1]); // hh : hour part is required
          if (matches[TIME_ONLY_INDEX_MINUTE]) {
            minute = Number(matches[TIME_ONLY_INDEX_MINUTE + 1]); // mm : minute part is optional
          }
          if (matches[TIME_ONLY_INDEX_SECOND] !== undefined) {
            second = Number(matches[TIME_ONLY_INDEX_SECOND + 1]); // ss : second part is optional
          }
          if (matches[TIME_ONLY_INDEX_MILLISECOND] !== undefined) {
            millisecond = Number(matches[TIME_ONLY_INDEX_MILLISECOND + 1]); // SSS : millisecond part is optional
            // period on millisecond is required on both basic and extended format
          }
          // matches[INDEX_TZ] examples: 'Z', '+09:00', '-1100', '+09', '-11'
          if (matches[TIME_ONLY_INDEX_TZ] !== undefined) {
            // Only adjust offset if this is not UTC
            if (matches[TIME_ONLY_INDEX_TZ] !== 'Z') {
              let offset = Number(matches[TIME_ONLY_INDEX_TZ + 2]) * 60; // offset hour part is required for non 'Z' offset
              if (matches[TIME_ONLY_INDEX_TZ_MINUTE] !== undefined) {
                // offset minute part is optional
                offset += Number(matches[TIME_ONLY_INDEX_TZ_MINUTE + 1]);
              }
              if (matches[TIME_ONLY_INDEX_TZ + 1] === '+') {
                // plus/minus is required for non 'Z' offset
                // If offset is positive, substract offset from minutes
                // e.g. 11am in +09:00 is 2am in UTC (11:00 - 09:00)
                offset = -offset;
              }
              minute += offset;
            }
          }
        }
        const date = new Date();
        // Date is instantiated with runtime timezone offset.
        // We use Date.UTC to generate a timestamp and use that to instantiate the Date instance.
        const timestamp = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), hour, minute, second, millisecond);
        const parsedDate = new Date(timestamp);
        return parsedDate;
      }
      throw new Error("Unparseable date '" + value + "'");
    }
    function parseDateTimeString(value) {
      const matches = value.match(EXPR);
      if (matches) {
        // Date/time parts in UTC
        /** This will stay undefined for  --MM-dd and --MMdd representation */
        let year;
        let isLeapYear;
        /** Only a full date can be combined with time */
        let isFullDate = true;
        let isDateExtendedFormat = false;
        if (matches[INDEX_YEAR]) {
          year = Number(matches[INDEX_YEAR]); // yyyy : year part
          if (matches[INDEX_YEAR_SIGN] && matches[INDEX_YEAR_SIGN] === '-') {
            year = -year;
          }
          isDateExtendedFormat = isDateExtendedFormat || matches[INDEX_YEAR_OR_NONE].endsWith('-');
        }
        let month = 1; // Defaults to Jan 1
        let day = 1; // Defaults to Jan 1
        if (year !== undefined && matches[INDEX_MONTH_MONTHDATE_WEEK_ORDINAL]) {
          isLeapYear = new Date(Date.UTC(year, 1, 29, 0, 0, 0, 0)).getUTCDate() === 29;
          isDateExtendedFormat = isDateExtendedFormat || matches[INDEX_MONTH_MONTHDATE_WEEK_ORDINAL].indexOf('-') >= 0;
          if (matches[INDEX_MONTH]) {
            // Only extended form YYYY-MM is allowed, not YYYYMM
            if (!matches[INDEX_YEAR_OR_NONE].endsWith('-')) {
              throw new Error("Unparseable date '" + value + "'");
            }
            // Calendar date, with date omitted
            month = Number(matches[INDEX_MONTH]); // MM : month part
            day = 1;
            isFullDate = false;
          } else if (matches[INDEX_MONTHDATE]) {
            // Calendar date
            month = Number(matches[INDEX_MONTHDATE]); // MM : month part
            day = Number(matches[INDEX_MONTHDATE + 1]); // dd : date part
          } else if (matches[INDEX_WEEK]) {
            const week = Number(matches[INDEX_WEEK + 1]); // ww : week part
            let dayOfWeek = 1; // 1: monday, 7: sunday
            if (matches[INDEX_WEEK + 2]) {
              dayOfWeek = Number(matches[INDEX_WEEK + 3]); // E : day of week part is optional
            } else {
              isFullDate = false;
            }
            // Validate week/dayOfWeek
            if (!isValidWeek(week) || !isValidDayOfWeek(dayOfWeek)) {
              throw new Error("Unparseable date '" + value + "'");
            }
            // Calculate month and date from Www-E
            const jan1 = new Date(Date.UTC(year, 0, 1, 0, 0, 0, 0));
            // Date#getDay|getUTCDay returns 0: sunday, 6: saturday
            const jan1Day = jan1.getUTCDay();
            // If 1 January is on a Monday, Tuesday, Wednesday or Thursday, it is in week 01.
            // Else 1 January is on last week of previous year (week 52 or 53)
            // So, to summarize (jan1Day: W01-1 date) is:
            // 1: Jan 1
            // 2: Dec 31
            // 3: Dec 30
            // 4: Dec 29
            // 5: Jan 4
            // 6: Jan 3
            // 0: Jan 2
            // Date constructor allows overflow of date and correctly recalculate the upper parts (month, year)
            // Source is kept verbose. This is basically doing this:
            // const weekDate = (jan1Day === 2 || jan1Day === 3 || jan1Day === 4) ? //
            //     new Date(Date.UTC(year - 1, 11, 7 * (week - 1) + (33 - jan1Day) + (dayOfWeek - 1), 0, 0, 0, 0)) : //
            //     new Date(Date.UTC(year, 0, 7 * (week - 1) + ((9 - jan1Day) % 7) + (dayOfWeek - 1), 0, 0, 0, 0));
            const week1Day1Year = jan1Day === 2 || jan1Day === 3 || jan1Day === 4 ? year - 1 : year;
            const week1Day1Month = jan1Day === 2 || jan1Day === 3 || jan1Day === 4 ? 12 : 1;
            const week1Day1Date = jan1Day === 2 || jan1Day === 3 || jan1Day === 4 ? 33 - jan1Day : (9 - jan1Day) % 7;
            // Date constructor allows overflow of date and correctly recalculate the upper parts (month, year)
            const weekDate = new Date(Date.UTC(week1Day1Year, week1Day1Month - 1, week1Day1Date + 7 * (week - 1) + (dayOfWeek - 1), 0, 0, 0, 0));
            // Override year, month and date
            year = weekDate.getUTCFullYear();
            month = weekDate.getUTCMonth() + 1;
            day = weekDate.getUTCDate();
          } else if (matches[INDEX_ORDINAL]) {
            // Ordinal dates
            // 1: Jan 1, 365|366: Dec 31
            const ordinal = Number(matches[INDEX_ORDINAL]); // DDD : ordinal day part
            // Validate ordinal
            if (!isValidOrdinal(ordinal, isLeapYear)) {
              throw new Error("Unparseable date '" + value + "'");
            }
            // Date constructor allows overflow of date and correctly recalculate the upper parts (month, year)
            const ordinalDate = new Date(Date.UTC(year, 0, ordinal, 0, 0, 0, 0));
            // Override month and date
            month = ordinalDate.getUTCMonth() + 1;
            day = ordinalDate.getUTCDate();
          }
        } else if (year === undefined && matches[INDEX_MONTH_MONTHDATE_WEEK_ORDINAL] && matches[INDEX_MONTHDATE]) {
          // Only --MM-dd and --MMdd representation do not have year defined.
          // We support this pattern by using 2000 as year since it is a leap year (to allow --02-29).
          // We can default lesser significant part (e.g. month, date, hours) and have a sensibly usable value,
          // but, this representation is not suitable for JS Date since the significant part (year) of a calendar date is missing.
          // Calendar date
          year = 2000; // year defaults 2000
          month = Number(matches[INDEX_MONTHDATE]); // MM : month part
          day = Number(matches[INDEX_MONTHDATE + 1]); // dd : date part
          isLeapYear = new Date(Date.UTC(year, 1, 29, 0, 0, 0, 0)).getUTCDate() === 29;
          isFullDate = false;
          isDateExtendedFormat = isDateExtendedFormat || matches[INDEX_MONTH_MONTHDATE_WEEK_ORDINAL].indexOf('-') >= 0;
        } else {
          throw new Error("Unparseable date '" + value + "'");
        }
        if (!isValidDate(month, day, isLeapYear)) {
          throw new Error("Unparseable date '" + value + "'");
        }
        // Time parts
        let hour = 0;
        let minute = 0;
        let second = 0;
        let millisecond = 0;
        let isTimeExtendedFormat = false;
        let isHourOnly = true;
        // matches[INDEX_TIME] examples: 'T12:34:56.789+10:00', 'T00:00Z'
        if (matches[INDEX_TIME] !== undefined) {
          if (!isFullDate) {
            throw new Error("Unparseable date '" + value + "'");
          }
          hour = Number(matches[INDEX_TIME + 1]); // hh : hour part is required
          if (matches[INDEX_MINUTE]) {
            minute = Number(matches[INDEX_MINUTE + 1]); // mm : minute part is optional
            isTimeExtendedFormat = isTimeExtendedFormat || matches[INDEX_MINUTE].startsWith(':');
            isHourOnly = false;
          }
          if (matches[INDEX_SECOND] !== undefined) {
            second = Number(matches[INDEX_SECOND + 1]); // ss : second part is optional
            isTimeExtendedFormat = isTimeExtendedFormat || matches[INDEX_SECOND].startsWith(':');
            isHourOnly = false;
          }
          if (matches[INDEX_MILLISECOND] !== undefined) {
            millisecond = Number(matches[INDEX_MILLISECOND + 1]); // SSS : millisecond part is optional
            // period on millisecond is required on both basic and extended format
          }
          // matches[INDEX_TZ] examples: 'Z', '+09:00', '-1100', '+09', '-11'
          if (matches[INDEX_TZ] !== undefined) {
            // Only adjust offset if this is not UTC
            if (matches[INDEX_TZ] !== 'Z') {
              let offset = Number(matches[INDEX_TZ + 2]) * 60; // offset hour part is required for non 'Z' offset
              if (matches[INDEX_TZ_MINUTE] !== undefined) {
                // offset minute part is optional
                offset += Number(matches[INDEX_TZ_MINUTE + 1]);
              }
              if (matches[INDEX_TZ + 1] === '+') {
                // plus/minus is required for non 'Z' offset
                // If offset is positive, substract offset from minutes
                // e.g. 11am in +09:00 is 2am in UTC (11:00 - 09:00)
                offset = -offset;
              }
              minute += offset;
            }
          }
          // Combined date and time must have the same format
          // Hour only is valid, and the same for both basic and extended format
          if (isDateExtendedFormat !== isTimeExtendedFormat && !isHourOnly) {
            throw new Error("Unparseable date '" + value + "'");
          }
        }
        // Date is instantiated with runtime timezone offset.
        // We use Date.UTC to generate a timestamp and use that to instantiate the Date instance.
        const timestamp = Date.UTC(year, month - 1, day, hour, minute, second, millisecond);
        return new Date(timestamp);
      }
      throw new Error("Unparseable date '" + value + "'");
    }
    /**
     * Parse an ISO-8601 datetime string representation to a Date object, or throw on unparseable value.
     *
     * This parser adheres to ISO-8601:2019, where the time separator 'T' is required, and full date part is required, and minute/second/millisecond is optional.
     *
     * Time defaults to 00:00:00.000Z if not specified.
     *
     * Timezone defaults to UTC if not specified.
     *
     * Only calendar (e.g. 2021-01-07) representation is supported for date part.
     * Week (e.g. 2021-W01-5 for 2021-01-07) or ordinal (e.g. 2021-007 for 2021-01-07) representations are not supported.
     */
    class DateTimeIso8601Parse {
      /**
       * Constructor
       *
       * @constructor
       * @param options Options
       */
      constructor() {}
      /**
       * Parse an ISO-8601 datetime string representation to a Date object, or throw on unparseable value.
       * If parser instance constructed with a timeZone option, returned Date instance will be offsetted to that time zone.
       *
       * @param value {string} Value to parse
       * @returns {Date} Date instance
       */
      parse(value) {
        return parseDateTimeIsoString(value);
      }
    }
    const iso8601Parser = new DateTimeIso8601Parse();
    /**
     * Instantiate or returns a cached value of a CLDR-based date time parser, instantiated with given a parser options.
     *
     * @param options {DateTimeIso8601ParseOptions} Parser options
     * @returns {DateTimeParse} Parser instance
     */
    function getDateTimeISO8601Parser() {
      return iso8601Parser;
    }

    /**
     * Localizer
     *
     * @author aazizy
     */
    function clearCache() {
      clearDateTimeFormatCache();
      clearDateTimeCLDRParserCache();
      clearRelativeTimeFormatCache();
      clearNumberFormatCache();
      clearNumberParserCache();
    }

    exports.clearCache = clearCache;
    exports.getDateTimeCLDRParser = getDateTimeCLDRParser;
    exports.getDateTimeFormat = getDateTimeFormat;
    exports.getDateTimeISO8601Parser = getDateTimeISO8601Parser;
    exports.getNumberFormat = getNumberFormat;
    exports.getNumberParser = getNumberParser;
    exports.getRelativeTimeFormat = getRelativeTimeFormat;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/internationalizationLibrary', ['exports', '@salesforce/i18n/currency', '@salesforce/i18n/locale', 'lightning/i18nService', '@salesforce/i18n/number.numberFormat', '@salesforce/i18n/number.percentFormat', '@salesforce/i18n/number.currencyFormat', 'lightning/configProvider', 'lightning/iso8601Utils', 'lightning/utilsPrivate', '@salesforce/i18n/dateTime.mediumDateFormat', 'lightning/i18nCldrOptions', '@salesforce/i18n/dateTime.shortDateFormat', '@salesforce/i18n/dateTime.longDateFormat', '@salesforce/i18n/dateTime.shortTimeFormat', '@salesforce/i18n/dateTime.mediumTimeFormat', '@salesforce/i18n/lang'], (function (exports, currency, locale, i18nService, numberFormat$1, percentFormat, currencyFormat, configProvider, iso8601Utils, utilsPrivate, mediumDateFormat, getFormattingOptions, shortDateFormat, longDateFormat, shortTimeFormat, mediumTimeFormat, salesforceLanguage) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var currency__default = /*#__PURE__*/_interopDefaultCompat(currency);
    var locale__default = /*#__PURE__*/_interopDefaultCompat(locale);
    var numberFormat__default = /*#__PURE__*/_interopDefaultCompat(numberFormat$1);
    var percentFormat__default = /*#__PURE__*/_interopDefaultCompat(percentFormat);
    var currencyFormat__default = /*#__PURE__*/_interopDefaultCompat(currencyFormat);
    var mediumDateFormat__default = /*#__PURE__*/_interopDefaultCompat(mediumDateFormat);
    var getFormattingOptions__default = /*#__PURE__*/_interopDefaultCompat(getFormattingOptions);
    var shortDateFormat__default = /*#__PURE__*/_interopDefaultCompat(shortDateFormat);
    var longDateFormat__default = /*#__PURE__*/_interopDefaultCompat(longDateFormat);
    var shortTimeFormat__default = /*#__PURE__*/_interopDefaultCompat(shortTimeFormat);
    var mediumTimeFormat__default = /*#__PURE__*/_interopDefaultCompat(mediumTimeFormat);
    var salesforceLanguage__default = /*#__PURE__*/_interopDefaultCompat(salesforceLanguage);

    // This is a library built from Globalization's repo
    // https://git.soma.salesforce.com/Globalization/address.js
    // For new versions, copy AddressFormat.js from node_modules/address.js/dist/AddressFormat.js
    // And add "export { address };" at the end.
    // If the node modules file doesn't reflect the current code in the address.js github repo linked above,
    // then manually generate the AddressFormat.js file from the above globalization repo following the steps in its readMe
    // Note: The format for Japanese (JP) language should be '%K%n' + String.fromCharCode(12306) + '%Z%n%S %C%n%A',
    // '〒' - Aura component test cannot parse non-ASCII string properly.

    /* eslint-disable */
    function _toPrimitive(t, r) {
      if ('object' != typeof t || !t) return t;
      let e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        let i = e.call(t, r || 'default');
        if ('object' != typeof i) return i;
        throw new TypeError('@@toPrimitive must return a primitive value.');
      }
      return ('string' === r ? String : Number)(t);
    }
    function _toPropertyKey(t) {
      let i = _toPrimitive(t, 'string');
      return 'symbol' == typeof i ? i : String(i);
    }
    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    function _defineProperties(target, props) {
      for (let i = 0; i < props.length; i++) {
        let descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass$1(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, 'prototype', {
        writable: false
      });
      return Constructor;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === 'string') return _arrayLikeToArray(o, minLen);
      let n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === 'Object' && o.constructor) n = o.constructor.name;
      if (n === 'Map' || n === 'Set') return Array.from(o);
      if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      let it = typeof Symbol !== 'undefined' && o[Symbol.iterator] || o['@@iterator'];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === 'number') {
          if (it) o = it;
          let i = 0;
          let F = function () {};
          return {
            s: F,
            n: function () {
              if (i >= o.length) {
                return {
                  done: true
                };
              }
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function (e) {
              throw e;
            },
            f: F
          };
        }
        throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
      }
      let normalCompletion = true;
      let didErr = false;
      let err;
      return {
        s: function () {
          it = it.call(o);
        },
        n: function () {
          let step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function (e) {
          didErr = true;
          err = e;
        },
        f: function () {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }
    let data$1 = {
      AE: {
        fmt: '%A%n%S%n%K',
        require: 'ASK',
        input: 'ASK'
      },
      AL: {
        fmt: '%A%n%Z%n%C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      EC: {
        _ref: 'AL'
      },
      MU: {
        _ref: 'AL'
      },
      OM: {
        _ref: 'AL'
      },
      AM: {
        fmt: '%A%n%Z%n%C%n%S%n%K',
        require: 'AZK',
        input: 'AZK'
      },
      AR: {
        fmt: '%A%n%Z %C%n%S%n%K',
        require: 'AZCSK',
        input: 'AZCSK'
      },
      CL: {
        _ref: 'AR'
      },
      CV: {
        _ref: 'AR'
      },
      MY: {
        _ref: 'AR'
      },
      UZ: {
        _ref: 'AR'
      },
      AT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      BA: {
        _ref: 'AT'
      },
      BG: {
        _ref: 'AT'
      },
      CH: {
        _ref: 'AT'
      },
      CY: {
        _ref: 'AT'
      },
      DE: {
        _ref: 'AT'
      },
      DK: {
        _ref: 'AT'
      },
      DO: {
        _ref: 'AT'
      },
      DZ: {
        _ref: 'AT'
      },
      EE: {
        _ref: 'AT'
      },
      ET: {
        _ref: 'AT'
      },
      FR: {
        _ref: 'AT'
      },
      GE: {
        _ref: 'AT'
      },
      GL: {
        _ref: 'AT'
      },
      GR: {
        _ref: 'AT'
      },
      IL: {
        _ref: 'AT'
      },
      KW: {
        _ref: 'AT'
      },
      LA: {
        _ref: 'AT'
      },
      LR: {
        _ref: 'AT'
      },
      IS: {
        _ref: 'AT'
      },
      MA: {
        _ref: 'AT'
      },
      MG: {
        _ref: 'AT'
      },
      MK: {
        _ref: 'AT'
      },
      MZ: {
        _ref: 'AT'
      },
      NL: {
        _ref: 'AT'
      },
      NO: {
        _ref: 'AT'
      },
      PL: {
        _ref: 'AT'
      },
      PT: {
        _ref: 'AT'
      },
      PY: {
        _ref: 'AT'
      },
      RO: {
        _ref: 'AT'
      },
      RS: {
        _ref: 'AT'
      },
      SK: {
        _ref: 'AT'
      },
      TJ: {
        _ref: 'AT'
      },
      TN: {
        _ref: 'AT'
      },
      TZ: {
        _ref: 'AT'
      },
      WF: {
        _ref: 'AT'
      },
      AU: {
        fmt: '%A%n%C %S %Z%n%K',
        require: 'ACSZK',
        input: 'ACSZK'
      },
      CA: {
        _ref: 'AU'
      },
      AZ: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      AF: {
        fmt: '%A%n%C%n%Z%n%K',
        require: 'ACZK',
        input: 'ACZK'
      },
      FK: {
        _ref: 'AF'
      },
      GB: {
        fmt: '%A%n%C%n%S%n%Z%n%K',
        require: 'ACZK',
        input: 'ACSZK'
      },
      KE: {
        _ref: 'AF'
      },
      LK: {
        _ref: 'AF'
      },
      ZA: {
        _ref: 'AF'
      },
      SH: {
        _ref: 'AF'
      },
      SZ: {
        _ref: 'AF'
      },
      US: {
        fmt: '%A%n%C, %S %Z%n%K',
        require: 'ACSZK',
        input: 'ACSZK'
      },
      BB: {
        _ref: 'US'
      },
      BS: {
        _ref: 'US'
      },
      SO: {
        _ref: 'US'
      },
      ES: {
        fmt: '%A%n%Z %C %S%n%K',
        require: 'AZCSK',
        input: 'AZCSK'
      },
      IT: {
        _ref: 'ES'
      },
      UY: {
        _ref: 'ES'
      },
      ID: {
        fmt: '%A%n%C%n%S %Z%n%K',
        require: 'ACSZK',
        input: 'ACSZK'
      },
      IE: {
        _ref: 'ID'
      },
      TH: {
        _ref: 'ID'
      },
      VN: {
        _ref: 'ID'
      },
      HU: {
        fmt: '%C%n%A%n%Z%n%K',
        require: 'CAZK',
        input: 'CAZK'
      },
      BH: {
        fmt: '%A%n%C %Z%n%K',
        require: 'ACZK',
        input: 'ACZK'
      },
      BM: {
        _ref: 'BH'
      },
      BN: {
        _ref: 'BH'
      },
      BT: {
        _ref: 'BH'
      },
      KH: {
        _ref: 'BH'
      },
      LB: {
        _ref: 'BH'
      },
      JO: {
        _ref: 'BH'
      },
      MT: {
        _ref: 'BH'
      },
      NP: {
        _ref: 'BH'
      },
      NZ: {
        _ref: 'BH'
      },
      SA: {
        _ref: 'BH'
      },
      BD: {
        fmt: '%A%n%C - %Z%n%K',
        require: 'ACZK',
        input: 'ACZK'
      },
      BR: {
        fmt: '%A%n%C-%S%n%Z%n%K',
        require: 'ACSZK',
        input: 'ACSZK'
      },
      CN: {
        fmt: '%K%n%S %C%n%A%n%Z',
        require: 'KCAZ',
        input: 'KSCAZ'
      },
      HK: {
        fmt: '%K%S%C%n%A%n%Z',
        require: 'KCA',
        input: 'KSCAZ'
      },
      CO: {
        fmt: '%A%n%C, %S, %Z%n%K',
        require: 'ACSZK',
        input: 'ACSZK'
      },
      CR: {
        fmt: '%A%n%S, %C%n%Z%n%K',
        require: 'ACSZK',
        input: 'ASCZK'
      },
      EG: {
        fmt: '%A%n%C%n%S%n%Z%n%K',
        require: 'ACSZK',
        input: 'ACSZK'
      },
      RU: {
        _ref: 'EG'
      },
      UA: {
        _ref: 'EG'
      },
      FI: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      GT: {
        fmt: '%A%n%Z-%C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      HN: {
        fmt: '%A%n%C, %S%n%Z%n%K',
        require: 'ACSZK',
        input: 'ACSZK'
      },
      IQ: {
        _ref: 'HN'
      },
      HR: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      HT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      IN: {
        fmt: '%A%n%C %Z%n%S%n%K',
        require: 'ACZSK',
        input: 'ACZSK'
      },
      NG: {
        _ref: 'IN'
      },
      PE: {
        _ref: 'IN'
      },
      IR: {
        fmt: '%S%n%C%n%A%n%Z%n%K',
        require: 'SCAZK',
        input: 'SCAZK'
      },
      JM: {
        fmt: '%A%n%C%n%S%n%K',
        require: 'ACSK',
        input: 'ACSK'
      },
      PA: {
        _ref: 'JM'
      },
      SC: {
        _ref: 'JM'
      },
      SR: {
        _ref: 'JM'
      },
      JP: {
        // Escape non-ASCII character. Aura component test cannot parse non-ASCII string properly.
        fmt: '%K%n' + String.fromCharCode(12306) + '%Z%n%S %C%n%A',
        require: 'KZCA',
        input: 'KZSCA'
      },
      EN_JP: {
        fmt: '%A%n%C %S%n%Z %K',
        require: 'ACSZK',
        input: 'ACSZK'
      },
      KG: {
        fmt: '%Z %C%n%A%n%S%n%K',
        require: 'ZCAK',
        input: 'ZCAK'
      },
      KR: {
        fmt: '%S %C%n%A%n%Z%n%K',
        require: 'SCAZK',
        input: 'SCAZK'
      },
      KY: {
        fmt: '%A%n%S %Z%n%K',
        require: 'ASZK',
        input: 'ASZK'
      },
      KZ: {
        fmt: '%Z%n%S%n%C%n%A%n%K',
        require: 'ZSCAK',
        input: 'ZSCAK'
      },
      LT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      LV: {
        fmt: '%A%n%C, %Z%n%K',
        require: 'ACZK',
        input: 'ACZK'
      },
      MM: {
        _ref: 'LV'
      },
      MC: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      MD: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      MW: {
        fmt: '%A%n%C%n%K',
        require: 'ACK',
        input: 'ACK'
      },
      MX: {
        fmt: '%A%n%Z %C, %S%n%K',
        require: 'AZCSK',
        input: 'AZCSK'
      },
      NI: {
        fmt: '%A%n%Z%n%C, %S%n%K',
        require: 'AZCSK',
        input: 'AZCSK'
      },
      PG: {
        fmt: '%A%n%C %Z %S%n%K',
        require: 'ACZSK',
        input: 'ACZSK'
      },
      PH: {
        fmt: '%A, %C%n%Z %S%n%K',
        require: 'ACZSK',
        input: 'ACZSK'
      },
      PK: {
        fmt: '%A%n%C-%Z%n%K',
        require: 'ACZK',
        input: 'ACZK'
      },
      PR: {
        fmt: '%A%n%C %Z%n%K',
        require: 'ACZK',
        input: 'ACZK'
      },
      SE: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      SG: {
        fmt: '%A%n%C %Z%n%S%n%K',
        require: 'AZK',
        input: 'AZK'
      },
      SI: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      SV: {
        fmt: '%A%n%Z-%C%n%S%n%K',
        require: 'AZCSK',
        input: 'AZCSK'
      },
      TR: {
        fmt: '%A%n%Z %C/%S%n%K',
        require: 'AZCK',
        input: 'AZCK'
      },
      TW: {
        fmt: '%K%n%Z%n%S %C%n%A',
        require: 'KZSCA',
        input: 'KZSCA'
      },
      VE: {
        fmt: '%A%n%C %Z, %S%n%K',
        require: 'ACZSK',
        input: 'ACZSK'
      }
    };
    let languageCodeToCountry = {
      languageCode: {
        'af': 'ZA',
        'am': 'ET',
        'ar': 'AE',
        'bg': 'BG',
        'bn': 'BD',
        'bs': 'BA',
        'ca': 'ES',
        'cs': 'CZ',
        'cy': 'GB',
        'da': 'DK',
        'de': 'DE',
        'el': 'GR',
        'es': 'ES',
        'et': 'EE',
        'eu': 'ES',
        'fa': 'IR',
        'fi': 'FI',
        'fr': 'FR',
        'ga': 'IE',
        'gu': 'IN',
        'haw': 'US',
        'hi': 'IN',
        'hmn': 'US',
        'hr': 'HR',
        'ht': 'HT',
        'hu': 'HU',
        'hy': 'AM',
        'in': 'ID',
        'is': 'IS',
        'it': 'IT',
        'iw': 'IL',
        'ja': 'JP',
        'ji': 'IL',
        'ka': 'GE',
        'kk': 'KZ',
        'kl': 'GL',
        'km': 'KH',
        'kn': 'IN',
        'ko': 'KR',
        'lb': 'LU',
        'lt': 'LT',
        'lv': 'LV',
        'mi': 'NZ',
        'mk': 'MK',
        'ml': 'IN',
        'mr': 'IN',
        'ms': 'MY',
        'mt': 'MT',
        'my': 'MM',
        'nl': 'NL',
        'no': 'NO',
        'pa': 'IN',
        'pl': 'PL',
        'pt': 'PT',
        'rm': 'CH',
        'ro': 'RO',
        'ru': 'RU',
        'sh': 'RS',
        'sk': 'SK',
        'sl': 'SL',
        'sm': 'WS',
        'sq': 'AL',
        'sr': 'RS',
        'sv': 'SE',
        'sw': 'ZA',
        'ta': 'IN',
        'te': 'IN',
        'th': 'TH',
        'tl': 'PH',
        'tr': 'TR',
        'uk': 'UA',
        'ur': 'IN',
        'vi': 'VN',
        'xh': 'ZA',
        'zh': 'CN',
        'zu': 'ZA'
      }
    };

    /**
         * Define address format patterns.
         */
    var AddressFormatPattern = Object.freeze({
      /**
       *
       * N: Name (The formatting of names for this field is outside of the scope of the address elements.)
       * O: Organization
       * A: Address Lines (2 or 3 lines address)
       * D: District (Sub-locality): smaller than a city, and could be a neighborhood, suburb or dependent locality.
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * X: Sorting code, for example, CEDEX as used in France
       * n: newline
       */
      A: Symbol('Address Lines'),
      C: Symbol('City'),
      S: Symbol('State'),
      K: Symbol('Country'),
      Z: Symbol('Zip Code'),
      n: Symbol('New Line'),
      fromPlaceHolder: function fromPlaceHolder(placeHolder) {
        switch (placeHolder) {
          case 'A':
            return AddressFormatPattern.A;
          case 'C':
            return AddressFormatPattern.C;
          case 'S':
            return AddressFormatPattern.S;
          case 'K':
            return AddressFormatPattern.K;
          case 'Z':
            return AddressFormatPattern.Z;
          case 'n':
            return AddressFormatPattern.n;
        }
        return null;
      },
      getPlaceHolder: function getPlaceHolder(pattern) {
        switch (pattern) {
          case AddressFormatPattern.A:
            return 'A';
          case AddressFormatPattern.C:
            return 'C';
          case AddressFormatPattern.S:
            return 'S';
          case AddressFormatPattern.K:
            return 'K';
          case AddressFormatPattern.Z:
            return 'Z';
          case AddressFormatPattern.n:
            return 'n';
        }
        return null;
      },
      getData: function getData(pattern, data) {
        if (data) {
          switch (pattern) {
            case AddressFormatPattern.A:
              return data.address;
            case AddressFormatPattern.C:
              return data.city;
            case AddressFormatPattern.S:
              return data.state;
            case AddressFormatPattern.K:
              return data.country;
            case AddressFormatPattern.Z:
              return data.zipCode;
            case AddressFormatPattern.n:
              return data.newLine;
          }
        }
        return null;
      }
    });

    /**
         * Address token types enum
         *
         * @private
         */
    let AddressTokenTypes = Object.freeze({
      DATA: Symbol('data'),
      STRING: Symbol('string'),
      NEWLINE: Symbol('newline'),
      GROUP: Symbol('group')
    });

    /**
         * AddressToken class
         *
         * @private
         */
    let AddressToken = /* #__PURE__*/function () {
      /**
       *
       * @param {AddressTokenTypes} type
       * @param {string} string
       * @param {*} pattern
       */
      function AddressToken(type, string, pattern) {
        _classCallCheck$1(this, AddressToken);
        this.type = type;
        this.string = string;
        this.pattern = pattern;
      }

      /**
       * Construct a string type token
       *
       * @param {string} string String
       * @return {AddressToken} Address Token
       */
      _createClass$1(AddressToken, null, [{
        key: 'string',
        value: function string(_string) {
          return new AddressToken(AddressTokenTypes.STRING, _string);
        }
        /**
         * Construct a data type token
         *
         * @param {pattern} pattern Address Format Pattern
         * @return {AddressToken} Address Token
         */
      }, {
        key: 'data',
        value: function data(pattern) {
          return new AddressToken(AddressTokenTypes.DATA, undefined, pattern);
        }
        /**
         * Construct a new line type token
         *
         * @return {AddressToken} Address Token
         */
      }, {
        key: 'newLine',
        value: function newLine() {
          return new AddressToken(AddressTokenTypes.NEWLINE);
        }
      }]);
      return AddressToken;
    }();
    /**
     * TokenizerState class
     *
     * @private
     */
    let TokenizerState = /* #__PURE__*/_createClass$1(
    /**
     * Constructor
     *
     * @param {string} pattern
     * @param {int} start
     */
    function TokenizerState(pattern, start) {
      _classCallCheck$1(this, TokenizerState);
      this.pattern = pattern;
      this.start = start;
    });
    /**
     * Tokenize string pattern to AddressToken array
     *
     * @param {TokenizerState} state
     * @param {AddressToken[]} tokens
     * @return {TokenizerState} Tokenizer state
     *
     * @private
     */
    function tokenize(state, tokens) {
      let nextIndex = state.start;
      if (state.pattern) {
        let len = state.pattern.length;
        while (state.start < len) {
          nextIndex = state.pattern.indexOf('%', nextIndex);
          if (nextIndex >= 0 && nextIndex + 1 < len) {
            let placeHolder = state.pattern.substring(nextIndex + 1, nextIndex + 2);
            switch (placeHolder) {
              case 'n':
                {
                  if (nextIndex - state.start > 0) {
                    tokens.push(AddressToken.string(state.pattern.substring(state.start, nextIndex)));
                  }
                  tokens.push(AddressToken.newLine());
                  state.start = nextIndex + 2;
                  nextIndex = state.start;
                  break;
                }
              default:
                {
                  let p = AddressFormatPattern.fromPlaceHolder(placeHolder);
                  if (p) {
                    if (nextIndex - state.start > 0) {
                      tokens.push(AddressToken.string(state.pattern.substring(state.start, nextIndex)));
                    }
                    tokens.push(AddressToken.data(p));
                    state.start = nextIndex + 2;
                    nextIndex = state.start;
                  } else {
                    state.start = nextIndex + 2;
                    nextIndex = state.start;
                  }
                  break;
                }
            }
          } else {
            if (state.start < len) {
              tokens.push(AddressToken.string(state.pattern.substring(state.start)));
            }
            state.start = len;
          }
        }
      }
      return state;
    }

    /**
         * Format line from tokens
         *
         * @param {*} tokens
         * @param {*} data
         * @param {*} ignoreEmptyLines
         * @param {*} firstIndex
         * @param {*} lastIndex
         * @return {string} Formatted line
         *
         * @private
         */
    function formatLineTokens(tokens, data, ignoreEmptyLines, firstIndex, lastIndex) {
      let parts = [];
      for (let index = firstIndex; index <= lastIndex; index++) {
        let token = tokens[index];
        if (!token) {
          continue;
        } else if (token.type == AddressTokenTypes.DATA) {
          // Consume all subsequent data if available
          let dataBuffer = '';
          let lastDataIndex = index;
          for (let dataIndex = index; dataIndex <= lastIndex; dataIndex++) {
            let dataToken = tokens[dataIndex];
            if (!dataToken || dataToken.type != AddressTokenTypes.DATA) {
              break;
            }
            let fieldData = AddressFormatPattern.getData(dataToken.pattern, data);
            if (fieldData) {
              dataBuffer += fieldData;
              lastDataIndex = dataIndex;
            }
          }
          let hasData = dataBuffer && dataBuffer.length > 0;
          // Output previous string only if there is data before it,
          // or if it is the first on the line
          let hasPreviousData = false;
          if (index - 1 >= firstIndex) {
            let stringToken = tokens[index - 1];
            if (stringToken && stringToken.type == AddressTokenTypes.STRING && stringToken.string) {
              for (let prevIndex = index - 2; prevIndex >= firstIndex; prevIndex--) {
                let prevToken = tokens[prevIndex];
                if (prevToken && prevToken.type == AddressTokenTypes.DATA) {
                  let _fieldData = AddressFormatPattern.getData(prevToken.pattern, data);
                  if (_fieldData) {
                    hasPreviousData = true;
                    break;
                  }
                } else if (prevToken && prevToken.type == AddressTokenTypes.STRING) {
                  // ie. for "%C, %S %Z" without S -> "City, 95100"
                  // Comment this if we want "City 95100" instead
                  // (use the separator between S Z instead of C S)
                  stringToken = prevToken;
                }
              }
              if (!ignoreEmptyLines || hasPreviousData && hasData || index - 1 == firstIndex && hasData) {
                parts.push(stringToken.string);
              }
            }
          }
          if (hasData) {
            parts.push(dataBuffer);
          }
          index = lastDataIndex;
          // Output next string only if it is the last
          // and there is previous data before it
          if (index + 1 == lastIndex) {
            let _stringToken = tokens[index + 1];
            if (_stringToken && _stringToken.type == AddressTokenTypes.STRING && _stringToken.string) {
              if (!ignoreEmptyLines || hasData || hasPreviousData) {
                parts.push(_stringToken.string);
              }
            }
            // Consume the last string token
            index = index + 1;
          }
        } else ;
      }
      return parts.join('').trim();
    }

    /**
         * Tokenize address format pattern.
         *
         * @param {AddressToken[]} tokens
         * @param {*} data
         * @param {string} lineBreak
         * @param {boolean} ignoreEmptyLines
         * @return {string} Formatted Address
         *
         * @private
         */
    function formatTokens(tokens, data, lineBreak, ignoreEmptyLines) {
      let lines = [];
      let lineIndex = -1;
      for (let index = 0; index < tokens.length; index++) {
        let doFormat = false;
        let endWithNewLine = false;
        let token = tokens[index];
        switch (token.type) {
          case AddressTokenTypes.NEWLINE:
            {
              if (lineIndex >= 0) {
                doFormat = true;
                endWithNewLine = true;
              } else if (!ignoreEmptyLines) {
                lines.push(''); // Empty line
                // If the pattern ends with a newline
                if (index + 1 == tokens.length) {
                  lines.push(''); // Empty line
                }
              }
              break;
            }
          default:
            {
              lineIndex = lineIndex < 0 ? index : lineIndex;
              doFormat = index + 1 == tokens.length ? true : doFormat;
              break;
            }
        }
        if (doFormat) {
          let line = formatLineTokens(tokens, data, ignoreEmptyLines, lineIndex, endWithNewLine ? index - 1 : index);
          if (!ignoreEmptyLines || line) {
            lines.push(line);
          }
          // If line ends with a newline, and it is the last line on pattern
          if (!ignoreEmptyLines && endWithNewLine && index + 1 == tokens.length) {
            lines.push('');
          }
          lineIndex = -1;
        }
      }
      return lines.join(lineBreak);
    }

    /**
         * Format address data.
         *
         * @param {*} data Address data being processed.
         * @param {string} pattern Address format pattern.
         * @param {string} lineBreak Line break string to use
         * @param {boolean} ignoreEmptyLines Ignore lines that has no or empty data to replace.
         * @return {string} Formatted address.
         */
    function format$1(data, pattern, lineBreak, ignoreEmptyLines) {
      // TODO: support escapeHtml to match Java class feature parity
      ignoreEmptyLines = ignoreEmptyLines === false ? false : true; // Defaults to false
      lineBreak = lineBreak || '\n'; // Defaults to <br/> or lf
      let tokens = [];
      tokenize(new TokenizerState(pattern, 0), tokens);
      return formatTokens(tokens, data, lineBreak, ignoreEmptyLines);
    }
    let addressFormatter = {
      format: format$1
    };
    let CJK_COUNTRIES = ['CN', 'HK', 'TW', 'JP', 'KR', 'KP'];
    let CJK_LANGUAGES = ['zh', 'ja', 'ko'];
    let address = {
      /**
       * Gets the globalization for the specified country code.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {{fmt: string, input: string, require: string}} Format Data
       */
      getAddressInfoForCountry: function getAddressInfoForCountry(langCode, countryCode) {
        let code = this.getCountryFromLocale(langCode, countryCode);
        if (data$1[code]) {
          // Double check.
          let cloneAddressRep = Object.freeze(Object.assign({}, data$1[code]));
          return Object.freeze({
            address: cloneAddressRep
          });
        }
        return {};
      },
      /**
       * Get the format pattern.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Address Format Pattern
       */
      getAddressFormat: function getAddressFormat(langCode, countryCode) {
        let code = this.getCountryFromLocale(langCode, countryCode);
        if (data$1[code]) {
          // Double check.
          return data$1[code].fmt;
        }
        return '';
      },
      /**
       * Get the input order pattern.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Input Order
       */
      getAddressInputOrder: function getAddressInputOrder(langCode, countryCode) {
        // A special case to deal with en_HK locale. We want to use US like
        // format for en_HK.
        // See W-4718344
        if (langCode && langCode.toLowerCase() == 'en' && countryCode && countryCode.toUpperCase() == 'HK') {
          langCode = 'en';
          countryCode = 'US';
        }
        let code = this.getCountryFromLocale(langCode, countryCode);
        if (data$1[code]) {
          // Double check.
          return data$1[code].input;
        }
        return '';
      },
      /**
       * Get the input order pattern for all fields.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Input Order
       */
      getAddressInputOrderAllField: function getAddressInputOrderAllField(langCode, countryCode) {
        // A special case to deal with en_HK locale. We want to use US like
        // format for en_HK.
        // See W-4718344
        if (langCode && langCode.toLowerCase() == 'en' && countryCode && countryCode.toUpperCase() == 'HK') {
          langCode = 'en';
          countryCode = 'US';
        }

        // Double check.
        let code = this.getCountryFromLocale(langCode, countryCode);
        if (data$1[code]) {
          let input = data$1[code].input;

          // Add missing patterns.
          if (input.indexOf('S') === -1) {
            input = input.replace('K', 'SK');
          }
          if (input.indexOf('C') === -1) {
            input = input.replace('S', 'CS');
          }
          if (input.indexOf('Z') === -1) {
            input = input.replace('C', 'ZC');
          }
          return input;
        }
        return '';
      },
      /**
       * Get required fields.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Required Fields
       */
      getAddressRequireFields: function getAddressRequireFields(langCode, countryCode) {
        let code = this.getCountryFromLocale(langCode, countryCode);
        if (data$1[code]) {
          // Double check.
          return data$1[code].require;
        }
        return '';
      },
      /**
       * Format a address values for given language code and country code with specified line break.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values Actual Address Data
       * @param {string} lineBreak Line Break
       * @return {string} Formatted Address
       */
      formatAddressAllFields: function formatAddressAllFields(langCode, countryCode, values, lineBreak) {
        let code = this.getCountryFromLocale(langCode, countryCode, values);
        if (data$1[code]) {
          // Double check.
          let pattern = data$1[code].fmt;
          // Some countries don't have City, State or ZIP code. We don't want to
          // lose those data from formatted string.
          if (values.zipCode && pattern.indexOf('%Z') === -1) {
            pattern = pattern.replace('%K', '%Z %K');
          }
          if (values.city && pattern.indexOf('%C') === -1) {
            pattern = pattern.replace('%K', '%C %K');
          }
          if (values.state && pattern.indexOf('%S') === -1) {
            pattern = pattern.replace('%K', '%S %K');
          }
          return this.buildAddressLines(pattern, values, lineBreak, true);
        }
        return '';
      },
      /**
       * Format a address values for given language code and country code with specified line break.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values Actual Address Data
       * @param {string} lineBreak Line Break
       * @return {string} Formatted Address
       */
      formatAddress: function formatAddress(langCode, countryCode, values, lineBreak) {
        let code = this.getCountryFromLocale(langCode, countryCode, values);
        if (data$1[code]) {
          // Double check.
          return this.buildAddressLines(data$1[code].fmt, values, lineBreak, true);
        }
        return '';
      },
      /**
       * Creates an array of address lines given the format and the values to use.
       *
       * @param {string} pattern
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values
       * @param {string} lineBreak
       * @param {string} ignoreEmptyLines
       * @return {string} the text for use in the address
       */
      buildAddressLines: function buildAddressLines(pattern, values, lineBreak, ignoreEmptyLines) {
        return addressFormatter.format(values, pattern, lineBreak, ignoreEmptyLines);
      },
      /**
       * Resolve the reference by tracing down the _ref value.
       * @param {*} data Address Format Data
       * @param {string} countryCode Country Code
       * @return {*} Referenced Address Format Data
       */
      followReferences: function followReferences(data, countryCode) {
        if (data[countryCode] && data[countryCode]._ref) {
          return this.followReferences(data, data[countryCode]._ref);
        }
        return countryCode;
      },
      /**
       * Check strings for Han characters
       *
       * @param {...string} values String values to check against
       * @return {boolean} true if any of string values contain Han script character
       */
      containsHanScript: function containsHanScript() {
        for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
          values[_key] = arguments[_key];
        }
        if (!values || !Array.isArray(values)) return false;
        return values.some(function (value) {
          if (!value) return false;
          // Javascript regex do not work with surrogate pairs so String#match is unusable with supplemental ranges.
          // Iterating a string returns a char that contains one codepoint.
          // Surrogate pairs will be returned as a pair.
          // Unicode block ranges: @see http://www.unicode.org/Public/UCD/latest/ucd/Blocks.txt
          let _iterator = _createForOfIteratorHelper(value);
          let _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              let singleChar = _step.value;
              let codePoint = singleChar.codePointAt(0); // Thank you ES2015
              if (0x2e80 <= codePoint && codePoint <= 0x2eff ||
              // CJK Radicals Supplement
              0x3300 <= codePoint && codePoint <= 0x33ff ||
              // CJK Compatibility
              0xfe30 <= codePoint && codePoint <= 0xfe4f ||
              // CJK Compatibility Forms
              0xf900 <= codePoint && codePoint <= 0xfaff ||
              // CJK Compatibility Ideographs
              0x2f800 <= codePoint && codePoint <= 0x2fa1f ||
              // CJK Compatibility Ideographs Supplement
              0x3000 <= codePoint && codePoint <= 0x303f ||
              // CJK Symbols and Punctuation
              0x4e00 <= codePoint && codePoint <= 0x9fff ||
              // CJK Unified Ideographs
              0x3400 <= codePoint && codePoint <= 0x4dbf ||
              // CJK Unified Ideographs Extension A
              0x20000 <= codePoint && codePoint <= 0x2a6df ||
              // CJK Unified Ideographs Extension B
              0x2a700 <= codePoint && codePoint <= 0x2b73f ||
              // CJK Unified Ideographs Extension C
              0x2b740 <= codePoint && codePoint <= 0x2b81f ||
              // CJK Unified Ideographs Extension D
              0x2b820 <= codePoint && codePoint <= 0x2ceaf ||
              // CJK Unified Ideographs Extension E // Not on core
              0x2ceb0 <= codePoint && codePoint <= 0x2ebef ||
              // CJK Unified Ideographs Extension F // Not on core
              0x3200 <= codePoint && codePoint <= 0x32ff ||
              // Enclosed CJK Letters and Months
              0x31c0 <= codePoint && codePoint <= 0x31ef ||
              // CJK Strokes
              // Chinese
              0x3100 <= codePoint && codePoint <= 0x312f ||
              // Bopomofo
              0x31a0 <= codePoint && codePoint <= 0x31bf ||
              // Bopomofo Extended
              0x2f00 <= codePoint && codePoint <= 0x2fdf ||
              // Kangxi Radicals
              0x2ff0 <= codePoint && codePoint <= 0x2fff ||
              // Ideographic Description Characters
              // Japanese
              0xff00 <= codePoint && codePoint <= 0xffef ||
              // Halfwidth and Fullwidth Forms
              0x3040 <= codePoint && codePoint <= 0x309f ||
              // Hiragana
              0x30a0 <= codePoint && codePoint <= 0x30ff ||
              // Katakana
              0x31f0 <= codePoint && codePoint <= 0x31ff ||
              // Katakana Phonetic Extensions
              0x1b000 <= codePoint && codePoint <= 0x1b0ff ||
              // Kana Supplement
              0x1b100 <= codePoint && codePoint <= 0x1b12f ||
              // Kana Extended-A // Not on core
              // Korean
              0x1100 <= codePoint && codePoint <= 0x11ff ||
              // Hangul Jamo
              0xac00 <= codePoint && codePoint <= 0xd7af ||
              // Hangul Syllables
              0x3130 <= codePoint && codePoint <= 0x318f ||
              // Hangul Compatibility Jamo
              0xa960 <= codePoint && codePoint <= 0xa97f ||
              // Hangul Jamo Extended-A
              0xd7b0 <= codePoint && codePoint <= 0xd7ff // Hangul Jamo Extended-B
              ) {
                return true;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return false;
        });
      },
      /**
       * Returns the address code (country code) for given locale and data.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {*} values Address Data
       * @return {string} Address Code
       */
      getCountryFromLocale: function getCountryFromLocale(langCode, countryCode, values) {
        if (values) {
          let isCJK = !countryCode && CJK_LANGUAGES.indexOf(langCode.toLowerCase()) >= 0 || countryCode && CJK_COUNTRIES.indexOf(countryCode.toUpperCase()) >= 0;
          let isJA = !countryCode && 'ja' == langCode.toLowerCase() || countryCode && 'JP' == countryCode.toUpperCase();

          // English format (ja_en_JP) is only used when all fields do not contain CJK characters
          if (!(isJA && this.containsHanScript(values.address, values.city, values.state, values.country)) && isCJK && !this.containsHanScript(values.address)) {
            return this.getCountryFromLocale(langCode, 'EN_' + countryCode);
          }
        }
        let country = countryCode;
        // hack for 'uz_Latn_UZ'. caller may pass 'Latn' as countryCode. override with 'UZ' here.
        if (langCode == 'uz' && country && country.toLowerCase() == 'latn') {
          country = 'UZ';
        }

        // Address format should be always associated to a COUNTRY.
        // If country part is empty, we need to map language to a
        // certain country. For example, "de" -> "DE".da
        if (!country && languageCodeToCountry.languageCode[langCode]) {
          country = languageCodeToCountry.languageCode[langCode];
        }

        // Trace the real data from country reference.
        country = this.followReferences(data$1, country);
        if (!country || !data$1[country]) {
          return 'US'; // Always fall back to US format.
        }
        return country;
      },
      /**
       * Get fall back country code.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {*} address Address Data
       * @return {string} Address Code
       *
       * @deprecated Use getCountryFromLocale instead
       */
      getFallback: function getFallback(langCode, countryCode, address) {
        return this.getCountryFromLocale(langCode, countryCode);
      }
    };

    // This is a library built from Globalization's repo
    // https://git.soma.salesforce.com/Globalization/name.js
    // This will be added/updated through a build process in the future
    /* eslint-disable */
    var data = {
      DEFAULT: {
        short_f: '%F %L',
        medium_f: '%F %M %L',
        long_f: '%S %F %M %L %X %I',
        input: 'SFMLXI'
      },
      vi: {
        short_f: '%L %F',
        medium_f: '%L %M %F',
        long_f: '%L %M %F %X %I',
        input: 'SLFMXI'
      },
      vi_VN: {
        _ref: 'vi'
      },
      hu: {
        short_f: '%L %F',
        medium_f: '%L %F',
        long_f: '%L %F %M %X %I',
        input: 'SLFMXI'
      },
      hu_HU: {
        _ref: 'hu'
      },
      ja: {
        short_f: '%L %F',
        medium_f: '%L %M %F',
        long_f: '%L %M %F %X %I',
        input: 'SLMFXI'
      },
      ja_JP: {
        _ref: 'ja'
      },
      ko: {
        _ref: 'ja'
      },
      ko_KR: {
        _ref: 'ja'
      },
      zh: {
        _ref: 'ja'
      },
      zh_CN: {
        _ref: 'ja'
      },
      zh_CN_PINYIN: {
        _ref: 'ja'
      },
      zh_CN_STROKE: {
        _ref: 'ja'
      },
      zh_HK: {
        _ref: 'ja'
      },
      zh_HK_STROKE: {
        _ref: 'ja'
      },
      zh_MO: {
        _ref: 'ja'
      },
      zh_SG: {
        _ref: 'ja'
      },
      zh_TW: {
        _ref: 'ja'
      },
      zh_TW_STROKE: {
        _ref: 'ja'
      }
    };

    // Define all available fields.

    /**
     S: Salutation
     F: First Name(givenName)
     M: Middle Name
     L: Last Name(familyName)
     X: Suffix
     I: Informal Name
     */

    var fieldConstants = {
      SALUTATION: Symbol('Salutation'),
      FIRST: Symbol('First Name'),
      MIDDLE: Symbol('Middle Name'),
      LAST: Symbol('Last Name'),
      SUFFIX: Symbol('Suffix'),
      INFORMAL: Symbol('Informal Name')
    };
    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var Format = function Format(parts) {
      _classCallCheck(this, Format);
      this.parts = Object.freeze(parts);
      Object.freeze(this);
    };

    /**
     * Represents a field within the format
     */

    var FieldFormatPart = function FieldFormatPart(field) {
      _classCallCheck(this, FieldFormatPart);
      this.field = field;
      this.type = 'field';
      Object.freeze(this);
    };

    /**
     * Represents text to be output directly
     */

    var TextFormatPart = function TextFormatPart(text) {
      _classCallCheck(this, TextFormatPart);
      this.type = 'text';
      this.text = text;
      Object.freeze(this);
    };
    var fieldFormatParts = Object.freeze({
      SALUTATION: new FieldFormatPart(fieldConstants.SALUTATION),
      FIRST: new FieldFormatPart(fieldConstants.FIRST),
      MIDDLE: new FieldFormatPart(fieldConstants.MIDDLE),
      LAST: new FieldFormatPart(fieldConstants.LAST),
      SUFFIX: new FieldFormatPart(fieldConstants.SUFFIX),
      INFORMAL: new FieldFormatPart(fieldConstants.INFORMAL)
    });
    var FormatParser = function () {
      function FormatParser() {
        _classCallCheck(this, FormatParser);
      }
      _createClass(FormatParser, [{
        key: 'parse',
        /**
         * Parses the format
         * @param {string} fmt the format to be parsed
         * @returns {Format}
         */
        value: function parse(fmt) {
          var nodes = [];
          var textBuffer = '';

          // parse the format string
          for (var i = 0; i < fmt.length; i = i + 1) {
            if (fmt[i] === '%') {
              i = i + 1; // move to the next character after %

              // end the last text buffer
              if (textBuffer.length > 0) {
                nodes.push(Object.freeze(new TextFormatPart(textBuffer)));
                textBuffer = '';
              }
              if (i >= fmt.length) {
                throw new Error('Unexpected end of format. Symbol at ' + (i - 1) + ' should be followed by a valid field code');
              }
              var code = fmt[i];
              switch (code) {
                case 'S':
                  nodes.push(fieldFormatParts.SALUTATION);
                  break;
                case 'F':
                  nodes.push(fieldFormatParts.FIRST);
                  break;
                case 'M':
                  nodes.push(fieldFormatParts.MIDDLE);
                  break;
                case 'L':
                  nodes.push(fieldFormatParts.LAST);
                  break;
                case 'X':
                  nodes.push(fieldFormatParts.SUFFIX);
                  break;
                case 'I':
                  nodes.push(fieldFormatParts.INFORMAL);
                  break;
              }
            } else {
              // if it wasn't a symbol, then just output the value directly
              textBuffer += fmt[i];
            }
          }
          if (textBuffer.length > 0) {
            nodes.push(new TextFormatPart(textBuffer));
          }
          return new Format(nodes);
        }
      }]);
      return FormatParser;
    }();
    var formatParser = new FormatParser();
    var name = {
      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {{short: string, medium: string, long: string, input: string}} format data
       */
      getNameInfoForLocale: function getNameInfoForLocale(localeStr) {
        var key = this.getFallback(localeStr);
        if (data[key]) {
          // Double check.
          var cloneNameInfo = Object.freeze(Object.assign({}, data[key]));
          return Object.freeze({
            name: cloneNameInfo
          });
        }
      },
      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternMedium: function getNameFormatPatternMedium(localeStr) {
        var key = this.getFallback(localeStr);
        if (data[key]) {
          // Double check.
          return data[key].medium_f;
        }
      },
      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternShort: function getNameFormatPatternShort(localeStr) {
        var key = this.getFallback(localeStr);
        if (data[key]) {
          // Double check.
          return data[key].short_f;
        }
      },
      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternLong: function getNameFormatPatternLong(localeStr) {
        var key = this.getFallback(localeStr);
        if (data[key]) {
          // Double check.
          return data[key].long_f;
        }
      },
      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} input order
       */
      getNameInputOrder: function getNameInputOrder(localeStr) {
        var key = this.getFallback(localeStr);
        if (data[key]) {
          // Double check.
          return data[key].input;
        }
      },
      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameShort: function formatNameShort(localeStr, values) {
        var key = this.getFallback(localeStr);
        if (data[key]) {
          // Double check.
          return this.buildName(data[key].short_f, values);
        }
      },
      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameMedium: function formatNameMedium(localeStr, values) {
        var key = this.getFallback(localeStr);
        if (data[key]) {
          // Double check.
          return this.buildName(data[key].medium_f, values);
        }
      },
      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameLong: function formatNameLong(localeStr, values) {
        var key = this.getFallback(localeStr);
        if (data[key]) {
          // Double check.
          return this.buildName(data[key].long_f, values);
        }
      },
      /**
       * Creates an array of address lines given the format and the values to use.
       * @param {string} pattern
       * @param @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the text for use in the address
       */
      buildName: function buildName(pattern, values) {
        var format = formatParser.parse(pattern);
        var sb = [];
        for (var i = 0; i < format.parts.length; i++) {
          var part = format.parts[i];
          if (part.type === 'text') {
            sb.push(part.text);
          } else if (part.type === 'field') {
            if (part.field === fieldConstants.SALUTATION) {
              sb.push(values.salutation || '');
            } else if (part.field === fieldConstants.FIRST) {
              sb.push(values.first || '');
            } else if (part.field === fieldConstants.MIDDLE) {
              sb.push(values.middle || '');
            } else if (part.field === fieldConstants.LAST) {
              sb.push(values.last || '');
            } else if (part.field === fieldConstants.SUFFIX) {
              sb.push(values.suffix || '');
            } else if (part.field === fieldConstants.INFORMAL) {
              sb.push(values.informal || '');
            } else ;
          }
        }
        return sb.join('').trim().replace(/  /g, ' ');
      },
      // Resolve the reference by tracing down the _ref value.
      followReferences: function followReferences(key) {
        if (data[key] && data[key]._ref) {
          return this.followReferences(data[key]._ref);
        }
        return key;
      },
      // Get fall back key.
      getFallback: function getFallback(localeStr) {
        // Resolve the reference.
        var key = this.followReferences(localeStr);
        if (!data[key]) {
          return 'DEFAULT'; // Always fall back to 'US'.
        }
        return key;
      }
    };

    // TODO: when migrating off aura, remove functions
    // and variables only needed for numberOptions

    // For possible parameters, see the Intl.NumberFormat spec:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat#Parameters

    const STYLE = {
      DECIMAL: 'decimal',
      CURRENCY: 'currency',
      PERCENT: 'percent'
    };
    const CURRENCY_DISPLAY = {
      CODE: 'code',
      // USD
      SYMBOL: 'symbol',
      // $
      NAME: 'name' // US Dollars
    };
    const SAFE_NUM_LENGTH = 15;
    const SAFE_NUM_REGEXP = /0+$/;
    function toNumber(value) {
      return parseInt(value, 10);
    }

    /**
     * Gets portion of skeleton for decimal portion of number
     */
    function getFractionSkeleton(skeleton) {
      const format = skeleton.split(';')[0];
      return format.split('.')[1] || '';
    }

    /**
     * Sets minimum and maximum fraction digits in options based on
     * default skeleton and current values; needed to adjust skeleton
     *
     * @param {string} skeleton
     */
    function normalizeFractionDigits(skeleton, options) {
      const fractionSkeleton = getFractionSkeleton(skeleton);
      const defaultMinimum = fractionSkeleton.replace(/[^0]/g, '').length; // number of 0s in skeleton
      const defaultMaximum = fractionSkeleton.replace(/[^0#]/g, '').length; // number of 0s and #s in skeleton
      const minDigits = toNumber(options.minimumFractionDigits);
      const maxDigits = toNumber(options.maximumFractionDigits);
      if (!isFinite(options.minimumFractionDigits)) {
        // min fraction digits shouldn't be more than max digits
        options.minimumFractionDigits = Math.min(defaultMinimum, isNaN(maxDigits) ? defaultMinimum : maxDigits);
      }
      if (!isFinite(options.maximumFractionDigits) || maxDigits < minDigits) {
        // max fraction digits shouldn't be less than min digits
        options.maximumFractionDigits = Math.max(defaultMaximum, isNaN(minDigits) ? defaultMaximum : minDigits);
      }
    }

    /**
     * Gets the fraction/decimal portion of the number formatting
     * string based on the provided formatting options
     *
     * @param {Object} options - number formatting options
     * @returns {string}
     */
    function getFractionPart(options) {
      const {
        minimumFractionDigits,
        maximumFractionDigits
      } = options;
      return '.' + '0'.repeat(minimumFractionDigits) + '#'.repeat(maximumFractionDigits - minimumFractionDigits);
    }

    /**
     * Updates "skeleton" for number format
     * based on the formatting options provided
     *
     * @param {string} skeleton - outline for number format
     * @param {Object} options - number formatting options
     * @returns {string} updated skeleton
     */
    function updateFractionPart(skeleton, options) {
      normalizeFractionDigits(skeleton, options);
      const fractionPart = getFractionPart(options);
      return addFractionsToPattern(skeleton, fractionPart);
    }

    /**
     * Updates provided pattern to use provided
     * fractionPart for fraction/decimal portion
     * @param {string} pattern - current string for number format
     * @param {string} fractionPart - string to use for fraction part of number formatting
     * @returns {string} updated pattern
     */
    function addFractionsToPattern(pattern, fractionPart) {
      if (!fractionPart) {
        return pattern;
      }

      // if pattern has two formats (one for positive and one for negative numbers), add fractions to both patterns
      if (pattern.indexOf(';') > 0) {
        const [positivePattern, negativePattern] = pattern.split(';');
        return `${addFractionsToPattern(positivePattern, fractionPart)};${addFractionsToPattern(negativePattern, fractionPart)}`;
      }

      // If the pattern already has a fraction part, replace it with the fractions calculated from the options
      if (pattern.indexOf('.') > 0) {
        return pattern.replace(/\.(0|#)*/, fractionPart);
      }

      // If the pattern doesn't have a fraction part, we need to add it to the pattern
      // We need to add the fraction part after the last digit (represented by '0' or '#')
      const position = Math.max(pattern.lastIndexOf('0'), pattern.lastIndexOf('#')) + 1;
      return [pattern.slice(0, position), fractionPart, pattern.slice(position)].join('');
    }

    /**
     * Gets count of numbers in last "grouping" before decimal
     * e.g. for en-IN pattern "#,##,##0.###" this returns 3
     * @param {Object} skeleton
     * @returns {Number}
     */
    function getGroupingCount(skeleton) {
      const match = skeleton.match(/,[#0]*\./);
      return match ? match[0].length - 2 : 0;
    }

    /**
     * Updates integer part of string representation for number format
     * for number as needed based on minimumIntegerDigits option
     *
     * @param {string} skeleton - string of default number format
     * @param {Object} options - number format options
     * @returns skeleton with integer part updated for options
     */
    function updateIntegerPart(skeleton, options) {
      const minimumIntegerDigits = options.minimumIntegerDigits;
      const groupingCount = getGroupingCount(skeleton);
      if (!minimumIntegerDigits) {
        return skeleton;
      }
      if (minimumIntegerDigits <= groupingCount) {
        // handle case where number will include grouping e.g., "1,234"
        return skeleton.replace(/,[#0]*\./, ',' + '#'.repeat(groupingCount - minimumIntegerDigits) + '0'.repeat(minimumIntegerDigits) + '.');
      }
      // handle case where number will not include grouping e.g., "123"
      return skeleton.replace(/[#0]*\./, '0'.repeat(minimumIntegerDigits - groupingCount) + ',' + '0'.repeat(groupingCount) + '.');
    }

    /**
     * Gets string for how to display currency for provided
     * currency code and display style by formatting value
     * and removing remainder of string a set
     *
     * @param {string} code - currency code to format number with
     * @param {string} currencyDisplay - style for displaying currency
     * @returns {string} for currency
     */
    function getBestMatchCurrencySymbol(code, currencyDisplay) {
      const opts = {
        style: STYLE.CURRENCY,
        currency: code,
        minimumFractionDigits: 0
      };
      if (currencyDisplay) {
        opts.currencyDisplay = currencyDisplay;
      }
      const nf = i18nService.getNumberFormat(locale__default.default, opts);
      return nf.format(2).replace(/2/g, '');
    }

    /**
     * Returns string for how currency should be displayed
     * based on provided number formatting options
     *
     * @param {Object} options - number formatting options
     * @returns {string} for how currency will show in formatted number
     */
    function getCurrency(options) {
      const currencyDisplay = options.currencyDisplay || CURRENCY_DISPLAY.SYMBOL;
      if (currencyDisplay === CURRENCY_DISPLAY.SYMBOL || currencyDisplay === CURRENCY_DISPLAY.NAME) {
        return getBestMatchCurrencySymbol(options.currency, currencyDisplay);
      }
      return options.currency; // if displaying code no formatting needed
    }

    /**
     * Updates "skeleton" to include currency code/name
     * based on provided currencyCode and options
     *
     * @param {string} skeleton - current number formatting skeleton
     * @param {string} currencyCode - currency code to use
     * @param {Object} options - number formatting options
     * @returns {string} updated skeleton
     */
    function updateCurrencySymbol(skeleton, currencyCode, options) {
      const symbol = String.fromCharCode(164); // corresponds to "¤"
      if (options.currencyDisplay === CURRENCY_DISPLAY.NAME) {
        // append the currency code at the end
        return skeleton.replace(symbol, '') + currencyCode;
      }
      return skeleton.replace(symbol, currencyCode);
    }

    /**
     * Determines whether or not the provided value has more
     * significant digits than what Intl.NumberFormat supports
     *
     * @param {Number|String} value - value to check
     * @returns {boolean} true if value exceeds safe length for Intl.NumberFormat
     */
    function exceedsSafeLength(value) {
      const numberAsString = value.toString();
      const [intPart, fractionPart] = numberAsString.split('.');
      // This count strips out insignificant trailing zeroes in the fraction part of the number.
      const digitCount = intPart.length + (fractionPart ? fractionPart.replace(SAFE_NUM_REGEXP, '').length : 0);
      return digitCount >= SAFE_NUM_LENGTH;
    }

    // TODO: remove file when migrating off aura
    const isDefaultCurrency = options => {
      return !options.currency || currency__default.default === options.currency;
    };
    const getDefaultSkeleton = options => {
      if (options.style === STYLE.CURRENCY) {
        return currencyFormat__default.default;
      } else if (options.style === STYLE.PERCENT) {
        return percentFormat__default.default;
      }
      return numberFormat__default.default;
    };

    /**
     * Function translating provided number formatting options to a
     * string that can be passed into Aura localization service.
     *
     * @param {Object} options - number formatting options
     * @returns {string} representing provided options as a string -
     * e.g. "$#,##,##0.00#"
     */
    const getSkeleton$1 = options => {
      const defaultSkeleton = getDefaultSkeleton(options);
      let skeleton = updateFractionPart(defaultSkeleton, options);
      skeleton = updateIntegerPart(skeleton, options);
      if (!isDefaultCurrency(options)) {
        skeleton = updateCurrencySymbol(skeleton, getCurrency(options), options);
      }
      return skeleton;
    };

    // TODO: remove mosst if not all of file when migrating off aura
    // This is a library for all calls to the aura localizationService.

    function isBefore(date1, date2, unit) {
      return configProvider.getLocalizationService().isBefore(date1, date2, unit);
    }
    function isAfter(date1, date2, unit) {
      return configProvider.getLocalizationService().isAfter(date1, date2, unit);
    }
    function formatDateTimeUTC(date) {
      return configProvider.getLocalizationService().formatDateTimeUTC(date);
    }
    function formatDate(dateString, format, locale) {
      return configProvider.getLocalizationService().formatDate(dateString, format, locale);
    }
    function formatDateUTC(dateString, format, locale) {
      return configProvider.getLocalizationService().formatDateUTC(dateString, format, locale);
    }
    function formatTime(timeString, format) {
      return configProvider.getLocalizationService().formatTime(timeString, format);
    }
    function parseDateTimeUTC(dateTimeString) {
      return configProvider.getLocalizationService().parseDateTimeUTC(dateTimeString);
    }
    function parseDateTimeISO8601(dateTimeString) {
      return configProvider.getLocalizationService().parseDateTimeISO8601(dateTimeString);
    }
    function parseDateTime(dateTimeString, format, strictMode) {
      return configProvider.getLocalizationService().parseDateTime(dateTimeString, format, strictMode);
    }
    function syncUTCToWallTime(date, timeZone) {
      let converted = null;

      // eslint-disable-next-line new-cap
      configProvider.getLocalizationService().UTCToWallTime(date, timeZone, result => {
        converted = result;
      });
      return converted;
    }
    function syncWallTimeToUTC(date, timeZone) {
      let converted = null;

      // eslint-disable-next-line new-cap
      configProvider.getLocalizationService().WallTimeToUTC(date, timeZone, result => {
        converted = result;
      });
      return converted;
    }
    function toOtherCalendar(date) {
      return configProvider.getLocalizationService().translateToOtherCalendar(date);
    }
    function fromOtherCalendar(date) {
      return configProvider.getLocalizationService().translateFromOtherCalendar(date);
    }
    function toLocalizedDigits(input) {
      return configProvider.getLocalizationService().translateToLocalizedDigits(input);
    }
    function fromLocalizedDigits(input) {
      return configProvider.getLocalizationService().translateFromLocalizedDigits(input);
    }

    // This belongs to localization service; i.e. getLocalizationService().parseTime()
    // Should be removed after it's been added to the localization service
    function parseTime(timeString, format, strictParsing) {
      if (!timeString) {
        return null;
      }
      if (!format) {
        if (!iso8601Utils.isValidISOTimeString(timeString)) {
          return null;
        }
        return parseDateTimeISO8601(timeString);
      }
      const parseString = timeString.replace(/(\d)([AaPp][Mm])/g, '$1 $2');

      // Modifying the time string so that strict parsing doesn't break on minor deviations
      const parseFormat = format.replace(/(\b|[^h])h{2}(?!h)/g, '$1h').replace(/(\b|[^H])H{2}(?!H)/g, '$1H').replace(/(\b|[^m])m{2}(?!m)/g, '$1m').replace(/\s*A/g, ' A').trim();
      const acceptableFormats = [parseFormat];
      // We want to be lenient and accept input values with seconds or milliseconds precision.
      // So even though we may display the time as 10:23 AM, we would accept input values like 10:23:30.555 AM.
      acceptableFormats.push(parseFormat.replace('m', 'm:s'), parseFormat.replace('m', 'm:s.S'), parseFormat.replace('m', 'm:s.SS'), parseFormat.replace('m', 'm:s.SSS'));

      // Start parsing from the most strict format (i.e. time with milliseconds).
      // The strict mode parsing of time strings using parseDateTime seems to be lenient for certain formats
      acceptableFormats.reverse();
      for (let i = 0; i < acceptableFormats.length; i++) {
        const time = parseDateTime(parseString, acceptableFormats[i], strictParsing);
        if (time) {
          return time;
        }
      }
      return null;
    }

    // This is called from the numberFormat library when the value exceeds the safe length.
    function getNumberFormat(format) {
      return configProvider.getLocalizationService().getNumberFormat(format);
    }
    function duration(value, unit) {
      return configProvider.getLocalizationService().duration(value, unit);
    }
    function displayDuration(value, withSuffix) {
      return configProvider.getLocalizationService().displayDuration(value, withSuffix);
    }

    // TODO: remove file when migrating off aura
    function numberFormatFallback(options) {
      const skeleton = getSkeleton$1(options);
      return {
        format: value => {
          return getNumberFormat(skeleton).format(value);
        }
      };
    }

    /**
     * Used to determine if aura localization service is available
     * This should be true on-core and false off-core, and will
     * no longer be needed when we fully migrate off aura's service
     */
    /* eslint-disable-next-line @lwc/lwc/no-restricted-browser-globals-during-ssr */
    const isAuraL10NAvailable = utilsPrivate.isCSR && window.$A?.localizationService;

    /**
     * Returns string to use when throwing an error message
     * if an invalid value is provided when parsing a datetime
     */
    const getDateTimeErrorMessage = value => `datetime component: The value attribute accepts a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`;

    function numberFormat(options) {
      const currencyValue = {
        currency: options.currency || currency__default.default
      };
      const normalizedOpts = Object.assign({}, options, currencyValue);
      return {
        format: value => {
          // TODO: when migrating off aura just use getNumberFormat directly
          // TD-0117848 will need to be completed before migrating off
          // aura fallback should only be used when aura is available and value has
          // too many significant digits to work correctly with localizer
          const useFallback = isAuraL10NAvailable && value && exceedsSafeLength(value);
          const numberFormatter = useFallback ? numberFormatFallback(normalizedOpts) : i18nService.getNumberFormat(locale__default.default, normalizedOpts);
          return numberFormatter.format(value);
        }
      };
    }

    const MINUTE_MILLISECONDS = 1000 * 60;
    function relativeFormat() {
      return {
        format: value => {
          const now = Date.now();
          const timestamp = Number(value);
          utilsPrivate.assert(isFinite(timestamp), `RelativeFormat: The value attribute accepts either a Date object or a timestamp, but we are getting the ${typeof value} value "${value}" instead.`);
          const getDiffInMinutes = (timestamp - now) / MINUTE_MILLISECONDS;
          const durationData = duration(getDiffInMinutes, 'minutes');
          return displayDuration(durationData, true);
        }
      };
    }

    // TODO: remove file when migrating off aura
    const FORMAT_MAP = {
      weekday: {
        short: 'EEE, ',
        narrow: 'EEE, ',
        long: 'EEEE, '
      },
      month: {
        short: 'MMM ',
        narrow: 'MMM ',
        numeric: 'MMM ',
        '2-digit': 'MMM ',
        long: 'MMMM '
      },
      day: {
        numeric: 'd, ',
        '2-digit': 'dd, '
      },
      year: {
        numeric: 'yyyy ',
        '2-digit': 'yy '
      },
      hour: {
        numeric12: 'h',
        numeric24: 'H',
        '2-digit12': 'hh',
        '2-digit24': 'HH'
      },
      minute: {
        numeric: 'mm',
        '2-digit': 'mm'
      },
      second: {
        numeric: 'ss',
        '2-digit': 'ss'
      },
      timeZoneName: {
        short: '[GMT]Z',
        long: '[GMT]Z'
      }
    };
    const SEPARATORS = [',', ' ', ':'];
    function getWeekDayPart(format, options) {
      const weekdayOptionValue = options.weekday;
      if (FORMAT_MAP.weekday[weekdayOptionValue] !== undefined) {
        format.push(FORMAT_MAP.weekday[weekdayOptionValue]);
      }
    }
    function getMonthPart(format, options) {
      const monthOptionValue = options.month;
      if (FORMAT_MAP.month[monthOptionValue] !== undefined) {
        format.push(FORMAT_MAP.month[monthOptionValue]);
      }
    }
    function getDayPart(format, options) {
      const dayOptionValue = options.day;
      if (FORMAT_MAP.day[dayOptionValue] !== undefined) {
        format.push(FORMAT_MAP.day[dayOptionValue]);
      }
    }
    function getYearPart(format, options) {
      const yearOptionValue = options.year;
      if (FORMAT_MAP.year[yearOptionValue] !== undefined) {
        format.push(FORMAT_MAP.year[yearOptionValue]);
      }
    }
    function getTZPart(format, options) {
      const timeZoneNameOptionValue = options.timeZoneName;
      if (FORMAT_MAP.timeZoneName[timeZoneNameOptionValue] !== undefined) {
        if (options.timeZone === 'UTC') {
          format.push('[GMT]');
        } else {
          format.push(FORMAT_MAP.timeZoneName[timeZoneNameOptionValue]);
        }
      }
    }
    function getTimePart(format, options) {
      const hourOptionValue = options.hour,
        minuteOptionValue = options.minute,
        secondOptionValue = options.second;
      let hasTime = false;
      let hasHourOnly = false;

      // hour 12 hr or 24 hr
      if (hourOptionValue === 'numeric' || hourOptionValue === '2-digit') {
        hasTime = true;
        if (options.hour12 === false) {
          if (hourOptionValue === 'numeric') {
            format.push(FORMAT_MAP.hour.numeric24);
          } else {
            format.push(FORMAT_MAP.hour['2-digit24']);
          }
        } else if (hourOptionValue === 'numeric') {
          format.push(FORMAT_MAP.hour.numeric12);
        } else {
          format.push(FORMAT_MAP.hour['2-digit12']);
        }
        if (FORMAT_MAP.minute[minuteOptionValue] !== undefined) {
          format.push(':');
        } else if (FORMAT_MAP.second[secondOptionValue] !== undefined) {
          hasHourOnly = true;
        }
      }

      // minute
      if (FORMAT_MAP.minute[minuteOptionValue] !== undefined) {
        hasTime = true;
        format.push(FORMAT_MAP.minute[minuteOptionValue]);
        if (FORMAT_MAP.second[secondOptionValue] !== undefined) {
          format.push(':');
        }
      }

      // second
      if (FORMAT_MAP.second[secondOptionValue] !== undefined && !hasHourOnly) {
        hasTime = true;
        format.push(FORMAT_MAP.second[secondOptionValue]);
      }

      // AM/PM marker
      if (hasTime) {
        format.push(' a ');
      }
      if (hasHourOnly) {
        format.push('[(sec]: ' + FORMAT_MAP.second[secondOptionValue] + '[)]');
      }
    }

    /**
     * Function translating provided date time options to a
     * string that can be passed into Aura localization service.
     *
     * @param {Object} options - date time formatting options
     * @returns {string} representing provided options as a string -
     * e.g. "dd, MMM yyyy h:mm"
     */
    const getSkeleton = options => {
      const format = [];
      getWeekDayPart(format, options);
      getMonthPart(format, options);
      getDayPart(format, options);
      getYearPart(format, options);
      getTimePart(format, options);
      getTZPart(format, options);
      let formatStr = format.join('');
      SEPARATORS.forEach(element => {
        if (formatStr.lastIndexOf(element) === formatStr.length - 1) {
          formatStr = formatStr.slice(0, -1);
        }
      });
      return formatStr;
    };

    // TODO: When migrating off Aura, consider removing 'asserts'; consider
    // consider using console.error, throwing Error and/or sticking with
    // default behavior for handling invalid inputs in i18nService
    const ISO_FORMAT = "yyyy-MM-dd'T'hh:mm:ss.SSS'Z'";
    const LATN = 'latn';
    const utcTimeZone = {
      timeZone: 'UTC'
    };

    /**
     * HELPER FUNCTIONS
     */

    /**
     * Checks if a value contains a time zone offset by checking
     * for a '+' or '-' character in string and null otherwise
     *
     * @param {any} value
     * @returns
     */
    const hasTimeZoneOffset = value => {
      if (typeof value === 'string') {
        return value.indexOf('+') !== -1 || value.indexOf('-') !== -1;
      }
      return false;
    };

    /**
     * If provided a string returns trimmed string, otherwise
     * returns provided value exactly as-is
     *
     * @param {any} value
     * @returns {any}
     */
    const getTrimmedValue = value => {
      return typeof value === 'string' ? value.trim() : value;
    };

    /**
     * If provided a string returns trimmed string
     * with 0 or 3 digits for milliseconds, otherwise
     * returns provided value exactly as-is
     *
     * @param {any} value
     * @returns {any}
     */
    const getNormalizedValue = value => {
      const trimmedValue = getTrimmedValue(value);
      return iso8601Utils.padMilliseconds(trimmedValue);
    };

    /**
     * Returns part of a provided string before 'T', representing
     * date portion of ISO string. If provided value is not a string
     * simply returns the value exactly as-is
     *
     * @param {any} value - value to get date for
     * @returns {any}
     */
    const getDateOnly = value => {
      return typeof value === 'string' ? value.split(iso8601Utils.TIME_SEPARATOR)[0] : value;
    };

    /**
     * Returns true if provided value is a Date object, false otherwise
     *
     * @param {any} value - value to check if Date object or not
     * @returns {boolean}
     */
    function isDate(value) {
      return Object.prototype.toString.call(value) === '[object Date]' && !isNaN(value.getTime());
    }

    /**
     * @returns YYYY-MM-DD string for system time zone
     */
    function getCurrentDateString() {
      const today = getTodayBasedOnTimezone();
      return getISODateString(today);
    }

    /**
     * Returns ISO date string corresponding to provided date in local time zone
     *
     * @param {Date} date - date to get ISO date string for
     * @returns 'YYYY-MM-DD' string representing provided date in local time zone
     */
    function getISODateString(date) {
      if (!isDate(date)) {
        return null;
      }
      return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
    }

    /**
     * Returns ISO time string without any time zone indicator
     * corresponding to provided date in local time zone
     *
     * @param {Date} date - date to get ISO time string in local time zone for
     * @returns 'HH:mm:ss.SSS' string representing the provided
     * date time in local time zone
     */
    function getISOTimeString(date) {
      if (!isDate(date)) {
        return null;
      }
      return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${doublePad(date.getMilliseconds())}`;
    }

    /**
     * Returns ISO time string without any time zone indicator
     * corresponding to provided date in UTC time zone
     *
     * @param {Date} date - date to get ISO time string in UTC for
     * @returns 'HH:mm:ss.SSS' string representing the provided
     * date time in UTC time zone
     */
    function getISOTimeStringUTC(date) {
      if (!isDate(date)) {
        return null;
      }
      return `${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}:${pad(date.getUTCSeconds())}.${doublePad(date.getUTCMilliseconds())}`;
    }

    /**
     * Gets current time in provided timezone in hours and minutes
     *
     * @param {string} timezone - timezone to get time for
     * @returns time in HH:mm format
     */
    function getCurrentTimeString(timezone) {
      const today = getTodayBasedOnTimezone(timezone);
      return `${pad(today.getHours())}:${pad(today.getMinutes())}`;
    }

    /**
     * Gets offset between provided timezone and either
     * system timezone or UTC timezone at current date
     *
     * @param {Date} date - date used when determining offset
     * @param {string} timeZone - time zone to get offset for
     * @returns {Number} offset in milliseconds
     */
    function getOffsetForTimezone(date, timeZone, shouldAddUTCOffset) {
      const time1 = i18nService.getDateTimeCLDRParser({
        pattern: ISO_FORMAT,
        timeZone,
        numberingSystem: LATN
      }).parse(date.toISOString());
      const extraOffset = shouldAddUTCOffset ? date.getTimezoneOffset() : 0;
      // need to subtract milliseconds since CLDR seems to reset milliseconds to zero
      const time2 = date.getTime() - date.getMilliseconds() + extraOffset * 60 * 1000;
      return time2 - time1;
    }

    /**
     * Adjust provided date by offset from either system time zone or UTC
     *
     * @param {Date} date - initial date to adjust
     * @param {string} timeZone - time zone to adjust date based on
     * @param {boolean} shouldAddUTCOffset - adjust by UTC instead of local offset if true
     *
     * @returns {Date} date adjusted by either system time zone or UTC
     * e.g., if the date corresponds to 2pm in provided time zone and calculated
     * offset is +4 hours, returns date corresponding to 6pm in provided time zone
     */
    function adjustDateByOffset(date, timeZone, shouldAddUTCOffset) {
      const offset = getOffsetForTimezone(date, timeZone, shouldAddUTCOffset);
      const timestamp = date.getTime() + offset;
      return new Date(timestamp);
    }

    /**
     * Get current date moved by offset between provided timezone
     * (or system time zone if none provided) and UTC
     *
     * @param {string} timeZone - optional time zone to get current date for
     * @returns {Date} current date adjusted by offset between provided
     * time zone and UTC; e.g., if current time is 6pm in UTC and 2pm
     * locally, returns date corresponding to 6pm locally and 10pm UTC
     */
    function getTodayBasedOnTimezone(timeZone) {
      const today = new Date();
      if (isAuraL10NAvailable) {
        // time in UTC
        today.setTime(today.getTime() + today.getTimezoneOffset() * 60 * 1000);
        // localization service will use $Locale.timezone when no timezone provided
        return syncUTCToWallTime(today, timeZone);
      }
      return adjustDateByOffset(today, timeZone, true);
    }
    function pad(n) {
      return Number(n) < 10 ? '0' + n : n;
    }
    function doublePad(n) {
      const number = Number(n);
      if (number < 10) {
        return '00' + n;
      } else if (number < 100) {
        return '0' + n;
      }
      return n;
    }

    /**
     * STYLE-TO-FORMAT MAPPING
     */

    const DATE = 'date';
    const TIME = 'time';
    const DATETIME_STYLES = {
      SHORT: 'short',
      MEDIUM: 'medium',
      LONG: 'long'
    };
    // mapping of type/style of formats to use when
    // getting format based on provided type/style
    const DATETIME_FORMATS = {
      [DATE]: {
        [DATETIME_STYLES.SHORT]: shortDateFormat__default.default,
        [DATETIME_STYLES.MEDIUM]: mediumDateFormat__default.default,
        [DATETIME_STYLES.LONG]: longDateFormat__default.default,
        default: mediumDateFormat__default.default
      },
      [TIME]: {
        [DATETIME_STYLES.SHORT]: shortTimeFormat__default.default,
        [DATETIME_STYLES.MEDIUM]: mediumTimeFormat__default.default,
        [DATETIME_STYLES.LONG]: mediumTimeFormat__default.default,
        default: shortTimeFormat__default.default
      }
    };

    /**
     * Returns short/medium/long format for date/time/datetime
     * in CLDR format or options for datetime formatter
     *
     * Always returns CLDR in Aura, otherwise returns
     * formatting object if isCldr is falsy
     *
     * @param {string} type - date/time/datetime
     * @param {string} style - short/medium/long
     * @param {boolean} isCldr - true if getting cldr format
     * @returns {string|Object}
     */
    const getFormatFromStyle = (type, style, isCldr) => {
      let cldrString = DATETIME_FORMATS[type][style];
      if (!cldrString) {
        cldrString = DATETIME_FORMATS[type].default;
      }
      if (isAuraL10NAvailable || isCldr) {
        return cldrString;
      }
      return getFormattingOptions__default.default(cldrString);
    };
    const getDateFormatFromStyle = (dateStyle, isCldr) => {
      return getFormatFromStyle(DATE, dateStyle, isCldr);
    };
    const getTimeFormatFromStyle = (timeStyle, isCldr) => {
      return getFormatFromStyle(TIME, timeStyle, isCldr);
    };

    /**
     * NORMALIZE ISO DATETIMES
     */

    /**
     * Normalizes ISO date string to localized short,
     * medium, or long date string. Uses Aura on core
     * and localizer off-core.
     *
     * @param {string} value - ISO date to normalize
     * @param {string} dateStyle - style date should be in
     * eg., style 'short' may correspond to 'dd/mm/yy'
     *
     * @returns {Object} with ISO value and localized display value
     */
    function normalizeISODate(value, dateStyle) {
      const format = getDateFormatFromStyle(dateStyle);
      const isoValue = getDateOnly(getNormalizedValue(value));
      let parsedDate, displayValue;
      if (isoValue) {
        const isValid = iso8601Utils.isValidISODateTimeString(isoValue);
        if (utilsPrivate.isCSR) {
          utilsPrivate.assert(isValid, getDateTimeErrorMessage(value));
        } else if (!isValid) {
          // If SSR, do not throw to ensure hydration completes.
          return {
            isoValue: null,
            displayValue: ''
          };
        }
        try {
          if (isAuraL10NAvailable) {
            parsedDate = parseDateTime(isoValue, iso8601Utils.STANDARD_DATE_FORMAT);
            // converts to Buddhist calendar if necessary
            const civilDate = toOtherCalendar(parsedDate);
            displayValue = formatDate(civilDate, format);
          } else {
            parsedDate = i18nService.getDateTimeISO8601Parser().parse(isoValue);
            const formatOptions = Object.assign({}, utcTimeZone, format);
            displayValue = i18nService.getDateTimeFormat(locale__default.default, formatOptions).format(parsedDate);
          }
        } catch (error) {
          console.warn(error.message);
          parsedDate = null;
        }
      }
      if (!parsedDate) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }
      return {
        isoValue,
        displayValue
      };
    }

    /**
     * Normalizes ISO time string to localized format
     * Used in formattedTime and timepicker components
     *
     * @param {string} value - ISO time to normalize
     * @param {string} timeStyle - style time should be in
     * eg., style 'short' may correspond to 'HH:mm'
     *
     * @returns {Object} with ISO value, parsed Date value and localized display value
     */
    function normalizeISOTime(value, timeStyle) {
      const format = getTimeFormatFromStyle(timeStyle);
      const timeValue = getNormalizedValue(iso8601Utils.removeTimeZoneSuffix(value));
      let parsedValue, displayValue, getISO;
      if (timeValue) {
        const isValid = iso8601Utils.isValidISOTimeString(timeValue);
        if (utilsPrivate.isCSR) {
          utilsPrivate.assert(isValid, getDateTimeErrorMessage(value));
        } else if (!isValid) {
          // If SSR, do not throw to ensure hydration completes.
          return {
            isoValue: null,
            parsedValue: null,
            displayValue: ''
          };
        }
        try {
          if (isAuraL10NAvailable) {
            parsedValue = parseTime(timeValue);
            displayValue = formatTime(parsedValue, format);
            getISO = getISOTimeString;
          } else {
            parsedValue = i18nService.getDateTimeISO8601Parser().parse(timeValue);
            const formatOptions = Object.assign({}, utcTimeZone, format);
            displayValue = i18nService.getDateTimeFormat(locale__default.default, formatOptions).format(parsedValue);
            getISO = getISOTimeStringUTC;
          }
        } catch (error) {
          console.warn(error.message);
          parsedValue = null;
        }
      }
      if (!parsedValue) {
        return {
          isoValue: null,
          parsedValue: null,
          displayValue: value || ''
        };
      } else if (hasTimeZoneOffset(value)) {
        // log warning to avoid confusion when time zone offset is ignored
        console.warn('lightning-formatted-time does not support non-UTC time zones and will ignore any time zone offsets.');
      }
      const isoValue = getISO(parsedValue);
      return {
        isoValue,
        parsedValue,
        displayValue
      };
    }

    /**
     * Normalizes ISO datetime string to localized format
     * Used in datetimepicker component
     *
     * @param {string} value - ISO datetime to normalize
     * @param {string} timeZone - IANA time zone to adjust value to
     *
     * @returns {Object} with ISO value, and localized/time zone adjusted display value
     */
    function normalizeISODateTime(value, timeZone) {
      const dateTimeValue = getNormalizedValue(value);
      let parsedDate, displayValue;
      if (dateTimeValue) {
        const isValid = iso8601Utils.isValidISODateTimeString(dateTimeValue);
        if (utilsPrivate.isCSR) {
          utilsPrivate.assert(isValid, getDateTimeErrorMessage(value));
        } else if (!isValid) {
          // If SSR, do not throw to ensure hydration completes.
          return {
            isoValue: null,
            displayValue: ''
          };
        }
        try {
          if (isAuraL10NAvailable) {
            const utcDate = parseDateTimeISO8601(dateTimeValue);
            if (utcDate) {
              parsedDate = syncUTCToWallTime(utcDate, timeZone);
              displayValue = formatDateTimeUTC(parsedDate);
            }
          } else {
            const utcDate = i18nService.getDateTimeISO8601Parser().parse(dateTimeValue);
            parsedDate = adjustDateByOffset(utcDate, timeZone);
            const dateFormat = getFormattingOptions__default.default(mediumDateFormat__default.default);
            const timeFormat = getFormattingOptions__default.default(mediumTimeFormat__default.default);
            const formatOptions = Object.assign({}, utcTimeZone, dateFormat, timeFormat);
            displayValue = i18nService.getDateTimeFormat(locale__default.default, formatOptions).format(parsedDate);
          }
        } catch (error) {
          console.warn(error.message);
          parsedDate = null;
        }
      }
      if (!parsedDate) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }
      return {
        isoValue: iso8601Utils.removeTimeZoneSuffix(parsedDate.toISOString()),
        displayValue
      };
    }

    /**
     * NORMALIZE FORMATTED DATETIMES
     */

    /**
     * Attempts to parse provided string into Date assuming string
     * is provided date style (short, medium, long) and returns string
     * in YYYY-MM-DD format. If parsing unsuccessful returns null.
     *
     * @param {string} value - formatted date string to parse into date
     * @param {string} dateStyle - date style to parse string as (short/medium/long)
     * @returns {string|null}
     */
    function normalizeFormattedDate(value, dateStyle) {
      const dateValue = getTrimmedValue(value);
      const format = getDateFormatFromStyle(dateStyle, true);
      let parsedDate;
      try {
        if (dateValue) {
          if (isAuraL10NAvailable) {
            parsedDate = fromOtherCalendar(parseDateTime(dateValue, format, true));
          } else {
            // doesn't work as expected for th-TH
            parsedDate = i18nService.getDateTimeCLDRParser({
              pattern: format
            }).parse(dateValue);
          }
        }
      } catch (error) {
        return null;
      }
      if (!parsedDate) {
        return null;
      }
      return getISODateString(parsedDate);
    }

    /**
     * Attempts to parse provided string into Date assuming string
     * is provided time style (short, medium, long) and returns string
     * in HH:mm:ss.SSS format. If parsing unsuccessful returns null.
     *
     * @param {string} value - formatted time string to parse into date
     * @param {string} timeStyle - time style to parse string as (short/medium/long)
     * @returns {string|null}
     */
    function normalizeFormattedTime(value, timeStyle) {
      const timeValue = getTrimmedValue(value);
      const format = getTimeFormatFromStyle(timeStyle, true);
      let parsedTime;
      try {
        if (timeValue) {
          if (isAuraL10NAvailable) {
            parsedTime = parseTime(timeValue, format || mediumTimeFormat__default.default, true);
          } else {
            parsedTime = i18nService.getDateTimeCLDRParser({
              pattern: format
            }).parse(timeValue);
          }
        }
      } catch (error) {
        return null;
      }
      if (!parsedTime) {
        return null;
      }
      return getISOTimeString(parsedTime);
    }

    /**
     * Converts ISO date time string without time zone indicator in given
     * time zone to the equivalent ISO date time string in UTC time zone
     *
     * @param {string} value - ISO datetime string without time zone indicator
     * @param {string} timeZone - IANA time zone that corresponds to value
     * @returns Equivalent ISO date string in UTC
     */
    function normalizeFormattedDateTime(value, timeZone) {
      const datetimeValue = getTrimmedValue(value);
      let parsedDate;
      try {
        if (datetimeValue) {
          if (isAuraL10NAvailable) {
            // given that value is an ISO string without Z, the parseDateTimeUTC
            // call below is equivalent to parseDateTimeISO8601(value + 'Z')
            const utcDate = parseDateTimeUTC(datetimeValue);
            if (utcDate) {
              parsedDate = syncWallTimeToUTC(utcDate, timeZone);
            }
          } else {
            // no time zone in value so UTC time zone is assumed
            const utcDate = i18nService.getDateTimeISO8601Parser().parse(datetimeValue);
            parsedDate = i18nService.getDateTimeCLDRParser({
              pattern: ISO_FORMAT,
              timeZone,
              numberingSystem: LATN
            }).parse(utcDate.toISOString());
          }
        }
      } catch (error) {
        return null;
      }
      if (!parsedDate) {
        return null;
      }
      return parsedDate.toISOString();
    }

    /**
     * Checks if normalization function recognizes provided value for any styles
     * returning the style recognized and the value as an ISO string
     * Used to allow user's to input a date/time in any style and have it
     * recognized as valid even though the picker defaults to a specific style
     *
     * @param {Function} normalizeFormattedValue - function to normalize formatted string to ISO string
     * @param {string} displayValue - string to format, generally input by user
     * @returns {Object} object with style of displayValue and displayValue normalized to ISO string
     */
    const parseFormattedValue = (normalizeFormattedValue, displayValue) => {
      const allowedStyles = Object.values(DATETIME_STYLES);
      let value = null,
        style = null;
      for (let i = 0; i < allowedStyles.length; i++) {
        value = normalizeFormattedValue(displayValue, allowedStyles[i]);
        if (value) {
          style = allowedStyles[i];
          break;
        }
      }
      return {
        value,
        style
      };
    };
    const parseFormattedTime = value => {
      return parseFormattedValue(normalizeFormattedTime, value);
    };
    const parseFormattedDate = value => {
      return parseFormattedValue(normalizeFormattedDate, value);
    };

    // TODO: when migrating off aura, remove functions
    // and vaiables only used in dateTimeOptions
    function convertAndFormatDate(date, format, timeZone) {
      const translatedDate = toOtherCalendar(date);
      const converted = syncUTCToWallTime(translatedDate, timeZone);
      return formatDateUTC(converted, format);
    }

    /**
     * Tries toDateStrict; if error thrown (unparseable string),
     * logs warning and returns value from Date.parse
     *
     * @param {String|Number|Date} value
     * @returns Date
     */
    function toDate(value) {
      try {
        return toDateStrict(value);
      } catch (err) {
        console.warn(`'${value}' does not follow a supported date format. Please use either a timestamp, ISO8601 string, or Date object to avoid risking inconsistencies and breakages.`);
        return new Date(value);
      }
    }

    /**
     * Converts a timestamp or ISO-8601 string to a Date object
     * If a Date object is provided it is returned as-is
     *
     * @param {String|Number|Date} value
     * @returns Date
     */
    function toDateStrict(value) {
      if (value && !isDate(value) && isFinite(value)) {
        // handles timestamp as number or string
        return new Date(parseInt(value, 10));
      } else if (value && !isDate(value)) {
        // handles non-timestamp string
        const strictString = iso8601Utils.padMilliseconds(value);
        return i18nService.getDateTimeISO8601Parser().parse(strictString);
      }
      return value; // handles date object
    }

    /**
     * Returns true if the current browser supports time zones
     * for Intl other than UTC by seeing if error is thrown when
     * a non-UTC time zone is passed; should return false for IE11
     * and true for all other supported browsers.
     */
    const isNonUTCSupported = function () {
      try {
        // eslint-disable-next-line new-cap
        Intl.DateTimeFormat('en-US', {
          timeZone: 'America/Los_Angeles'
        });
      } catch (err) {
        return false;
      }
      return true;
    }();
    function dateTimeFormatFallback(options) {
      const format = !useDefaultFormat(options) ? getSkeleton(options) : null;
      const {
        timeZone
      } = options;
      return {
        format: value => {
          // if value is an ISO date string with no time component, do not convert between timezones
          if (iso8601Utils.isValidISODateTimeString(value) && value.indexOf(iso8601Utils.TIME_SEPARATOR) < 0) {
            return formatDate(value);
          }
          // FIXME use standard methods from localizationService for parsing and formatting instead
          const dateObj = toDate(value);
          if (isDate(dateObj)) {
            if (timeZone === 'UTC') {
              dateObj.setTime(dateObj.getTime() + dateObj.getTimezoneOffset() * 60 * 1000);
            }
            return convertAndFormatDate(dateObj, format, timeZone);
          }
          return '';
        }
      };
    }

    /**
     * Returns true if Aura fallback should be used for
     * datetime formatting with provided date time optionss
     *
     * More specifically, Aura should be used on-core and
     * when no formatting options are provided or we're
     * using a non-UTC time zone on a browser that does
     * not support them
     */
    function useAuraFallbackFormatting(options) {
      const {
        timeZone
      } = options;
      const isNonUTCTimeZone = timeZone && timeZone !== 'UTC';
      if (isAuraL10NAvailable && (useDefaultFormat(options) || !isNonUTCSupported && isNonUTCTimeZone)) {
        return true;
      }
      return false;
    }

    /**
     * Returns true if the mediumDateFormat options should be used
     * Medium date format should be used when there are no options
     * or only options are for the time zone and hour system
     */
    function useDefaultFormat(options) {
      const excludedOptions = {
        hour12: true,
        hourCycle: true,
        timeZone: true,
        timeZoneName: true
      };
      const hasFormattingOption = Object.keys(options).some(opt => options[opt] !== undefined && !excludedOptions[opt]);
      return !hasFormattingOption;
    }

    /**
     * Creates date time formatter based on feature availability and provided options.
     * When on-core, uses Aura on IE11 or when we need default format, and uses
     * Intl.DateTimeFormat through i18nService otherwise
     *
     * @param {Object} opts - Formatting options from lightning-formatted-date-time
     * @returns {Object} - Object with "format" function
     */
    function dateTimeFormat(opts) {
      const options = opts || {};
      if (useAuraFallbackFormatting(options)) {
        return dateTimeFormatFallback(options);
      } else if (useDefaultFormat(options)) {
        // use mediumDateFormat options if not using Aura
        // and no options outside of hour system or time zone
        // need to use Object.assign so hour system and
        // time zone options work as expected when passed in
        opts = Object.assign(options, getFormattingOptions__default.default(mediumDateFormat__default.default));
      }
      return {
        format: value => {
          const formatter = i18nService.getDateTimeFormat(locale__default.default, opts);
          return formatter.format(toDate(value));
        }
      };
    }

    // Month and weekdays names should be based on the user's language setting.
    // Falling back to the user's locale or the default 'en-us' in case the tag isn't supported by the browser's Intl implementation
    const FALLBACK_LOCALES = [locale__default.default, 'en-us'];
    const symbolsCache = {};

    // languageOverride is only used in the tests
    function getNameOfWeekdays(languageOverride) {
      //It's a temporary workaround related to the calendar component, addressing the issue [W-8630541]: Saturday (Sabado) column extending outside of the calendar for the Portuguese language.
      const languageLocale = languageOverride || salesforceLanguage__default.default;
      const language = languageLocale === 'pt-PT' ? 'pt' : languageLocale;
      const languageDataCache = symbolsCache[language];
      if (languageDataCache && languageDataCache.weekdays) {
        return languageDataCache.weekdays;
      }
      const intlLocales = [language, ...FALLBACK_LOCALES];
      const fullNameFormatter = new Intl.DateTimeFormat(intlLocales, {
        weekday: 'long',
        timeZone: 'UTC'
      });
      const shortNameFormatter = new Intl.DateTimeFormat(intlLocales, {
        weekday: 'short',
        timeZone: 'UTC'
      });
      const weekdays = [];
      for (let i = 0; i <= 6; i++) {
        // (1970, 0, 4) corresponds to a sunday.
        const date = new Date(Date.UTC(1970, 0, 4 + i));
        weekdays.push({
          fullName: format(fullNameFormatter, date),
          shortName: format(shortNameFormatter, date)
        });
      }
      if (!symbolsCache[language]) {
        symbolsCache[language] = {};
      }
      symbolsCache[language].weekdays = weekdays;
      return weekdays;
    }

    // languageOverride is only used in the tests
    function getMonthNames(languageOverride) {
      const language = languageOverride || salesforceLanguage__default.default;
      const languageDataCache = symbolsCache[language];
      if (languageDataCache && languageDataCache.months) {
        return languageDataCache.months;
      }
      const intlLocales = [language, ...FALLBACK_LOCALES];
      const monthNameFormatter = new Intl.DateTimeFormat(intlLocales, {
        month: 'long'
      });
      const months = [];
      for (let i = 0; i <= 11; i++) {
        const date = new Date(1970, i, 4);
        months.push({
          // we currently only need the fullName
          fullName: format(monthNameFormatter, date)
        });
      }
      if (!symbolsCache[language]) {
        symbolsCache[language] = {};
      }
      symbolsCache[language].months = months;
      return months;
    }
    function format(dateTimeFormat, date) {
      const formattedDate = dateTimeFormat.format(date);
      return removeIE11Markers(formattedDate);
    }
    function removeIE11Markers(formattedString) {
      // IE11 adds LTR / RTL mark in the formatted date time string
      return formattedString.replace(/[\u200E\u200F]/g, '');
    }

    exports.addressFormat = address;
    exports.dateTimeFormat = dateTimeFormat;
    exports.formatDate = formatDate;
    exports.formatDateTimeUTC = formatDateTimeUTC;
    exports.formatDateUTC = formatDateUTC;
    exports.formatTime = formatTime;
    exports.fromLocalizedDigits = fromLocalizedDigits;
    exports.fromOtherCalendar = fromOtherCalendar;
    exports.getCurrentDateString = getCurrentDateString;
    exports.getCurrentTimeString = getCurrentTimeString;
    exports.getDateFormatFromStyle = getDateFormatFromStyle;
    exports.getISODateString = getISODateString;
    exports.getISOTimeString = getISOTimeString;
    exports.getMonthNames = getMonthNames;
    exports.getNameOfWeekdays = getNameOfWeekdays;
    exports.getTimeFormatFromStyle = getTimeFormatFromStyle;
    exports.isAfter = isAfter;
    exports.isAuraL10NAvailable = isAuraL10NAvailable;
    exports.isBefore = isBefore;
    exports.nameFormat = name;
    exports.normalizeFormattedDateTime = normalizeFormattedDateTime;
    exports.normalizeISODate = normalizeISODate;
    exports.normalizeISODateTime = normalizeISODateTime;
    exports.normalizeISOTime = normalizeISOTime;
    exports.numberFormat = numberFormat;
    exports.parseDateTime = parseDateTime;
    exports.parseDateTimeUTC = parseDateTimeUTC;
    exports.parseFormattedDate = parseFormattedDate;
    exports.parseFormattedTime = parseFormattedTime;
    exports.parseTime = parseTime;
    exports.relativeFormat = relativeFormat;
    exports.syncUTCToWallTime = syncUTCToWallTime;
    exports.syncWallTimeToUTC = syncWallTimeToUTC;
    exports.toDate = toDate;
    exports.toLocalizedDigits = toLocalizedDigits;
    exports.toOtherCalendar = toOtherCalendar;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/label/LightningErrorMessage.validityBadInput', ['@view/forgotPassword/labels'], m => m[22]);
LWR.define('@salesforce/label/LightningErrorMessage.validityBadNumericInput', ['@view/forgotPassword/labels'], m => m[23]);
LWR.define('@salesforce/label/LightningErrorMessage.validityBadEmailInput', ['@view/forgotPassword/labels'], m => m[24]);
LWR.define('@salesforce/label/LightningErrorMessage.validityPatternMismatch', ['@view/forgotPassword/labels'], m => m[25]);
LWR.define('@salesforce/label/LightningErrorMessage.validityRangeOverflow', ['@view/forgotPassword/labels'], m => m[26]);
LWR.define('@salesforce/label/LightningErrorMessage.validityRangeUnderflow', ['@view/forgotPassword/labels'], m => m[27]);
LWR.define('@salesforce/label/LightningErrorMessage.validityStepMismatch', ['@view/forgotPassword/labels'], m => m[28]);
LWR.define('@salesforce/label/LightningErrorMessage.validityTooLong', ['@view/forgotPassword/labels'], m => m[29]);
LWR.define('@salesforce/label/LightningErrorMessage.validityTooShort', ['@view/forgotPassword/labels'], m => m[30]);
LWR.define('@salesforce/label/LightningErrorMessage.validityTypeMismatch', ['@view/forgotPassword/labels'], m => m[31]);
LWR.define('@salesforce/label/LightningErrorMessage.validityValueMissing', ['@view/forgotPassword/labels'], m => m[32]);
LWR.define('@salesforce/label/LightningErrorMessage.validitySelectAtleastOne', ['@view/forgotPassword/labels'], m => m[33]);
(function() { LWR.define('lightning/inputUtils', ['exports', 'lightning/utilsPrivate', '@salesforce/label/LightningErrorMessage.validityBadInput', '@salesforce/label/LightningErrorMessage.validityBadNumericInput', '@salesforce/label/LightningErrorMessage.validityBadEmailInput', '@salesforce/label/LightningErrorMessage.validityPatternMismatch', '@salesforce/label/LightningErrorMessage.validityRangeOverflow', '@salesforce/label/LightningErrorMessage.validityRangeUnderflow', '@salesforce/label/LightningErrorMessage.validityStepMismatch', '@salesforce/label/LightningErrorMessage.validityTooLong', '@salesforce/label/LightningErrorMessage.validityTooShort', '@salesforce/label/LightningErrorMessage.validityTypeMismatch', '@salesforce/label/LightningErrorMessage.validityValueMissing', '@salesforce/label/LightningErrorMessage.validitySelectAtleastOne'], (function (exports, utilsPrivate, labelBadInput, labelBadNumericInput, labelBadEmailInput, labelPatternMismatch, labelRangeOverflow, labelRangeUnderflow, labelStepMismatch, labelTooLong, labelTooShort, labelTypeMismatch, labelValueMissing, labelSelectAtleastOneValue) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var labelBadInput__default = /*#__PURE__*/_interopDefaultCompat(labelBadInput);
    var labelBadNumericInput__default = /*#__PURE__*/_interopDefaultCompat(labelBadNumericInput);
    var labelBadEmailInput__default = /*#__PURE__*/_interopDefaultCompat(labelBadEmailInput);
    var labelPatternMismatch__default = /*#__PURE__*/_interopDefaultCompat(labelPatternMismatch);
    var labelRangeOverflow__default = /*#__PURE__*/_interopDefaultCompat(labelRangeOverflow);
    var labelRangeUnderflow__default = /*#__PURE__*/_interopDefaultCompat(labelRangeUnderflow);
    var labelStepMismatch__default = /*#__PURE__*/_interopDefaultCompat(labelStepMismatch);
    var labelTooLong__default = /*#__PURE__*/_interopDefaultCompat(labelTooLong);
    var labelTooShort__default = /*#__PURE__*/_interopDefaultCompat(labelTooShort);
    var labelTypeMismatch__default = /*#__PURE__*/_interopDefaultCompat(labelTypeMismatch);
    var labelValueMissing__default = /*#__PURE__*/_interopDefaultCompat(labelValueMissing);
    var labelSelectAtleastOneValue__default = /*#__PURE__*/_interopDefaultCompat(labelSelectAtleastOneValue);

    let idCounter = 0;
    function generateUniqueId(prefix = 'input') {
      idCounter++;
      return `${prefix}-${idCounter}`;
    }

    /**
     Represents an object which keeps track of a user's interacting state.
     @constructor InteractingState
     @param {Object} options - The options object.
     @param {Object} [options.duration=2000] - The number of milliseconds of idle time to wait before exiting the interacting state.
     @param {Object} [options.debounceInteraction=false] - Whether to debounce interaction to ignore consecutive leave-enter interactions.
     **/
    class InteractingState {
      constructor(options) {
        const duration = options && options.duration >= 0 ? options.duration : 2000;
        this.eventemitter = new utilsPrivate.EventEmitter();
        this._interacting = false;
        this._debouncedLeave = debounce(this.leave.bind(this), duration);
        this._debounceInteraction = options && options.debounceInteraction;
        this._interactedRecently = false;
        if (this._debounceInteraction) {
          // debounce leave until a short time later
          this._debouncedEmitLeave = debounce(() => {
            if (!this._interacting) {
              this._interactedRecently = false;
              this.eventemitter.emit('leave');
            }
          }, 200);
          // debounce enter until left
          this._debouncedEmitEnter = () => {
            if (!this._interactedRecently) {
              this._interactedRecently = true;
              this.eventemitter.emit('enter');
            }
          };
        }
      }

      /**
       Checks whether or not we are in the interacting state.
       @method InteractingState#isInteracting
       @return {Boolean} - Whether or not we are interacting.
       **/
      isInteracting() {
        return this._interacting;
      }

      /**
       Enters the interacting state.
       @method InteractingState#enter
       @returns {void}
       **/
      enter() {
        if (!this._interacting) {
          this._interacting = true;
          if (this._debounceInteraction) {
            this._debouncedEmitEnter();
          } else {
            this.eventemitter.emit('enter');
          }
        }
      }

      /**
       Registers a handler to execute when we enter the interacting state.
       @method InteractingState#onenter
       @param {Function} handler - The callback function.
       **/
      onenter(handler) {
        this.eventemitter.on('enter', handler);
      }

      /**
       Leaves the interacting state.
       @method InteractingState#leave
       @returns {void}
       **/
      leave() {
        if (this._interacting) {
          this._interacting = false;
          if (this._debounceInteraction) {
            this._debouncedEmitLeave();
          } else {
            this.eventemitter.emit('leave');
          }
        }
      }

      /**
       Registers a handler to execute when we leave the interacting state.
       @method InteractingState#onleave
       @param {Function} handler - The callback function.
       **/
      onleave(handler) {
        this.eventemitter.on('leave', handler);
      }

      /**
       Signals the start of the transition into the interacting state and
       schedules a transition out of the interacting state after an idle
       duration. Calling this method multiple times will reset the timer.
       @method InteractingState#interacting
       @returns {void}
       **/
      interacting() {
        this.enter();
        this._debouncedLeave();
      }
    }

    /**
     Creates a debounced function that delays invoking `func` until after
     `delay` milliseconds have elapsed since the last time the debounced
     function was invoked.
     @function debounce
     @param {Function} func - The function to debounce
     @param {Number} delay - The number of milliseconds to delay
     @param {Object} options - The options object
     @param {Boolean} options.leading - Specify invoking on the leading edge of the timeout
     @return {Function} - debounced function
     **/
    function debounce(func, delay, options) {
      const _options = options || {};
      let invokeLeading = _options.leading;
      let timer;
      return function debounced() {
        const args = Array.prototype.slice.apply(arguments);
        if (invokeLeading) {
          func.apply(this, args);
          invokeLeading = false;
        }
        clearTimeout(timer);
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        timer = setTimeout(function () {
          func.apply(this, args);
          invokeLeading = _options.leading; // reset for next debounce sequence
        }, delay);
      };
    }

    const constraintsSortedByPriority = ['customError', 'badInput', 'badNumericInput', 'badEmailInput', 'patternMismatch', 'rangeOverflow', 'rangeUnderflow', 'stepMismatch', 'tooLong', 'tooShort', 'typeMismatch', 'valueMissing', 'selectAtleastOneValue'];
    const defaultLabels = {
      badInput: labelBadInput__default.default,
      customError: labelBadInput__default.default,
      badNumericInput: labelBadNumericInput__default.default,
      badEmailInput: labelBadEmailInput__default.default,
      patternMismatch: labelPatternMismatch__default.default,
      rangeOverflow: labelRangeOverflow__default.default,
      rangeUnderflow: labelRangeUnderflow__default.default,
      stepMismatch: labelStepMismatch__default.default,
      tooLong: labelTooLong__default.default,
      tooShort: labelTooShort__default.default,
      typeMismatch: labelTypeMismatch__default.default,
      valueMissing: labelValueMissing__default.default,
      selectAtleastOneValue: labelSelectAtleastOneValue__default.default
    };
    function resolveBestMatch(validity) {
      let validityState;
      if (validity && validity.valid === false) {
        validityState = 'badInput';
        constraintsSortedByPriority.some(stateName => {
          if (validity[stateName] === true) {
            validityState = stateName;
            return true;
          }
          return false;
        });
      }
      return validityState;
    }
    function computeConstraint(valueProvider, constraint) {
      const provider = valueProvider[constraint];
      if (typeof provider === 'function') {
        return provider();
      }
      if (typeof provider === 'boolean') {
        return provider;
      }
      return false;
    }

    // We're doing the below to avoid exposing the constraintsProvider in the ValidityState
    function newValidityState(constraintsProvider) {
      class ValidityState {
        get valueMissing() {
          return computeConstraint(constraintsProvider, 'valueMissing');
        }
        get typeMismatch() {
          return computeConstraint(constraintsProvider, 'typeMismatch');
        }
        get patternMismatch() {
          return computeConstraint(constraintsProvider, 'patternMismatch');
        }
        get tooLong() {
          return computeConstraint(constraintsProvider, 'tooLong');
        }
        get tooShort() {
          return computeConstraint(constraintsProvider, 'tooShort');
        }
        get rangeUnderflow() {
          return computeConstraint(constraintsProvider, 'rangeUnderflow');
        }
        get rangeOverflow() {
          return computeConstraint(constraintsProvider, 'rangeOverflow');
        }
        get stepMismatch() {
          return computeConstraint(constraintsProvider, 'stepMismatch');
        }
        get customError() {
          return computeConstraint(constraintsProvider, 'customError');
        }
        get badInput() {
          return computeConstraint(constraintsProvider, 'badInput');
        }
        get badNumericInput() {
          return computeConstraint(constraintsProvider, 'badNumericInput');
        }
        get badEmailInput() {
          return computeConstraint(constraintsProvider, 'badEmailInput');
        }
        get selectAtleastOneValue() {
          return computeConstraint(constraintsProvider, 'validitySelectAtleastOneValue');
        }
        get valid() {
          return !(this.valueMissing || this.typeMismatch || this.patternMismatch || this.tooLong || this.tooShort || this.rangeUnderflow || this.rangeOverflow || this.stepMismatch || this.customError || this.badInput || this.badNumericInput || this.badEmailInput || this.selectAtleastOneValue);
        }
      }
      return new ValidityState();
    }
    function buildSyntheticValidity(constraintProvider) {
      return Object.freeze(newValidityState(constraintProvider));
    }
    function getErrorMessage(validity, labelMap) {
      const key = resolveBestMatch(validity);
      if (key) {
        return labelMap[key] ? labelMap[key] : defaultLabels[key];
      }
      return '';
    }
    class FieldConstraintApi {
      constructor(inputComponentProvider, constraintProviders) {
        utilsPrivate.assert(typeof inputComponentProvider === 'function');
        this._inputComponentProvider = inputComponentProvider;
        this._constraintsProvider = Object.assign({}, constraintProviders);
        if (!this._constraintsProvider.customError) {
          this._constraintsProvider.customError = () => typeof this._customValidityMessage === 'string' && this._customValidityMessage !== '';
        }
      }
      get validity() {
        if (!this._constraint) {
          this._constraint = buildSyntheticValidity(this._constraintsProvider);
        }
        return this._constraint;
      }
      checkValidity() {
        const isValid = this.validity.valid;
        if (!isValid) {
          if (this.inputComponent) {
            this.inputComponent.dispatchEvent(new CustomEvent('invalid', {
              cancellable: true
            }));
          }
        }
        return isValid;
      }
      reportValidity(callback) {
        const valid = this.checkValidity();

        // the input might have been removed from the DOM by the time we query it
        if (this.inputComponent) {
          this.inputComponent.classList.toggle('slds-has-error', !valid);
          utilsPrivate.reflectAttribute(this.inputComponent, 'invalid', !valid);
          if (callback) {
            callback(this.validationMessage);
          }
        }
        return valid;
      }
      setCustomValidity(message) {
        this._customValidityMessage = message;
      }
      get validationMessage() {
        return getErrorMessage(this.validity, {
          customError: this._customValidityMessage,
          badInput: this.inputComponent.messageWhenBadInput,
          badNumericInput: this.inputComponent.messageWhenBadInput,
          badEmailInput: this.inputComponent.messageWhenTypeMismatch,
          patternMismatch: this.inputComponent.messageWhenPatternMismatch,
          rangeOverflow: this.inputComponent.messageWhenRangeOverflow,
          rangeUnderflow: this.inputComponent.messageWhenRangeUnderflow,
          stepMismatch: this.inputComponent.messageWhenStepMismatch,
          tooShort: this.inputComponent.messageWhenTooShort,
          tooLong: this.inputComponent.messageWhenTooLong,
          typeMismatch: this.inputComponent.messageWhenTypeMismatch,
          valueMissing: this.inputComponent.messageWhenValueMissing,
          selectAtleastOneValue: this.inputComponent.messageWhenValueMissing
        });
      }
      get inputComponent() {
        if (!this._inputComponentElement) {
          this._inputComponentElement = this._inputComponentProvider();
        }
        return this._inputComponentElement;
      }
    }
    class FieldConstraintApiWithProxyInput {
      constructor(inputComponent, overrides = {}, inputElementName = 'input') {
        this._inputComponent = inputComponent;
        this._overrides = overrides;
        this._proxyInput = document.createElement(inputElementName);
      }
      setInputAttributes(attributes) {
        this._attributes = attributes;
        this._attributeUpdater = attributeNames => {
          if (!attributes) {
            return;
          }
          if (typeof attributeNames === 'string') {
            this._setAttribute(attributeNames, attributes[attributeNames]());
          } else {
            attributeNames.forEach(attributeName => {
              this._setAttribute(attributeName, attributes[attributeName]());
            });
          }
        };
        return this._attributeUpdater;
      }
      get validity() {
        return this._constraintApi.validity;
      }
      checkValidity() {
        return this._constraintApi.checkValidity();
      }
      reportValidity(callback) {
        return this._constraintApi.reportValidity(callback);
      }
      setCustomValidity(message) {
        this._constraintApi.setCustomValidity(message);
        this._proxyInput.setCustomValidity(message);
      }
      get validationMessage() {
        return this._constraintApi.validationMessage;
      }
      _setAttribute(attributeName, value) {
        if (value !== null && value !== undefined && value !== false) {
          if (attributeName === 'value') {
            if (this._proxyInput.type === 'file') {
              // Can't set value on file
              return;
            }
            this._proxyInput.value = value;
          } else {
            this._proxyInput.setAttribute(attributeName, value);
          }
        } else {
          this._removeAttribute(attributeName);
        }
      }
      _removeAttribute(attributeName) {
        this._proxyInput.removeAttribute(attributeName);
      }
      get _constraintApi() {
        if (!this._privateConstraintApi) {
          this._updateAllAttributes();
          const computeConstraintWithProxyInput = constraintName => {
            const constraintOverride = this._overrides[constraintName];
            const isDisabledOrReadOnly = this._proxyInput.hasAttribute('disabled') || this._proxyInput.hasAttribute('readonly');
            if (typeof constraintOverride === 'function') {
              return !isDisabledOrReadOnly && constraintOverride();
            }

            // Firefox incorrectly computes rangeUnderflow for disabled and readonly inputs, so we're adding
            // a check here instead to always return false when the input has readonly or disabled attributes set
            return !isDisabledOrReadOnly && this._proxyInput.validity[constraintName];
          };
          const constraintsProvider = constraintsSortedByPriority.reduce((provider, constraint) => {
            provider[constraint] = computeConstraintWithProxyInput.bind(this, constraint);
            return provider;
          }, {});
          this._privateConstraintApi = new FieldConstraintApi(this._inputComponent, constraintsProvider);
        }
        return this._privateConstraintApi;
      }
      _updateAllAttributes() {
        if (this._attributes) {
          Object.entries(this._attributes).forEach(([key, valueFunction]) => {
            this._setAttribute(key, valueFunction());
          });
        }
      }
    }

    const VARIANT = {
      STANDARD: 'standard',
      LABEL_HIDDEN: 'label-hidden',
      LABEL_STACKED: 'label-stacked',
      LABEL_INLINE: 'label-inline'
    };

    /**
    A variant normalization utility for attributes.
    @param {Any} value - The value to normalize.
    @return {Boolean} - The normalized value.
    **/
    function normalizeVariant(value) {
      return utilsPrivate.normalizeString(value, {
        fallbackValue: VARIANT.STANDARD,
        validValues: [VARIANT.STANDARD, VARIANT.LABEL_HIDDEN, VARIANT.LABEL_STACKED, VARIANT.LABEL_INLINE]
      });
    }
    function normalizeInput(value) {
      if (typeof value === 'number' || typeof value === 'string') {
        return String(value);
      }
      return '';
    }

    /**
     * Validate email with loose standards.
     * @param {string} value Value must be a string.
     */
    function isValidEmail(value) {
      // Input treats all data types as string
      const normalized = `${value}`;
      // Empty is not a typeMismatch
      if (normalized === '') {
        return true;
      }
      // Only one @ symbol allowed as delimitator
      if (normalized.match(/@\S*@/) !== null) {
        return false;
      }
      // Spaces and Commas are not allowed
      if (normalized.match(/[\s,]+/) !== null) {
        return false;
      }
      // Basic let anything with content before/after an @
      return normalized.match(/^\S+@\S+$/) !== null;
    }

    /**
     * Validate comma deliminated emails with loose standards.
     * @param {string} value Value must be a string.
     */
    function isValidMultipleEmails(value) {
      // Input treats all data types as string
      const normalized = `${value}`;
      // Empty is not a typeMismatch
      if (normalized === '') {
        return true;
      }
      // Invalid early on multiple commas / empty
      if (normalized.match(/,\s*,/) !== null) {
        return false;
      }
      // Validate each email individually
      const emails = normalized.split(/\s*,\s*/g);
      for (let i = 0; i < emails.length; i++) {
        if (!isValidEmail(emails[i])) {
          return false;
        }
      }
      return true;
    }

    function isEmptyString(s) {
      return s === undefined || s === null || typeof s === 'string' && s.trim() === '';
    }
    function isEmptyObject(obj) {
      if (obj === undefined || obj === null || typeof obj !== 'object') {
        return false;
      }
      // eslint-disable-next-line guard-for-in
      for (const name in obj) {
        return false;
      }
      return true;
    }

    exports.FieldConstraintApi = FieldConstraintApi;
    exports.FieldConstraintApiWithProxyInput = FieldConstraintApiWithProxyInput;
    exports.InteractingState = InteractingState;
    exports.VARIANT = VARIANT;
    exports.buildSyntheticValidity = buildSyntheticValidity;
    exports.debounce = debounce;
    exports.generateUniqueId = generateUniqueId;
    exports.getErrorMessage = getErrorMessage;
    exports.isEmptyObject = isEmptyObject;
    exports.isEmptyString = isEmptyString;
    exports.isValidEmail = isValidEmail;
    exports.isValidMultipleEmails = isValidMultipleEmails;
    exports.normalizeInput = normalizeInput;
    exports.normalizeVariant = normalizeVariant;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/label/LightningDateTimePicker.invalidDate', ['@view/forgotPassword/labels'], m => m[34]);
LWR.define('@salesforce/label/LightningDateTimePicker.minRangeMessage', ['@view/forgotPassword/labels'], m => m[35]);
LWR.define('@salesforce/label/LightningDateTimePicker.maxRangeMessage', ['@view/forgotPassword/labels'], m => m[36]);
LWR.define('@salesforce/label/LightningDateTimePicker.minAndMaxRangeMessage', ['@view/forgotPassword/labels'], m => m[37]);
LWR.define('@salesforce/label/LightningDateTimePicker.selectDateFor', ['@view/forgotPassword/labels'], m => m[38]);
LWR.define('@salesforce/label/LightningDateTimePicker.ariaLabelMonth', ['@view/forgotPassword/labels'], m => m[39]);
LWR.define('@salesforce/label/LightningDateTimePicker.nextMonth', ['@view/forgotPassword/labels'], m => m[40]);
LWR.define('@salesforce/label/LightningDateTimePicker.previousMonth', ['@view/forgotPassword/labels'], m => m[41]);
LWR.define('@salesforce/label/LightningDateTimePicker.today', ['@view/forgotPassword/labels'], m => m[42]);
LWR.define('@salesforce/label/LightningDateTimePicker.yearSelector', ['@view/forgotPassword/labels'], m => m[43]);
LWR.define('@salesforce/i18n/firstDayOfWeek', [], function() { return 1; });
(function() { LWR.define('@salesforce/i18n/showJapaneseCalendar', ['exports'], (function (exports) {

	var _4sel6rcpm4e39q9u81k56r23265m2ef64vaok1e = false;

	exports.default = _4sel6rcpm4e39q9u81k56r23265m2ef64vaok1e;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/focusUtils', ['exports', 'lightning/tooltipLibrary'], (function (exports, tooltipLibrary) {

    const IGNORE_AUTOFOCUS = 'ignore-autofocus';
    /**
     *
     * Returns all tabbable elements within a containing element. Tabbable elements are:
     * a visible/non-disabled element that has a tabIndex of 0 and is not within a custom
     * element with tabindex attribute of “-1" on it.
     *
     * @param {Element} container The element to search for tabbable element.
     * @returns {Array} Tabbable elements.
     */
    function findAllTabbableElements(container) {
      const result = [];
      traverseActiveTreeRecursively(container, element => {
        // Remove the try/catch once https://github.com/salesforce/lwc/issues/1421 is fixed
        try {
          if (isTabbable({
            element,
            rootContainer: container
          })) {
            result.push(element);
          }
        } catch (e) {
          console.warn(e);
        }
      });
      return result;
    }
    const FOCUSABLE_NODES = /^input$|^select$|^textarea$|^a$|^button$/;

    /**
     * Returns all focusable nodes within a containing element. Focusable nodes are
     * those which have a focus() method specified in the object definition spec:
     * https://www.w3.org/TR/DOM-Level-2-HTML/html.html
     *
     * Exception: button - Browsers today allow setting focus programmatically
     * on button elements + autofocus attribute present on HTMLButtonElement
     *
     * @param {Element} container The element to search for focusable nodes.
     * @returns {Array} Focusable elements.
     */
    function findAllFocusableNodes(container) {
      const result = [];
      traverseActiveTreeRecursively(container, element => {
        if (FOCUSABLE_NODES.test(element.tagName.toLowerCase())) {
          result.push(element);
        }
      });
      return result;
    }

    /**
     * Finds the element that currently has focus, even when the element is part of a shadow root or iframe.
     *
     * @returns {Element} Element that has focus.
     */
    function getElementWithFocus() {
      let currentFocusedElement = document.activeElement;
      while (currentFocusedElement) {
        if (currentFocusedElement.shadowRoot) {
          let nextFocusedElement = currentFocusedElement.shadowRoot.activeElement;
          if (nextFocusedElement) {
            currentFocusedElement = nextFocusedElement;
          } else {
            return currentFocusedElement;
          }
        } else if (currentFocusedElement.contentDocument) {
          let nextFocusedElement = currentFocusedElement.contentDocument.activeElement;
          if (nextFocusedElement) {
            currentFocusedElement = nextFocusedElement;
          } else {
            return currentFocusedElement;
          }
        } else {
          return currentFocusedElement;
        }
      }
      return undefined;
    }

    /**
     * Return the focus to an element if it is still attached to the DOM.
     * @param {Element} element - element which will receive the focus.
     * @returns {boolean} - true if the element is focused.
     */
    function returnFocusToElement(element) {
      const isSavedElemInDOM = document.body.contains(element);
      if (element) {
        if (isSavedElemInDOM) {
          element.focus();
          return true;
        }
        const isElementInDOM = isElementInDocument(element);
        if (isElementInDOM) {
          element.focus();
          return true;
        }
      }
      return false;
    }

    /**
     * Return true if the given element is in document (rather it is in shadow or not)
     * @param {Element} element - element to be inspected
     * @returns {boolean} - true if the element is in document, otherwise false
     */
    function isElementInDocument(element) {
      let currentElement = element;
      // traverse all the way up to the document, to make sure
      // the element is inside of the document.
      while (currentElement && currentElement.parentNode) {
        if (currentElement.parentNode === document) {
          return true;
        } else if (currentElement.parentNode instanceof DocumentFragment) {
          currentElement = currentElement.parentNode.host;
        } else {
          currentElement = currentElement.parentNode;
        }
      }
      return false;
    }

    /**
     * Recursively traverse an active tree and run callback on each non-inert node element.
     *
     * @param {Node} node The starting node to recursively traverse.
     * @param {Function} callback Function to call on each node element.
     */
    function traverseActiveTreeRecursively(node, callback) {
      if (!node) {
        return;
      }
      if (node.nodeType === Node.ELEMENT_NODE) {
        // inert is only supported by Chrome for now (behind a flag)
        if (node.hasAttribute('inert')) {
          return;
        }
        if (isIframe(node)) {
          if (isIframeOfSameOrigin(node)) {
            // for a same-origin iframe, we don't want to include the
            // iframe itself in the list, since we can see any of the
            // frames focusable children. So, skip calling callback on
            // the iframe node, and proceed to traverse it's children.
            traverseActiveTreeRecursively(node.contentDocument, callback);
          } else {
            // a non same-origin iframe is totally opaque, so include the
            // iframe in the results, but do no try to traverse into the
            // iframes children
            if (callback) {
              callback(node);
            }
          }
          return;
        }
        if (callback) {
          callback(node);
        }
        // If the element has a shadow root, traverse that
        if (node.shadowRoot) {
          traverseActiveTreeRecursively(node.shadowRoot, callback);
          return;
        }
        // if it's a slot element, get all assigned nodes and traverse them
        if (node.localName === 'slot') {
          const slottedNodes = node.assignedNodes({
            flatten: true
          });
          for (let i = 0; i < slottedNodes.length; i++) {
            traverseActiveTreeRecursively(slottedNodes[i], callback);
          }
          return;
        }
      }
      let child = node.firstChild;
      while (child !== null) {
        traverseActiveTreeRecursively(child, callback);
        child = child.nextSibling;
      }
    }

    // returns true if iframe is same origin, and therefore, can focus its internal elements
    function isIframe(node) {
      return node.tagName === 'IFRAME' || node instanceof HTMLIFrameElement;
    }
    function isIframeOfSameOrigin(iframe) {
      // if we can access contentDocument (is not null) on the iframe, then it is of same origin
      return !!iframe.contentDocument;
    }
    const ELEMENTS_WITH_DISABLED_ATTRIBUTE = ['button', 'select', 'textarea', 'input'];

    // https://html.spec.whatwg.org/multipage/interaction.html#dom-tabindex
    const ELEMENTS_WITH_TABINDEX_ZERO_BY_DEFAULT = ['a', 'select', 'textarea', 'input', 'button', 'iframe', 'object', 'area', 'frame'];
    function isTabbable({
      element,
      rootContainer
    }) {
      const elementLocalName = element.localName;
      if (elementLocalName === 'input' && elementLocalName.type === 'hidden') {
        return false;
      }
      const tabIndexAttribute = element.getAttribute('tabindex');
      if (tabIndexAttribute === '-1') {
        return false;
      }
      if (element.disabled && ELEMENTS_WITH_DISABLED_ATTRIBUTE.includes(element.localName)) {
        return false;
      }

      // Either the attribute was set directly to '0' or it's an element that has tabIndex zero by default
      const hasTabIndexZero = tabIndexAttribute === '0' || element.tabIndex === 0 && ELEMENTS_WITH_TABINDEX_ZERO_BY_DEFAULT.includes(element.localName);
      return hasTabIndexZero && isElementVisible(element) && isParentCustomElementTabbable({
        element,
        rootContainer
      });
    }

    /**
     * Test if element has role='tooltip'
     * @param {Element} Element that has focus.
     * @returns {boolean} element has role='tooltip'
     */
    const elemHasRoleTooltip = elem => {
      return elem.getAttribute('role') === 'tooltip';
    };

    /**
     * Test if the element has class='ignore-autofocus'
     * @param {Element} Element that has focus.
     * @returns {boolean} element has class='ignore-autofocus'
     */
    const elemHasIgnoreAutofocus = elem => {
      return elem.classList.contains(IGNORE_AUTOFOCUS);
    };

    /**
     * Test if element has unique properties of <lightning-helptext>
     * @param {Element} Element that needs to be tested
     * @returns {boolean} element matches criteria of <lightning-helptext>
     */
    const elemIsHelpTextComponent = elem => {
      // properties of <lightning-helptext>
      const tagNameIsButton = elem.tagName.toLowerCase() === 'button';
      const ariaDescValue = elem.getAttribute('aria-describedby');
      // ie11 doesn't support .startsWith()
      const ariaValueMatchesPrefix = ariaDescValue ? String(ariaDescValue).indexOf(tooltipLibrary.BUBBLE_PREFIX) === 0 : false;
      return tagNameIsButton && ariaValueMatchesPrefix;
    };

    /**
     * Verify element doesn't have tooltip properties by running tooltip tests
     * Primary use in autofocus feature of LighningModal
     * @param {Element} Element to verify is not a tooltip
     * @returns {boolean} element is not a tooltip
     */
    const elemIsNotTooltip = elem => {
      if (!elem) {
        return false;
      }
      // evaluate whether element has properties of a tooltip
      // if any tooltip test is true, the element is a tooltip
      const elemIsTooltip = [
      // array of tooltip tests
      elemHasRoleTooltip(elem), elemIsHelpTextComponent(elem), elemHasIgnoreAutofocus(elem)].some(val => val === true);
      return !elemIsTooltip;
    };

    /**
     *
     * Returns tabbable elements, filtered to remove any tooltips
     * @param {Array} elemsArray Array of elements to filter tooltips from
     * @returns {Array} Filtered tabbable elements with no tooltips
     */
    function filterTooltips(elemsArray) {
      // reference SLDS tooltip patterns && global focus in
      // modalBase focusFirstElement() -> used to autofocus first element
      // https://www.lightningdesignsystem.com/accessibility/patterns/tooltip/
      return elemsArray && Array.isArray(elemsArray) && elemsArray.length > 0 ? elemsArray.filter(elemIsNotTooltip) : [];
    }
    function isElementVisible(element) {
      const {
        width,
        height
      } = element.getBoundingClientRect();
      const nonZeroSize = width > 0 || height > 0;
      return nonZeroSize && getComputedStyle(element).visibility !== 'hidden';
    }
    function isParentCustomElementTabbable({
      element,
      rootContainer
    }) {
      const parentRoot = rootContainer.getRootNode();
      const ownerDocument = element.ownerDocument;
      let root = element.getRootNode();
      while (root !== parentRoot && root !== ownerDocument) {
        const host = root.host;
        if (host.getAttribute('tabindex') === '-1') {
          return false;
        }
        root = host && host.getRootNode();
      }
      return true;
    }

    exports.filterTooltips = filterTooltips;
    exports.findAllFocusableNodes = findAllFocusableNodes;
    exports.findAllTabbableElements = findAllTabbableElements;
    exports.getElementWithFocus = getElementWithFocus;
    exports.returnFocusToElement = returnFocusToElement;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/focusTrap', ['exports', 'lwc', 'lightning/shadowBaseClassPrivate', 'lightning/focusUtils'], (function (exports, lwc, LightningShadowBaseClass, focusUtils) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      return "div[data-start]" + shadowSelector + ",div[data-end]" + shadowSelector + " {position: fixed;top: 1rem;left: 1rem;}";
      /*LWC compiler v7.1.5*/
    }
    var _implicitStylesheets = [stylesheet];

    const $fragment1 = lwc.parseFragment`<div${"a0:tabindex"} data-start${3}></div>`;
    const $fragment2 = lwc.parseFragment`<div${"a0:tabindex"} data-end${3}></div>`;
    const stc0 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {ti: api_tab_index, b: api_bind, sp: api_static_part, st: api_static_fragment, s: api_slot} = $api;
      const {_m0, _m1, _m2, _m3, _m4, _m5} = $ctx;
      return [api_static_fragment($fragment1, 1, [api_static_part(0, {
        on: {
          "focus": _m1 || ($ctx._m1 = api_bind($cmp._focusLastElement))
        },
        attrs: {
          "tabindex": api_tab_index($cmp._bookendTabIndex)
        }
      }, null)]), api_slot("", {
        key: 2,
        on: {
          "focusin": _m2 || ($ctx._m2 = api_bind($cmp._handleFocusIn)),
          "focusout": _m3 || ($ctx._m3 = api_bind($cmp._handleFocusOut))
        }
      }, stc0, $slotset), api_static_fragment($fragment2, 4, [api_static_part(0, {
        on: {
          "focus": _m5 || ($ctx._m5 = api_bind($cmp._focusFirstElement))
        },
        attrs: {
          "tabindex": api_tab_index($cmp._bookendTabIndex)
        }
      }, null)])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = [""];
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-654o76jjrnk";
    tmpl.legacyStylesheetToken = "lightning-focusTrap_focusTrap";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    class FocusTrap extends LightningShadowBaseClass__default.default {
      constructor(...args) {
        super(...args);
        this._startNode = void 0;
        this._endNode = void 0;
        this._focused = false;
        this._initialized = false;
        this._pendingFocusOut = false;
      }
      renderedCallback() {
        if (!this._initialized) {
          this._initialized = true;
          this._startNode = this.template.querySelector('[data-start]');
          this._endNode = this.template.querySelector('[data-end]');
        }
      }

      /**
       * Focuses the first focusable element in the focus trap.
       */
      focus() {
        if (!this._focused) {
          // We could potentially add support for focusing the element that has 'autofocus' attribute on it,
          // and if none, then focus on the first element
          this._focusFirstElement();
        }
      }
      get _bookendTabIndex() {
        return this._focused ? '0' : '-1';
      }
      _handleFocusIn() {
        if (this._pendingFocusOut) {
          this._pendingFocusOut = false;
        }
        this._focused = true;
      }
      _handleFocusOut() {
        // This assumes that a focusin will be dispatched after a focusout
        this._pendingFocusOut = true;
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          if (this._pendingFocusOut) {
            this._focused = false;
          }
        });
      }

      /**
       * Focuses on the specified element location.
       * @param {String} elementLocation Could be 'first or 'last'.
       */
      _moveFocusTo(elementLocation) {
        const focusableElements = this._getFocusableElements();
        if (focusableElements.length > 0) {
          let node;
          if (elementLocation === 'last') {
            node = focusableElements[focusableElements.length - 1];
          } else if (elementLocation === 'first') {
            node = focusableElements[0];
          }
          node.focus();
        }
      }

      /**
       * Focuses the last focusable element in the focus trap.
       */
      _focusFirstElement() {
        this._moveFocusTo('first');
      }

      /**
       * Focuses the last focusable element in the focus trap.
       */
      _focusLastElement() {
        this._moveFocusTo('last');
      }

      /**
       * Returns a list of the focusable children found within the element.
       */
      _getFocusableElements() {
        return focusUtils.findAllTabbableElements(this.template.querySelector('slot'));
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(FocusTrap, {
      publicMethods: ["focus"],
      fields: ["_startNode", "_endNode", "_focused", "_initialized", "_pendingFocusOut"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(FocusTrap, {
      tmpl: _tmpl,
      sel: "lightning-focus-trap",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/select', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/helptext', '@salesforce/label/LightningControl.required', '@salesforce/label/LightningInput.helptextAlternativeText', 'lightning/shadowBaseClassPrivate', 'lightning/utils', 'lightning/utilsPrivate', 'lightning/inputUtils', 'lightning/ariaObserver'], (function (exports, lwc, stylesheet0$1, _lightningHelptext, labelRequired, labelHelpTextAlternativeText, LightningShadowBaseClass, utils, utilsPrivate, inputUtils, AriaObserver) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningHelptext__default = /*#__PURE__*/_interopDefaultCompat(_lightningHelptext);
  var labelRequired__default = /*#__PURE__*/_interopDefaultCompat(labelRequired);
  var labelHelpTextAlternativeText__default = /*#__PURE__*/_interopDefaultCompat(labelHelpTextAlternativeText);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);
  var AriaObserver__default = /*#__PURE__*/_interopDefaultCompat(AriaObserver);

  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) fieldset" : hostSelector + "[data-render-mode=\"shadow\"] fieldset")), shadowSelector, " {border: 0;margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {position: relative;min-width: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;hyphens: auto;display: inline-block;color: var(--slds-g-color-on-surface-2);font-size: var(--slds-s-label-font-size, var(--slds-g-font-scale-neg-2));padding-inline-end: var(--slds-g-spacing-2);padding-block-start: var(--slds-g-spacing-1);margin-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label:empty")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {clear: inline-start;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-radio", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {display: inline-block;position: relative;padding-block-start: var(--slds-g-spacing-1);vertical-align: top;line-height: var(--slds-g-font-lineheight-1);z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-form-element__helper" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__helper")), shadowSelector, " {font-size: var(--slds-s-helptext-font-size, var(--slds-g-font-scale-neg-2));margin-block-start: calc(var(--slds-g-spacing-1) / 2);display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_edit")), shadowSelector, " .slds-form-element__static", shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " {flex-basis: 0%;border-bottom: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__label", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__legend" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__legend")), shadowSelector, " {font-weight: var(--slds-g-font-weight-7);float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__addon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__addon")), shadowSelector, " {display: inline-block;margin-block-start: 0;margin-block-end: 0;margin-inline-start: var(--slds-g-spacing-2);margin-inline-end: var(--slds-g-spacing-2);align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;word-break: break-word;display: inline-block;font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-neutral-base-10);width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static.slds-text-longform" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static.slds-text-longform")), shadowSelector, " *:last-child", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static:empty")), shadowSelector, " {min-height: calc(var(--slds-g-sizing-6) + 1px);vertical-align: bottom;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static--edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static--edit")), shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-required" : hostSelector + "[data-render-mode=\"shadow\"] .slds-required")), shadowSelector, " {color: var(--slds-g-color-error-1);margin-block-start: 0;margin-block-end: 0;margin-inline-start: calc(var(--slds-g-spacing-1) / 2);margin-inline-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-form-element__help", shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-form-element__help" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) {" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {padding: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__label" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__label" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {width: 100%;flex-basis: 100%;clear: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__icon" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {float: none;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline'].slds-form-element_horizontal) {" : hostSelector + ".slds-form-element_horizontal[variant='label-inline'][data-render-mode=\"shadow\"] {")), "padding: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']).slds-is-edited {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"].slds-is-edited {")), "padding-block-start: var(--slds-g-sizing-6)}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__label" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {float: inline-start;max-width: calc(33% - var(--slds-g-sizing-6));flex-basis: calc(33% - var(--slds-g-sizing-6));flex-grow: 1;margin-block-end: 0;position: relative;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) lightning-helptext" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] lightning-helptext")), shadowSelector, " {float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {margin-inline-start: 33%;clear: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list__column" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list__column")), shadowSelector, " .slds-form-element__label", shadowSelector, " {width: auto;max-width: 100%;flex-basis: auto;float: none;position: relative;padding-inline-start: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__help" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list")), shadowSelector, " {clear: none;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " {display: flex;margin-bottom: var(--slds-g-spacing-1);margin-left: calc(var(--slds-g-spacing-1) * -1);margin-right: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " .slds-form-element__label", shadowSelector, " {padding-top: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element", shadowSelector, " {padding-left: var(--slds-g-spacing-1);padding-right: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_address" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_address")), shadowSelector, " .slds-form-element__row", shadowSelector, " {align-items: flex-end;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-hidden']) .slds-form-element__label" : hostSelector + "[variant='label-hidden'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {display: none}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet$1];

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='select']" : hostSelector + "[data-render-mode=\"shadow\"] [part='select']")) + shadowSelector + " {height: calc(var(--slds-c-select-input-sizing-height, 1.875rem) + (var(--slds-g-sizing-border-1) * 2));width: 100%;border: var(--slds-g-sizing-border-1) solid var(--slds-c-select-color-border, var(--slds-s-input-color-border, var(--slds-g-color-border-1)));border-radius: var(--slds-c-select-radius-border, var(--slds-g-radius-border-2));background-color: var(--slds-c-select-color-background,\n var(--slds-g-color-surface-container-1));color: var(--slds-c-select-text-color, currentcolor, var(--slds-g-color-on-surface-1));box-shadow: var(--slds-c-select-shadow);transition: border 0.1s linear, background-color 0.1s linear;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='select'][required]" : hostSelector + "[data-render-mode=\"shadow\"] [part='select'][required]")) + shadowSelector + " {box-shadow: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='select']:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='select']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part='select']:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='select']:active")) + shadowSelector + " {outline: 0;border-color: var(--slds-c-select-color-border-focus, var(--slds-g-color-border-2));background-color: var(--slds-c-select-color-background-focus, var(--slds-g-color-surface-container-1));color: var(--slds-c-select-text-color-focus);box-shadow: var(--slds-c-select-shadow-focus, 0 0 3px var(--slds-g-color-accent-2));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='select'][disabled]" : hostSelector + "[data-render-mode=\"shadow\"] [part='select'][disabled]")) + shadowSelector + " {background-color: var(--slds-g-color-disabled-container-1);border-color: var(--slds-g-color-border-disabled-1);color: var(--slds-g-color-on-disabled-1);cursor: not-allowed;user-select: none;opacity: 1;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='select'][disabled]:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='select'][disabled]:active" : hostSelector + "[data-render-mode=\"shadow\"] [part='select'][disabled]:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='select'][disabled]:active")) + shadowSelector + " {box-shadow: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='select'][size]" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='select'][multiple]" : hostSelector + "[data-render-mode=\"shadow\"] [part='select'][size]" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='select'][multiple]")) + shadowSelector + " {min-height: calc(var(--slds-c-select-input-sizing-height) + (var(--slds-g-sizing-border-1) * 2));height: inherit;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='select'][size]" + shadowSelector + " option" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='select'][multiple]" : hostSelector + "[data-render-mode=\"shadow\"] [part='select'][size]" + shadowSelector + " option" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='select'][multiple]")) + shadowSelector + " option" + shadowSelector + " {padding: var(--slds-g-spacing-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-select_container" : hostSelector + "[data-render-mode=\"shadow\"] .slds-select_container")) + shadowSelector + " {position: relative;color: var(--slds-c-select-container-color);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-select_container" : hostSelector + "[data-render-mode=\"shadow\"] .slds-select_container")) + shadowSelector + " [part=\"select\"]" + shadowSelector + " {-moz-appearance: none;-webkit-appearance: none;padding: 0 var(--slds-g-spacing-5) 0 var(--slds-g-spacing-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-select_container" : hostSelector + "[data-render-mode=\"shadow\"] .slds-select_container")) + shadowSelector + " [part=\"select\"]" + shadowSelector + "::-ms-expand {display: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-select_container" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-select_container" : hostSelector + "[data-render-mode=\"shadow\"] .slds-select_container" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-select_container")) + shadowSelector + "::after {position: absolute;content: '';display: block;right: var(--slds-g-spacing-2);width: 0;height: 0;border-left: 3px solid transparent;border-right: 3px solid transparent;pointer-events: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-select_container" : hostSelector + "[data-render-mode=\"shadow\"] .slds-select_container")) + shadowSelector + "::before {border-bottom: 5px solid currentcolor;top: calc((var(--slds-g-sizing-8) / 2) - 6px);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-select_container" : hostSelector + "[data-render-mode=\"shadow\"] .slds-select_container")) + shadowSelector + "::after {border-top: 5px solid currentcolor;bottom: calc((var(--slds-g-sizing-8) / 2) - 6px);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][multiple]) .slds-select_container" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][multiple]) .slds-select_container" : hostSelector + "[multiple][data-render-mode=\"shadow\"] .slds-select_container" + shadowSelector + "::before," + hostSelector + "[multiple][data-render-mode=\"shadow\"] .slds-select_container")) + shadowSelector + "::after {display: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part=\"select\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part=\"select\"]")) + shadowSelector + " {border-color: var(--slds-g-color-error-base-50);box-shadow: var(--slds-g-color-error-base-50) 0 0 0 var(--slds-g-sizing-border-1) inset;background-clip: padding-box;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part=\"select\"]:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"][invalid]) [part=\"select\"]:active" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part=\"select\"]:focus" + shadowSelector + "," + hostSelector + "[invalid][data-render-mode=\"shadow\"] [part=\"select\"]:active")) + shadowSelector + " {box-shadow: var(--slds-g-color-error-1) 0 0 0 var(--slds-g-sizing-border-1) inset, 0 0 3px var(--slds-g-color-border-error-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part=\"select-label\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part=\"select-label\"]")) + shadowSelector + " {padding-inline-end: var(--slds-g-spacing-2);color: var(--slds-c-select-label-color, var(--slds-g-color-on-surface-2));font-size: var(--slds-c-select-label-font-size, var(--slds-g-font-scale-neg-1));display: inline-flex;column-gap: 0.125rem;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")) + shadowSelector + " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet2 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1, stylesheet2];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<abbr class="slds-required${0}"${"a0:title"}${2}>*</abbr>`;
  const $fragment2 = lwc.parseFragment`<option disabled${"a0:value"}${3}>${"t1"}</option>`;
  const $fragment3 = lwc.parseFragment`<option${"a0:value"}${3}>${"t1"}</option>`;
  const $fragment4 = lwc.parseFragment`<div aria-live="assertive" class="slds-form-element__help${0}" data-help-message${"a0:id"}${2}>${"t1"}</div>`;
  const stc0 = {
    classMap: {
      "slds-form-element__control": true
    },
    key: 4
  };
  const stc1 = {
    classMap: {
      "slds-select_container": true
    },
    key: 5
  };
  const stc2 = {
    "slds-select": true
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {ncls: api_normalize_class_name, gid: api_scoped_id, sp: api_static_part, st: api_static_fragment, d: api_dynamic_text, t: api_text, h: api_element, c: api_custom_element, b: api_bind, k: api_key, i: api_iterator} = $api;
    const {_m0, _m1, _m2} = $ctx;
    return [api_element("label", {
      className: api_normalize_class_name($cmp.computedLabelClass),
      attrs: {
        "for": api_scoped_id("select"),
        "part": "select-label"
      },
      key: 0
    }, [$cmp.required ? api_static_fragment($fragment1, 2, [api_static_part(0, {
      attrs: {
        "title": $cmp.i18n.required
      }
    }, null)]) : null, api_text(api_dynamic_text($cmp.label))]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext__default.default, {
      props: {
        "content": $cmp.fieldLevelHelp,
        "alternativeText": $cmp.helptextAlternativeText
      },
      key: 3
    }) : null, api_element("div", stc0, [api_element("div", stc1, [api_element("select", {
      classMap: stc2,
      attrs: {
        "autocomplete": $cmp.autocomplete,
        "disabled": $cmp.disabled ? "" : null,
        "id": api_scoped_id("select"),
        "multiple": $cmp.multiple ? "" : null,
        "name": $cmp.name,
        "required": $cmp.required ? "" : null,
        "accesskey": $cmp.accessKey,
        "size": $cmp.size,
        "aria-invalid": $cmp.computedAriaInvalid,
        "part": "select"
      },
      key: 6,
      on: {
        "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
        "change": _m1 || ($ctx._m1 = api_bind($cmp.handleChange)),
        "focus": _m2 || ($ctx._m2 = api_bind($cmp.handleFocus))
      }
    }, api_iterator($cmp.options, function (option) {
      return [option.disabled ? api_static_fragment($fragment2, api_key(8, option.value), [api_static_part(0, {
        attrs: {
          "value": option.value
        }
      }, null), api_static_part(1, null, api_dynamic_text(option.label))]) : null, !option.disabled ? api_static_fragment($fragment3, api_key(10, option.value), [api_static_part(0, {
        attrs: {
          "value": option.value
        }
      }, null), api_static_part(1, null, api_dynamic_text(option.label))]) : null];
    }))])]), $cmp._helpMessage ? api_static_fragment($fragment4, 12, [api_static_part(0, {
      attrs: {
        "id": api_scoped_id("help-message")
      }
    }, null), api_static_part(1, null, api_dynamic_text($cmp._helpMessage))]) : null];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-4mmaihmbcge";
  tmpl.legacyStylesheetToken = "lightning-select_select";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  const i18n = {
    required: labelRequired__default.default,
    helpTextAlternativeText: labelHelpTextAlternativeText__default.default
  };
  class LightningSelect extends LightningShadowBaseClass__default.default {
    constructor() {
      super();
      /**
       * The text label for the component.
       * To hide the label but make it available to assistive technologies,
       * use the label-hidden variant.
       * @type {string}
       */
      this.label = void 0;
      /**
       * The identifier for the component.
       * @type {string}
       */
      this.name = void 0;
      /**
       * The error message that's displayed below the menu
       * when a user interacts with the menu but does not select an option.
       * @type {string}
       */
      this.messageWhenValueMissing = void 0;
      /**
       * A shortcut key that activates and focuses on the menu.
       * @type {string}
       */
      this.accessKey = void 0;
      /**
       * Reserved for internal use. Controls auto-filling of the field.
       * @type {string}
       */
      this.autocomplete = void 0;
      this._options = [];
      this._helpMessage = '';
      this._selectedValue = void 0;
      this._variant = void 0;
      this._required = false;
      this._disabled = false;
      this._multiple = false;
      this._fieldLevelHelp = void 0;
      this._size = void 0;
      this._ariaDescribedBy = '';
      this._ariaLabelledBy = '';
      this._helpMessageChanged = false;
      this.ariaObserver = null;
      this.ariaObserver = new AriaObserver__default.default(this);
      this._isNativeShadow = utilsPrivate.isNativeComponent(this);
    }
    connectedCallback() {
      super.connectedCallback();
      if (!this.ariaObserver) {
        this.ariaObserver = new AriaObserver__default.default(this);
      }
      this._connected = true;
      this.classList.add('slds-form-element');
      this.updateClassList();
      this.interactingState = new inputUtils.InteractingState();
      this.interactingState.onleave(() => this.reportValidity());
    }
    renderedCallback() {
      if (this.isConnected) {
        this.ariaObserver.sync(this._isNativeShadow);
      }
      if (!this._rendered) {
        this.connectAriaDescribedBy();
        this.connectAriaLabelledBy();
        this._rendered = true;
      }
      if (this.options && this._selectedValue !== undefined) {
        this.selectOptionsByValue(this._selectedValue);
      }
      // If the help message changed, the help message element needs to be (un)related
      if (this._helpMessageChanged) {
        this.connectAriaDescribedBy();
        this._helpMessageChanged = false;
      }
    }
    disconnectedCallback() {
      this._connected = false;
      if (this.ariaObserver && this.ariaObserver.disconnect) {
        this.ariaObserver.disconnect();
        this.ariaObserver = null;
      }
    }
    get computedAriaInvalid() {
      return !!this._helpMessage || undefined;
    }

    /**
     * Help text detailing the purpose and function of the menu of options.
     * The text is displayed in a tooltip above the menu.
     * @type {string}
     */
    get fieldLevelHelp() {
      return this._fieldLevelHelp;
    }
    set fieldLevelHelp(value) {
      this._fieldLevelHelp = value;
    }

    /**
     * The variant changes the appearance of the dropdown menu.
     * Accepted variants include standard, label-inline, label-hidden, and label-stacked.
     * This value defaults to standard, which displays the label above the dropdown menu.
     * label-hidden hides the label but make it available to assistive technology.
     * label-inline horizontally aligns the label and dropdown menu.
     * label-stacked places the label above the dropdown menu.
     * @type {string}
     */
    get variant() {
      return this._variant || inputUtils.VARIANT.STANDARD;
    }
    set variant(value) {
      this._variant = inputUtils.normalizeVariant(value);
      this.updateClassList();
      utilsPrivate.reflectAttribute(this, 'variant', this._variant);
    }

    /**
     * Specifies whether multiple options can be selected.
     * @type {boolean}
     * @default false
     */
    get multiple() {
      return this._multiple;
    }
    set multiple(value) {
      this._multiple = utilsPrivate.normalizeBoolean(value);
      utilsPrivate.reflectAttribute(this, 'multiple', this._multiple);
    }

    /**
     * The number of rows in the list that should be visible at one time.
     * Use this attribute with the multiple attribute.
     * @type {number}
     * @default 4
     */
    get size() {
      if (!this.multiple) {
        return null;
      }
      if (this._size === undefined) {
        return '4';
      }
      return this._size;
    }
    set size(newValue) {
      this._size = newValue;
    }

    /**
     * Specifies whether an option must be selected.
     * @type {boolean}
     * @default false
     */
    get required() {
      return this._required;
    }
    set required(value) {
      this._required = utilsPrivate.normalizeBoolean(value);
    }

    /**
     * Specifies whether the menu is disabled and users cannot interact with it.
     * @type {boolean}
     * @default false
     */
    get disabled() {
      return this._disabled;
    }
    set disabled(value) {
      this._disabled = utilsPrivate.normalizeBoolean(value);
    }

    /**
     * The value of the selected option.
     * If empty and a value is required, the component is in an invalid state.
     * @type {string}
     */
    get value() {
      return this._selectedValue;
    }
    set value(newValue) {
      this._selectedValue = newValue;
      if (this.isConnected) {
        this.selectOptionsByValue(newValue);
      }
    }

    /**
     * An array of menu options with key-value pairs for label and value.
     * @type {object}
     */
    get options() {
      return this._options;
    }
    set options(newValue) {
      this._options = newValue;
      if (this.isConnected && newValue) {
        this.selectOptionsByValue(this._selectedValue);
      }
    }

    /**
     * Aria Described by value on parent lighting-select
     * @type {string}
     */
    get ariaDescribedBy() {
      return this._ariaDescribedBy;
    }
    set ariaDescribedBy(elements) {
      this._ariaDescribedBy = elements;
      this.connectAriaDescribedBy();
    }
    /**
     * A space-separated list of element IDs that provide labels for the
     * aria-labelled-by value on parent lighting-select.
     * @type {string}
     */
    get ariaLabelledBy() {
      return this._ariaLabelledBy;
    }
    set ariaLabelledBy(references) {
      this._ariaLabelledBy = references;
      this.connectAriaLabelledBy();
    }
    updateClassList() {
      utilsPrivate.classListMutation(this.classList, {
        'slds-form-element_stacked': this.variant === inputUtils.VARIANT.LABEL_STACKED,
        'slds-form-element_horizontal': this.variant === inputUtils.VARIANT.LABEL_INLINE
      });
    }

    /**
     * Sets focus on the select element.
     */
    focus() {
      if (this.isConnected) {
        this.selectElement.focus();
      }
    }

    /**
     * Removes focus on from the select element.
     */
    blur() {
      if (this.isConnected) {
        this.selectElement.blur();
      }
    }

    /**
     * Represents the validity states that an element can be in, with respect to constraint validation.
     * @type {object}
     *
     */
    get validity() {
      return this._constraint.validity;
    }

    /**
     * Checks if the input is valid.
     * @returns {boolean} Indicates whether the element meets all constraint validations.
     */
    checkValidity() {
      return this._constraint.checkValidity();
    }

    /**
     * Sets a custom error message to be displayed when a form is submitted.
     * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
     */
    setCustomValidity(message) {
      this._constraint.setCustomValidity(message);
      this.customErrorMessage = message;
    }

    /**
     * Displays the error messages and returns false if the input is invalid.
     * If the input is valid, reportValidity() clears displayed error messages and returns true.
     * @returns {boolean} - The validity status of the input fields.
     */
    reportValidity() {
      return this._constraint.reportValidity(message => {
        this._helpMessage = message;
        this._helpMessageChanged = true;
      });
    }

    /**
     * Displays an error message on an invalid select field.
     * An invalid field fails at least one constraint validation
     * and returns false when checkValidity() is called.
     */
    showHelpMessageIfInvalid() {
      const validity = this.validity;
      if (validity.valid) {
        this._helpMessage = '';
        this.classList.remove('slds-has-error');
      } else {
        this.classList.add('slds-has-error');
        this._helpMessage = inputUtils.getErrorMessage(validity, {
          valueMissing: this.messageWhenValueMissing,
          customError: this.customErrorMessage
        });
        this._helpMessageChanged = true;
      }
    }
    get i18n() {
      return i18n;
    }
    get selectElement() {
      return this.template.querySelector('select');
    }
    get isLabelHidden() {
      return this.variant === inputUtils.VARIANT.LABEL_HIDDEN;
    }
    get computedLabelClass() {
      return utils.classSet('slds-form-element__label').add({
        'slds-assistive-text': this.isLabelHidden
      }).toString();
    }
    get _constraint() {
      if (!this._constraintApi) {
        this._constraintApi = new inputUtils.FieldConstraintApi(() => this, {
          valueMissing: () => {
            const isMultipleAndNoValue = this.multiple && (!this.value || this.value.length === 0);
            return !this.disabled && this.required && (inputUtils.isEmptyString(this.value) || isMultipleAndNoValue);
          }
        });
      }
      return this._constraintApi;
    }
    handleChange(event) {
      event.preventDefault();
      event.stopPropagation();
      this._selectedValue = this.getSelectedOptionValues();
      this.dispatchEvent(new CustomEvent('change', {
        bubbles: true,
        composed: true,
        detail: {
          value: this._selectedValue
        }
      }));
    }
    handleFocus() {
      this.interactingState.enter();
      this.dispatchEvent(new CustomEvent('focus'));
    }
    handleBlur() {
      this.interactingState.leave();
      this.dispatchEvent(new CustomEvent('blur'));
    }
    connectAriaDescribedBy() {
      if (utilsPrivate.isCSR) {
        this.ariaObserver.connect({
          targetSelector: 'select',
          attribute: 'aria-describedby',
          relatedNodeIds: this.ariaDescribedBy,
          relatedNodes: this.template.querySelector('[data-help-message]')
        });
      }
    }
    connectAriaLabelledBy() {
      if (utilsPrivate.isCSR) {
        this.ariaObserver.connect({
          targetSelector: 'select',
          attribute: 'aria-labelledby',
          relatedNodeIds: this.ariaLabelledBy
        });
      }
    }
    selectOptionsByValue(optionValue) {
      if (this.multiple) {
        if (Array.isArray(optionValue)) {
          const options = this.template.querySelectorAll('option');
          options.forEach(option => {
            option.selected = optionValue.includes(option.value);
          });
        }
      } else {
        this.selectElement.value = optionValue;
      }
    }
    getSelectedOptionValues() {
      if (this.multiple) {
        const options = this.template.querySelectorAll('option');
        return Array.prototype.reduce.call(options, (selectedValues, option) => {
          if (option.selected) {
            selectedValues.push(option.value);
          }
          return selectedValues;
        }, []);
      }
      return this.selectElement.value;
    }
    get helptextAlternativeText() {
      return utils.formatLabel(i18n.helpTextAlternativeText, this.label);
    }
    /*LWC compiler v7.1.5*/
  }
  LightningSelect.delegatesFocus = true;
  LightningSelect.validationOptOut = ['class'];
  lwc.registerDecorators(LightningSelect, {
    publicProps: {
      label: {
        config: 0
      },
      name: {
        config: 0
      },
      messageWhenValueMissing: {
        config: 0
      },
      accessKey: {
        config: 0
      },
      autocomplete: {
        config: 0
      },
      fieldLevelHelp: {
        config: 3
      },
      variant: {
        config: 3
      },
      multiple: {
        config: 3
      },
      size: {
        config: 3
      },
      required: {
        config: 3
      },
      disabled: {
        config: 3
      },
      value: {
        config: 3
      },
      options: {
        config: 3
      },
      ariaDescribedBy: {
        config: 3
      },
      ariaLabelledBy: {
        config: 3
      },
      validity: {
        config: 1
      }
    },
    publicMethods: ["focus", "blur", "checkValidity", "setCustomValidity", "reportValidity", "showHelpMessageIfInvalid"],
    track: {
      _options: 1
    },
    fields: ["_helpMessage", "_selectedValue", "_variant", "_required", "_disabled", "_multiple", "_fieldLevelHelp", "_size", "_ariaDescribedBy", "_ariaLabelledBy", "_helpMessageChanged", "ariaObserver"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningSelect, {
    tmpl: _tmpl,
    sel: "lightning-select",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/calendar', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/buttonIcon', 'lightning/select', 'lightning/focusTrap', '@salesforce/label/LightningDateTimePicker.ariaLabelMonth', '@salesforce/label/LightningDateTimePicker.nextMonth', '@salesforce/label/LightningDateTimePicker.previousMonth', '@salesforce/label/LightningDateTimePicker.today', '@salesforce/label/LightningDateTimePicker.yearSelector', 'lightning/shadowBaseClassPrivate', 'lightning/utils', 'lightning/utilsPrivate', 'lightning/inputUtils', '@salesforce/i18n/firstDayOfWeek', '@salesforce/i18n/lang', '@salesforce/i18n/showJapaneseCalendar', 'lightning/internationalizationLibrary', 'lightning/iso8601Utils'], (function (exports, lwc, stylesheet0$1, _lightningButtonIcon, _lightningSelect, _lightningFocusTrap, labelAriaLabelMonth, labelNextMonth, labelPreviousMonth, labelToday, labelYearSelector, LightningShadowBaseClass, utils, utilsPrivate, inputUtils, firstDayOfWeek, salesforceLanguage, showJapaneseCalendar, internationalizationLibrary, iso8601Utils) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
    var _lightningButtonIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningButtonIcon);
    var _lightningSelect__default = /*#__PURE__*/_interopDefaultCompat(_lightningSelect);
    var _lightningFocusTrap__default = /*#__PURE__*/_interopDefaultCompat(_lightningFocusTrap);
    var labelAriaLabelMonth__default = /*#__PURE__*/_interopDefaultCompat(labelAriaLabelMonth);
    var labelNextMonth__default = /*#__PURE__*/_interopDefaultCompat(labelNextMonth);
    var labelPreviousMonth__default = /*#__PURE__*/_interopDefaultCompat(labelPreviousMonth);
    var labelToday__default = /*#__PURE__*/_interopDefaultCompat(labelToday);
    var labelYearSelector__default = /*#__PURE__*/_interopDefaultCompat(labelYearSelector);
    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);
    var firstDayOfWeek__default = /*#__PURE__*/_interopDefaultCompat(firstDayOfWeek);
    var salesforceLanguage__default = /*#__PURE__*/_interopDefaultCompat(salesforceLanguage);
    var showJapaneseCalendar__default = /*#__PURE__*/_interopDefaultCompat(showJapaneseCalendar);

    function stylesheet$3(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      return (useNativeDirPseudoclass ? '' : '[dir="rtl"]') + " .slds-dropdown_left" + (useNativeDirPseudoclass ? ':dir(rtl)' : '') + shadowSelector + " {left: 0;right: auto;}";
      /*LWC compiler v7.1.5*/
    }
    var stylesheet0 = [stylesheet$3];

    function stylesheet$2(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top")), shadowSelector, "::after {box-shadow: -1px -1px 0 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: var(--slds-g-spacing-5);top: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, "::after {box-shadow: -1px -1px 0 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);left: auto;right: var(--slds-g-spacing-5);top: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-right: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, "::after {box-shadow: -1px -1px 0 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom")), shadowSelector, "::after {box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;bottom: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);left: var(--slds-g-spacing-5);top: 100%;margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, "::after {box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;inset: 100% auto calc((var(--slds-g-spacing-4) * 0.5) * -1) var(--slds-g-spacing-5);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-right: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, "::after {box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left")), shadowSelector, "::after {box-shadow: -1px 1px 2px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);top: var(--slds-g-spacing-5);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, "::after {box-shadow: -1px 1px 2px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);top: auto;bottom: var(--slds-g-spacing-4);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::before {margin-bottom: -1px;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::after {box-shadow: -1px 2px 3px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right")), shadowSelector, "::after {box-shadow: 1px -1px 2px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;right: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);top: var(--slds-g-spacing-5);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, "::after {box-shadow: 1px -1px 2px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;right: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);top: auto;bottom: var(--slds-g-spacing-4);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::before {margin-bottom: -1px;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::after {box-shadow: 2px -1px 3px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, "::after {left: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, "::after {left: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, "::after {right: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, "::after {right: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, "::after {top: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, "::after {top: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::after {bottom: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::after {bottom: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='dropdown']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='dropdown']")), shadowSelector, " {--_dropdown-size-x-small: 12rem;--_dropdown-size-medium: var(--slds-g-sizing-15);--_dropdown-square-icon-small-boundary: var(--slds-g-sizing-7);--_nubbin-size-default: var(--slds-g-sizing-5);--_duration-quickly: 0.1s;background-color:var(--slds-g-color-surface-container-1);color: var(--slds-g-color-on-surface-3);border-radius: var(--slds-g-radius-border-2);border-width: var(--slds-g-sizing-border-1);border-color: var(--slds-g-color-border-1);box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 16%);padding-inline-start: 0;padding-inline-end: 0;padding-block-start: var(--slds-g-spacing-1);padding-block-end: var(--slds-g-spacing-1);position: absolute;z-index: 7000;left: 50%;float: left;min-width: 6rem;max-width: var(--_dropdown-size-medium);margin-block-start: calc(var(--slds-g-spacing-1) / 2);margin-block-end: calc(var(--slds-g-spacing-1) / 2);font-size: var(--slds-g-font-scale-neg-1);border-style: solid;transform: translateX(-50%);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) mark" : hostSelector + "[data-render-mode=\"shadow\"] mark")), shadowSelector, " {font-weight: var(--slds-g-font-weight-bold);background-color: transparent;color: inherit;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger),:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger" : hostSelector + ".slds-dropdown-trigger[data-render-mode=\"shadow\"]," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger")), shadowSelector, " {position: relative;display: inline-block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger" : hostSelector + ".slds-dropdown-trigger[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger")), shadowSelector, " .slds-dropdown", shadowSelector, " {top: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger) .slds-dropdown_bottom" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger" : hostSelector + ".slds-dropdown-trigger[data-render-mode=\"shadow\"] .slds-dropdown_bottom" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger")), shadowSelector, " .slds-dropdown_bottom", shadowSelector, " {top: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger) > [class*='slds-button_icon']" + shadowSelector + " ~ .slds-dropdown_left[class*='slds-nubbin']" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger" : hostSelector + ".slds-dropdown-trigger[data-render-mode=\"shadow\"] > [class*='slds-button_icon']" + shadowSelector + " ~ .slds-dropdown_left[class*='slds-nubbin']" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger")), shadowSelector, " > [class*='slds-button_icon']", shadowSelector, " ~ .slds-dropdown_left[class*='slds-nubbin']", shadowSelector, " {left: calc(var(--slds-g-spacing-2) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger) > [class*='slds-button_icon']" + shadowSelector + " ~ .slds-dropdown_right[class*='slds-nubbin']" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger" : hostSelector + ".slds-dropdown-trigger[data-render-mode=\"shadow\"] > [class*='slds-button_icon']" + shadowSelector + " ~ .slds-dropdown_right[class*='slds-nubbin']" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger")), shadowSelector, " > [class*='slds-button_icon']", shadowSelector, " ~ .slds-dropdown_right[class*='slds-nubbin']", shadowSelector, " {right: calc(var(--slds-g-spacing-2) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger_hover) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_hover" : hostSelector + ".slds-dropdown-trigger_hover[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_hover")), shadowSelector, " .slds-dropdown", shadowSelector, " {visibility: hidden;opacity: 0;transition: opacity var(--_duration-quickly) linear, visibility var(--_duration-quickly) linear;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger_hover:hover),:host([data-render-mode=\"shadow\"].slds-dropdown-trigger_hover:focus),:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_hover:hover" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_hover:focus" : hostSelector + ":hover.slds-dropdown-trigger_hover[data-render-mode=\"shadow\"]," + hostSelector + ":focus.slds-dropdown-trigger_hover[data-render-mode=\"shadow\"]," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_hover:hover" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_hover:focus")), shadowSelector, " {outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger_hover:hover) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-dropdown-trigger_hover:focus) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_hover:hover" + shadowSelector + " .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_hover:focus" : hostSelector + ":hover.slds-dropdown-trigger_hover[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + ":focus.slds-dropdown-trigger_hover[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_hover:hover" + shadowSelector + " .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_hover:focus")), shadowSelector, " .slds-dropdown", shadowSelector, " {visibility: visible;opacity: 1;transition: opacity var(--_duration-quickly) linear, visibility var(--_duration-quickly) linear;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger_click) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-dropdown-trigger_click:hover) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_click" + shadowSelector + " .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_click:hover" : hostSelector + ".slds-dropdown-trigger_click[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + ":hover.slds-dropdown-trigger_click[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_click" + shadowSelector + " .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_click:hover")), shadowSelector, " .slds-dropdown", shadowSelector, " {display: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger_click.slds-is-open) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_click.slds-is-open" : hostSelector + ".slds-is-open.slds-dropdown-trigger_click[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_click.slds-is-open")), shadowSelector, " .slds-dropdown", shadowSelector, " {display: block;visibility: visible;opacity: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='dropdown'][class*='slds-nubbin_top']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='dropdown'][class*='slds-nubbin_top']")), shadowSelector, " {margin-top: calc(var(--_nubbin-size-default) * 0.5);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='dropdown'][class*='slds-nubbin_bottom']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='dropdown'][class*='slds-nubbin_bottom']")), shadowSelector, " {margin-bottom: calc(var(--_nubbin-size-default) * 0.5);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_left")), shadowSelector, " {left: 0;right: auto;transform: translateX(0);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_right")), shadowSelector, " {left: auto;right: 0;transform: translateX(0);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_bottom" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_bottom")), shadowSelector, " {bottom: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_xx-small" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_xx-small")), shadowSelector, " {min-width: var(--dropdown-size-xx-small);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_x-small" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_x-small")), shadowSelector, " {min-width: var(--_dropdown-size-x-small);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_small" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_small")), shadowSelector, " {min-width: var(--slds-g-sizing-14);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_medium" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_medium")), shadowSelector, " {min-width: var(--_dropdown-size-medium);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_large" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_large")), shadowSelector, " {min-width: 25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_fluid" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_fluid")), shadowSelector, " {min-width: var(\n --_dropdown-size-x-small\n );max-width: 100%;width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-5" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-5")), shadowSelector, " {max-height: calc(((var(--slds-g-font-scale-neg-3) * var(--slds-g-font-lineheight)) + var(--slds-g-spacing-4)) * 5);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-7" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-7")), shadowSelector, " {max-height: calc(((var(--slds-g-font-scale-neg-3) * var(--slds-g-font-lineheight)) + var(--slds-g-spacing-4)) * 7);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-10" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-10")), shadowSelector, " {max-height: calc(((var(--slds-g-font-scale-neg-3) * var(--slds-g-font-lineheight)) + var(--slds-g-spacing-4)) * 10);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-with-icon-5" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-with-icon-5")), shadowSelector, " {max-height: calc((var(--_dropdown-square-icon-small-boundary) + var(--slds-g-spacing-4)) * 5);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-with-icon-7" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-with-icon-7")), shadowSelector, " {max-height: calc((var(--_dropdown-square-icon-small-boundary) + var(--slds-g-spacing-4)) * 7);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-with-icon-10" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-with-icon-10")), shadowSelector, " {max-height: calc((var(--_dropdown-square-icon-small-boundary) + var(--slds-g-spacing-4)) * 10);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [dir='rtl']" : hostSelector + "[data-render-mode=\"shadow\"] [dir='rtl']")), shadowSelector, " .slds-dropdown_center", shadowSelector, " {left: auto;right: auto;transform: translateX(calc(50% - (0.875rem / 2)));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " {background: var(--slds-g-color-brand-base-10);border-color: var(--slds-g-color-brand-base-10);color: var(--slds-g-color-neutral-base-100);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " .slds-dropdown__item", shadowSelector, " > a", shadowSelector, " {color: var(--slds-g-color-neutral-base-100);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" + shadowSelector + " .slds-dropdown__item" + shadowSelector + " > a:hover" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse" + shadowSelector + " .slds-dropdown__item" + shadowSelector + " > a:hover" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " .slds-dropdown__item", shadowSelector, " > a:focus", shadowSelector, " {color: var(--slds-g-color-neutral-base-90);background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " .slds-dropdown__item", shadowSelector, " > a:active", shadowSelector, " {color: var(--slds-g-color-neutral-base-80);background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " .slds-dropdown__item", shadowSelector, " > a[aria-disabled='true']", shadowSelector, " {color: var(--slds-g-color-palette-blue-20);cursor: default;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " .slds-dropdown__item", shadowSelector, " > a[aria-disabled='true']:hover", shadowSelector, " {background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_actions" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_actions")), shadowSelector, " a", shadowSelector, " {color: var(--slds-g-color-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-submenu" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-submenu")), shadowSelector, " .slds-dropdown_submenu", shadowSelector, " {top: 0;transform: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-submenu" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-submenu")), shadowSelector, " .slds-dropdown_submenu-right", shadowSelector, " {left: 100%;margin-left: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-submenu" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-submenu")), shadowSelector, " .slds-dropdown_submenu-left", shadowSelector, " {left: 100%;margin-left: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-submenu" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-submenu")), shadowSelector, " .slds-dropdown_submenu-bottom", shadowSelector, " {top: auto;bottom: 0;margin-bottom: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-p-vertical_large" : hostSelector + "[data-render-mode=\"shadow\"] .slds-p-vertical_large")), shadowSelector, " {padding: var(--slds-g-spacing-5);}"].join('');
      /*LWC compiler v7.1.5*/
    }
    var stylesheet1$1 = [stylesheet$2];

    function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) button" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) input" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) optgroup" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) textarea" : hostSelector + "[data-render-mode=\"shadow\"] button" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] input" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] optgroup" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] textarea")), shadowSelector, " {color: inherit;font: inherit;margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " {--slds-c-buttonicon-sizing: 0.875rem;padding: 0;font-size: var(--slds-g-font-scale-neg-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" + shadowSelector + " thead" + shadowSelector + " > tr" + shadowSelector + " > th" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]" + shadowSelector + " thead" + shadowSelector + " > tr" + shadowSelector + " > th" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " tbody", shadowSelector, " > tr", shadowSelector, " > td", shadowSelector, " {text-align: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " thead", shadowSelector, " > tr", shadowSelector, " > th", shadowSelector, " {padding: var(--slds-g-spacing-2);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-on-surface-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " tbody", shadowSelector, " > tr", shadowSelector, " > td", shadowSelector, " {padding: var(--slds-g-spacing-1);font-size: var(--slds-g-font-scale-neg-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " tbody", shadowSelector, " > tr", shadowSelector, " > td", shadowSelector, " > .slds-day", shadowSelector, " {width: var(--slds-g-sizing-9);height: var(--slds-g-sizing-9);display: block;position: relative;min-width: var(--slds-g-sizing-9);line-height: var(--slds-g-sizing-9);border-radius: 50%;margin: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" + shadowSelector + " tbody" + shadowSelector + " > tr" + shadowSelector + " > td:hover" + shadowSelector + " > .slds-day" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" + shadowSelector + " tbody" + shadowSelector + " > tr" + shadowSelector + " > td:focus" + shadowSelector + " > .slds-day" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]" + shadowSelector + " tbody" + shadowSelector + " > tr" + shadowSelector + " > td:hover" + shadowSelector + " > .slds-day" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]" + shadowSelector + " tbody" + shadowSelector + " > tr" + shadowSelector + " > td:focus" + shadowSelector + " > .slds-day" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " tbody", shadowSelector, " > tr", shadowSelector, " > td.slds-is-today", shadowSelector, " > .slds-day", shadowSelector, " {cursor: pointer;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " tbody", shadowSelector, " > tr", shadowSelector, " > td.slds-is-today", shadowSelector, " > .slds-day", shadowSelector, " {background-color: var(--slds-g-color-brand-base-90);color: var(--slds-g-color-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " tbody", shadowSelector, " > tr", shadowSelector, " > td:focus", shadowSelector, " {outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " tbody", shadowSelector, " > tr", shadowSelector, " > td:focus", shadowSelector, " > .slds-day", shadowSelector, " {box-shadow: var(--slds-s-table-cell-shadow-selected);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " tbody", shadowSelector, " > tr", shadowSelector, " > td:hover", shadowSelector, " > .slds-day", shadowSelector, " {background-color: var(--slds-g-color-brand-base-90);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " tbody", shadowSelector, " > tr", shadowSelector, " > td.slds-is-selected", shadowSelector, " > .slds-day", shadowSelector, " {background: var(--slds-g-color-accent-container-1);color: var(--slds-g-color-on-accent-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~=\"calendar\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part~=\"calendar\"]")), shadowSelector, " tbody", shadowSelector, " > tr", shadowSelector, " > td.slds-is-selected:focus", shadowSelector, " > .slds-day", shadowSelector, " {background: var(--slds-g-color-accent-container-2);box-shadow: var(--slds-g-shadow-5, 0 0 3px #0176d3);color: var(--slds-g-color-on-accent-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-datepicker__filter" : hostSelector + "[data-render-mode=\"shadow\"] .slds-datepicker__filter")), shadowSelector, " {padding: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-datepicker__filter_month" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-datepicker__filter--month" : hostSelector + "[data-render-mode=\"shadow\"] .slds-datepicker__filter_month" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-datepicker__filter--month")), shadowSelector, " {padding: 0 var(--slds-g-spacing-1) 0 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-datepicker__month" : hostSelector + "[data-render-mode=\"shadow\"] .slds-datepicker__month")), shadowSelector, " {font-size: var(--slds-g-font-scale-neg-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-datepicker__filter", shadowSelector, " .slds-select", shadowSelector, " {border: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-base-1);box-shadow: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-day_adjacent-month" : hostSelector + "[data-render-mode=\"shadow\"] .slds-day_adjacent-month")), shadowSelector, " {color: var(--slds-g-color-border-base-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-table" : hostSelector + "[data-render-mode=\"shadow\"] .slds-table")), shadowSelector, " .slds-datepicker", shadowSelector, " .slds-datepicker__month", shadowSelector, " tbody", shadowSelector, " > tr:hover", shadowSelector, " > td", shadowSelector, " {background-color: unset;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button")), shadowSelector, " {position: relative;display: inline-flex;align-items: center;padding-block: 0;padding-inline: 0;background: none;background-color: transparent;background-clip: border-box;border-color: transparent;border-style: solid;border-width: var(--slds-g-sizing-border-1);border-radius: var(--slds-g-radius-border-2);line-height: 1.875rem;text-decoration: none;color: var(--slds-g-color-on-surface-1);white-space: normal;user-select: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button:hover" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-button:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-button:active" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-button:visited" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button:hover" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-button:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-button:active" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-button:visited")), shadowSelector, " {text-decoration: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button:hover" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-button:focus" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button:hover" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-button:focus")), shadowSelector, " {color: var(--slds-g-color-accent-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button:focus" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button:focus")), shadowSelector, " {outline: 0;box-shadow: 0 0 3px var(--slds-g-color-brand-base-50)}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button:active" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button:active")), shadowSelector, " {color: var(--slds-g-color-accent-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button[disabled]" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-button:disabled" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button[disabled]" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-button:disabled")), shadowSelector, " {background-color: transparent;border-color: transparent;color: var(--slds-g-color-disabled-1);cursor: default;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button[disabled]" + shadowSelector + " *" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-button:disabled" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button[disabled]" + shadowSelector + " *" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-button:disabled")), shadowSelector, " *", shadowSelector, " {pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button:hover" + shadowSelector + " .slds-button__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-button:focus" + shadowSelector + " .slds-button__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-button:active" + shadowSelector + " .slds-button__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-button[disabled]" + shadowSelector + " .slds-button__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-button:disabled" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button:hover" + shadowSelector + " .slds-button__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-button:focus" + shadowSelector + " .slds-button__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-button:active" + shadowSelector + " .slds-button__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-button[disabled]" + shadowSelector + " .slds-button__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-button:disabled")), shadowSelector, " .slds-button__icon", shadowSelector, " {fill: currentcolor;pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-align_absolute-center" : hostSelector + "[data-render-mode=\"shadow\"] .slds-align_absolute-center")), shadowSelector, " {display: flex;justify-content: center;align-content: center;align-items: center;margin: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-text-link" : hostSelector + "[data-render-mode=\"shadow\"] .slds-text-link")), shadowSelector, " {color: var(--slds-g-color-accent-2);text-decoration: none;transition: color 0.1s linear;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-text-link:hover" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-text-link:focus" : hostSelector + "[data-render-mode=\"shadow\"] .slds-text-link:hover" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-text-link:focus")), shadowSelector, " {text-decoration: underline;color: var(--slds-g-color-accent-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-text-link:active" : hostSelector + "[data-render-mode=\"shadow\"] .slds-text-link:active")), shadowSelector, " {color: var(--slds-g-color-accent-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-grid" : hostSelector + "[data-render-mode=\"shadow\"] .slds-grid")), shadowSelector, " {display: flex;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-align-middle" : hostSelector + "[data-render-mode=\"shadow\"] .slds-align-middle")), shadowSelector, " {vertical-align: middle;align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-grid_align-spread" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-grid--align-spread" : hostSelector + "[data-render-mode=\"shadow\"] .slds-grid_align-spread" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-grid--align-spread")), shadowSelector, " {justify-content: space-between;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-grid_align-spread" + shadowSelector + " .slds-col" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-grid--align-spread" + shadowSelector + " .slds-col" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-grid_align-spread" + shadowSelector + " [class*=\"slds-col_padded\"]" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-grid--align-spread" : hostSelector + "[data-render-mode=\"shadow\"] .slds-grid_align-spread" + shadowSelector + " .slds-col" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-grid--align-spread" + shadowSelector + " .slds-col" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-grid_align-spread" + shadowSelector + " [class*=\"slds-col_padded\"]" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-grid--align-spread")), shadowSelector, " [class*=\"slds-col_padded\"]", shadowSelector, " {flex-grow: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-grow" : hostSelector + "[data-render-mode=\"shadow\"] .slds-grow")), shadowSelector, " {flex-grow: 1;}"].join('');
      /*LWC compiler v7.1.5*/
    }
    var stylesheet2 = [stylesheet$1];

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      return (useNativeDirPseudoclass ? '' : '[dir="rtl"]') + " .slds-dropdown_left" + (useNativeDirPseudoclass ? ':dir(rtl)' : '') + shadowSelector + " {left: 0;right: auto;}";
      /*LWC compiler v7.1.5*/
    }
    var stylesheet1 = [stylesheet0__default.default, stylesheet1$1, stylesheet2, stylesheet];

    var _implicitStylesheets = [stylesheet0, stylesheet1];

    const $fragment1 = lwc.parseFragment`<h2 aria-atomic="false" aria-live="polite" class="slds-align-middle${0}"${"a0:id"}${"a0:data-index"}${2}>${"t1"}</h2>`;
    const $fragment2 = lwc.parseFragment`<th${"a0:id"} scope="col"${3}><abbr${"a1:title"}${3}>${"t2"}</abbr></th>`;
    const $fragment3 = lwc.parseFragment`<td role="gridcell"${"a0:aria-selected"}${"a0:aria-current"}${"c0"}${"a0:tabindex"}${"a0:data-value"}${"a0:aria-label"}${2}><span class="slds-day${0}" tabindex="-1" role="button"${2}>${"t2"}</span></td>`;
    const $fragment4 = lwc.parseFragment`<button name="today" type="button" class="slds-button slds-align_absolute-center slds-text-link${0}"${2}>${"t1"}</button>`;
    const stc0 = {
      "slds-datepicker": true,
      "slds-dropdown": true,
      "slds-dropdown_left": true
    };
    const stc1 = {
      key: 1
    };
    const stc2 = {
      classMap: {
        "slds-datepicker__filter": true,
        "slds-grid": true
      },
      key: 2
    };
    const stc3 = {
      classMap: {
        "slds-datepicker__filter_month": true,
        "slds-grid": true,
        "slds-grid_align-spread": true,
        "slds-grow": true
      },
      key: 3
    };
    const stc4 = {
      classMap: {
        "slds-align-middle": true
      },
      key: 4
    };
    const stc5 = {
      classMap: {
        "slds-align-middle": true
      },
      key: 8
    };
    const stc6 = {
      classMap: {
        "slds-shrink-none": true
      },
      key: 10
    };
    const stc7 = {
      classMap: {
        "slds-datepicker__month": true
      },
      attrs: {
        "role": "grid"
      },
      key: 12
    };
    const stc8 = {
      key: 13
    };
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {b: api_bind, c: api_custom_element, h: api_element, gid: api_scoped_id, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment, k: api_key, i: api_iterator, ncls: api_normalize_class_name, ti: api_tab_index} = $api;
      const {_m0, _m1, _m2, _m3, _m4, _m5, _m6, _m7} = $ctx;
      return [api_element("div", {
        classMap: stc0,
        attrs: {
          "aria-hidden": "false",
          "aria-label": $cmp.computedAriaLabel,
          "role": "dialog",
          "tabindex": "-1",
          "part": "overlay dropdown calendar"
        },
        key: 0
      }, [api_custom_element("lightning-focus-trap", _lightningFocusTrap__default.default, stc1, [api_element("div", stc2, [api_element("div", stc3, [api_element("div", stc4, [api_custom_element("lightning-button-icon", _lightningButtonIcon__default.default, {
        props: {
          "iconName": $cmp.previousMonthIconName,
          "variant": "container",
          "alternativeText": $cmp.i18n.previousMonth
        },
        key: 5,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.goToPreviousMonth))
        }
      })]), api_static_fragment($fragment1, 7, [api_static_part(0, {
        attrs: {
          "id": api_scoped_id("month-title"),
          "data-index": $cmp.monthIndex
        }
      }, null), api_static_part(1, null, api_dynamic_text($cmp.computedMonthTitle))]), api_element("div", stc5, [api_custom_element("lightning-button-icon", _lightningButtonIcon__default.default, {
        props: {
          "iconName": $cmp.nextMonthIconName,
          "variant": "container",
          "alternativeText": $cmp.i18n.nextMonth
        },
        key: 9,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.goToNextMonth))
        }
      })])]), api_element("div", stc6, [api_custom_element("lightning-select", _lightningSelect__default.default, {
        props: {
          "value": $cmp.calendarYear,
          "label": $cmp.i18n.yearSelector,
          "variant": "label-hidden",
          "options": $cmp.computedYearList
        },
        key: 11,
        on: {
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleYearChange)),
          "click": _m3 || ($ctx._m3 = api_bind($cmp.handleYearSelectClick))
        }
      })])]), api_element("table", stc7, [api_element("thead", stc8, [api_element("tr", {
        attrs: {
          "id": api_scoped_id("weekdays-element")
        },
        key: 14
      }, api_iterator($cmp.computedWeekdayLabels, function (weekday) {
        return api_static_fragment($fragment2, api_key(16, weekday.fullName), [api_static_part(0, {
          attrs: {
            "id": api_scoped_id(weekday.fullName)
          }
        }, null), api_static_part(1, {
          attrs: {
            "title": weekday.fullName
          }
        }, null), api_static_part(2, null, api_dynamic_text(weekday.shortName))]);
      }))]), api_element("tbody", {
        key: 17,
        on: {
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleCalendarKeyDown))
        }
      }, api_iterator($cmp.computedMonth, function (week, index) {
        return api_element("tr", {
          key: api_key(18, week.id)
        }, api_iterator(week.days, function (day) {
          return api_static_fragment($fragment3, api_key(20, day.dateValue), [api_static_part(0, {
            className: api_normalize_class_name(day.className),
            attrs: {
              "aria-selected": day.isSelected,
              "aria-current": day.ariaCurrent,
              "tabindex": api_tab_index(day.tabIndex),
              "data-value": day.dateValue,
              "aria-label": day.dateValue
            }
          }, null), api_static_part(1, {
            on: {
              "click": _m5 || ($ctx._m5 = api_bind($cmp.handleDateClick))
            }
          }, null), api_static_part(2, null, api_dynamic_text(day.dayInMonth))]);
        }));
      }))]), api_static_fragment($fragment4, 22, [api_static_part(0, {
        on: {
          "click": _m7 || ($ctx._m7 = api_bind($cmp.handleTodayClick))
        }
      }, null), api_static_part(1, null, api_dynamic_text($cmp.i18n.today))])])])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-71geokdeko1";
    tmpl.legacyStylesheetToken = "lightning-calendar_calendar";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    function handleKeyDownOnCalendar(event, date, calendarInterface) {
      const tdElement = event.target;
      const keyValue = utilsPrivate.normalizeKeyValue(event.key);
      switch (keyValue) {
        case 'ArrowUp':
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() - 7);
          calendarInterface.focusDate(date);
          break;
        case 'ArrowDown':
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() + 7);
          calendarInterface.focusDate(date);
          break;
        case 'ArrowRight':
          preventDefaultAndStopPropagation(event);
          if (utilsPrivate.isRTL()) {
            date.setDate(date.getDate() - 1);
          } else {
            date.setDate(date.getDate() + 1);
          }
          calendarInterface.focusDate(date);
          break;
        case 'ArrowLeft':
          preventDefaultAndStopPropagation(event);
          if (utilsPrivate.isRTL()) {
            date.setDate(date.getDate() + 1);
          } else {
            date.setDate(date.getDate() - 1);
          }
          calendarInterface.focusDate(date);
          break;
        case 'Enter':
        case ' ':
          preventDefaultAndStopPropagation(event);
          calendarInterface.selectDate(tdElement);
          break;
        case 'PageUp':
          preventDefaultAndStopPropagation(event);
          if (event.altKey) {
            date.setFullYear(date.getFullYear() - 1);
          } else {
            date.setMonth(date.getMonth() - 1);
          }
          calendarInterface.focusDate(date);
          break;
        case 'PageDown':
          preventDefaultAndStopPropagation(event);
          if (event.altKey) {
            date.setFullYear(date.getFullYear() + 1);
          } else {
            date.setMonth(date.getMonth() + 1);
          }
          calendarInterface.focusDate(date);
          break;
        case 'Home':
          {
            preventDefaultAndStopPropagation(event);
            const startOfWeek = calendarInterface.getStartOfWeek(date);
            calendarInterface.focusDate(startOfWeek);
            break;
          }
        case 'End':
          {
            preventDefaultAndStopPropagation(event);
            const endOfWeek = calendarInterface.getStartOfWeek(date);
            endOfWeek.setDate(endOfWeek.getDate() + 6);
            calendarInterface.focusDate(endOfWeek);
            break;
          }
      }
    }
    function preventDefaultAndStopPropagation(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    const i18n = {
      ariaLabelMonth: labelAriaLabelMonth__default.default,
      nextMonth: labelNextMonth__default.default,
      previousMonth: labelPreviousMonth__default.default,
      today: labelToday__default.default,
      yearSelector: labelYearSelector__default.default
    };
    const WEEKS_PER_MONTH = 6;
    const DAYS_PER_WEEK = 7;
    const calendarCache = {}; // cache of calendar cells for a given year/month

    // Japanese Era (https://en.wikipedia.org/wiki/Regnal_year#Japanese)
    const JAPANESE_CALENDAR_YEARS = [
    // note: the order matters. the latest comes first.
    {
      key: 'R',
      year: 2019,
      label: '\u4ee4\u548c'
    },
    // Reiwa:   5/1/2019
    {
      key: 'H',
      year: 1989,
      label: '\u5e73\u6210'
    },
    // Heisei:  1/8/1989
    {
      key: 'S',
      year: 1926,
      label: '\u662d\u548c'
    },
    // Showa:  12/25/1926
    {
      key: 'T',
      year: 1912,
      label: '\u5927\u6b63'
    },
    // Taisho:  7/30/1912
    {
      key: 'M',
      year: 1868,
      label: '\u660e\u6cbb'
    } // Meiji:   1/1/1868
    ];
    class LightningCalendar extends LightningShadowBaseClass__default.default {
      get value() {
        return this.selectedDate;
      }
      set value(newValue) {
        // if value is an ISO string, only fetch the time part
        const dateOnlyString = typeof newValue === 'string' ? newValue.split(iso8601Utils.TIME_SEPARATOR)[0] : newValue;
        if (dateOnlyString !== this.selectedDate) {
          this.selectedDate = dateOnlyString;
          if (!this._connected) {
            return;
          }
          const newDate = this.parseDate(dateOnlyString);

          // if the date is invalid, render today's date
          if (!newDate) {
            this.selectedDate = null;
            this.renderToday();
          } else {
            this.selectDate(newDate);
          }
        }
      }
      constructor() {
        super();
        this.calendarYear = null;
        this.calendarMonth = null;
        this.min = void 0;
        this.max = void 0;
        this.uniqueId = inputUtils.generateUniqueId();
      }
      renderedCallback() {
        this.dispatchEvent(new CustomEvent('ready'));
      }
      connectedCallback() {
        super.connectedCallback();
        this._connected = true;
        this.todayDate = internationalizationLibrary.getCurrentDateString();
        const renderDate = this.getSelectedDate() || this.getTodaysDate();
        this.renderCalendar(renderDate);
        this.keyboardInterface = this.calendarKeyboardInterface();
      }
      disconnectedCallback() {
        this._connected = false;
      }

      /**
       * Sets focus on the focusable date cell in the calendar.
       */
      focus() {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          const dateElement = this.getFocusableDateCell();
          if (dateElement) {
            dateElement.focus();
          }
        });
      }
      get i18n() {
        return i18n;
      }
      get computedAriaLabel() {
        const renderedMonth = this.getCalendarDate().getMonth();
        return i18n.ariaLabelMonth + internationalizationLibrary.getMonthNames()[renderedMonth].fullName;
      }
      get computedMonthTitle() {
        const renderedMonth = this.getCalendarDate().getMonth();
        return internationalizationLibrary.getMonthNames()[renderedMonth].fullName;
      }
      get computedWeekdayLabels() {
        const nameOfWeekdays = internationalizationLibrary.getNameOfWeekdays();
        const firstDay = this.getFirstDayOfWeek();
        const computedWeekdayLabels = [];

        // We need to adjust the weekday labels to start from the locale's first day of week
        for (let i = firstDay; i < nameOfWeekdays.length; i++) {
          computedWeekdayLabels.push(nameOfWeekdays[i]);
        }
        for (let i = 0; i < firstDay; i++) {
          computedWeekdayLabels.push(nameOfWeekdays[i]);
        }
        return computedWeekdayLabels;
      }
      get computedSelectElementId() {
        return this.uniqueId + '-select';
      }
      get computedWeekdaysElementId() {
        return this.uniqueId + '-weekdays';
      }
      get computedMonthTitleId() {
        return this.uniqueId + '-month';
      }
      get computedYearList() {
        const sampleDate = new Date();
        const currentYear = sampleDate.getFullYear();
        const minDate = this.parseDate(this.min);
        const maxDate = this.parseDate(this.max);
        const minYear = minDate ? minDate.getFullYear() : currentYear - 100;
        const maxYear = maxDate ? maxDate.getFullYear() : currentYear + 100;
        const yearList = [];
        for (let year = minYear; year <= maxYear; year++) {
          yearList.push({
            label: this.getYearDisplayValue(sampleDate, year),
            value: year
          });
        }
        return yearList;
      }
      get monthIndex() {
        return this.getCalendarDate().getMonth();
      }
      get hostDirection() {
        let computedStyle;
        if (utilsPrivate.isCSR) {
          // eslint-disable-next-line lightning-global/check-return-value-for-nullable-call
          computedStyle = window.getComputedStyle(this.template.host);
        }
        return computedStyle ? computedStyle.direction.toLowerCase() : 'ltr';
      }
      get previousMonthIconName() {
        return this.hostDirection === 'ltr' ? 'utility:left' : 'utility:right';
      }
      get nextMonthIconName() {
        return this.hostDirection === 'ltr' ? 'utility:right' : 'utility:left';
      }
      getJapaneseCalendarYear(year) {
        const JAPANESE = 'ja';
        const displayValue = (japaneseYearData, useKey) => {
          return useKey ? japaneseYearData.key : japaneseYearData.label;
        };
        let useShortName = salesforceLanguage__default.default !== JAPANESE;
        for (let i = 0; i < JAPANESE_CALENDAR_YEARS.length; i++) {
          if (year < JAPANESE_CALENDAR_YEARS[i].year) {
            continue;
          }
          let jpYear = displayValue(JAPANESE_CALENDAR_YEARS[i], useShortName) + (year - JAPANESE_CALENDAR_YEARS[i].year + 1);
          if (year === JAPANESE_CALENDAR_YEARS[i].year && i < JAPANESE_CALENDAR_YEARS.length - 1) {
            // transition year -- display both
            let previousJapaneseYearData = JAPANESE_CALENDAR_YEARS[i + 1];
            jpYear += '/' + displayValue(previousJapaneseYearData, useShortName) + (year - previousJapaneseYearData.year + 1);
          }
          return jpYear;
        }
        return null;
      }
      getYearDisplayValue(date, yearValue) {
        date.setFullYear(yearValue);
        let displayValue = internationalizationLibrary.toLocalizedDigits(String(internationalizationLibrary.toOtherCalendar(date).getFullYear()));

        // additional display value for Japanese calendar year support
        if (showJapaneseCalendar__default.default) {
          let jpYear = this.getJapaneseCalendarYear(yearValue);
          if (jpYear) {
            displayValue += ' (' + jpYear + ')';
          }
        }
        return displayValue;
      }
      get computedMonth() {
        if (!this._connected) {
          return [];
        }
        const selectedDate = this.getSelectedDate();
        const renderDate = this.getCalendarDate();
        const cacheKey = this.getCalendarCacheKey(renderDate, selectedDate);
        if (cacheKey in calendarCache) {
          return calendarCache[cacheKey];
        }
        const todayDate = this.getTodaysDate();
        const focusableDate = this.getInitialFocusDate(todayDate, selectedDate, renderDate);
        const calendarDates = {
          selectedDate,
          renderDate,
          focusableDate,
          todayDate,
          minDate: this.parseDate(this.min),
          maxDate: this.parseDate(this.max)
        };
        const monthCells = [];
        const date = this.getCalendarStartDate(renderDate);
        for (let week = 0; week < WEEKS_PER_MONTH; week++) {
          const weekCells = {
            id: week,
            days: []
          };
          for (let weekday = 0; weekday < DAYS_PER_WEEK; weekday++) {
            const dayCell = this.getDateCellAttributes(date, calendarDates);
            weekCells.days.push(dayCell);
            date.setDate(date.getDate() + 1);
          }
          monthCells.push(weekCells);
        }
        calendarCache[cacheKey] = monthCells;
        return monthCells;
      }
      getDateCellAttributes(date, calendarDates) {
        const isInAdjacentMonth = !this.dateInCalendar(date, calendarDates.renderDate) || !this.isBetween(date, calendarDates.minDate, calendarDates.maxDate);
        const isSelected = this.isSame(date, calendarDates.selectedDate);
        const isToday = this.isSame(date, calendarDates.todayDate);
        const ariaCurrent = isToday ? 'date' : false;
        const tabIndex = this.isSame(date, calendarDates.focusableDate) ? '0' : false;

        // setting className to undefined avoids hydration errors in SSR
        const className = utils.classSet().add({
          'slds-is-today': isToday,
          'slds-is-selected': isSelected,
          'slds-day_adjacent-month': isInAdjacentMonth
        }).toString() || undefined;
        return {
          dayInMonth: internationalizationLibrary.toLocalizedDigits(String(date.getDate())),
          dateValue: this.formatDate(date),
          isSelected: isSelected ? 'true' : 'false',
          className,
          tabIndex,
          ariaCurrent
        };
      }
      dispatchSelectEvent() {
        this.dispatchEvent(new CustomEvent('select', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this.selectedDate
          }
        }));
      }

      // Determines if the date is in the rendered month/year calendar.
      dateInCalendar(date, calendarDate) {
        const renderedCalendar = calendarDate || this.getCalendarDate();
        return date.getMonth() === renderedCalendar.getMonth() && date.getFullYear() === renderedCalendar.getFullYear();
      }
      getInitialFocusDate(todayDate, selectedDate, renderedDate) {
        if (selectedDate && this.dateInCalendar(selectedDate, renderedDate)) {
          return selectedDate;
        }
        if (this.dateInCalendar(todayDate, renderedDate)) {
          return todayDate;
        }
        return new Date(renderedDate.getFullYear(), renderedDate.getMonth(), 1);
      }
      getTodaysDate() {
        if (this.todayDate) {
          return this.parseDate(this.todayDate);
        }
        // Today's date will be fetched in connectedCallback. In the meantime, use the date based on the device timezone.
        return new Date();
      }
      getSelectedDate() {
        return this.parseDate(this.selectedDate);
      }

      // returns the month and year in the calendar
      getCalendarDate() {
        if (this.calendarYear) {
          return new Date(this.calendarYear, this.calendarMonth, 1);
        }
        return this.getTodaysDate();
      }
      getCalendarStartDate(renderedDate) {
        const firstDayOfMonth = new Date(renderedDate.getFullYear(), renderedDate.getMonth(), 1);
        return this.getStartOfWeek(firstDayOfMonth);
      }
      getStartOfWeek(dayInWeek) {
        const firstDay = this.getFirstDayOfWeek();

        // Negative dates in JS will subtract days from the 1st of the given month
        let startDay = dayInWeek.getDay();
        while (startDay !== firstDay) {
          dayInWeek.setDate(dayInWeek.getDate() - 1);
          startDay = dayInWeek.getDay();
        }
        return dayInWeek;
      }
      getFirstDayOfWeek() {
        return firstDayOfWeek__default.default - 1; // In Java, week days are 1 - 7
      }

      // This method is called when a new value is set, or when you click the today button.
      // In both cases, we need to check if newValue is in the currently rendered calendar
      selectDate(newDate) {
        if (this.dateInCalendar(newDate)) {
          const dateElement = this.getElementByDate(this.formatDate(newDate));
          this.selectDateInCalendar(dateElement);
        } else {
          this.renderCalendar(newDate);
        }
      }

      // Select a date in current calendar without the need to re-render the calendar
      selectDateInCalendar(dateElement) {
        this.selectedDate = dateElement.getAttribute('data-value');
        this.removeCurrentlySelectedDateAttributes();
        this.addSelectedDateAttributes(dateElement);
      }
      selectDateInCalendarAndDispatchSelect(dateElement) {
        this.selectDateInCalendar(dateElement);
        this.dispatchSelectEvent();
      }
      getElementByDate(dateString) {
        return this.template.querySelector(`td[data-value='${dateString}']`);
      }
      getFocusableDateCell() {
        return this.template.querySelector(`td[tabIndex='0']`);
      }
      unfocusDateCell(element) {
        if (element) {
          element.removeAttribute('tabIndex');
        }
      }
      focusDateCell(element) {
        if (element) {
          element.setAttribute('tabIndex', 0);
          element.focus();
        }
      }
      focusElementByDate(date) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          const element = this.getElementByDate(this.formatDate(date));
          if (element) {
            this.unfocusDateCell(this.getFocusableDateCell());
            this.focusDateCell(element);
          }
        });
      }
      renderCalendar(newDate) {
        this.calendarMonth = newDate.getMonth();
        this.calendarYear = newDate.getFullYear();
      }
      renderToday() {
        const todaysDate = this.getTodaysDate();
        if (this.dateInCalendar(todaysDate)) {
          this.removeCurrentlySelectedDateAttributes();
          this.unfocusDateCell(this.getFocusableDateCell());
          const todayElement = this.getElementByDate(this.todayDate);
          todayElement.setAttribute('tabIndex', 0);
        } else {
          this.renderCalendar(todaysDate);
        }
      }
      removeCurrentlySelectedDateAttributes() {
        const currentlySelectedElement = this.template.querySelector(`td[class*='slds-is-selected']`);
        if (currentlySelectedElement) {
          currentlySelectedElement.classList.remove('slds-is-selected');
          currentlySelectedElement.setAttribute('aria-selected', 'false');
        }
        this.unfocusDateCell(this.getFocusableDateCell());
      }
      addSelectedDateAttributes(dateElement) {
        this.focusDateCell(dateElement);
        dateElement.classList.add('slds-is-selected');
        dateElement.setAttribute('aria-selected', 'true');
      }
      handleCalendarKeyDown(event) {
        const dateString = event.target.getAttribute('data-value');
        handleKeyDownOnCalendar(event, this.parseDate(dateString), this.keyboardInterface);
      }
      handleDateClick(event) {
        event.stopPropagation();
        const tdElement = event.target.parentElement;
        this.selectDateInCalendarAndDispatchSelect(tdElement);
      }
      handleTodayClick(event) {
        event.stopPropagation();
        this.selectedDate = this.todayDate;
        this.selectDate(this.getTodaysDate());
        this.dispatchSelectEvent();
      }
      handleYearSelectClick(event) {
        event.stopPropagation();
      }
      handleYearChange(event) {
        event.stopPropagation();
        const newYearValue = event.target.value;
        if (this.calendarYear !== newYearValue) {
          this.calendarYear = newYearValue;
        }
      }
      goToNextMonth(event) {
        event.stopPropagation();
        const calendarDate = this.getCalendarDate();
        calendarDate.setMonth(calendarDate.getMonth() + 1);
        this.renderCalendar(calendarDate);
      }
      goToPreviousMonth(event) {
        event.stopPropagation();
        const calendarDate = this.getCalendarDate();
        calendarDate.setMonth(calendarDate.getMonth() - 1);
        this.renderCalendar(calendarDate);
      }
      calendarKeyboardInterface() {
        const that = this;
        return {
          focusDate(newDate) {
            if (!that.dateInCalendar(newDate)) {
              that.renderCalendar(newDate);
            }
            that.focusElementByDate(newDate);
          },
          getStartOfWeek(dayInWeek) {
            return that.getStartOfWeek(dayInWeek);
          },
          selectDate(dateElement) {
            that.selectDateInCalendarAndDispatchSelect(dateElement);
          }
        };
      }
      formatDate(date) {
        return internationalizationLibrary.getISODateString(date);
      }
      parseDate(dateString) {
        return internationalizationLibrary.parseDateTime(dateString, iso8601Utils.STANDARD_DATE_FORMAT, true);
      }
      isSame(date1, date2) {
        if (!date1 || !date2) {
          return false;
        }
        return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate() // getDate returns the day in month whereas getDay returns the weekday number
        ;
      }
      isBetween(date, date1, date2) {
        let isBeforeEndDate = true;
        let isAfterStartDate = true;
        if (date2) {
          isBeforeEndDate = internationalizationLibrary.isBefore(date, date2, 'day') || this.isSame(date, date2);
        }
        if (date1) {
          isAfterStartDate = internationalizationLibrary.isAfter(date, date1, 'day') || this.isSame(date, date1);
        }
        return isBeforeEndDate && isAfterStartDate;
      }
      getCalendarCacheKey(renderDate, selectedDate) {
        let key = renderDate.getFullYear() + '-' + renderDate.getMonth();
        // Having the key include min/max seems enough for now.
        // We're not going to complicate things by checking if renderDate falls before/after the min/max.
        key += this.min ? 'min' + this.min : '';
        key += this.max ? 'max' + this.max : '';
        if (selectedDate && this.dateInCalendar(selectedDate, renderDate)) {
          key += '_' + selectedDate.getDate();
        }
        return key;
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(LightningCalendar, {
      publicProps: {
        min: {
          config: 0
        },
        max: {
          config: 0
        },
        value: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        calendarYear: 1,
        calendarMonth: 1
      }
    });
    const __lwc_component_class_internal = lwc.registerComponent(LightningCalendar, {
      tmpl: _tmpl,
      sel: "lightning-calendar",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/datepicker', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/helptext', 'lightning/buttonIcon', 'lightning/calendar', '@salesforce/label/LightningDateTimePicker.invalidDate', '@salesforce/label/LightningDateTimePicker.rangeOverflow', '@salesforce/label/LightningDateTimePicker.rangeUnderflow', '@salesforce/label/LightningDateTimePicker.minRangeMessage', '@salesforce/label/LightningDateTimePicker.maxRangeMessage', '@salesforce/label/LightningDateTimePicker.minAndMaxRangeMessage', '@salesforce/label/LightningControl.required', '@salesforce/label/LightningDateTimePicker.valueMissingWithDateFormat', '@salesforce/label/LightningDateTimePicker.customErrorWithDateFormat', '@salesforce/label/LightningDateTimePicker.selectDateFor', '@salesforce/label/LightningInput.helptextAlternativeText', 'lightning/shadowBaseClassPrivate', 'lightning/internationalizationLibrary', 'lightning/positionLibrary', 'lightning/utils', 'lightning/utilsPrivate', 'lightning/inputUtils', 'lightning/ariaObserver'], (function (exports, lwc, stylesheet0$1, _lightningHelptext, _lightningButtonIcon, _lightningCalendar, labelInvalidDate, labelRangeOverflow, labelRangeUnderflow, labelMinRangeMessage, labelMaxRangeMessage, labelMinAndMaxRangeMessage, labelRequired, labelValueMissingWithDateFormat, labelCustomErrorWithDateFormat, labelSelectDateFor, labelHelpTextAlternativeText, LightningShadowBaseClass, internationalizationLibrary, positionLibrary, utils, utilsPrivate, inputUtils, AriaObserver) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningHelptext__default = /*#__PURE__*/_interopDefaultCompat(_lightningHelptext);
  var _lightningButtonIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningButtonIcon);
  var _lightningCalendar__default = /*#__PURE__*/_interopDefaultCompat(_lightningCalendar);
  var labelInvalidDate__default = /*#__PURE__*/_interopDefaultCompat(labelInvalidDate);
  var labelRangeOverflow__default = /*#__PURE__*/_interopDefaultCompat(labelRangeOverflow);
  var labelRangeUnderflow__default = /*#__PURE__*/_interopDefaultCompat(labelRangeUnderflow);
  var labelMinRangeMessage__default = /*#__PURE__*/_interopDefaultCompat(labelMinRangeMessage);
  var labelMaxRangeMessage__default = /*#__PURE__*/_interopDefaultCompat(labelMaxRangeMessage);
  var labelMinAndMaxRangeMessage__default = /*#__PURE__*/_interopDefaultCompat(labelMinAndMaxRangeMessage);
  var labelRequired__default = /*#__PURE__*/_interopDefaultCompat(labelRequired);
  var labelValueMissingWithDateFormat__default = /*#__PURE__*/_interopDefaultCompat(labelValueMissingWithDateFormat);
  var labelCustomErrorWithDateFormat__default = /*#__PURE__*/_interopDefaultCompat(labelCustomErrorWithDateFormat);
  var labelSelectDateFor__default = /*#__PURE__*/_interopDefaultCompat(labelSelectDateFor);
  var labelHelpTextAlternativeText__default = /*#__PURE__*/_interopDefaultCompat(labelHelpTextAlternativeText);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);
  var AriaObserver__default = /*#__PURE__*/_interopDefaultCompat(AriaObserver);

  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {display: flex;align-items: center;gap: var(--sds-c-inputtext-spacing-gap, var(--sds-s-input-spacing-gap));min-height: var(--sds-c-inputtext-sizing-height, var(--sds-s-input-sizing-height));padding-inline-start: var(\n --sds-c-inputtext-spacing-inlinestart,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-spacing-inlineend,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-spacing-blockstart,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-spacing-blockend,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );background: var(--sds-c-inputtext-color-background, var(--sds-s-input-color-background));border-block-start: var(\n --sds-c-inputtext-sizing-border-blockstart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockstart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-start: var(\n --sds-c-inputtext-sizing-border-inlinestart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlinestart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-end: var(\n --sds-c-inputtext-sizing-border-inlineend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlineend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-block-end: var(\n --sds-c-inputtext-sizing-border-blockend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-radius: var(--sds-c-inputtext-radius-border, var(--sds-s-input-radius-border));box-shadow: var(--sds-c-inputtext-shadow, var(--sds-s-input-shadow));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, " {width: 100%;height: 100%;padding: 0;font-size: var(--sds-c-inputtext-font-size, var(--sds-s-input-font-size));color: var(--sds-c-inputtext-text-color, var(--sds-s-input-text-color));line-height: 1;border: none;background: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][active]) [part~='input-container']" : hostSelector + "[active][data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-active,\n var(--sds-s-input-color-background-active)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-active,\n var(--sds-s-input-color-border-active)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-active, var(--sds-s-input-shadow-active));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, "::placeholder {color: var(--sds-c-inputtext-text-color-placeholder, var(--sds-s-input-text-color-placeholder));font-style: var(--sds-c-inputtext-font-style-placeholder, var(--sds-s-input-font-style-placeholder));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']:focus-within" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-focus,\n var(--sds-s-input-color-border-focus, revert)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-focus, var(--sds-s-input-shadow-focus));--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-focus,\n var(--sds-s-input-color-background-focus, revert)\n );--sds-c-inputtext-text-color: var(\n --sds-c-inputtext-text-color-focus,\n var(--sds-s-input-text-color-focus, revert)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']:focus")), shadowSelector, " {outline: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {display: inline-flex;align-items: center;gap: var(--sds-c-inputtext-label-spacing-gap, var(--sds-s-label-spacing-gap));padding-inline-start: var(\n --sds-c-inputtext-label-spacing-inlinestart,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-label-spacing-inlineend,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-label-spacing-blockstart,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-label-spacing-blockend,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );color: var(--sds-c-inputtext-label-color, var(--sds-s-label-color));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {font-size: var(--sds-c-inputtext-label-font-size, var(--sds-s-label-font-size));font-weight: var(--sds-c-inputtext-label-font-weight, var(--sds-s-label-font-weight));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='help-text visible']" : hostSelector + "[data-render-mode=\"shadow\"] [part='help-text visible']")), shadowSelector, " {font-size: var(--sds-c-inputtext-helptext-font-size, var(--sds-s-helptext-font-size));color: var(--sds-c-inputtext-helptext-text-color, var(--sds-s-helptext-text-color));padding-inline-start: var(\n --sds-c-inputtext-helptext-spacing-inlinestart,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-helptext-spacing-inlineend,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-helptext-spacing-blockstart,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-helptext-spacing-blockend,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) {" : hostSelector + "[disabled][data-render-mode=\"shadow\"] {")), "--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-disabled,\n var(--sds-s-input-color-background-disabled)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-disabled,\n var(--sds-s-input-color-border-disabled)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][label-hidden]) [part='label-container']" : hostSelector + "[label-hidden][data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-inputtext-icon-color-foreground,\n var(--slds-g-color-on-surface-1)\n );--slds-c-icon-sizing: var(--slds-c-inputtext-icon-sizing, 14px);--sds-c-inputtext-sizing-height: var(\n --slds-c-inputtext-sizing-height,\n var(--slds-g-sizing-9)\n );--sds-c-inputtext-color-background: var(\n --slds-c-inputtext-color-background,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-color-background-focus: var(\n --slds-c-inputtext-color-background-focus,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-text-color: var(--slds-c-inputtext-text-color);--sds-c-inputtext-font-size: var(\n --slds-c-inputtext-font-size,\n var(--slds-g-font-size-base)\n );--sds-c-inputtext-text-color-placeholder: var(\n --slds-c-inputtext-text-color-placeholder,\n var(--slds-g-color-on-surface-1)\n );--sds-c-inputtext-color-border: var(\n --slds-c-inputtext-color-border,\n var(--slds-g-color-border-2)\n );--sds-c-inputtext-sizing-border: var(--slds-c-inputtext-sizing-border);--sds-c-inputtext-radius-border: var(\n --slds-c-inputtext-radius-border,\n var(--slds-g-radius-border-2)\n );display: flex;flex-wrap: wrap;flex-direction: column;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {flex: 1 0 100%;align-items: stretch;--sds-c-inputtext-spacing-inline: 0;--sds-c-inputtext-spacing-block: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']")), shadowSelector, " {border: none;display: inline-block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " .slds-input__icon:not(button)", shadowSelector, " {pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input'][type='range']")), shadowSelector, " {min-height: calc(1.875rem + (1px * 2));margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:focus-within" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 3px var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;border-width: var(--sds-c-inputtext-sizing-border, var(--slds-g-sizing-border-1));border-color: var(--sds-c-inputtext-color-border, var(--slds-g-color-border-2));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {padding-inline-start: var(\n --slds-c-inputtext-spacing-inlinestart,\n var(--slds-g-spacing-3));padding-inline-end: var(\n --slds-c-inputtext-spacing-inlineend,\n var(--slds-g-spacing-4));height: unset;font-family: var(--slds-g-font-family);}", ((useActualHostSelector ? ":host(:not([disabled])) [part=\"input-container\"]:focus-within" + shadowSelector + ", :host(:not([disabled])) [part=\"input-container\"]:active" : hostSelector + ":not([disabled]) [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + ":not([disabled]) [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part='input-text']" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-spacing-inline-start-readonly: 0;--sds-c-inputtext-color-border-focus: transparent;--slds-c-inputtext-color-border: transparent;--slds-c-inputtext-color-background: transparent;--slds-c-inputtext-color-background-focus: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:active" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-disabled-container-2);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: transparent;outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-text']" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-shadow: 0 0 0 var(--slds-g-sizing-border-1) inset\n var(--slds-g-color-error-1);--slds-c-inputtext-color-border: var(--slds-g-color-border-error-1);--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-input-has-icon" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " {--slds-c-input-color-background: var(--slds-s-input-color-background-invalid);--slds-c-input-color-border: var(--slds-g-color-border-error-1);--slds-c-input-text-color: var(--slds-s-input-color-invalid);background-clip: padding-box;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {fill: var(--slds-g-color-error-1);color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-container']:focus-within" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-shadow:\n var(--slds-g-color-error-base-50) 0 0 0 var(--slds-g-sizing-border-1) inset,\n 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-border-error-1);--sds-c-inputtext-color-border: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-container']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][disabled]) [part='input']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-container']" + shadowSelector + "," + hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {cursor: not-allowed;--sds-c-inputtext-color-background: var(--slds-s-input-color-background-disabled, var(--slds-g-color-disabled-container-1));--sds-c-inputtext-color-border: var(--slds-g-color-border-disabled-1);--sds-c-inputtext-text-color: var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-text']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-text-color-placeholder:\n var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " [part='label']", shadowSelector, " {padding-block-start: var(--slds-g-spacing-1);padding-inline-end: var(--slds-g-spacing-2);color: var(\n --slds-c-inputtext-label-color,\n var(--slds-g-color-on-surface-2)\n );margin-block-end: var(--slds-g-sizing-1);display: inline-flex;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='start']" : hostSelector + "[data-render-mode=\"shadow\"] [part='start']")), shadowSelector, " {--slds-c-icon-spacing-inlineend: var(--slds-g-spacing-2);}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-text']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='label']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {float: left;max-width: calc(33% - 1.125rem);padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-container']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='inline-help']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='inline-help']")), shadowSelector, " {float: left;padding-block-start: var(--slds-g-spacing-1);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) input[type=\"search\"]" : hostSelector + "[data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {left: var(--slds-g-spacing-3);fill: var(--slds-g-color-on-surface-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-accent-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-input__icon", shadowSelector, " {width: 0.875rem;height: 0.875rem;position: absolute;top: 50%;margin-top: -0.4375rem;line-height: 1;border: 0;z-index: 2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_left", shadowSelector, " {inset-inline-start: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right")), shadowSelector, " {--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_right", shadowSelector, " {inset-inline-end: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet$1];

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) fieldset" : hostSelector + "[data-render-mode=\"shadow\"] fieldset")), shadowSelector, " {border: 0;margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {position: relative;min-width: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;hyphens: auto;display: inline-block;color: var(--slds-g-color-on-surface-2);font-size: var(--slds-s-label-font-size, var(--slds-g-font-scale-neg-2));padding-inline-end: var(--slds-g-spacing-2);padding-block-start: var(--slds-g-spacing-1);margin-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label:empty")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {clear: inline-start;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-radio", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {display: inline-block;position: relative;padding-block-start: var(--slds-g-spacing-1);vertical-align: top;line-height: var(--slds-g-font-lineheight-1);z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-form-element__helper" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__helper")), shadowSelector, " {font-size: var(--slds-s-helptext-font-size, var(--slds-g-font-scale-neg-2));margin-block-start: calc(var(--slds-g-spacing-1) / 2);display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_edit")), shadowSelector, " .slds-form-element__static", shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " {flex-basis: 0%;border-bottom: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__label", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__legend" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__legend")), shadowSelector, " {font-weight: var(--slds-g-font-weight-7);float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__addon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__addon")), shadowSelector, " {display: inline-block;margin-block-start: 0;margin-block-end: 0;margin-inline-start: var(--slds-g-spacing-2);margin-inline-end: var(--slds-g-spacing-2);align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;word-break: break-word;display: inline-block;font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-neutral-base-10);width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static.slds-text-longform" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static.slds-text-longform")), shadowSelector, " *:last-child", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static:empty")), shadowSelector, " {min-height: calc(var(--slds-g-sizing-6) + 1px);vertical-align: bottom;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static--edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static--edit")), shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-required" : hostSelector + "[data-render-mode=\"shadow\"] .slds-required")), shadowSelector, " {color: var(--slds-g-color-error-1);margin-block-start: 0;margin-block-end: 0;margin-inline-start: calc(var(--slds-g-spacing-1) / 2);margin-inline-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-form-element__help", shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-form-element__help" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) {" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {padding: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__label" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__label" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {width: 100%;flex-basis: 100%;clear: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__icon" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {float: none;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline'].slds-form-element_horizontal) {" : hostSelector + ".slds-form-element_horizontal[variant='label-inline'][data-render-mode=\"shadow\"] {")), "padding: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']).slds-is-edited {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"].slds-is-edited {")), "padding-block-start: var(--slds-g-sizing-6)}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__label" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {float: inline-start;max-width: calc(33% - var(--slds-g-sizing-6));flex-basis: calc(33% - var(--slds-g-sizing-6));flex-grow: 1;margin-block-end: 0;position: relative;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) lightning-helptext" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] lightning-helptext")), shadowSelector, " {float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {margin-inline-start: 33%;clear: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list__column" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list__column")), shadowSelector, " .slds-form-element__label", shadowSelector, " {width: auto;max-width: 100%;flex-basis: auto;float: none;position: relative;padding-inline-start: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__help" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list")), shadowSelector, " {clear: none;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " {display: flex;margin-bottom: var(--slds-g-spacing-1);margin-left: calc(var(--slds-g-spacing-1) * -1);margin-right: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " .slds-form-element__label", shadowSelector, " {padding-top: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element", shadowSelector, " {padding-left: var(--slds-g-spacing-1);padding-right: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_address" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_address")), shadowSelector, " .slds-form-element__row", shadowSelector, " {align-items: flex-end;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-hidden']) .slds-form-element__label" : hostSelector + "[variant='label-hidden'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {display: none}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet2 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1, stylesheet2];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<abbr class="slds-required${0}"${"a0:title"}${2}>*</abbr>`;
  const $fragment2 = lwc.parseFragment`<span${"a0:id"} data-range-message class="slds-assistive-text${0}"${2}>${"t1"}</span>`;
  const $fragment3 = lwc.parseFragment`<div${"a0:id"} data-date-format class="slds-form-element__help${0}"${2}>${"t1"}</div>`;
  const $fragment4 = lwc.parseFragment`<div${"a0:id"} data-error-message${"c0"} aria-live="polite"${2}><span class="slds-assistive-text${0}"${2}>${"t2"}</span>${"t3"}</div>`;
  const stc0 = {
    classMap: {
      "slds-dropdown-trigger": true,
      "slds-dropdown-trigger_click": true,
      "slds-size_1-of-1": true
    },
    attrs: {
      "role": "group",
      "part": "input-text"
    },
    key: 0
  };
  const stc1 = {
    classMap: {
      "slds-form-element__control": true,
      "slds-input-has-icon": true,
      "slds-input-has-icon_right": true
    },
    attrs: {
      "part": "input-container"
    },
    key: 7
  };
  const stc2 = {
    "slds-input": true
  };
  const stc3 = {
    "slds-input__icon": true,
    "slds-input__icon_right": true
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {ncls: api_normalize_class_name, gid: api_scoped_id, sp: api_static_part, st: api_static_fragment, d: api_dynamic_text, t: api_text, h: api_element, c: api_custom_element, b: api_bind} = $api;
    const {_m0, _m1, _m2, _m3, _m4, _m5, _m6, _m7, _m8, _m9, _m10, _m11, _m12, _m13, _m14} = $ctx;
    return [api_element("div", stc0, [!$cmp.hasExternalLabel ? api_element("label", {
      className: api_normalize_class_name($cmp.computedLabelClass),
      attrs: {
        "for": api_scoped_id("input"),
        "part": "label"
      },
      key: 1
    }, [$cmp.required ? api_static_fragment($fragment1, 3, [api_static_part(0, {
      attrs: {
        "title": $cmp.i18n.required
      }
    }, null)]) : null, api_text(api_dynamic_text($cmp.label))]) : null, !$cmp.hasExternalLabel ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext__default.default, {
      props: {
        "content": $cmp.fieldLevelHelp,
        "alternativeText": $cmp.helptextAlternativeText
      },
      key: 4
    }) : null : null, $cmp.isRangeMessageVisible ? api_static_fragment($fragment2, 6, [api_static_part(0, {
      attrs: {
        "id": api_scoped_id("range-message")
      }
    }, null), api_static_part(1, null, api_dynamic_text($cmp.rangeMessage))]) : null, api_element("div", stc1, [api_element("input", {
      classMap: stc2,
      attrs: {
        "type": "text",
        "id": api_scoped_id("input"),
        "part": "input",
        "name": $cmp.name,
        "accesskey": $cmp.accessKey,
        "placeholder": $cmp.placeholder,
        "aria-invalid": $cmp.computedAriaInvalid,
        "aria-label": $cmp.ariaLabel,
        "aria-disabled": $cmp.ariaDisabled,
        "required": $cmp.required ? "" : null,
        "readonly": $cmp.readOnly ? "" : null,
        "disabled": $cmp.disabled ? "" : null,
        "autocomplete": $cmp.autocomplete
      },
      props: {
        "value": $cmp.displayValue
      },
      key: 8,
      on: {
        "input": _m0 || ($ctx._m0 = api_bind($cmp.handleInput)),
        "change": _m1 || ($ctx._m1 = api_bind($cmp.handleInputChange)),
        "focusin": _m2 || ($ctx._m2 = api_bind($cmp.onFocusIn)),
        "focusout": _m3 || ($ctx._m3 = api_bind($cmp.handleInputBlur)),
        "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleInputKeydown)),
        "click": _m5 || ($ctx._m5 = api_bind($cmp.handleInputClick))
      }
    }), api_custom_element("lightning-button-icon", _lightningButtonIcon__default.default, {
      classMap: stc3,
      props: {
        "iconName": "utility:event",
        "variant": "bare",
        "disabled": $cmp.computedIconDisabledState,
        "title": $cmp.computedSelectDateLabel,
        "alternativeText": $cmp.computedSelectDateLabel
      },
      key: 9,
      on: {
        "click": _m6 || ($ctx._m6 = api_bind($cmp.handleDatePickerIconClick)),
        "keydown": _m7 || ($ctx._m7 = api_bind($cmp.handleDatePickerIconKeyDown)),
        "focusin": _m8 || ($ctx._m8 = api_bind($cmp.onFocusIn)),
        "focusout": _m9 || ($ctx._m9 = api_bind($cmp.onFocusOut))
      }
    }), $cmp.isCalendarVisible ? api_custom_element("lightning-calendar", _lightningCalendar__default.default, {
      props: {
        "value": $cmp.value,
        "min": $cmp.min,
        "max": $cmp.max
      },
      key: 10,
      on: {
        "select": _m10 || ($ctx._m10 = api_bind($cmp.handleDateSelect)),
        "ready": _m11 || ($ctx._m11 = api_bind($cmp.startPositioning)),
        "keydown": _m12 || ($ctx._m12 = api_bind($cmp.handleCalendarKeyDown)),
        "focusin": _m13 || ($ctx._m13 = api_bind($cmp.onFocusIn)),
        "focusout": _m14 || ($ctx._m14 = api_bind($cmp.onFocusOut))
      }
    }) : null])]), $cmp.computedShowDateFormat ? api_static_fragment($fragment3, 12, [api_static_part(0, {
      attrs: {
        "id": api_scoped_id("fmt-text")
      }
    }, null), api_static_part(1, null, api_dynamic_text($cmp.dateFormat))]) : null, $cmp.errorMessage ? api_static_fragment($fragment4, 14, [api_static_part(0, {
      className: api_normalize_class_name($cmp.computedClassErrorMessage),
      attrs: {
        "id": api_scoped_id("error-message")
      }
    }, null), api_static_part(2, null, api_dynamic_text($cmp.label)), api_static_part(3, null, api_dynamic_text($cmp.errorMessage))]) : null];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-2fb3f2nu4or";
  tmpl.legacyStylesheetToken = "lightning-datepicker_datepicker";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  function handleKeyDownOnDatePickerIcon(event, datepickerInterface) {
    switch (utilsPrivate.normalizeKeyValue(event.key)) {
      case 'Enter':
      case ' ':
        preventDefaultAndStopPropagation(event);
        datepickerInterface.showCalendar();
        break;
      case 'Escape':
        preventDefaultAndStopPropagation(event);
        datepickerInterface.hideCalendar();
        break;
    }
  }
  function handleBasicKeyDownBehaviour(event, datepickerInterface) {
    if (!datepickerInterface.isCalendarVisible()) {
      return;
    }
    if (utilsPrivate.normalizeKeyValue(event.key) === 'Escape') {
      preventDefaultAndStopPropagation(event);
      datepickerInterface.hideCalendar();
    }
  }
  function preventDefaultAndStopPropagation(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  const i18n = {
    invalidDate: labelInvalidDate__default.default,
    rangeOverflow: labelRangeOverflow__default.default,
    rangeUnderflow: labelRangeUnderflow__default.default,
    minRangeMessage: labelMinRangeMessage__default.default,
    maxRangeMessage: labelMaxRangeMessage__default.default,
    minAndMaxRangeMessage: labelMinAndMaxRangeMessage__default.default,
    required: labelRequired__default.default,
    selectDateFor: labelSelectDateFor__default.default,
    helpTextAlternativeText: labelHelpTextAlternativeText__default.default,
    valueMissingWithDateFormat: labelValueMissingWithDateFormat__default.default,
    customErrorWithDateFormat: labelCustomErrorWithDateFormat__default.default
  };
  const ARIA_CONTROLS = 'aria-controls';
  const ARIA_DETAILS = 'aria-details';
  const ARIA_LABEL = 'aria-label';
  const ARIA_DISABLED = 'aria-disabled';
  const ARIA_LABELLEDBY = 'aria-labelledby';
  const ARIA_DESCRIBEDBY = 'aria-describedby';
  const ARIA_INVALID = 'aria-invalid';
  const DATE_STYLE = {
    SHORT: 'short',
    MEDIUM: 'medium',
    LONG: 'long'
  };
  class LightningDatePicker extends LightningShadowBaseClass__default.default {
    get rootAriaNode() {
      if (this.ariaObserver) {
        return this.ariaObserver.root;
      }
      return null;
    }
    set rootAriaNode(root) {
      if (this.ariaObserver) {
        this.ariaObserver.root = root;
      }
    }
    setNormalisedIsoDateMin() {
      const normalizedDate = internationalizationLibrary.normalizeISODate(this._userMinValue, this._dateStyle);
      if (normalizedDate.isoValue) {
        this._min = normalizedDate.isoValue;
        this._displayMin = normalizedDate.displayValue;
      }
    }
    get min() {
      return this._min;
    }
    set min(value) {
      // W-7702418: We previously always set the raw value and should continue to do so unless
      // normalization of the given value is possible.
      this._min = value;
      this._displayMin = value;
      this._userMinValue = value;
      this.setNormalisedIsoDateMin();
    }
    setNormalisedIsoDateMax() {
      const normalizedDate = internationalizationLibrary.normalizeISODate(this._userMaxValue, this._dateStyle);
      if (normalizedDate.isoValue) {
        this._max = normalizedDate.isoValue;
        this._displayMax = normalizedDate.displayValue;
      }
    }
    get max() {
      return this._max;
    }
    set max(value) {
      // W-7702418: We previously always set the raw value and should continue to do so unless
      // normalization of the given value is possible.
      this._max = value;
      this._displayMax = value;
      this._userMaxValue = value;
      this.setNormalisedIsoDateMax();
    }
    get messageWhenValueMissing() {
      if (this._messageWhenValueMissing) {
        return utils.formatLabel(this.i18n.customErrorWithDateFormat, this._messageWhenValueMissing, this.dateFormat);
      }
      return utils.formatLabel(this.i18n.valueMissingWithDateFormat, this.dateFormat);
    }
    set messageWhenValueMissing(message) {
      this._messageWhenValueMissing = message;
    }
    get messageWhenBadInput() {
      if (this._messageWhenBadInput) {
        return utils.formatLabel(this.i18n.customErrorWithDateFormat, this._messageWhenBadInput, this.dateFormat);
      }
      return utils.formatLabel(this.i18n.invalidDate, this.dateFormat);
    }
    set messageWhenBadInput(message) {
      this._messageWhenBadInput = message;
    }
    get messageWhenRangeOverflow() {
      if (this._messageWhenRangeOverflow) {
        return utils.formatLabel(this.i18n.customErrorWithDateFormat, this._messageWhenRangeOverflow, this.dateFormat);
      }
      return utils.formatLabel(this.i18n.rangeOverflow, this._displayMax);
    }
    set messageWhenRangeOverflow(message) {
      this._messageWhenRangeOverflow = message;
    }
    get messageWhenRangeUnderflow() {
      if (this._messageWhenRangeUnderflow) {
        return utils.formatLabel(this.i18n.customErrorWithDateFormat, this._messageWhenRangeUnderflow, this.dateFormat);
      }
      return utils.formatLabel(this.i18n.rangeUnderflow, this._displayMin);
    }
    set messageWhenRangeUnderflow(message) {
      this._messageWhenRangeUnderflow = message;
    }

    // setter is required to properly trigger update
    get ariaLabel() {
      return this._ariaLabel;
    }
    set ariaLabel(val) {
      this._ariaLabel = val;
      this.synchronizeA11y();
    }
    get ariaDisabled() {
      return this._ariaDisabled;
    }
    set ariaDisabled(val) {
      this._ariaDisabled = val;
      this.synchronizeA11y();
    }
    set ariaLabelledByElement(el) {
      this._ariaLabelledBy = el;
      if (this.ariaObserver) {
        this.ariaObserver.connect({
          attribute: ARIA_LABELLEDBY,
          targetSelector: 'input',
          relatedNodeIds: utilsPrivate.getRealDOMId(this._ariaLabelledBy)
        });
      }
    }
    get ariaLabelledByElement() {
      return this._ariaLabelledBy;
    }
    set ariaControlsElement(el) {
      this._ariaControls = el;
      if (this.ariaObserver) {
        this.ariaObserver.connect({
          attribute: ARIA_CONTROLS,
          targetSelector: 'input',
          relatedNodeIds: utilsPrivate.getRealDOMId(this.ariaControlsElement)
        });
      }
    }
    get ariaControlsElement() {
      return this._ariaControls;
    }
    set ariaDetailsElements(el) {
      this._ariaDetails = el;
      if (this.ariaObserver) {
        this.ariaObserver.connect({
          attribute: ARIA_DETAILS,
          targetSelector: 'input',
          relatedNodeIds: utilsPrivate.getRealDOMId(this.ariaDetailsElements)
        });
      }
    }
    get ariaDetailsElements() {
      return this._ariaDetails;
    }
    set ariaDescribedByElements(el) {
      if (Array.isArray(el)) {
        this._ariaDescribedBy = el;
      } else {
        this._ariaDescribedBy = [el];
      }
      this.connectAriaDescribedBy();
    }
    get ariaDescribedByElements() {
      return this._ariaDescribedBy;
    }
    get ariaErrorMessageElement() {
      return this._ariaErrorMessageElement;
    }
    set ariaErrorMessageElement(element) {
      this._ariaErrorMessageElement = element;
      this.connectAriaDescribedBy();
    }
    synchronizeA11y() {
      if (!this._rendered) {
        return;
      }
      const input = this.template.querySelector('input');
      if (!input) {
        return;
      }
      utilsPrivate.synchronizeAttrs(input, {
        [ARIA_LABEL]: this._ariaLabel,
        [ARIA_DISABLED]: this._ariaDisabled,
        [ARIA_INVALID]: this.computedAriaInvalid
      });

      // Set aria-describedby on the calendar button that opens the calendar dialog
      // to inform user of date validity (min/max). Same is done for input.
      const calendarButton = this.template.querySelector('lightning-button-icon');
      calendarButton.ariaDescribedBy = this.computedDatepickerButtonAriaDescribedby;
      if (this.isConnected) {
        this.connectAriaDescribedBy();
        this.ariaObserver.sync();
      }
    }
    renderedCallback() {
      this._rendered = true;
      this.synchronizeA11y();
    }
    get value() {
      return this._value;
    }
    set value(newValue) {
      const normalizedDate = internationalizationLibrary.normalizeISODate(newValue, this.dateStyle);
      this._value = normalizedDate.isoValue;
      this._displayValue = normalizedDate.displayValue;
    }
    get disabled() {
      return this._disabled;
    }
    set disabled(value) {
      this._disabled = utilsPrivate.normalizeBoolean(value);
      utilsPrivate.reflectAttribute(this, 'disabled', this._disabled);
    }
    get readOnly() {
      return this._readonly;
    }
    set readOnly(value) {
      this._readonly = utilsPrivate.normalizeBoolean(value);
      utilsPrivate.reflectAttribute(this, 'readonly', this._readonly);
    }
    get required() {
      return this._required;
    }
    set required(value) {
      this._required = utilsPrivate.normalizeBoolean(value);
    }
    set fieldLevelHelp(value) {
      this._fieldLevelHelp = value;
    }
    get fieldLevelHelp() {
      return this._fieldLevelHelp;
    }
    get variant() {
      return this._variant || inputUtils.VARIANT.STANDARD;
    }
    set variant(value) {
      this._variant = inputUtils.normalizeVariant(value);
      utilsPrivate.reflectAttribute(this, 'variant', value);
    }
    focus() {
      if (this.connected) {
        this.inputElement.focus();
      }
    }
    blur() {
      if (this.connected) {
        this.inputElement.blur();
      }
    }
    showHelpMessage(message) {
      if (!message) {
        this.classList.remove('slds-has-error');
        this._errorMessage = '';
      } else {
        this.classList.add('slds-has-error');
        this._errorMessage = message;
      }
    }
    hasBadInput() {
      return !!this._displayValue && this._value === null;
    }
    get dateStyle() {
      return this._dateStyle;
    }
    set dateStyle(value) {
      this._dateStyle = utilsPrivate.normalizeString(value, {
        fallbackValue: DATE_STYLE.MEDIUM,
        validValues: [DATE_STYLE.SHORT, DATE_STYLE.MEDIUM, DATE_STYLE.LONG]
      });
      const normalizedDate = internationalizationLibrary.normalizeISODate(this._value, this._dateStyle);
      this._displayValue = normalizedDate.displayValue;

      // W-14161407 min and max setters are being called before dateStyle is being set
      // hence updating the min max values
      this.setNormalisedIsoDateMax();
      this.setNormalisedIsoDateMin();
    }
    constructor() {
      super();
      this._disabled = false;
      this._readonly = false;
      this._required = false;
      this._value = null;
      this._calendarVisible = false;
      this._displayValue = null;
      this._errorMessage = '';
      this._fieldLevelHelp = void 0;
      this._variant = void 0;
      this.accessKey = void 0;
      this._min = void 0;
      this._max = void 0;
      this._messageWhenValueMissing = void 0;
      this._userMaxValue = void 0;
      this._userMinValue = void 0;
      this._displayMin = void 0;
      this._displayMax = void 0;
      this._dateStyle = DATE_STYLE.MEDIUM;
      this.label = void 0;
      this.name = void 0;
      this.placeholder = void 0;
      this.externalErrorMessage = void 0;
      /**
       * Controls auto-filling of the input. Set the attribute to pass
       * through autocomplete values to be interpreted by the browser.
       * By default autocomplete is off to avoid overlap of dropdown.
       * @type {string}
       */
      this.autocomplete = 'off';
      this._ariaLabelledBy = void 0;
      this._ariaControls = void 0;
      this._ariaDetails = void 0;
      this._ariaDescribedBy = [];
      this.uniqueId = inputUtils.generateUniqueId();
      this.ariaObserver = new AriaObserver__default.default(this);
    }
    connectedCallback() {
      super.connectedCallback();
      this.connected = true;
      if (!this.ariaObserver) {
        this.ariaObserver = new AriaObserver__default.default(this);
      }
      this.keyboardInterface = this.datepickerKeyboardInterface();
    }
    disconnectedCallback() {
      this.connected = false;
      this._rendered = false;
      if (this.ariaObserver) {
        this.ariaObserver.disconnect();
        this.ariaObserver = undefined;
      }
    }
    get computedShowDateFormat() {
      return !this.errorMessage && !this.externalErrorMessage;
    }
    get dateFormat() {
      return internationalizationLibrary.getDateFormatFromStyle(this.dateStyle, true);
    }
    get i18n() {
      return i18n;
    }
    get isLabelHidden() {
      return this.variant === inputUtils.VARIANT.LABEL_HIDDEN;
    }
    get computedLabelClass() {
      return utils.classSet('slds-form-element__label').add({
        'slds-assistive-text': this.isLabelHidden
      }).toString();
    }
    get errorMessageElement() {
      return this.template.querySelector('[data-error-message]');
    }
    get rangeMessageElement() {
      return this.template.querySelector('[data-range-message]');
    }
    get dateFormatElement() {
      return this.template.querySelector('[data-date-format]');
    }
    get computedUniqueRangeMessageElementId() {
      const el = this.template.querySelector('[data-range-message]');
      return utilsPrivate.getRealDOMId(el);
    }
    get isRangeMessageVisible() {
      return this.min || this.max;
    }
    get isCalendarVisible() {
      return this._calendarVisible;
    }
    get displayValue() {
      return this._displayValue;
    }
    get computedClassErrorMessage() {
      const displayClass = this.errorMessage ? 'slds-show' : 'slds-hide';
      return 'slds-form-element__help ' + displayClass;
    }
    get errorMessage() {
      return this._errorMessage;
    }
    get computedIconDisabledState() {
      return this.disabled || this.readOnly;
    }
    get ariaDescribedByElementsInternal() {
      const elements = [this.ariaErrorMessageElement];
      if (this.errorMessage) {
        elements.push(this.errorMessageElement);
      } else {
        elements.push(this.dateFormatElement);
      }

      // To inform user of valid date ranges that are set via min/max attributes
      if (this.isRangeMessageVisible) {
        elements.push(this.rangeMessageElement);
      }
      return elements;
    }
    get computedAriaDescribedby() {
      const ariaValues = [];
      this._ariaDescribedBy.forEach(item => {
        const id = utilsPrivate.getRealDOMId(item);
        if (id) {
          ariaValues.push(id);
        }
      });
      return utilsPrivate.normalizeAriaAttribute(ariaValues);
    }
    connectAriaDescribedBy() {
      if (this.ariaObserver && this._rendered) {
        this.ariaObserver.connect({
          attribute: ARIA_DESCRIBEDBY,
          targetSelector: 'input',
          relatedNodeIds: this.computedAriaDescribedby,
          relatedNodes: this.ariaDescribedByElementsInternal
        });
      }
    }
    get computedDatepickerButtonAriaDescribedby() {
      if (this.isRangeMessageVisible) {
        return this.computedUniqueRangeMessageElementId;
      }
      return '';
    }
    get computedSelectDateLabel() {
      return utils.formatLabel(this.i18n.selectDateFor, this.label);
    }
    get rangeMessage() {
      if (this.min && !this.max) {
        // If only min is set
        return utils.formatLabel(this.i18n.minRangeMessage, this._displayMin);
      } else if (this.max && !this.min) {
        // If only max is set
        return utils.formatLabel(this.i18n.maxRangeMessage, this._displayMax);
      } else if (this.min && this.max) {
        // If both min and max are set
        return utils.formatLabel(this.i18n.minAndMaxRangeMessage, this._displayMin, this._displayMax);
      }
      return '';
    }
    handleInputChange(event) {
      event.stopPropagation();

      // keeping the display value in sync with the element's value
      this._displayValue = event.currentTarget.value;
      this._value = internationalizationLibrary.parseFormattedDate(this._displayValue).value;
      this.dispatchChangeEvent();
    }
    handleInput() {
      // keeping the display value in sync with the element's value
      this._displayValue = this.inputElement.value;

      // IE11 fires an input event along with the click event when the element has a placeholder.
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/101220/
      // remove this block when we stop support for IE11
      if (utilsPrivate.isIE11 && this.placeholder !== undefined) {
        return;
      }

      // Making sure that the focus remains on the input and we're not triggering leave
      this.hideCalendarAndFocusTrigger();
    }
    handleInputBlur() {
      if (this._value !== null) {
        const normalizedDate = internationalizationLibrary.normalizeISODate(this._value, this.dateStyle);
        this._displayValue = normalizedDate.displayValue;
      }
      this.onFocusOut();
    }
    handleInputClick(event) {
      if (this.readOnly) {
        return;
      }
      this.calendarTrigger = event.target;
      this.showCalendar();
    }

    /**
     * When the element gains focus this function is called.
     */
    onFocusIn() {
      if (this._pendingFocusOut) {
        this._pendingFocusOut = false;
      }
      if (!this._focused) {
        this.dispatchEvent(new CustomEvent('focus'));
      }
      this._focused = true;
    }

    /**
     * When the element looses its focus this function is called.
     */
    onFocusOut() {
      // This assumes that a focusin will be dispatched after a focusout
      this._pendingFocusOut = true;
      // eslint-disable-next-line @lwc/lwc/no-async-operation
      requestAnimationFrame(() => {
        if (this._pendingFocusOut) {
          this._focused = false;
          this.hideCalendar();
          this.dispatchEvent(new CustomEvent('blur'));
        }
      });
    }
    handleDatePickerIconClick(event) {
      if (this.readOnly || this.disabled) {
        return;
      }
      this.calendarTrigger = event.target;
      this.showAndFocusCalendar();
    }
    handleInputKeydown(event) {
      this.calendarTrigger = event.target;
      handleBasicKeyDownBehaviour(event, this.keyboardInterface);
    }
    handleDatePickerIconKeyDown(event) {
      this.calendarTrigger = event.target;
      handleKeyDownOnDatePickerIcon(event, this.keyboardInterface);
    }
    handleCalendarKeyDown(event) {
      handleBasicKeyDownBehaviour(event, this.keyboardInterface);
    }
    handleDateSelect(event) {
      event.stopPropagation();
      this._value = event.detail.value;
      this._displayValue = internationalizationLibrary.normalizeISODate(this._value, this.dateStyle).displayValue;
      this.hideCalendarAndFocusTrigger();
      this.dispatchChangeEvent();
    }
    showAndFocusCalendar() {
      this.showCalendar();

      // eslint-disable-next-line @lwc/lwc/no-async-operation
      requestAnimationFrame(() => {
        this.focusCalendar();
      });
    }
    hideCalendarAndFocusTrigger() {
      this.hideCalendar();
      if (this.calendarTrigger) if (this.calendarTrigger === this.calendarButtonElement) {
        // Fix for W-14258862, focus is transferred to the input element
        // instead of the button element when trigger is button
        this.inputElement.focus();
      } else {
        this.calendarTrigger.focus();
      }
    }
    focusCalendar() {
      const calendar = this.template.querySelector('lightning-calendar');
      if (calendar) {
        calendar.focus();
      }
    }
    startPositioning() {
      if (!this._relationship) {
        this._relationship = positionLibrary.startPositioning(this, {
          target: () => this.template.querySelector('div.slds-form-element__control'),
          element: () => this.template.querySelector('lightning-calendar').shadowRoot.querySelector('div'),
          align: {
            horizontal: positionLibrary.Direction.Right,
            vertical: positionLibrary.Direction.Top
          },
          targetAlign: {
            horizontal: positionLibrary.Direction.Right,
            vertical: positionLibrary.Direction.Bottom
          },
          autoFlip: true,
          // Auto flip direction if not have enough space
          leftAsBoundary: true // horizontal flip uses target left as boundary
        });
      } else {
        this._relationship.reposition();
      }
    }
    stopPositioning() {
      if (this._relationship) {
        positionLibrary.stopPositioning(this._relationship);
        this._relationship = null;
      }
    }
    showCalendar() {
      if (!this.isCalendarVisible) {
        this.rootElement.classList.add('slds-is-open');
        this._calendarVisible = true;
      }
    }
    hideCalendar() {
      if (this.isCalendarVisible) {
        this.rootElement.classList.remove('slds-is-open');
        this.stopPositioning();
        this._calendarVisible = false;
      }
    }
    get rootElement() {
      return this.template.querySelector('div');
    }
    get inputElement() {
      return this.template.querySelector('input');
    }
    get calendarButtonElement() {
      return this.template.querySelector('lightning-button-icon');
    }
    dispatchChangeEvent() {
      this.dispatchEvent(new CustomEvent('change', {
        composed: true,
        bubbles: true,
        detail: {
          value: this._value
        }
      }));
    }
    datepickerKeyboardInterface() {
      const that = this;
      return {
        showCalendar() {
          that.showAndFocusCalendar();
        },
        hideCalendar() {
          that.hideCalendarAndFocusTrigger();
        },
        isCalendarVisible() {
          return that.isCalendarVisible;
        }
      };
    }
    get hasExternalLabel() {
      return this.variant === inputUtils.VARIANT.LABEL_HIDDEN && this.ariaLabelledByElement && this.ariaLabelledByElement.length;
    }
    get computedAriaInvalid() {
      const dataAriaInvalid = utilsPrivate.isCSR ? this.template.host.getAttribute('data-aria-invalid') : null;
      const isAriaInvalid = dataAriaInvalid || this._errorMessage;
      return utilsPrivate.computeAriaInvalid(isAriaInvalid, this.hasBadInput() || '');
    }
    get helptextAlternativeText() {
      return utils.formatLabel(i18n.helpTextAlternativeText, this.label);
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(LightningDatePicker, {
    publicProps: {
      accessKey: {
        config: 0
      },
      label: {
        config: 0
      },
      name: {
        config: 0
      },
      placeholder: {
        config: 0
      },
      externalErrorMessage: {
        config: 0
      },
      autocomplete: {
        config: 0
      },
      rootAriaNode: {
        config: 3
      },
      min: {
        config: 3
      },
      max: {
        config: 3
      },
      messageWhenValueMissing: {
        config: 3
      },
      messageWhenBadInput: {
        config: 3
      },
      messageWhenRangeOverflow: {
        config: 3
      },
      messageWhenRangeUnderflow: {
        config: 3
      },
      ariaLabel: {
        config: 3
      },
      ariaDisabled: {
        config: 3
      },
      ariaLabelledByElement: {
        config: 3
      },
      ariaControlsElement: {
        config: 3
      },
      ariaDetailsElements: {
        config: 3
      },
      ariaDescribedByElements: {
        config: 3
      },
      ariaErrorMessageElement: {
        config: 3
      },
      value: {
        config: 3
      },
      disabled: {
        config: 3
      },
      readOnly: {
        config: 3
      },
      required: {
        config: 3
      },
      fieldLevelHelp: {
        config: 3
      },
      variant: {
        config: 3
      },
      dateStyle: {
        config: 3
      }
    },
    publicMethods: ["focus", "blur", "showHelpMessage", "hasBadInput"],
    track: {
      _disabled: 1,
      _readonly: 1,
      _required: 1,
      _value: 1,
      _calendarVisible: 1,
      _displayValue: 1,
      _errorMessage: 1,
      _fieldLevelHelp: 1,
      _variant: 1
    },
    fields: ["_min", "_max", "_messageWhenValueMissing", "_userMaxValue", "_userMinValue", "_displayMin", "_displayMax", "_dateStyle", "_ariaLabelledBy", "_ariaControls", "_ariaDetails", "_ariaDescribedBy"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningDatePicker, {
    tmpl: _tmpl,
    sel: "lightning-datepicker",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/label/LightningCombobox.ariaSelectedOptions', ['@view/forgotPassword/labels'], m => m[44]);
LWR.define('@salesforce/label/LightningCombobox.deselectOptionKeyboard', ['@view/forgotPassword/labels'], m => m[45]);
LWR.define('@salesforce/label/LightningCombobox.loadingText', ['@view/forgotPassword/labels'], m => m[46]);
LWR.define('@salesforce/label/LightningCombobox.pillCloseButtonAlternativeText', ['@view/forgotPassword/labels'], m => m[47]);
LWR.define('@salesforce/label/LightningCombobox.placeholder', ['@view/forgotPassword/labels'], m => m[48]);
(function() { LWR.define('lightning/icon', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/primitiveIcon', 'lightning/shadowBaseClassPrivate', 'lightning/utilsPrivate', 'lightning/iconUtils'], (function (exports, lwc, stylesheet0$1, _lightningPrimitiveIcon, LightningShadowBaseClass, utilsPrivate, iconUtils) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningPrimitiveIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveIcon);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) {" : hostSelector + "[data-render-mode=\"shadow\"] {")) + "display: inline-flex;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='boundary']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='boundary']")) + shadowSelector + " {padding-block-start: var(\n --sds-c-icon-spacing-blockstart,\n var(--sds-c-icon-spacing-block, var(--sds-c-icon-spacing, var(--sds-s-icon-spacing)))\n );padding-block-end: var(\n --sds-c-icon-spacing-blockend,\n var(--sds-c-icon-spacing-block, var(--sds-c-icon-spacing, var(--sds-s-icon-spacing)))\n );padding-inline-start: var(\n --sds-c-icon-spacing-inlinestart,\n var(--sds-c-icon-spacing-inline, var(--sds-c-icon-spacing, var(--sds-s-icon-spacing)))\n );padding-inline-end: var(\n --sds-c-icon-spacing-inlineend,\n var(--sds-c-icon-spacing-inline, var(--sds-c-icon-spacing, var(--sds-s-icon-spacing)))\n );border-radius: var(--sds-c-icon-radius-border, var(--sds-s-icon-radius-border));border-width: var(--sds-c-icon-sizing-border, var(--sds-s-icon-sizing-border));border-style: solid;border-color: var(--sds-c-icon-color-border, var(--sds-s-icon-color-border, transparent));background-color: var(--sds-c-icon-color-background, var(--sds-s-icon-color-background));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='icon']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='icon']")) + shadowSelector + " {display: flex;height: var(--sds-c-icon-sizing-height, var(--sds-c-icon-sizing, var(--sds-s-icon-sizing)));width: var(--sds-c-icon-sizing-width, var(--sds-c-icon-sizing, var(--sds-s-icon-sizing)));color: var(--sds-c-icon-color-foreground, var(--sds-s-icon-color-foreground));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) svg" : hostSelector + "[data-render-mode=\"shadow\"] svg")) + shadowSelector + " {width: 100%;height: 100%;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xxx-small']) {" : hostSelector + "[size='xxx-small'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-sizing: var(--slds-g-sizing-3);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) {" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-sizing: calc(var(--slds-g-sizing-1) + var(--slds-g-sizing-4));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) {" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-sizing: var(--slds-g-sizing-5);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) {" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-sizing: var(--slds-g-sizing-7);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) {" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-sizing: var(--slds-g-sizing-10);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='warning']) {" : hostSelector + "[variant='warning'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-color-foreground: var(--slds-g-color-warning-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='success']) {" : hostSelector + "[variant='success'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-color-foreground: var(--slds-g-color-success-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='error']) {" : hostSelector + "[variant='error'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='light']) {" : hostSelector + "[variant='light'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-color-foreground: var(--slds-g-color-neutral-base-70);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='boundary']" : hostSelector + "[data-render-mode=\"shadow\"] [part='boundary']")) + shadowSelector + " {--sds-c-icon-radius-border: var(--slds-c-icon-radius-border, var(--slds-g-radius-border-2));--sds-c-icon-sizing-border: var(--slds-c-icon-sizing-border);--sds-c-icon-color-border: var(--slds-c-icon-color-border);--sds-c-icon-spacing-block-start: var(\n --slds-c-icon-spacing-blockstart,\n var(--slds-c-icon-spacing-block)\n );--sds-c-icon-spacing-block-end: var(--slds-c-icon-spacing-blockend, var(--slds-c-icon-spacing-block));--sds-c-icon-spacing-inline-start: var(\n --slds-c-icon-spacing-inlinestart,\n var(--slds-c-icon-spacing-inline)\n );--sds-c-icon-spacing-inline-end: var(--slds-c-icon-spacing-inlineend, var(--slds-c-icon-spacing-inline));display: inline-flex;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='icon']" : hostSelector + "[data-render-mode=\"shadow\"] [part='icon']")) + shadowSelector + " {--sds-c-icon-color-foreground: var(--slds-c-icon-color-foreground, var(--slds-g-color-on-accent-1));--sds-c-icon-sizing-height: var(--slds-c-icon-sizing-height, var(--slds-c-icon-sizing, var(--slds-g-sizing-9)));--sds-c-icon-sizing-width: var(--slds-c-icon-sizing-width, var(--slds-c-icon-sizing, var(--slds-g-sizing-9)));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][icon-name*='action']) {" : hostSelector + "[icon-name*='action'][data-render-mode=\"shadow\"] {")) + "--slds-c-icon-spacing-block: var(--slds-g-sizing-3);--slds-c-icon-spacing-inline: var(--slds-g-sizing-3);--slds-c-icon-radius-border: calc(var(--slds-g-radius-border-circle) / 2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-icon-text-default" : hostSelector + "[data-render-mode=\"shadow\"] .slds-icon-text-default")) + shadowSelector + " {--slds-c-icon-color-foreground: var(\n --slds-c-icon-color-foreground-default,\n var(--sds-c-icon-color-foreground-default, var(\n --slds-g-color-on-surface-1))\n );}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-icon-text-default.slds-is-disabled" : hostSelector + "[data-render-mode=\"shadow\"] .slds-icon-text-default.slds-is-disabled")) + shadowSelector + " {fill: var(--slds-g-color-disabled-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")) + shadowSelector + " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-icon_disabled" : hostSelector + "[data-render-mode=\"shadow\"] .slds-icon_disabled")) + shadowSelector + " {background-color: currentcolor;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input__icon")) + shadowSelector + " {--slds-c-icon-sizing: calc(var(--slds-g-sizing-1) + var(--slds-g-sizing-4));position: absolute;top: 50%;margin-block-start: -0.4375rem;line-height: var(--slds-g-font-lineheight-1);border: 0;z-index: 2;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-input-pill-search-primicon]) .slds-icon" : hostSelector + "[data-input-pill-search-primicon][data-render-mode=\"shadow\"] .slds-icon")) + shadowSelector + " {--sds-c-icon-sizing-height: 1.25rem;--sds-c-icon-sizing-width: 1.25rem;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-input-pill-close-primicon]) [part=\"icon\"]" : hostSelector + "[data-input-pill-close-primicon][data-render-mode=\"shadow\"] [part=\"icon\"]")) + shadowSelector + " {--sds-c-icon-color-foreground: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-input-pill-close-primicon]) [part=\"icon\"]:hover" : hostSelector + "[data-input-pill-close-primicon][data-render-mode=\"shadow\"] [part=\"icon\"]:hover")) + shadowSelector + " {--sds-c-icon-color-foreground: var(--slds-g-color-accent-4);}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<span class="slds-assistive-text${0}"${2}>${"t1"}</span>`;
  const stc0 = {
    "part": "boundary"
  };
  const stc1 = {
    "exportparts": "icon"
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {c: api_custom_element, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment, h: api_element} = $api;
    return [api_element("span", {
      style: $cmp.iconBgColorStyle,
      attrs: stc0,
      key: 0
    }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon__default.default, {
      attrs: stc1,
      props: {
        "iconName": $cmp._iconName,
        "size": $cmp.size,
        "variant": $cmp.variant,
        "src": $cmp._src
      },
      key: 1
    }), $cmp.alternativeText ? api_static_fragment($fragment1, 3, [api_static_part(1, null, api_dynamic_text($cmp.alternativeText))]) : null])];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-4897l11qtae";
  tmpl.legacyStylesheetToken = "lightning-icon_icon";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  function normalizeVariant(variant, iconName) {
    // Unfortunately, the `bare` variant was implemented to do what the
    // `inverse` variant should have done. Keep this logic for as long as
    // we support the `bare` variant.
    if (variant === 'bare') {
      // TODO: Deprecation warning using strippable assertion
      variant = 'inverse';
    }
    if (iconUtils.getCategory(iconName) === 'utility') {
      return utilsPrivate.normalizeString(variant, {
        fallbackValue: '',
        validValues: ['error', 'inverse', 'warning', 'success']
      });
    }
    return 'inverse';
  }

  /**
   * Represents a visual element that provides context and enhances usability.
   */
  class LightningIcon extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      this._src = void 0;
      this._privateIconName = void 0;
      this._iconName = void 0;
      this._size = void 0;
      this._variant = void 0;
      /**
       * The alternative text used to describe the icon.
       * This text should describe what happens when you click the button,
       * for example 'Upload File', not what the icon looks like, 'Paperclip'.
       * @type {string}
       */
      this.alternativeText = void 0;
    }
    /**
     * A uri path to a custom svg sprite, including the name of the resouce,
     * for example: /assets/icons/standard-sprite/svg/test.svg#icon-heart
     * @type {string}
     */
    get src() {
      return this.privateSrc;
    }
    set src(value) {
      this.privateSrc = value;

      // if value is not present, then we set the state back
      // to the original iconName that was passed
      // this might happen if the user sets a custom icon, then
      // decides to revert back to SLDS by removing the src attribute
      if (!value) {
        this.updateIconName(this.iconName);
      }

      // if isIE11 and the src is set
      // we'd like to show the 'standard:default' icon instead
      // for performance reasons.
      if (value && utilsPrivate.isIE11) {
        this.setDefault();
        return;
      }
      this._src = value;
    }

    /**
     * The Lightning Design System name of the icon.
     * Names are written in the format 'utility:down' where 'utility' is the category,
     * and 'down' is the specific icon to be displayed.
     * @type {string}
     * @required
     */
    get iconName() {
      return this._privateIconName;
    }
    set iconName(value) {
      this._privateIconName = value;

      // if src is set, we don't need to validate iconName
      if (this.src) {
        return;
      }
      this.updateIconName(value);
    }

    /**
     * Update the attributes and css classes on the host element, based on the given icon name
     */
    updateIconName(iconName) {
      if (iconName === this._iconName) {
        return;
      }
      const classes = {};
      if (typeof this._iconName !== 'undefined') {
        const oldIconClass = iconUtils.computeSldsClass(this._iconName);
        Object.assign(classes, {
          [oldIconClass]: false
        });
      }
      if (iconUtils.isValidName(iconName)) {
        const isAction = iconUtils.getCategory(iconName) === 'action';
        const iconClass = iconUtils.computeSldsClass(iconName);
        Object.assign(classes, {
          // action icons have circle background
          'slds-icon_container_circle': isAction,
          [iconClass]: true
        });
        this._iconName = iconName;
        this.setAttribute('icon-name', iconName);
      } else {
        console.warn(`<lightning-icon> Invalid icon name ${iconName}`); // eslint-disable-line no-console

        // Invalid icon names should render a blank icon. Remove any
        // classes that might have been previously added.
        Object.assign(classes, {
          'slds-icon_container_circle': false
        });
        this._iconName = undefined;
        this.removeAttribute('icon-name');
      }
      utilsPrivate.classListMutation(this.classList, classes);
    }

    /**
     * The size of the icon. Options include xx-small, x-small, small, medium, or large.
     * The default is medium.
     * @type {string}
     * @default medium
     */
    get size() {
      return utilsPrivate.normalizeString(this._size, {
        fallbackValue: 'medium',
        validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
      });
    }
    set size(value) {
      this._size = value;
    }

    /**
     * The variant changes the appearance of a utility icon.
     * Accepted variants include inverse, success, warning, and error.
     * Use the inverse variant to implement a white fill in utility icons on dark backgrounds.
     * @type {string}
     */
    get variant() {
      return normalizeVariant(this._variant, this._iconName);
    }
    set variant(value) {
      this._variant = value;
    }
    connectedCallback() {
      super.connectedCallback();
      this.classList.add('slds-icon_container');
    }
    renderedCallback() {
      const hostElement = this.template.host;
      const attributeValue = hostElement.hasAttribute('data-input-pill-search-icon');
      if (attributeValue) {
        utilsPrivate.reflectAttribute(this.template.querySelector('lightning-primitive-icon'), 'data-input-pill-search-primicon', true);
      }
    }
    setDefault() {
      this._src = undefined;
      this.updateIconName('standard:default');
    }
    get iconBgColorStyle() {
      // we set the bg color from the SLDS provided fall back colors
      // for performance reasons.
      const iconName = this.iconName;
      if (iconUtils.isValidName(iconName)) {
        const sdsStylingHook = '--sds-c-icon-color-background';
        const sldsStylingHook = '--slds-c-icon-color-background';
        const fallBackColor = 'transparent';
        const color = iconUtils.getIconColor(iconName);
        const colorToUse = color ? color : fallBackColor;
        // setting SDS based hook instead of background-color on the boundary element
        // so this will work in NS and synthetic.
        return `${sdsStylingHook}: var(${sldsStylingHook}, ${colorToUse})`;
      }
      return '';
    }
    /*LWC compiler v7.1.5*/
  }
  LightningIcon.validationOptOut = ['class'];
  lwc.registerDecorators(LightningIcon, {
    publicProps: {
      alternativeText: {
        config: 0
      },
      src: {
        config: 3
      },
      iconName: {
        config: 3
      },
      size: {
        config: 3
      },
      variant: {
        config: 3
      }
    },
    fields: ["_src", "_privateIconName", "_iconName", "_size", "_variant"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningIcon, {
    tmpl: _tmpl,
    sel: "lightning-icon",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/sldsMediaObject', ['exports'], (function (exports) {

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      return ".slds-media" + shadowSelector + " {display: flex;align-items: flex-start;}.slds-media__figure" + shadowSelector + " {flex-shrink: 0;margin-inline-end: var(--slds-g-spacing-3);}.slds-media__figure_fixed-width" + shadowSelector + " {min-width: var(--slds-g-sizing-10);}.slds-media__body" + shadowSelector + " {flex: 1;min-width: 0;}.slds-media__body" + shadowSelector + ",.slds-media__body" + shadowSelector + "> :last-child" + shadowSelector + " {margin-block-end: 0;}.slds-media-body-iefix" + shadowSelector + " {flex-shrink: 0;flex-basis: auto;}.slds-media_small" + shadowSelector + " .slds-media__figure" + shadowSelector + " {margin-inline-end: var(--slds-g-spacing-1);}.slds-media_small" + shadowSelector + " .slds-media__figure_reverse" + shadowSelector + " {margin-inline-start: var(--slds-g-spacing-1);}.slds-media_large" + shadowSelector + " .slds-media__figure" + shadowSelector + " {margin-inline-end: var(--slds-g-spacing-5);}.slds-media_large" + shadowSelector + " .slds-media__figure_reverse" + shadowSelector + " {margin-inline-start: var(--slds-g-spacing-5);}.slds-media_inline" + shadowSelector + " .slds-media__body" + shadowSelector + " {flex: 0 1 auto;}.slds-media_center" + shadowSelector + " {align-items: center;}.slds-media__figure_reverse" + shadowSelector + " {margin-block: 0;margin-inline-start: var(--slds-g-spacing-3);margin-inline-end: 0;}@media (width <= 48em) {.slds-media_responsive" + shadowSelector + " {display: block;}.slds-media_responsive" + shadowSelector + " .slds-media__figure" + shadowSelector + " {margin-block: 0;margin-inline-start: var(--slds-g-spacing-3);margin-inline-end: 0;}}";
      /*LWC compiler v7.1.5*/
    }
    var sldsMediaObject = [stylesheet];

    exports.default = sldsMediaObject;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/baseComboboxFormattedText', ['exports', 'lwc', 'lightning/shadowBaseClassPrivate'], (function (exports, lwc, LightningShadowBaseClass) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

    const $fragment1 = lwc.parseFragment`<strong${3}>${"t1"}</strong>`;
    const stc0 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {k: api_key, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment, t: api_text, i: api_iterator, f: api_flatten} = $api;
      return api_flatten([$cmp.hasParts ? api_iterator($cmp.text, function (item) {
        return [item.part.highlight ? api_static_fragment($fragment1, api_key(1, item.key), [api_static_part(1, null, api_dynamic_text(item.part.text))]) : null, !item.part.highlight ? api_text(api_dynamic_text(item.part.text)) : null];
      }) : stc0, !$cmp.hasParts ? api_text(api_dynamic_text($cmp.text)) : null]);
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-2bf7evhq2m0";
    tmpl.legacyStylesheetToken = "lightning-baseComboboxFormattedText_baseComboboxFormattedText";
    lwc.freezeTemplate(tmpl);

    class LightningBaseComboboxFormattedText extends LightningShadowBaseClass__default.default {
      constructor(...args) {
        super(...args);
        this._text = '';
        this.hasParts = void 0;
      }
      get text() {
        return this._text;
      }
      set text(value) {
        this.hasParts = Array.isArray(value) && value.length > 0;
        if (this.hasParts) {
          // Generate keys for LWC DOM
          this._text = value.map((part, i) => ({
            part,
            key: i
          }));
        } else {
          this._text = value;
        }
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(LightningBaseComboboxFormattedText, {
      publicProps: {
        text: {
          config: 3
        }
      },
      track: {
        _text: 1,
        hasParts: 1
      }
    });
    const __lwc_component_class_internal = lwc.registerComponent(LightningBaseComboboxFormattedText, {
      tmpl: _tmpl,
      sel: "lightning-base-combobox-formatted-text",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/baseComboboxItem', ['exports', 'lwc', 'lightning/shadowBaseClassPrivate', 'lightning/sldsCommon', 'lightning/sldsMediaObject', 'lightning/icon', 'lightning/baseComboboxFormattedText'], (function (exports, lwc, LightningShadowBaseClass, stylesheet0$2, stylesheet1, _lightningIcon, _lightningBaseComboboxFormattedText) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);
  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$2);
  var stylesheet1__default = /*#__PURE__*/_interopDefaultCompat(stylesheet1);
  var _lightningIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningIcon);
  var _lightningBaseComboboxFormattedText__default = /*#__PURE__*/_interopDefaultCompat(_lightningBaseComboboxFormattedText);

  var _tmpl = void 0;

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_horizontal" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_horizontal")), shadowSelector, " {display: inline-flex;flex-wrap: wrap;align-items: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_horizontal" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_horizontal")), shadowSelector, " li", shadowSelector, " {display: flex;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_horizontal" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_horizontal")), shadowSelector, " li", shadowSelector, "+li", shadowSelector, " {padding-inline-start: 0.125rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option:hover" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option:hover" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option.slds-has-focus", shadowSelector, " {background-color: var(--slds-g-color-surface-container-2);text-decoration: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option[aria-disabled=\"true\"]" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option[aria-disabled=\"true\"]" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option[role=\"presentation\"]:hover", shadowSelector, " {background-color: transparent;cursor: default;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option_entity", shadowSelector, " {padding-block: var(--slds-g-spacing-1);padding-inline: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option_plain", shadowSelector, " {padding-block: var(--slds-g-spacing-2);padding-inline: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option_term", shadowSelector, " {padding-block: var(--slds-g-spacing-2);padding-inline: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option:hover" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option:hover")), shadowSelector, " {cursor: pointer;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option:focus" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option:focus")), shadowSelector, " {outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option[aria-disabled=\"true\"]" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option[aria-disabled=\"true\"]")), shadowSelector, " {color: var(--slds-g-color-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option_entity", shadowSelector, " .slds-media__figure", shadowSelector, " {margin-inline-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option_has-meta", shadowSelector, " .slds-media__figure", shadowSelector, " {margin-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option")), shadowSelector, " .slds-truncate", shadowSelector, " {display: inline-block;vertical-align: middle;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option-header" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option-header")), shadowSelector, " {font-size: var(--slds-g-font-scale-neg-1);font-weight: 700;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option-icon")), shadowSelector, " {width: var(--slds-g-sizing-7);display: inline-flex;align-content: center;align-items: center;justify-content: center;color: var(--slds-g-color-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option[aria-disabled=\"true\"]" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option[aria-disabled=\"true\"]")), shadowSelector, " .slds-listbox__option-icon", shadowSelector, " {color: currentcolor;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__icon-selected" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__icon-selected")), shadowSelector, " {opacity: 0;fill: var(--slds-g-color-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option.slds-is-selected" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option.slds-is-selected")), shadowSelector, " .slds-listbox__icon-selected", shadowSelector, " {opacity: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option.slds-is-selected" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option.slds-is-selected")), shadowSelector, " .slds-listbox__option-icon", shadowSelector, " {color: var(--slds-g-color-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option-text_entity" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option-text_entity")), shadowSelector, " {max-width: 100%;overflow: hidden;text-overflow: ellipsis;white-space: nowrap;display: block;margin-block-end: 0.125rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option-meta" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option-meta")), shadowSelector, " {display: block;margin-block-start: calc(var(--slds-g-spacing-1) * -1);color: var(--slds-g-color-neutral-base-30);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option[aria-disabled=\"true\"]" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option[aria-disabled=\"true\"]")), shadowSelector, " .slds-listbox__option-meta", shadowSelector, " {color: currentcolor;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group")), shadowSelector, " {position: relative;padding: 0;padding-inline-end: calc(var(--slds-g-spacing-8) + var(--slds-g-spacing-3));height: 1.875rem;overflow: hidden;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group.slds-is-expanded" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group.slds-is-expanded")), shadowSelector, " {height: auto;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group")), shadowSelector, " .slds-listbox", shadowSelector, " {padding-block-start: 0;padding-block-end: 0.125rem;padding-inline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group")), shadowSelector, " .slds-listbox-item", shadowSelector, " {padding-block-start: 0.125rem;padding-block-end: 0;padding-inline: 0.125rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group")), shadowSelector, " .slds-listbox-toggle", shadowSelector, " {position: absolute;top: 50%;transform: translateY(-50%);right: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group")), shadowSelector, " .slds-listbox-toggle", shadowSelector, " .slds-button", shadowSelector, " {line-height: 1;}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet2 = [stylesheet];

  var stylesheet0$1 = [stylesheet0__default.default, stylesheet1__default.default, stylesheet2];

  var _implicitStylesheets$1 = [stylesheet0$1];

  const $fragment1$1 = lwc.parseFragment`<span class="slds-truncate${0}"${"a0:title"}${2}>${"t1"}</span>`;
  const $fragment2 = lwc.parseFragment`<span class="slds-truncate${0}"${"a0:title"}${2}>${"t1"}</span>`;
  const stc0$1 = {
    classMap: {
      "slds-media__figure": true,
      "slds-listbox__option-icon": true
    },
    key: 0
  };
  const stc1$1 = {
    classMap: {
      "slds-media__body": true
    },
    key: 2
  };
  const stc2$1 = {
    classMap: {
      "slds-listbox__option-text": true,
      "slds-listbox__option-text_entity": true
    },
    key: 3
  };
  const stc3 = {
    "slds-truncate": true
  };
  const stc4 = {
    classMap: {
      "slds-listbox__option-meta": true,
      "slds-listbox__option-meta_entity": true
    },
    key: 7
  };
  const stc5 = {
    classMap: {
      "slds-media__figure": true,
      "slds-media__figure_reverse": true
    },
    key: 11
  };
  function tmpl$1($api, $cmp, $slotset, $ctx) {
    const {c: api_custom_element, h: api_element, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment} = $api;
    return [api_element("span", stc0$1, [$cmp.item.iconName ? api_custom_element("lightning-icon", _lightningIcon__default.default, {
      props: {
        "size": $cmp.iconSize,
        "alternativeText": $cmp.item.iconAlternativeText,
        "iconName": $cmp.item.iconName
      },
      key: 1
    }) : null]), api_element("span", stc1$1, [api_element("span", stc2$1, [!$cmp.textHasParts ? api_static_fragment($fragment1$1, 5, [api_static_part(0, {
      attrs: {
        "title": $cmp.item.text
      }
    }, null), api_static_part(1, null, api_dynamic_text($cmp.item.text))]) : null, $cmp.textHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText__default.default, {
      classMap: stc3,
      props: {
        "title": $cmp.text,
        "text": $cmp.item.text
      },
      key: 6
    }) : null]), $cmp.hasSubText ? api_element("span", stc4, [!$cmp.subTextHasParts ? api_static_fragment($fragment2, 9, [api_static_part(0, {
      attrs: {
        "title": $cmp.item.subText
      }
    }, null), api_static_part(1, null, api_dynamic_text($cmp.item.subText))]) : null, $cmp.subTextHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText__default.default, {
      classMap: stc3,
      props: {
        "title": $cmp.subText,
        "text": $cmp.item.subText
      },
      key: 10
    }) : null]) : null]), $cmp.item.rightIconName ? api_element("span", stc5, [api_custom_element("lightning-icon", _lightningIcon__default.default, {
      props: {
        "size": $cmp.rightIconSize,
        "alternativeText": $cmp.item.rightIconAlternativeText,
        "iconName": $cmp.item.rightIconName
      },
      key: 12
    })]) : null];
    /*LWC compiler v7.1.5*/
  }
  var card = lwc.registerTemplate(tmpl$1);
  tmpl$1.stylesheets = [];
  tmpl$1.stylesheetToken = "lwc-3povdhm22r3";
  tmpl$1.legacyStylesheetToken = "lightning-baseComboboxItem_card";
  if (_implicitStylesheets$1) {
    tmpl$1.stylesheets.push.apply(tmpl$1.stylesheets, _implicitStylesheets$1);
  }
  lwc.freezeTemplate(tmpl$1);

  var stylesheet0 = [stylesheet0__default.default, stylesheet1__default.default, stylesheet2];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<span class="slds-truncate${0}"${"a0:title"}${2}>${"t1"}</span>`;
  const stc0 = {
    classMap: {
      "slds-media__figure": true,
      "slds-listbox__option-icon": true
    },
    key: 0
  };
  const stc1 = {
    classMap: {
      "slds-media__body": true
    },
    key: 2
  };
  const stc2 = {
    "slds-truncate": true
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {c: api_custom_element, h: api_element, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment} = $api;
    return [api_element("span", stc0, [$cmp.item.iconName ? api_custom_element("lightning-icon", _lightningIcon__default.default, {
      props: {
        "alternativeText": $cmp.item.iconAlternativeText,
        "iconName": $cmp.item.iconName,
        "size": "x-small"
      },
      key: 1
    }) : null]), api_element("span", stc1, [!$cmp.textHasParts ? api_static_fragment($fragment1, 4, [api_static_part(0, {
      attrs: {
        "title": $cmp.item.text
      }
    }, null), api_static_part(1, null, api_dynamic_text($cmp.item.text))]) : null, $cmp.textHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText__default.default, {
      classMap: stc2,
      props: {
        "text": $cmp.item.text,
        "title": $cmp.text
      },
      key: 5
    }) : null])];
    /*LWC compiler v7.1.5*/
  }
  var inline = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-7co8ha3nedg";
  tmpl.legacyStylesheetToken = "lightning-baseComboboxItem_inline";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  class LightningBaseComboboxItem extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      this.item = {};
    }
    connectedCallback() {
      super.connectedCallback();
      // We want to make sure that the item has 'aria-selected' if it's selectable
      if (this.item.selectable) {
        this.setAttribute('aria-selected', 'false');
      }
      if (this.item.type === 'option-inline') {
        this.classList.add('slds-media_small', 'slds-listbox__option_plain');
      } else {
        this.classList.add('slds-listbox__option_entity');
      }
    }
    get textHasParts() {
      const text = this.item.text;
      return text && Array.isArray(text) && text.length > 0;
    }
    get subTextHasParts() {
      const subText = this.item.subText;
      return subText && Array.isArray(subText) && subText.length > 0;
    }

    // Return html based on the specified item type
    render() {
      if (this.item.type === 'option-card') {
        return card;
      }
      return inline;
    }
    highlight() {
      this.toggleHighlight(true);
    }
    removeHighlight() {
      this.toggleHighlight(false);
    }
    toggleHighlight(highlighted) {
      if (this.item.selectable) {
        this.setAttribute('aria-selected', highlighted ? 'true' : 'false');
        this.classList.toggle('slds-has-focus', highlighted);
      }
    }

    // Parts are needed for highlighting
    partsToText(parts) {
      if (parts && Array.isArray(parts) && parts.length > 0) {
        return parts.map(part => part.text).join('');
      }
      return parts;
    }
    get rightIconSize() {
      return this.item.rightIconSize || 'small';
    }
    get iconSize() {
      return this.item.iconSize || 'small';
    }
    get text() {
      return this.partsToText(this.item.text);
    }
    get subText() {
      return this.partsToText(this.item.subText);
    }
    get hasSubText() {
      const subText = this.item.subText;
      return subText && subText.length > 0;
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(LightningBaseComboboxItem, {
    publicProps: {
      item: {
        config: 0
      }
    },
    publicMethods: ["highlight", "removeHighlight"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningBaseComboboxItem, {
    tmpl: _tmpl,
    sel: "lightning-base-combobox-item",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/sldsUtilsAlignment', ['exports'], (function (exports) {

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return ((useActualHostSelector ? ":host([data-render-mode='shadow']) .slds-align_absolute-center" : hostSelector + "[data-render-mode='shadow'] .slds-align_absolute-center")) + shadowSelector + " {display: flex;justify-content: center;align-content: center;align-items: center;margin: auto;}";
      /*LWC compiler v7.1.5*/
    }
    var sldsUtilsAlignment = [stylesheet];

    exports.default = sldsUtilsAlignment;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/spinner', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/shadowBaseClassPrivate', 'lightning/utils', 'lightning/utilsPrivate'], (function (exports, lwc, stylesheet0$1, LightningShadowBaseClass, utils, utilsPrivate) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    var suffixToken = token ? ("-" + token) : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " .slds-assistive-text", shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='backdrop']" : hostSelector + "[data-render-mode=\"shadow\"] [part='backdrop']")), shadowSelector, " {position: absolute;inset: 0;z-index: 9050;background-color: var(--_slds-c-spinner-backdrop-color-background, var(--slds-g-color-neutral-base-100));visibility: visible;opacity: 0.75;transition: opacity 0.2s ease, visibility 0s;transition-delay: 0s, 0.3s;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part='spinner']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {--_slds-c-spinner-color-background: var(---slds-g-color-accent-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='inverse']) [part='spinner']" : hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {--_slds-c-spinner-color-background: var(--slds-g-color-neutral-base-100);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) [part='spinner']" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {width: 2.75rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-b']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='large']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='large']) [part='spinner']" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::after," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::after {width: 0.625rem;height: 0.625rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-b']" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {top: -0.3125rem;left: -0.3125rem;animation-name: dotsBounceBefore-medium", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-b']" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {top: -0.3125rem;right: -0.3125rem;animation-name: dotsBounceAfter-medium", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='medium']) [part='spinner']" : hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {width: 2rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='medium']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-b']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='medium']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='medium']) [part='spinner']" : hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::after," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::after {width: 0.5rem;height: 0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='medium']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-b']" : hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {top: -0.25rem;left: -0.25rem;animation-name: dotsBounceBefore-medium", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='medium']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-b']" : hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {top: -0.25rem;right: -0.25rem;animation-name: dotsBounceAfter-medium", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) [part='spinner']" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {width: 1.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-b']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='small']) [part='spinner']" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::after," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::after {width: 0.25rem;height: 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-b']" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {top: -0.125rem;left: -0.125rem;animation-name: dotsBounceBefore-small", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-b']" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {width: 0.25rem;height: 0.25rem;top: -0.125rem;right: -0.125rem;animation-name: dotsBounceAfter-small", suffixToken, ";}@keyframes dotsBounceBefore-small", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(-0.375rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translate3d(0, 0, 0);}}@keyframes dotsBounceAfter-small", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(0.375rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translateX(0);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) [part='spinner']" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {width: 1rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-b']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='x-small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='x-small']) [part='spinner']" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::after," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::after {width: 0.25rem;height: 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-b']" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {top: -0.125rem;left: -0.125rem;animation-name: dotsBounceBefore-extraSmall", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-b']" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {top: -0.125rem;right: -0.125rem;animation-name: dotsBounceAfter-extraSmall", suffixToken, ";}@keyframes dotsBounceBefore-extraSmall", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(-0.25rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translate3d(0, 0, 0);}}@keyframes dotsBounceAfter-extraSmall", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(0.25rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translate3d(0, 0, 0);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) [part='spinner']" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {width: 0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-b']" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {width: 0.125rem;height: 0.125rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-b']" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {top: -0.0625rem;left: -0.0625rem;animation-name: dotsBounceBefore-extraExtraSmall", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-b']" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {top: -0.0625rem;right: -0.0625rem;animation-name: dotsBounceAfter-extraExtraSmall", suffixToken, ";}@keyframes dotsBounceBefore-extraExtraSmall", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.275, 0.0425, 0.34, 0.265);}80% {transform: translate3d(-0.125rem, 0, 0);animation-timing-function: cubic-bezier(0, 0.555, 0.35, 0.715);}100% {transform: translate3d(0, 0, 0);}}@keyframes dotsBounceAfter-extraExtraSmall", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {animation-timing-function: cubic-bezier(0.275, 0.0425, 0.34, 0.265);transform: translate3d(0, 0, 0);}80% {animation-timing-function: cubic-bezier(0, 0.555, 0.35, 0.715);transform: translate3d(0.125rem, 0, 0);}100% {transform: translate3d(0, 0, 0);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {position: absolute;top: 50%;width: 2rem;left: 50%;z-index: 9050;transform: translate(-50%, -50%) rotate(90deg);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, " {transform-origin: 50% 50%;will-change: transform;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, " {position: absolute;top: 0;left: 0;width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {content: '';position: absolute;background-color: var(--_slds-c-spinner-color-background, var(--slds-g-color-neutral-base-65));border-radius: 50%;animation-duration: 1000ms;animation-iteration-count: infinite;transform: translate3d(0, 0, 0);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-a']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']")), shadowSelector, " {transform: rotate(60deg);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, " {transform: rotate(120deg);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::before {animation-delay: -83.3333ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-a']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']")), shadowSelector, "::before {animation-delay: 83.3333ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {animation-delay: 250ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::after {animation-delay: 416.6667ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-a']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']")), shadowSelector, "::after {animation-delay: 583.3333ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {animation-delay: 750ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-b']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {width: 0.5rem;height: 0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {animation-name: dotsBounceBefore-medium", suffixToken, ";top: -0.25rem;left: -0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {animation-name: dotsBounceAfter-medium", suffixToken, ";top: -0.25rem;right: -0.25rem;}@keyframes dotsBounceBefore-medium", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(-0.5rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translate3d(0, 0, 0);}}@keyframes dotsBounceAfter-medium", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(0.5rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translateX(0);}}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<div part="backdrop"${3}></div>`;
  const $fragment2 = lwc.parseFragment`<span class="slds-assistive-text${0}"${2}>${"t1"}</span>`;
  const $fragment3 = lwc.parseFragment`<div part="dot-a" class="slds-spinner__dot-a${0}"${2}></div>`;
  const $fragment4 = lwc.parseFragment`<div part="dot-b" class="slds-spinner__dot-b${0}"${2}></div>`;
  const stc0 = {
    "role": "status",
    "part": "spinner"
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {st: api_static_fragment, ncls: api_normalize_class_name, d: api_dynamic_text, sp: api_static_part, h: api_element} = $api;
    return [api_static_fragment($fragment1, 1), api_element("div", {
      className: api_normalize_class_name($cmp.computedClass),
      attrs: stc0,
      key: 2
    }, [$cmp.validAlternativeText ? api_static_fragment($fragment2, 4, [api_static_part(1, null, api_dynamic_text($cmp._altText))]) : null, api_static_fragment($fragment3, 6), api_static_fragment($fragment4, 8)])];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-47dd688sbro";
  tmpl.legacyStylesheetToken = "lightning-spinner_spinner";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  const DEFAULT_SIZE = 'medium';
  const DEFAULT_VARIANT = 'base';

  /**
   * Displays an animated spinner.
   */
  class LightningSpinner extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      /**
       * The alternative text used to describe the reason for the wait and need for a spinner.
       * @type {string}
       */
      this.alternativeText = void 0;
      this._originalSize = DEFAULT_SIZE;
      this._privateSize = DEFAULT_SIZE;
      this._originalVariant = void 0;
      this._privateVariant = DEFAULT_VARIANT;
      this._altText = null;
    }
    /**
     * The size of the spinner. Accepted sizes are xx-small, x-small, small, medium, and large. This value defaults to medium.
     * @type {string}
     * @default medium
     */
    get size() {
      return this._originalSize;
    }
    set size(val) {
      this._originalSize = val;
      this._privateSize = this.normalizeSize(val);
      this.setAttribute('size', this._privateSize);
    }
    /**
     * The variant changes the appearance of the spinner.
     * Accepted variants include base, brand, and inverse. The default is base.
     * @type {string}
     * @default base
     */
    get variant() {
      return this._originalVariant;
    }
    set variant(val) {
      this._originalVariant = val;
      this._privateVariant = this.normalizeVariant(val);
      if (this._privateVariant !== DEFAULT_VARIANT) {
        this.setAttribute('variant', this._privateVariant);
      }
    }
    connectedCallback() {
      super.connectedCallback();
      this.classList.add('slds-spinner_container');
      if (utilsPrivate.isCSR) {
        this.template.addEventListener('mousewheel', this.stopScrolling);
        this.template.addEventListener('touchmove', this.stopScrolling);
      }
    }
    renderedCallback() {
      // [W-10320761] We set the _altText in the next tick because screen readers are not reading out
      // the text when the text along the aria-live container is inserted into the DOM together.
      // It is only working when only aria-live container is setup on load and later the content changes
      // eslint-disable-next-line @lwc/lwc/no-async-operation
      setTimeout(() => {
        this._altText = this.alternativeText;
      }, 0);
    }
    normalizeVariant(variant) {
      return utilsPrivate.normalizeString(variant, {
        fallbackValue: DEFAULT_VARIANT,
        validValues: ['base', 'brand', 'inverse']
      });
    }
    normalizeSize(size) {
      return utilsPrivate.normalizeString(size, {
        fallbackValue: DEFAULT_SIZE,
        validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
      });
    }
    get computedClass() {
      const classes = utils.classSet('slds-spinner');

      // add variant-specific class
      if (this._privateVariant !== DEFAULT_VARIANT) {
        classes.add(`slds-spinner_${this._privateVariant}`);
      }
      // add size-specific class
      classes.add(`slds-spinner_${this._privateSize}`);
      return classes.toString();
    }

    // alternativeText validation
    get validAlternativeText() {
      const hasAlternativeText = utilsPrivate.isCSR && !!this.alternativeText;

      // if we have an empty value output a console warning
      if (!hasAlternativeText) {
        // eslint-disable-next-line no-console
        console.warn(`<lightning-spinner> The alternativeText attribute should not be empty. Please add a description of what is causing the wait.`);
      }
      return hasAlternativeText;
    }

    // prevent scrolling
    stopScrolling(event) {
      event.preventDefault();
    }
    /*LWC compiler v7.1.5*/
  }
  LightningSpinner.validationOptOut = ['class'];
  lwc.registerDecorators(LightningSpinner, {
    publicProps: {
      alternativeText: {
        config: 0
      },
      size: {
        config: 3
      },
      variant: {
        config: 3
      }
    },
    fields: ["_originalSize", "_privateSize", "_originalVariant", "_privateVariant", "_altText"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningSpinner, {
    tmpl: _tmpl,
    sel: "lightning-spinner",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/baseCombobox', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/sldsUtilsAlignment', 'lightning/icon', 'lightning/primitiveIcon', 'lightning/baseComboboxItem', 'lightning/spinner', '@salesforce/label/LightningCombobox.ariaSelectedOptions', '@salesforce/label/LightningCombobox.deselectOptionKeyboard', '@salesforce/label/LightningCombobox.loadingText', '@salesforce/label/LightningCombobox.pillCloseButtonAlternativeText', '@salesforce/label/LightningCombobox.placeholder', 'lightning/shadowBaseClassPrivate', 'lightning/utilsPrivate', 'lightning/utils', 'lightning/positionLibrary', 'lightning/inputUtils', 'lightning/ariaObserver'], (function (exports, lwc, stylesheet0$1, stylesheet1$1, _lightningIcon, _lightningPrimitiveIcon, _lightningBaseComboboxItem, _lightningSpinner, labelAriaSelectedOptions, labelDeselectOptionKeyboard, labelLoadingText, labelPillCloseButtonAlternativeText, labelPlaceholder, LightningShadowBaseClass, utilsPrivate, utils, positionLibrary, inputUtils, AriaObserver) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
    var stylesheet1__default = /*#__PURE__*/_interopDefaultCompat(stylesheet1$1);
    var _lightningIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningIcon);
    var _lightningPrimitiveIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveIcon);
    var _lightningBaseComboboxItem__default = /*#__PURE__*/_interopDefaultCompat(_lightningBaseComboboxItem);
    var _lightningSpinner__default = /*#__PURE__*/_interopDefaultCompat(_lightningSpinner);
    var labelAriaSelectedOptions__default = /*#__PURE__*/_interopDefaultCompat(labelAriaSelectedOptions);
    var labelDeselectOptionKeyboard__default = /*#__PURE__*/_interopDefaultCompat(labelDeselectOptionKeyboard);
    var labelLoadingText__default = /*#__PURE__*/_interopDefaultCompat(labelLoadingText);
    var labelPillCloseButtonAlternativeText__default = /*#__PURE__*/_interopDefaultCompat(labelPillCloseButtonAlternativeText);
    var labelPlaceholder__default = /*#__PURE__*/_interopDefaultCompat(labelPlaceholder);
    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);
    var AriaObserver__default = /*#__PURE__*/_interopDefaultCompat(AriaObserver);

    function stylesheet$5(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      return ".slds-inline-logo" + shadowSelector + " {height: 1rem;margin-top: 1rem;margin-bottom: 1rem;}input[aria-readonly='true']" + shadowSelector + " {caret-color: transparent;}button:disabled" + shadowSelector + ",[type='button']:disabled" + shadowSelector + " {cursor: not-allowed;}.fix-slds-input_faux" + shadowSelector + " {line-height: max(1.875rem, calc(1.2em - 2px));}";
      /*LWC compiler v7.1.5*/
    }
    var stylesheet0 = [stylesheet$5];

    function stylesheet$4(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-combobox" : hostSelector + "[data-render-mode=\"shadow\"] .slds-combobox")), shadowSelector, " {position: static;display: flex;flex-direction: column;flex: 1 1 auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-combobox_container" : hostSelector + "[data-render-mode=\"shadow\"] .slds-combobox_container")), shadowSelector, " {display: flex;flex-direction: column;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input_faux" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input_faux")), shadowSelector, " {padding-block-start: 0;padding-block-end: 0;padding-inline-start: var(--slds-g-spacing-3);padding-inline-end: var(--slds-g-spacing-4);width: 100%;line-height: 1.875rem;border: var(--slds-c-inputtext-sizing-border, var(--slds-g-sizing-border-1)) solid\n var(--slds-c-inputtext-color-border, var(--slds-s-input-color-border));border-radius: var(--slds-c-inputtext-radius, var(--slds-g-radius-border-2));background-color: var(--slds-c-inputtext-color-background, var(--slds-g-color-surface-container-1));color: var(--slds-c-inputtext-text-color);transition: border 0.1s linear, background-color 0.1s linear;display: inline-flex;flex: 1 1 auto;text-align: left;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-input_faux" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-input_faux")), shadowSelector, " {box-shadow: 0 0 0 1px inset var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input_faux:not(.slds-combobox__input-value)" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input_faux:not(.slds-combobox__input-value)")), shadowSelector, " {--slds-c-inputtext-text-color: var(--slds-g-color-on-surface-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input_faux.slds-is-disabled" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input_faux.slds-is-disabled")), shadowSelector, " {background-color: var(--slds-g-color-disabled-container-1);border-color: var(--slds-g-color-border-1);color: var(--slds-g-color-on-surface-1);cursor: not-allowed;user-select: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input_faux.slds-is-disabled:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input_faux.slds-is-disabled:active" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input_faux.slds-is-disabled:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input_faux.slds-is-disabled:active")), shadowSelector, " {box-shadow: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input_faux" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input_faux")), shadowSelector, " > span", shadowSelector, "::before {content: '';display: inline-block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input_faux:focus-within" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input_faux:focus-within")), shadowSelector, " {border-color: var(--slds-g-color-brand-base-60);box-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-input__icon", shadowSelector, " {--slds-c-icon-sizing: 0.875rem;--slds-c-icon-color-foreground-default: var(--slds-g-color-on-surface-1);position: absolute;inset-block-start: 50%;margin-top: calc((0.875rem * 0.5) * -1);line-height: 1;border: 0;z-index: 2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-input__icon:not(button)", shadowSelector, " {pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left")), shadowSelector, " .slds-input__icon", shadowSelector, " {inset-inline-start: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left")), shadowSelector, " .slds-input_faux", shadowSelector, " {padding-inline-start: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right")), shadowSelector, " .slds-input__icon", shadowSelector, " {inset-inline-end: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right")), shadowSelector, " .slds-input_faux", shadowSelector, " {padding-inline-end: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input__icon-group" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input__icon-group")), shadowSelector, " {position: absolute;height: var(--slds-g-sizing-5);margin-block-start: calc(var(--slds-g-spacing-2) * -1 - 1px);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input__icon-group_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input__icon-group_right")), shadowSelector, " {inset-inline-end: 0;inset-block-start: 50%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input__icon-group_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input__icon-group_right")), shadowSelector, " .slds-input__icon_right", shadowSelector, " {inset-inline-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input__icon-group_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input__icon-group_right")), shadowSelector, " .slds-input__spinner", shadowSelector, " {inset-inline-end: var(--slds-g-spacing-5);inset-inline-start: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-p-top_medium" : hostSelector + "[data-render-mode=\"shadow\"] .slds-p-top_medium")), shadowSelector, " {padding-top: var(--slds-g-spacing-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-p-bottom_medium" : hostSelector + "[data-render-mode=\"shadow\"] .slds-p-bottom_medium")), shadowSelector, " {padding-bottom: var(--slds-g-spacing-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-spinner_inline" : hostSelector + "[data-render-mode=\"shadow\"] .slds-spinner_inline")), shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-filter]) button.slds-combobox__input" : hostSelector + "[data-filter][data-render-mode=\"shadow\"] button.slds-combobox__input")), shadowSelector, " {width: 7.5rem;transition: width 80ms linear;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-filter]) button.slds-combobox__input:focus" : hostSelector + "[data-filter][data-render-mode=\"shadow\"] button.slds-combobox__input:focus")), shadowSelector, " {width: 10rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-filter]) .slds-truncate" : hostSelector + "[data-filter][data-render-mode=\"shadow\"] .slds-truncate")), shadowSelector, " {max-width: 100%;overflow: hidden;text-overflow: ellipsis;white-space: nowrap;font-size: var(--slds-g-spacing-3);color: var(--slds-g-color-on-surface-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-filter-on]) [part=\"input-container\"]" : hostSelector + "[data-filter-on][data-render-mode=\"shadow\"] [part=\"input-container\"]")), shadowSelector, " {border-start-end-radius: var(--slds-g-sizing-border-4);border-end-end-radius: var(--slds-g-sizing-border-4);border-start-start-radius: 0;border-end-start-radius: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-filter]) .slds-combobox__input" : hostSelector + "[data-filter][data-render-mode=\"shadow\"] .slds-combobox__input")), shadowSelector, " {border-start-end-radius: 0;border-end-end-radius: 0;border-start-start-radius: var(--slds-g-sizing-border-4);border-end-start-radius: var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-input-pill]) [part=\"input\"]" : hostSelector + "[data-input-pill][data-render-mode=\"shadow\"] [part=\"input\"]")), shadowSelector, " {box-shadow: 0 0 0 var(--slds-g-sizing-border-2) var(--slds-g-color-surface-container-1) inset, 0 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-border-base-1, var(--slds-g-color-on-accent-1)) inset;border-radius: var(--slds-c-inputtext-radius, var(--slds-g-radius-border-2));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-input-pill]) .slds-combobox__input-entity-icon" : hostSelector + "[data-input-pill][data-render-mode=\"shadow\"] .slds-combobox__input-entity-icon")), shadowSelector, " {position: absolute;inset-block-start: 50%;inset-inline-start: calc(var(--slds-g-spacing-1) + var(--slds-g-sizing-border-1));z-index: 2;transform: translateY(-50%)}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-input-pill]) .slds-input__icon-group_right" : hostSelector + "[data-input-pill][data-render-mode=\"shadow\"] .slds-input__icon-group_right")), shadowSelector, " {inset-inline-end: calc(var(--slds-g-spacing-1) + var(--slds-g-sizing-border-1));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-input-pill]) .slds-button_icon" : hostSelector + "[data-input-pill][data-render-mode=\"shadow\"] .slds-button_icon")), shadowSelector, " {color: var(--slds-g-color-neutral-base-50, var(--slds-g-color-on-surface-1));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][data-input-pill]) [part=\"input-container\"]:focus-within" : hostSelector + "[data-input-pill][data-render-mode=\"shadow\"] [part=\"input-container\"]:focus-within")), shadowSelector, " {--sds-c-inputtext-color-border:\n var(--slds-g-color-brand-base-60);--sds-c-inputtext-shadow: none;}"].join('');
      /*LWC compiler v7.1.5*/
    }
    var stylesheet2 = [stylesheet$4];

    function stylesheet$3(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      var suffixToken = token ? ("-" + token) : "";
      return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " .slds-assistive-text", shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='backdrop']" : hostSelector + "[data-render-mode=\"shadow\"] [part='backdrop']")), shadowSelector, " {position: absolute;inset: 0;z-index: 9050;background-color: var(--_slds-c-spinner-backdrop-color-background, var(--slds-g-color-neutral-base-100));visibility: visible;opacity: 0.75;transition: opacity 0.2s ease, visibility 0s;transition-delay: 0s, 0.3s;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part='spinner']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {--_slds-c-spinner-color-background: var(---slds-g-color-accent-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='inverse']) [part='spinner']" : hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {--_slds-c-spinner-color-background: var(--slds-g-color-neutral-base-100);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) [part='spinner']" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {width: 2.75rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-b']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='large']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='large']) [part='spinner']" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::after," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::after {width: 0.625rem;height: 0.625rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-b']" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {top: -0.3125rem;left: -0.3125rem;animation-name: dotsBounceBefore-medium", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='large']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='large']) [part='dot-b']" : hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='large'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {top: -0.3125rem;right: -0.3125rem;animation-name: dotsBounceAfter-medium", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='medium']) [part='spinner']" : hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {width: 2rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='medium']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-b']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='medium']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='medium']) [part='spinner']" : hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::after," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::after {width: 0.5rem;height: 0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='medium']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-b']" : hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {top: -0.25rem;left: -0.25rem;animation-name: dotsBounceBefore-medium", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='medium']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='medium']) [part='dot-b']" : hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='medium'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {top: -0.25rem;right: -0.25rem;animation-name: dotsBounceAfter-medium", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) [part='spinner']" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {width: 1.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-b']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='small']) [part='spinner']" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::after," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::after {width: 0.25rem;height: 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-b']" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {top: -0.125rem;left: -0.125rem;animation-name: dotsBounceBefore-small", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='small']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='small']) [part='dot-b']" : hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {width: 0.25rem;height: 0.25rem;top: -0.125rem;right: -0.125rem;animation-name: dotsBounceAfter-small", suffixToken, ";}@keyframes dotsBounceBefore-small", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(-0.375rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translate3d(0, 0, 0);}}@keyframes dotsBounceAfter-small", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(0.375rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translateX(0);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) [part='spinner']" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {width: 1rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-b']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='x-small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='x-small']) [part='spinner']" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::after," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::after {width: 0.25rem;height: 0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-b']" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {top: -0.125rem;left: -0.125rem;animation-name: dotsBounceBefore-extraSmall", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='x-small']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='x-small']) [part='dot-b']" : hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='x-small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {top: -0.125rem;right: -0.125rem;animation-name: dotsBounceAfter-extraSmall", suffixToken, ";}@keyframes dotsBounceBefore-extraSmall", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(-0.25rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translate3d(0, 0, 0);}}@keyframes dotsBounceAfter-extraSmall", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(0.25rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translate3d(0, 0, 0);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) [part='spinner']" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {width: 0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-b']" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {width: 0.125rem;height: 0.125rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-b']" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {top: -0.0625rem;left: -0.0625rem;animation-name: dotsBounceBefore-extraExtraSmall", suffixToken, ";}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][size='xx-small']) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"][size='xx-small']) [part='dot-b']" : hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[size='xx-small'][data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {top: -0.0625rem;right: -0.0625rem;animation-name: dotsBounceAfter-extraExtraSmall", suffixToken, ";}@keyframes dotsBounceBefore-extraExtraSmall", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.275, 0.0425, 0.34, 0.265);}80% {transform: translate3d(-0.125rem, 0, 0);animation-timing-function: cubic-bezier(0, 0.555, 0.35, 0.715);}100% {transform: translate3d(0, 0, 0);}}@keyframes dotsBounceAfter-extraExtraSmall", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {animation-timing-function: cubic-bezier(0.275, 0.0425, 0.34, 0.265);transform: translate3d(0, 0, 0);}80% {animation-timing-function: cubic-bezier(0, 0.555, 0.35, 0.715);transform: translate3d(0.125rem, 0, 0);}100% {transform: translate3d(0, 0, 0);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, " {position: absolute;top: 50%;width: 2rem;left: 50%;z-index: 9050;transform: translate(-50%, -50%) rotate(90deg);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, " {transform-origin: 50% 50%;will-change: transform;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, " {position: absolute;top: 0;left: 0;width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-b']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {content: '';position: absolute;background-color: var(--_slds-c-spinner-color-background, var(--slds-g-color-neutral-base-65));border-radius: 50%;animation-duration: 1000ms;animation-iteration-count: infinite;transform: translate3d(0, 0, 0);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-a']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']")), shadowSelector, " {transform: rotate(60deg);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, " {transform: rotate(120deg);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::before {animation-delay: -83.3333ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-a']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']")), shadowSelector, "::before {animation-delay: 83.3333ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {animation-delay: 250ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']")), shadowSelector, "::after {animation-delay: 416.6667ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-a']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']")), shadowSelector, "::after {animation-delay: 583.3333ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {animation-delay: 750ms;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-b']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {width: 0.5rem;height: 0.5rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::before {animation-name: dotsBounceBefore-medium", suffixToken, ";top: -0.25rem;left: -0.25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='spinner']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-a']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='dot-b']" : hostSelector + "[data-render-mode=\"shadow\"] [part='spinner']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-a']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='dot-b']")), shadowSelector, "::after {animation-name: dotsBounceAfter-medium", suffixToken, ";top: -0.25rem;right: -0.25rem;}@keyframes dotsBounceBefore-medium", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(-0.5rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translate3d(0, 0, 0);}}@keyframes dotsBounceAfter-medium", suffixToken, " {0% {transform: translate3d(0, 0, 0);}60% {transform: translate3d(0, 0, 0);animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);}80% {transform: translate3d(0.5rem, 0, 0);animation-timing-function: cubic-bezier(0, 1.11, 0.7, 1.43);}100% {transform: translateX(0);}}"].join('');
      /*LWC compiler v7.1.5*/
    }
    var stylesheet3 = [stylesheet$3];

    function stylesheet$2(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_horizontal" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_horizontal")), shadowSelector, " {display: inline-flex;flex-wrap: wrap;align-items: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_horizontal" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_horizontal")), shadowSelector, " li", shadowSelector, " {display: flex;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_horizontal" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_horizontal")), shadowSelector, " li", shadowSelector, "+li", shadowSelector, " {padding-inline-start: 0.125rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option:hover" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option:hover" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option.slds-has-focus", shadowSelector, " {background-color: var(--slds-g-color-surface-container-2);text-decoration: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option[aria-disabled=\"true\"]" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical" + shadowSelector + " .slds-listbox__option[aria-disabled=\"true\"]" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option[role=\"presentation\"]:hover", shadowSelector, " {background-color: transparent;cursor: default;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option_entity", shadowSelector, " {padding-block: var(--slds-g-spacing-1);padding-inline: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option_plain", shadowSelector, " {padding-block: var(--slds-g-spacing-2);padding-inline: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option_term", shadowSelector, " {padding-block: var(--slds-g-spacing-2);padding-inline: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option:hover" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option:hover")), shadowSelector, " {cursor: pointer;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option:focus" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option:focus")), shadowSelector, " {outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option[aria-disabled=\"true\"]" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option[aria-disabled=\"true\"]")), shadowSelector, " {color: var(--slds-g-color-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option_entity", shadowSelector, " .slds-media__figure", shadowSelector, " {margin-inline-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_vertical" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_vertical")), shadowSelector, " .slds-listbox__option_has-meta", shadowSelector, " .slds-media__figure", shadowSelector, " {margin-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option")), shadowSelector, " .slds-truncate", shadowSelector, " {display: inline-block;vertical-align: middle;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option-header" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option-header")), shadowSelector, " {font-size: var(--slds-g-font-scale-neg-1);font-weight: 700;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option-icon")), shadowSelector, " {width: var(--slds-g-sizing-7);display: inline-flex;align-content: center;align-items: center;justify-content: center;color: var(--slds-g-color-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option[aria-disabled=\"true\"]" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option[aria-disabled=\"true\"]")), shadowSelector, " .slds-listbox__option-icon", shadowSelector, " {color: currentcolor;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__icon-selected" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__icon-selected")), shadowSelector, " {opacity: 0;fill: var(--slds-g-color-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option.slds-is-selected" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option.slds-is-selected")), shadowSelector, " .slds-listbox__icon-selected", shadowSelector, " {opacity: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option.slds-is-selected" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option.slds-is-selected")), shadowSelector, " .slds-listbox__option-icon", shadowSelector, " {color: var(--slds-g-color-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option-text_entity" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option-text_entity")), shadowSelector, " {max-width: 100%;overflow: hidden;text-overflow: ellipsis;white-space: nowrap;display: block;margin-block-end: 0.125rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option-meta" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option-meta")), shadowSelector, " {display: block;margin-block-start: calc(var(--slds-g-spacing-1) * -1);color: var(--slds-g-color-neutral-base-30);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox__option[aria-disabled=\"true\"]" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox__option[aria-disabled=\"true\"]")), shadowSelector, " .slds-listbox__option-meta", shadowSelector, " {color: currentcolor;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group")), shadowSelector, " {position: relative;padding: 0;padding-inline-end: calc(var(--slds-g-spacing-8) + var(--slds-g-spacing-3));height: 1.875rem;overflow: hidden;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group.slds-is-expanded" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group.slds-is-expanded")), shadowSelector, " {height: auto;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group")), shadowSelector, " .slds-listbox", shadowSelector, " {padding-block-start: 0;padding-block-end: 0.125rem;padding-inline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group")), shadowSelector, " .slds-listbox-item", shadowSelector, " {padding-block-start: 0.125rem;padding-block-end: 0;padding-inline: 0.125rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group")), shadowSelector, " .slds-listbox-toggle", shadowSelector, " {position: absolute;top: 50%;transform: translateY(-50%);right: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-listbox_selection-group" : hostSelector + "[data-render-mode=\"shadow\"] .slds-listbox_selection-group")), shadowSelector, " .slds-listbox-toggle", shadowSelector, " .slds-button", shadowSelector, " {line-height: 1;}"].join('');
      /*LWC compiler v7.1.5*/
    }
    var stylesheet4 = [stylesheet$2];

    function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {display: flex;align-items: center;gap: var(--sds-c-inputtext-spacing-gap, var(--sds-s-input-spacing-gap));min-height: var(--sds-c-inputtext-sizing-height, var(--sds-s-input-sizing-height));padding-inline-start: var(\n --sds-c-inputtext-spacing-inlinestart,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-spacing-inlineend,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-spacing-blockstart,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-spacing-blockend,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );background: var(--sds-c-inputtext-color-background, var(--sds-s-input-color-background));border-block-start: var(\n --sds-c-inputtext-sizing-border-blockstart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockstart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-start: var(\n --sds-c-inputtext-sizing-border-inlinestart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlinestart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-end: var(\n --sds-c-inputtext-sizing-border-inlineend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlineend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-block-end: var(\n --sds-c-inputtext-sizing-border-blockend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-radius: var(--sds-c-inputtext-radius-border, var(--sds-s-input-radius-border));box-shadow: var(--sds-c-inputtext-shadow, var(--sds-s-input-shadow));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, " {width: 100%;height: 100%;padding: 0;font-size: var(--sds-c-inputtext-font-size, var(--sds-s-input-font-size));color: var(--sds-c-inputtext-text-color, var(--sds-s-input-text-color));line-height: 1;border: none;background: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][active]) [part~='input-container']" : hostSelector + "[active][data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-active,\n var(--sds-s-input-color-background-active)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-active,\n var(--sds-s-input-color-border-active)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-active, var(--sds-s-input-shadow-active));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, "::placeholder {color: var(--sds-c-inputtext-text-color-placeholder, var(--sds-s-input-text-color-placeholder));font-style: var(--sds-c-inputtext-font-style-placeholder, var(--sds-s-input-font-style-placeholder));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']:focus-within" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-focus,\n var(--sds-s-input-color-border-focus, revert)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-focus, var(--sds-s-input-shadow-focus));--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-focus,\n var(--sds-s-input-color-background-focus, revert)\n );--sds-c-inputtext-text-color: var(\n --sds-c-inputtext-text-color-focus,\n var(--sds-s-input-text-color-focus, revert)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']:focus")), shadowSelector, " {outline: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {display: inline-flex;align-items: center;gap: var(--sds-c-inputtext-label-spacing-gap, var(--sds-s-label-spacing-gap));padding-inline-start: var(\n --sds-c-inputtext-label-spacing-inlinestart,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-label-spacing-inlineend,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-label-spacing-blockstart,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-label-spacing-blockend,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );color: var(--sds-c-inputtext-label-color, var(--sds-s-label-color));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {font-size: var(--sds-c-inputtext-label-font-size, var(--sds-s-label-font-size));font-weight: var(--sds-c-inputtext-label-font-weight, var(--sds-s-label-font-weight));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='help-text visible']" : hostSelector + "[data-render-mode=\"shadow\"] [part='help-text visible']")), shadowSelector, " {font-size: var(--sds-c-inputtext-helptext-font-size, var(--sds-s-helptext-font-size));color: var(--sds-c-inputtext-helptext-text-color, var(--sds-s-helptext-text-color));padding-inline-start: var(\n --sds-c-inputtext-helptext-spacing-inlinestart,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-helptext-spacing-inlineend,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-helptext-spacing-blockstart,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-helptext-spacing-blockend,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) {" : hostSelector + "[disabled][data-render-mode=\"shadow\"] {")), "--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-disabled,\n var(--sds-s-input-color-background-disabled)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-disabled,\n var(--sds-s-input-color-border-disabled)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][label-hidden]) [part='label-container']" : hostSelector + "[label-hidden][data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-inputtext-icon-color-foreground,\n var(--slds-g-color-on-surface-1)\n );--slds-c-icon-sizing: var(--slds-c-inputtext-icon-sizing, 14px);--sds-c-inputtext-sizing-height: var(\n --slds-c-inputtext-sizing-height,\n var(--slds-g-sizing-9)\n );--sds-c-inputtext-color-background: var(\n --slds-c-inputtext-color-background,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-color-background-focus: var(\n --slds-c-inputtext-color-background-focus,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-text-color: var(--slds-c-inputtext-text-color);--sds-c-inputtext-font-size: var(\n --slds-c-inputtext-font-size,\n var(--slds-g-font-size-base)\n );--sds-c-inputtext-text-color-placeholder: var(\n --slds-c-inputtext-text-color-placeholder,\n var(--slds-g-color-on-surface-1)\n );--sds-c-inputtext-color-border: var(\n --slds-c-inputtext-color-border,\n var(--slds-g-color-border-2)\n );--sds-c-inputtext-sizing-border: var(--slds-c-inputtext-sizing-border);--sds-c-inputtext-radius-border: var(\n --slds-c-inputtext-radius-border,\n var(--slds-g-radius-border-2)\n );display: flex;flex-wrap: wrap;flex-direction: column;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {flex: 1 0 100%;align-items: stretch;--sds-c-inputtext-spacing-inline: 0;--sds-c-inputtext-spacing-block: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']")), shadowSelector, " {border: none;display: inline-block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " .slds-input__icon:not(button)", shadowSelector, " {pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input'][type='range']")), shadowSelector, " {min-height: calc(1.875rem + (1px * 2));margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:focus-within" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 3px var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;border-width: var(--sds-c-inputtext-sizing-border, var(--slds-g-sizing-border-1));border-color: var(--sds-c-inputtext-color-border, var(--slds-g-color-border-2));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {padding-inline-start: var(\n --slds-c-inputtext-spacing-inlinestart,\n var(--slds-g-spacing-3));padding-inline-end: var(\n --slds-c-inputtext-spacing-inlineend,\n var(--slds-g-spacing-4));height: unset;font-family: var(--slds-g-font-family);}", ((useActualHostSelector ? ":host(:not([disabled])) [part=\"input-container\"]:focus-within" + shadowSelector + ", :host(:not([disabled])) [part=\"input-container\"]:active" : hostSelector + ":not([disabled]) [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + ":not([disabled]) [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part='input-text']" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-spacing-inline-start-readonly: 0;--sds-c-inputtext-color-border-focus: transparent;--slds-c-inputtext-color-border: transparent;--slds-c-inputtext-color-background: transparent;--slds-c-inputtext-color-background-focus: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:active" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-disabled-container-2);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: transparent;outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-text']" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-shadow: 0 0 0 var(--slds-g-sizing-border-1) inset\n var(--slds-g-color-error-1);--slds-c-inputtext-color-border: var(--slds-g-color-border-error-1);--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-input-has-icon" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " {--slds-c-input-color-background: var(--slds-s-input-color-background-invalid);--slds-c-input-color-border: var(--slds-g-color-border-error-1);--slds-c-input-text-color: var(--slds-s-input-color-invalid);background-clip: padding-box;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {fill: var(--slds-g-color-error-1);color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-container']:focus-within" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-shadow:\n var(--slds-g-color-error-base-50) 0 0 0 var(--slds-g-sizing-border-1) inset,\n 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-border-error-1);--sds-c-inputtext-color-border: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-container']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][disabled]) [part='input']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-container']" + shadowSelector + "," + hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {cursor: not-allowed;--sds-c-inputtext-color-background: var(--slds-s-input-color-background-disabled, var(--slds-g-color-disabled-container-1));--sds-c-inputtext-color-border: var(--slds-g-color-border-disabled-1);--sds-c-inputtext-text-color: var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-text']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-text-color-placeholder:\n var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " [part='label']", shadowSelector, " {padding-block-start: var(--slds-g-spacing-1);padding-inline-end: var(--slds-g-spacing-2);color: var(\n --slds-c-inputtext-label-color,\n var(--slds-g-color-on-surface-2)\n );margin-block-end: var(--slds-g-sizing-1);display: inline-flex;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='start']" : hostSelector + "[data-render-mode=\"shadow\"] [part='start']")), shadowSelector, " {--slds-c-icon-spacing-inlineend: var(--slds-g-spacing-2);}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-text']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='label']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {float: left;max-width: calc(33% - 1.125rem);padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-container']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='inline-help']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='inline-help']")), shadowSelector, " {float: left;padding-block-start: var(--slds-g-spacing-1);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) input[type=\"search\"]" : hostSelector + "[data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {left: var(--slds-g-spacing-3);fill: var(--slds-g-color-on-surface-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-accent-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-input__icon", shadowSelector, " {width: 0.875rem;height: 0.875rem;position: absolute;top: 50%;margin-top: -0.4375rem;line-height: 1;border: 0;z-index: 2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_left", shadowSelector, " {inset-inline-start: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right")), shadowSelector, " {--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_right", shadowSelector, " {inset-inline-end: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}"].join('');
      /*LWC compiler v7.1.5*/
    }
    var stylesheet5 = [stylesheet$1];

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top")), shadowSelector, "::after {box-shadow: -1px -1px 0 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: var(--slds-g-spacing-5);top: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, "::after {box-shadow: -1px -1px 0 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);left: auto;right: var(--slds-g-spacing-5);top: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-right: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, "::after {box-shadow: -1px -1px 0 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom")), shadowSelector, "::after {box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;bottom: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);left: var(--slds-g-spacing-5);top: 100%;margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, "::after {box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;inset: 100% auto calc((var(--slds-g-spacing-4) * 0.5) * -1) var(--slds-g-spacing-5);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-right: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-left: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, "::after {box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left")), shadowSelector, "::after {box-shadow: -1px 1px 2px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);top: var(--slds-g-spacing-5);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, "::after {box-shadow: -1px 1px 2px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);top: auto;bottom: var(--slds-g-spacing-4);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::before {margin-bottom: -1px;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::after {box-shadow: -1px 2px 3px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right")), shadowSelector, "::after {box-shadow: 1px -1px 2px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;right: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);top: var(--slds-g-spacing-5);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, "::after {box-shadow: 1px -1px 2px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::after {width: var(--slds-g-spacing-4);height: var(--slds-g-spacing-4);position: absolute;transform: rotate(45deg);content: '';background-color: inherit;right: calc((var(--slds-g-spacing-4) * 0.5) * -1);margin-top: calc((var(--slds-g-spacing-4) * 0.5) * -1);top: auto;bottom: var(--slds-g-spacing-4);z-index: -1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::before {margin-bottom: -1px;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::after {box-shadow: 2px -1px 3px 0 rgba(0, 0, 0, 16%);z-index: -2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-left-corner")), shadowSelector, "::after {left: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-left-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-left-corner")), shadowSelector, "::after {left: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_top-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_top-right-corner")), shadowSelector, "::after {right: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_bottom-right-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_bottom-right-corner")), shadowSelector, "::after {right: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-top-corner")), shadowSelector, "::after {top: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-top-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-top-corner")), shadowSelector, "::after {top: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_left-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_left-bottom-corner")), shadowSelector, "::after {bottom: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, " {border-radius: var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-4) var(--slds-g-sizing-border-2) var(--slds-g-sizing-border-4);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) .slds-nubbin_right-bottom-corner" : hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] .slds-nubbin_right-bottom-corner")), shadowSelector, "::after {bottom: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='dropdown']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='dropdown']")), shadowSelector, " {--_dropdown-size-x-small: 12rem;--_dropdown-size-medium: var(--slds-g-sizing-15);--_dropdown-square-icon-small-boundary: var(--slds-g-sizing-7);--_nubbin-size-default: var(--slds-g-sizing-5);--_duration-quickly: 0.1s;background-color:var(--slds-g-color-surface-container-1);color: var(--slds-g-color-on-surface-3);border-radius: var(--slds-g-radius-border-2);border-width: var(--slds-g-sizing-border-1);border-color: var(--slds-g-color-border-1);box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 16%);padding-inline-start: 0;padding-inline-end: 0;padding-block-start: var(--slds-g-spacing-1);padding-block-end: var(--slds-g-spacing-1);position: absolute;z-index: 7000;left: 50%;float: left;min-width: 6rem;max-width: var(--_dropdown-size-medium);margin-block-start: calc(var(--slds-g-spacing-1) / 2);margin-block-end: calc(var(--slds-g-spacing-1) / 2);font-size: var(--slds-g-font-scale-neg-1);border-style: solid;transform: translateX(-50%);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) mark" : hostSelector + "[data-render-mode=\"shadow\"] mark")), shadowSelector, " {font-weight: var(--slds-g-font-weight-bold);background-color: transparent;color: inherit;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger),:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger" : hostSelector + ".slds-dropdown-trigger[data-render-mode=\"shadow\"]," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger")), shadowSelector, " {position: relative;display: inline-block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger" : hostSelector + ".slds-dropdown-trigger[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger")), shadowSelector, " .slds-dropdown", shadowSelector, " {top: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger) .slds-dropdown_bottom" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger" : hostSelector + ".slds-dropdown-trigger[data-render-mode=\"shadow\"] .slds-dropdown_bottom" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger")), shadowSelector, " .slds-dropdown_bottom", shadowSelector, " {top: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger) > [class*='slds-button_icon']" + shadowSelector + " ~ .slds-dropdown_left[class*='slds-nubbin']" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger" : hostSelector + ".slds-dropdown-trigger[data-render-mode=\"shadow\"] > [class*='slds-button_icon']" + shadowSelector + " ~ .slds-dropdown_left[class*='slds-nubbin']" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger")), shadowSelector, " > [class*='slds-button_icon']", shadowSelector, " ~ .slds-dropdown_left[class*='slds-nubbin']", shadowSelector, " {left: calc(var(--slds-g-spacing-2) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger) > [class*='slds-button_icon']" + shadowSelector + " ~ .slds-dropdown_right[class*='slds-nubbin']" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger" : hostSelector + ".slds-dropdown-trigger[data-render-mode=\"shadow\"] > [class*='slds-button_icon']" + shadowSelector + " ~ .slds-dropdown_right[class*='slds-nubbin']" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger")), shadowSelector, " > [class*='slds-button_icon']", shadowSelector, " ~ .slds-dropdown_right[class*='slds-nubbin']", shadowSelector, " {right: calc(var(--slds-g-spacing-2) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger_hover) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_hover" : hostSelector + ".slds-dropdown-trigger_hover[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_hover")), shadowSelector, " .slds-dropdown", shadowSelector, " {visibility: hidden;opacity: 0;transition: opacity var(--_duration-quickly) linear, visibility var(--_duration-quickly) linear;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger_hover:hover),:host([data-render-mode=\"shadow\"].slds-dropdown-trigger_hover:focus),:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_hover:hover" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_hover:focus" : hostSelector + ":hover.slds-dropdown-trigger_hover[data-render-mode=\"shadow\"]," + hostSelector + ":focus.slds-dropdown-trigger_hover[data-render-mode=\"shadow\"]," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_hover:hover" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_hover:focus")), shadowSelector, " {outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger_hover:hover) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-dropdown-trigger_hover:focus) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_hover:hover" + shadowSelector + " .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_hover:focus" : hostSelector + ":hover.slds-dropdown-trigger_hover[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + ":focus.slds-dropdown-trigger_hover[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_hover:hover" + shadowSelector + " .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_hover:focus")), shadowSelector, " .slds-dropdown", shadowSelector, " {visibility: visible;opacity: 1;transition: opacity var(--_duration-quickly) linear, visibility var(--_duration-quickly) linear;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger_click) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"].slds-dropdown-trigger_click:hover) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_click" + shadowSelector + " .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_click:hover" : hostSelector + ".slds-dropdown-trigger_click[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + ":hover.slds-dropdown-trigger_click[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_click" + shadowSelector + " .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_click:hover")), shadowSelector, " .slds-dropdown", shadowSelector, " {display: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"].slds-dropdown-trigger_click.slds-is-open) .slds-dropdown" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown-trigger_click.slds-is-open" : hostSelector + ".slds-is-open.slds-dropdown-trigger_click[data-render-mode=\"shadow\"] .slds-dropdown" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown-trigger_click.slds-is-open")), shadowSelector, " .slds-dropdown", shadowSelector, " {display: block;visibility: visible;opacity: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='dropdown'][class*='slds-nubbin_top']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='dropdown'][class*='slds-nubbin_top']")), shadowSelector, " {margin-top: calc(var(--_nubbin-size-default) * 0.5);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='dropdown'][class*='slds-nubbin_bottom']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='dropdown'][class*='slds-nubbin_bottom']")), shadowSelector, " {margin-bottom: calc(var(--_nubbin-size-default) * 0.5);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_left")), shadowSelector, " {left: 0;right: auto;transform: translateX(0);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_right")), shadowSelector, " {left: auto;right: 0;transform: translateX(0);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_bottom" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_bottom")), shadowSelector, " {bottom: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_xx-small" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_xx-small")), shadowSelector, " {min-width: var(--dropdown-size-xx-small);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_x-small" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_x-small")), shadowSelector, " {min-width: var(--_dropdown-size-x-small);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_small" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_small")), shadowSelector, " {min-width: var(--slds-g-sizing-14);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_medium" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_medium")), shadowSelector, " {min-width: var(--_dropdown-size-medium);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_large" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_large")), shadowSelector, " {min-width: 25rem;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_fluid" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_fluid")), shadowSelector, " {min-width: var(\n --_dropdown-size-x-small\n );max-width: 100%;width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-5" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-5")), shadowSelector, " {max-height: calc(((var(--slds-g-font-scale-neg-3) * var(--slds-g-font-lineheight)) + var(--slds-g-spacing-4)) * 5);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-7" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-7")), shadowSelector, " {max-height: calc(((var(--slds-g-font-scale-neg-3) * var(--slds-g-font-lineheight)) + var(--slds-g-spacing-4)) * 7);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-10" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-10")), shadowSelector, " {max-height: calc(((var(--slds-g-font-scale-neg-3) * var(--slds-g-font-lineheight)) + var(--slds-g-spacing-4)) * 10);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-with-icon-5" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-with-icon-5")), shadowSelector, " {max-height: calc((var(--_dropdown-square-icon-small-boundary) + var(--slds-g-spacing-4)) * 5);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-with-icon-7" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-with-icon-7")), shadowSelector, " {max-height: calc((var(--_dropdown-square-icon-small-boundary) + var(--slds-g-spacing-4)) * 7);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_length-with-icon-10" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_length-with-icon-10")), shadowSelector, " {max-height: calc((var(--_dropdown-square-icon-small-boundary) + var(--slds-g-spacing-4)) * 10);overflow-y: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [dir='rtl']" : hostSelector + "[data-render-mode=\"shadow\"] [dir='rtl']")), shadowSelector, " .slds-dropdown_center", shadowSelector, " {left: auto;right: auto;transform: translateX(calc(50% - (0.875rem / 2)));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " {background: var(--slds-g-color-brand-base-10);border-color: var(--slds-g-color-brand-base-10);color: var(--slds-g-color-neutral-base-100);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " .slds-dropdown__item", shadowSelector, " > a", shadowSelector, " {color: var(--slds-g-color-neutral-base-100);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" + shadowSelector + " .slds-dropdown__item" + shadowSelector + " > a:hover" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse" + shadowSelector + " .slds-dropdown__item" + shadowSelector + " > a:hover" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " .slds-dropdown__item", shadowSelector, " > a:focus", shadowSelector, " {color: var(--slds-g-color-neutral-base-90);background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " .slds-dropdown__item", shadowSelector, " > a:active", shadowSelector, " {color: var(--slds-g-color-neutral-base-80);background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " .slds-dropdown__item", shadowSelector, " > a[aria-disabled='true']", shadowSelector, " {color: var(--slds-g-color-palette-blue-20);cursor: default;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_inverse" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_inverse")), shadowSelector, " .slds-dropdown__item", shadowSelector, " > a[aria-disabled='true']:hover", shadowSelector, " {background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-dropdown_actions" : hostSelector + "[data-render-mode=\"shadow\"] .slds-dropdown_actions")), shadowSelector, " a", shadowSelector, " {color: var(--slds-g-color-accent-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-submenu" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-submenu")), shadowSelector, " .slds-dropdown_submenu", shadowSelector, " {top: 0;transform: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-submenu" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-submenu")), shadowSelector, " .slds-dropdown_submenu-right", shadowSelector, " {left: 100%;margin-left: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-submenu" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-submenu")), shadowSelector, " .slds-dropdown_submenu-left", shadowSelector, " {left: 100%;margin-left: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-submenu" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-submenu")), shadowSelector, " .slds-dropdown_submenu-bottom", shadowSelector, " {top: auto;bottom: 0;margin-bottom: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-p-vertical_large" : hostSelector + "[data-render-mode=\"shadow\"] .slds-p-vertical_large")), shadowSelector, " {padding: var(--slds-g-spacing-5);}"].join('');
      /*LWC compiler v7.1.5*/
    }
    var stylesheet6 = [stylesheet];

    var stylesheet1 = [stylesheet0__default.default, stylesheet1__default.default, stylesheet2, stylesheet3, stylesheet4, stylesheet5, stylesheet6];

    var _implicitStylesheets = [stylesheet0, stylesheet1];

    const $fragment1 = lwc.parseFragment`<span class="slds-assistive-text${0}"${2}>${"t1"}</span>`;
    const $fragment2 = lwc.parseFragment`<div role="status" class="slds-spinner slds-spinner_brand slds-spinner_x-small slds-input__spinner${0}"${2}><span class="slds-assistive-text${0}"${2}>${"t2"}</span><div class="slds-spinner__dot-a${0}"${2}></div><div class="slds-spinner__dot-b${0}"${2}></div></div>`;
    const $fragment3 = lwc.parseFragment`<li role="presentation" class="slds-listbox__item${0}"${2}><div class="slds-media slds-listbox__option slds-listbox__option_plain slds-media_small${0}" role="presentation"${2}><h3 role="presentation"${"a2:title"} class="slds-listbox__option-header${0}"${2}>${"t3"}</h3></div></li>`;
    const $fragment4 = lwc.parseFragment`<div class="slds-align_absolute-center${0}"${2}><img${"a1:src"} class="slds-inline-logo${0}"${"a1:alt"}${"a1:title"}${2}></div>`;
    const stc0 = {
      classMap: {
        "slds-combobox_container": true
      },
      key: 0
    };
    const stc1 = {
      "role": "none"
    };
    const stc2 = {
      "slds-icon_container": true,
      "slds-combobox__input-entity-icon": true
    };
    const stc3 = {
      "data-input-pill-search-icon": ""
    };
    const stc4 = {
      attrs: {
        "part": "input-text"
      },
      key: 4
    };
    const stc5 = {
      attrs: {
        "part": "input-container"
      },
      key: 5
    };
    const stc6 = {
      classMap: {
        "slds-truncate": true
      },
      key: 8
    };
    const stc7 = {
      classMap: {
        "slds-input__icon-group": true,
        "slds-input__icon-group_right": true
      },
      key: 9
    };
    const stc8 = {
      "slds-button": true,
      "slds-button_icon": true,
      "slds-input__icon": true,
      "slds-input__icon_right": true
    };
    const stc9 = {
      props: {
        "iconName": "utility:close",
        "variant": "bare",
        "svgClass": "slds-button__icon"
      },
      key: 11
    };
    const stc10 = {
      classMap: {
        "slds-input__icon-group": true,
        "slds-input__icon-group_right": true
      },
      key: 14
    };
    const stc11 = {
      "slds-input__icon": true,
      "slds-input__icon_right": true
    };
    const stc12 = {
      "slds-media": true,
      "slds-listbox__option": true,
      "slds-media_center": true
    };
    const stc13 = {
      "slds-listbox__item": true
    };
    const stc14 = {
      "role": "presentation"
    };
    const stc15 = {
      classMap: {
        "slds-listbox__item": true,
        "slds-spinner_inline": true
      },
      attrs: {
        "role": "option"
      },
      key: 25
    };
    const stc16 = {
      classMap: {
        "slds-align_absolute-center": true,
        "slds-p-top_medium": true,
        "slds-p-bottom_medium": true
      },
      key: 26
    };
    const stc17 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {ncls: api_normalize_class_name, b: api_bind, c: api_custom_element, gid: api_scoped_id, h: api_element, d: api_dynamic_text, t: api_text, sp: api_static_part, st: api_static_fragment, k: api_key, i: api_iterator, f: api_flatten} = $api;
      const {_m0, _m1, _m2, _m3, _m4, _m5, _m6, _m7, _m8, _m9, _m10, _m11, _m12, _m13, _m14, _m15, _m16, _m17, _m18} = $ctx;
      return [api_element("div", stc0, [api_element("div", {
        className: api_normalize_class_name($cmp.computedDropdownTriggerClass),
        key: 1,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleTriggerClick))
        }
      }, [api_element("div", {
        className: api_normalize_class_name($cmp.computedFormElementClass),
        attrs: stc1,
        key: 2
      }, [$cmp.hasInputPill ? api_custom_element("lightning-icon", _lightningIcon__default.default, {
        classMap: stc2,
        attrs: stc3,
        props: {
          "iconName": $cmp.inputPill.iconName,
          "alternativeText": $cmp.inputPill.iconAlternativeText,
          "size": "x-small"
        },
        key: 3
      }) : null, !$cmp.isUserInputDisabled ? api_element("div", stc4, [api_element("div", stc5, [api_element("input", {
        className: api_normalize_class_name($cmp.computedInputClass),
        attrs: {
          "id": api_scoped_id("combobox-input"),
          "type": "text",
          "role": $cmp.customRole,
          "accesskey": $cmp.accessKey,
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-haspopup": $cmp.customAriaHasPopup,
          "required": $cmp.required ? "" : null,
          "readonly": $cmp._inputAriaReadOnly ? "" : null,
          "autocomplete": $cmp.autocomplete,
          "data-value": $cmp.computedInputValue,
          "name": $cmp.name,
          "placeholder": $cmp.computedPlaceholder,
          "maxlength": $cmp.inputMaxlength,
          "disabled": $cmp.disabled ? "" : null,
          "aria-disabled": $cmp.computedAriaDisabled,
          "aria-readonly": $cmp._inputAriaReadOnly,
          "aria-autocomplete": $cmp.computedAriaAutocomplete,
          "aria-owns": api_scoped_id("dropdown-element"),
          "aria-label": $cmp.inputLabel,
          "part": "input"
        },
        props: {
          "value": $cmp.computedInputValue
        },
        key: 6,
        on: {
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "select": _m2 || ($ctx._m2 = api_bind($cmp.handleInputSelect)),
          "change": _m3 || ($ctx._m3 = api_bind($cmp.handleTextChange)),
          "input": _m4 || ($ctx._m4 = api_bind($cmp.handleInput)),
          "keydown": _m5 || ($ctx._m5 = api_bind($cmp.handleInputKeyDown)),
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handleInputClick)),
          "blur": _m7 || ($ctx._m7 = api_bind($cmp.handleBlur))
        }
      })])]) : null, $cmp.isUserInputDisabled ? api_element("button", {
        className: api_normalize_class_name($cmp.computedInputClass),
        attrs: {
          "id": api_scoped_id("combobox-button"),
          "type": "button",
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-haspopup": $cmp.customAriaHasPopup,
          "name": $cmp.name,
          "role": $cmp.customRole,
          "data-value": $cmp.computedInputValue,
          "disabled": $cmp.disabled ? "" : null,
          "aria-disabled": $cmp.disabled,
          "aria-label": $cmp.inputLabel,
          "aria-required": $cmp.required
        },
        key: 7,
        on: {
          "focus": _m8 || ($ctx._m8 = api_bind($cmp.handleFocus)),
          "keydown": _m9 || ($ctx._m9 = api_bind($cmp.handleInputKeyDown)),
          "blur": _m10 || ($ctx._m10 = api_bind($cmp.handleBlur))
        }
      }, [api_element("span", stc6, [$cmp.computedInputValue ? api_text(api_dynamic_text($cmp.computedInputValue)) : null, !$cmp.computedInputValue ? api_text(api_dynamic_text($cmp.computedPlaceholder)) : null])]) : null, $cmp.isCloseVisible ? api_element("div", stc7, [api_element("button", {
        classMap: stc8,
        attrs: {
          "type": "button",
          "title": $cmp.i18n.pillCloseButtonAlternativeText
        },
        key: 10,
        on: {
          "click": _m11 || ($ctx._m11 = api_bind($cmp.handlePillRemove))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon__default.default, stc9), api_static_fragment($fragment1, 13, [api_static_part(1, null, api_dynamic_text($cmp.i18n.pillCloseButtonAlternativeText))])])]) : null, !$cmp.hasInputPill ? api_element("div", stc10, [$cmp.showInputActivityIndicator ? api_static_fragment($fragment2, 16, [api_static_part(2, null, api_dynamic_text($cmp.i18n.loadingText))]) : null, $cmp.inputIconName ? api_custom_element("lightning-icon", _lightningIcon__default.default, {
        classMap: stc11,
        props: {
          "alternativeText": $cmp.inputIconAlternativeText,
          "iconName": $cmp.inputIconName,
          "size": $cmp.inputIconSize
        },
        key: 17
      }) : null]) : null]), api_element("div", {
        className: api_normalize_class_name($cmp.computedDropdownClass),
        attrs: {
          "id": api_scoped_id("dropdown-element"),
          "data-dropdown-element": "",
          "role": "listbox",
          "part": "dropdown overlay",
          "aria-label": $cmp.inputLabel
        },
        key: 18,
        on: {
          "scroll": _m12 || ($ctx._m12 = api_bind($cmp.handleListboxScroll)),
          "mousedown": _m13 || ($ctx._m13 = api_bind($cmp.handleDropdownMouseDown)),
          "mouseup": _m14 || ($ctx._m14 = api_bind($cmp.handleDropdownMouseUp)),
          "mouseleave": _m15 || ($ctx._m15 = api_bind($cmp.handleDropdownMouseLeave)),
          "click": _m16 || ($ctx._m16 = api_bind($cmp.handleOptionClick))
        }
      }, $cmp._hasDropdownOpened ? api_flatten([api_iterator($cmp._items, function (item) {
        return [!item.items ? api_custom_element("lightning-base-combobox-item", _lightningBaseComboboxItem__default.default, {
          classMap: stc12,
          attrs: {
            "data-item-id": item.id,
            "exportparts": "option",
            "data-value": item.value
          },
          props: {
            "role": "option",
            "item": item,
            "id": api_scoped_id(item.id),
            "ariaChecked": item.checked
          },
          key: api_key(19, item.value),
          on: {
            "mouseenter": _m17 || ($ctx._m17 = api_bind($cmp.handleOptionMouseEnter))
          }
        }) : null, item.items ? api_element("ul", {
          attrs: {
            "role": "group",
            "aria-label": item.label
          },
          key: api_key(20, item.label)
        }, api_flatten([item.label ? api_static_fragment($fragment3, 22, [api_static_part(2, {
          attrs: {
            "title": item.label
          }
        }, null), api_static_part(3, null, api_dynamic_text(item.label))]) : null, api_iterator(item.items, function (groupItem) {
          return api_element("li", {
            classMap: stc13,
            attrs: stc14,
            key: api_key(23, groupItem.value)
          }, [api_custom_element("lightning-base-combobox-item", _lightningBaseComboboxItem__default.default, {
            classMap: stc12,
            attrs: {
              "data-item-id": groupItem.id,
              "data-value": groupItem.value
            },
            props: {
              "role": "option",
              "item": groupItem,
              "id": api_scoped_id(groupItem.id),
              "ariaChecked": groupItem.checked
            },
            key: 24,
            on: {
              "mouseenter": _m18 || ($ctx._m18 = api_bind($cmp.handleOptionMouseEnter))
            }
          })]);
        })])) : null];
      }), $cmp.showDropdownActivityIndicator ? api_element("div", stc15, [api_element("div", stc16, [api_custom_element("lightning-spinner", _lightningSpinner__default.default, {
        props: {
          "size": "x-small",
          "alternativeText": $cmp.i18n.loadingText
        },
        key: 27
      })])]) : null, $cmp.showAttribution ? api_static_fragment($fragment4, 29, [api_static_part(1, {
        attrs: {
          "src": $cmp.attributionLogoUrl,
          "alt": $cmp.attributionLogoAssistiveText,
          "title": $cmp.attributionLogoAssistiveText
        }
      }, null)]) : null]) : stc17)])])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-4kb6kaqheak";
    tmpl.legacyStylesheetToken = "lightning-baseCombobox_baseCombobox";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    function preventDefaultAndStopPropagation(event) {
      event.preventDefault();
      event.stopPropagation();
    }
    function handleEnterKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation(event);
      if (dropdownInterface.isDropdownVisible() && currentIndex >= 0) {
        dropdownInterface.selectByIndex(currentIndex);
      } else {
        dropdownInterface.openDropdownIfNotEmpty();
      }
    }
    function handlePageUpOrDownKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation(event);
      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }
      const pageUpDownOptionSkipCount = 10;
      if (dropdownInterface.getTotalOptions() > 0) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          let highlightIndex = 0;
          if (event.key === 'PageUp') {
            highlightIndex = Math.max(currentIndex - pageUpDownOptionSkipCount, 0);
          } else {
            // Jump 10 options down
            highlightIndex = Math.min(currentIndex + pageUpDownOptionSkipCount, dropdownInterface.getTotalOptions() - 1);
          }
          dropdownInterface.highlightOptionWithIndex(highlightIndex);
        });
      }
    }
    function handleHomeOrEndKey({
      event,
      dropdownInterface
    }) {
      // If not a read-only input we want the default browser behaviour
      if (!dropdownInterface.isInputReadOnly()) {
        return;
      }
      preventDefaultAndStopPropagation(event);
      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }
      if (dropdownInterface.getTotalOptions() > 0) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          const highlightIndex = event.key === 'Home' ? 0 : dropdownInterface.getTotalOptions() - 1;
          dropdownInterface.highlightOptionWithIndex(highlightIndex);
        });
      }
    }
    function handleUpOrDownKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation(event);
      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }
      const isUpKey = event.key === 'Up' || event.key === 'ArrowUp';
      let nextIndex;
      if (currentIndex >= 0) {
        nextIndex = isUpKey ? currentIndex - 1 : currentIndex + 1;
        if (nextIndex >= dropdownInterface.getTotalOptions()) {
          nextIndex = 0;
        } else if (nextIndex < 0) {
          nextIndex = dropdownInterface.getTotalOptions() - 1;
        }
      } else {
        nextIndex = isUpKey ? dropdownInterface.getTotalOptions() - 1 : 0;
      }
      if (dropdownInterface.getTotalOptions() > 0) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          dropdownInterface.highlightOptionWithIndex(nextIndex);
        });
      }
    }
    function handleEscapeKey({
      event,
      dropdownInterface
    }) {
      if (dropdownInterface.isDropdownVisible()) {
        event.stopPropagation();
        dropdownInterface.closeDropdown();
      }
    }
    function handleTabKey({
      event,
      dropdownInterface,
      currentIndex
    }) {
      if (dropdownInterface.isDropdownVisible() && currentIndex >= 0) {
        event.stopPropagation();
        dropdownInterface.closeDropdown();
        dropdownInterface.selectByIndex(currentIndex);
      }
    }
    function handleDeletionKeys({
      event,
      dropdownInterface
    }) {
      if (dropdownInterface.shouldPreventInputDeletion()) {
        event.preventDefault();
      }
      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }
    }
    function handleTypedCharacters({
      event,
      currentIndex,
      dropdownInterface
    }) {
      if (event.key && event.key.length > 1) {
        // not a printable character
        return;
      }
      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }
      if (dropdownInterface.isInputReadOnly()) {
        // The element should be read only, it's a work-around for IE11 as it will still make editable an input
        // that has focus and was dynamically changed to be readonly on focus change. Remove once we no longer
        // support IE11
        event.preventDefault();

        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => utilsPrivate.runActionOnBufferedTypedCharacters(event, dropdownInterface.highlightOptionWithText.bind(this, currentIndex || 0)));
      }
    }
    const eventKeyToHandlerMap = {
      Enter: handleEnterKey,
      PageUp: handlePageUpOrDownKey,
      PageDown: handlePageUpOrDownKey,
      Home: handleHomeOrEndKey,
      End: handleHomeOrEndKey,
      Down: handleUpOrDownKey,
      // IE11/Edge specific
      Up: handleUpOrDownKey,
      // IE11/Edge specific
      ArrowUp: handleUpOrDownKey,
      ArrowDown: handleUpOrDownKey,
      Esc: handleEscapeKey,
      // IE11/Edge specific
      Escape: handleEscapeKey,
      Tab: handleTabKey,
      Backspace: handleDeletionKeys,
      Delete: handleDeletionKeys
    };
    const NON_EDITING_KEYS = ['Enter', 'PageUp', 'PageDown', 'Home', 'End', 'Down', 'Up', 'ArrowUp', 'ArrowDown', 'Esc', 'Escape', 'Tab'];
    const isAnEditingKey = key => {
      return !NON_EDITING_KEYS.includes(key);
    };
    const handleEditingMode = ({
      event,
      dropdownInterface
    }) => {
      if (isAnEditingKey(event.key)) {
        dropdownInterface.setEditingMode(true);
      } else {
        dropdownInterface.setEditingMode(false);
      }
    };
    function handleKeyDownOnInput({
      event,
      currentIndex,
      dropdownInterface
    }) {
      const parameters = {
        event,
        currentIndex,
        dropdownInterface
      };
      if (eventKeyToHandlerMap[event.key]) {
        eventKeyToHandlerMap[event.key](parameters);
      } else {
        handleTypedCharacters(parameters);
      }
      handleEditingMode(parameters);
    }

    class BaseComboboxEvents {
      constructor(baseCombobox) {
        this.dispatchEvent = baseCombobox.dispatchEvent.bind(baseCombobox);
      }
      dispatchPillRemove(pill) {
        this.dispatchEvent(new CustomEvent('pillremove', {
          detail: {
            item: pill
          }
        }));
      }
      dispatchEndReached() {
        this.dispatchEvent(new CustomEvent('endreached'));
      }
      dispatchFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }
      dispatchBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }
      dispatchTextInput(text) {
        this.dispatchEvent(new CustomEvent('textinput', {
          detail: {
            text
          }
        }));
      }
      dispatchTextChange(text) {
        this.dispatchEvent(new CustomEvent('textchange', {
          detail: {
            text
          }
        }));
      }
      dispatchSelect(value) {
        this.dispatchEvent(new CustomEvent('select', {
          detail: {
            value
          }
        }));
      }
      dispatchDropdownOpen() {
        this.dispatchEvent(new CustomEvent('dropdownopen'));
      }
      dispatchDropdownOpenRequest() {
        this.dispatchEvent(new CustomEvent('dropdownopenrequest'));
      }
    }

    const i18n = {
      ariaSelectedOptions: labelAriaSelectedOptions__default.default,
      deselectOptionKeyboard: labelDeselectOptionKeyboard__default.default,
      pillCloseButtonAlternativeText: labelPillCloseButtonAlternativeText__default.default,
      loadingText: labelLoadingText__default.default,
      placeholder: labelPlaceholder__default.default
    };
    const SMALL_MIN_HEIGHT = '2.25rem';
    const MEDIUM_MIN_HEIGHT = '6.75rem';
    const INPUT_ELEMENT_SELECTOR = '.slds-combobox__input';
    const INPUT_PART_ELEMENT_SELECTOR = '[part~="input-text"]';
    const FAUX_INPUT_BUTTON_ELEMENT_SELECTOR = `${INPUT_ELEMENT_SELECTOR}.slds-input_faux`;
    const VARIANT_LOOKUP = 'lookup';

    /**
     * Breakpoint when viewport height doesn't fit 10 items in the dropdown
     * 834px is the height of 11 inch iPad in horizontal mode.
     */
    const VIEWPORT_HEIGHT_SMALL = 834;
    const ARIA_CONTROLS = 'aria-controls';
    const ARIA_DETAILS = 'aria-details';
    const ARIA_LABELLEDBY = 'aria-labelledby';
    const ARIA_DESCRIBEDBY = 'aria-describedby';
    const ARIA_LABEL = 'aria-label';
    const ARIA_ACTIVEDESCENDANT = 'aria-activedescendant';
    const ARIA_INVALID = 'aria-invalid';
    class LightningBaseCombobox extends LightningShadowBaseClass__default.default {
      /**
       * Controls auto-filling of the input. Set the attribute to pass
       * through autocomplete values to be interpreted by the browser.
       * By default autocomplete is off to avoid overlap of dropdowns.
       * @type {string}
       */
      get autocomplete() {
        return this._autocomplete;
      }
      set autocomplete(value) {
        this._autocomplete = value || 'off';
      }
      constructor() {
        super();
        this.inputText = '';
        this.inputIconName = 'utility:down';
        this.inputIconSize = 'x-small';
        this.inputIconAlternativeText = void 0;
        this.inputMaxlength = void 0;
        this.showInputActivityIndicator = false;
        this.required = false;
        this.placeholder = i18n.placeholder;
        this.inputLabel = void 0;
        this.customRole = 'combobox';
        this.customAriaHasPopup = 'listbox';
        this.accessKey = void 0;
        this.name = void 0;
        this.inputPill = void 0;
        this.attributionLogoUrl = void 0;
        this.attributionLogoAssistiveText = void 0;
        this._showDropdownActivityIndicator = false;
        this._items = [];
        this._disabled = false;
        this._dropdownVisible = false;
        this._hasDropdownOpened = false;
        this._highlightedOptionElementId = null;
        this._variant = void 0;
        this._dropdownHeight = 'standard';
        this._readonly = false;
        this._logoLoaded = false;
        this._inputDescribedBy = [];
        this._inputAriaControls = void 0;
        this._inputAriaDetails = void 0;
        this._activeElementDomId = void 0;
        this._autocomplete = 'off';
        this._dropdownAlignment = 'left';
        this.originDisableDefaultHighlight = void 0;
        this.privateDisableDefaultHighlight = void 0;
        this._editingMode = false;
        this._connected = false;
        this.ariaObserver = null;
        this.ariaDisabled = void 0;
        this._events = new BaseComboboxEvents(this);
        this.setupAriaObserverIfAbsent();
      }
      renderedCallback() {
        this.dispatchEvent(new CustomEvent('ready', {
          detail: {
            id: this.inputId,
            name: this.name
          }
        }));
        this.syncAriaObserver();
        this.synchronizeA11y();
        utilsPrivate.reflectAttribute(this, 'data-input-pill', this.hasInputPill);
        utilsPrivate.reflectAttribute(this.template.querySelector('lightning-primitive-icon'), 'data-input-pill-close-primicon', this.isCloseVisible);
        utilsPrivate.reflectAttribute(this.template.querySelector('slds-combobox__input-entity-icon'), 'data-input-pill-search-icon', this.hasInputPill);
      }
      connectedCallback() {
        super.connectedCallback();
        this.setupAriaObserverIfAbsent();
        if (utilsPrivate.isCSR) {
          this.overrideDropdownAlignment();
        }
        this.classList.add('slds-combobox_container');
        this._connected = true;
        this._keyboardInterface = this.dropdownKeyboardInterface();
      }
      disconnectedCallback() {
        this._connected = false;
        this._listBoxElementCache = undefined;
        this.removeAriaObserver();
      }
      setupAriaObserverIfAbsent() {
        if (!this.ariaObserver) {
          this.ariaObserver = new AriaObserver__default.default(this);
        }
      }
      removeAriaObserver() {
        if (this.ariaObserver && this.ariaObserver.disconnect) {
          this.ariaObserver.disconnect();
          this.ariaObserver = null;
        }
      }
      get dropdownAlignment() {
        return this._dropdownAlignment;
      }
      set dropdownAlignment(value) {
        this._dropdownAlignment = value;
      }
      get inputControlsElement() {
        return this._inputAriaControls;
      }
      set inputControlsElement(el) {
        this._inputAriaControls = el;
        this.connectAriaControls();
      }
      get inputDetailsElements() {
        return this._inputAriaDetails;
      }
      set inputDetailsElements(element) {
        this._inputAriaDetails = element;
        this.connectAriaAttribute({
          attribute: ARIA_DETAILS,
          relatedNodeIds: element
        });
      }
      syncAriaObserver() {
        this.setupAriaObserverIfAbsent();
        const ariaObserverSyncExists = this.ariaObserver && this.ariaObserver.sync;
        if (this.isConnected && ariaObserverSyncExists) {
          this.ariaObserver.sync();
        }
      }
      connectAriaControls() {
        this.connectAriaAttribute({
          attribute: ARIA_CONTROLS,
          relatedNodeIds: this._inputAriaControls,
          relatedNodes: this.dropdownElement
        });
      }
      connectAriaAttribute(params) {
        this.setupAriaObserverIfAbsent();
        if (this.ariaObserver && this.ariaObserver.connect) {
          const relatedNodeIds = Array.isArray(params.relatedNodeIds) ? params.relatedNodeIds.map(el => utilsPrivate.getRealDOMId(el)).join(' ') : utilsPrivate.getRealDOMId(params.relatedNodeIds);
          this.ariaObserver.connect({
            ...params,
            targetSelector: INPUT_ELEMENT_SELECTOR,
            relatedNodeIds
          });
        }
      }
      get ariaErrorMessageElements() {
        return this._ariaErrorMessageElements;
      }
      set ariaErrorMessageElements(elements) {
        this._ariaErrorMessageElements = elements;
        this.connectAriaDescribedByElements();
      }
      get inputDescribedByElements() {
        return this._inputDescribedBy;
      }
      set inputDescribedByElements(elements) {
        this._inputDescribedBy = elements;
        this.connectAriaDescribedByElements();
      }
      connectAriaDescribedByElements() {
        this.connectAriaAttribute({
          attribute: ARIA_DESCRIBEDBY,
          relatedNodeIds: this._inputDescribedBy,
          relatedNodes: this.ariaErrorMessageElements
        });
      }
      get inputLabelledByElement() {
        return this._inputLabelledBy;
      }
      set inputLabelledByElement(element) {
        this._inputLabelledBy = element;
        this.connectAriaAttribute({
          attribute: ARIA_LABELLEDBY,
          relatedNodeIds: element
        });
      }
      get rootAriaNode() {
        return this.ariaObserver.root;
      }
      set rootAriaNode(root) {
        this.setupAriaObserverIfAbsent();
        if (this.ariaObserver) {
          this.ariaObserver.root = root;
        }
      }
      get inputId() {
        return utilsPrivate.getRealDOMId(this.inputElement);
      }
      get dropdownHeight() {
        return this._dropdownHeight;
      }
      set dropdownHeight(height) {
        this._dropdownHeight = utilsPrivate.normalizeString(height, {
          fallbackValue: 'standard',
          validValues: ['standard', 'small']
        });
      }
      get showDropdownActivityIndicator() {
        return this._showDropdownActivityIndicator;
      }
      set showDropdownActivityIndicator(value) {
        this._showDropdownActivityIndicator = utilsPrivate.normalizeBoolean(value);
        if (this._connected) {
          if (this._showDropdownActivityIndicator) {
            if (this._shouldOpenDropDown) {
              this.openDropdownIfNotEmpty();
            }
          } else if (this._dropdownVisible && this.isDropdownEmpty) {
            this.closeDropdown();
          }
        }
      }
      get computedAriaDisabled() {
        return this.ariaDisabled === 'true' || this.disabled ? true : false;
      }
      get disabled() {
        return this._disabled;
      }
      set disabled(value) {
        this._disabled = utilsPrivate.normalizeBoolean(value);
        utilsPrivate.reflectAttribute(this, 'disabled', this._disabled);
        if (this._disabled && this._dropdownVisible) {
          this.closeDropdown();
        }
      }
      get readOnly() {
        return this._readonly;
      }
      set readOnly(value) {
        this._readonly = utilsPrivate.normalizeBoolean(value);
        if (this._readonly && this._dropdownVisible) {
          this.closeDropdown();
        }
      }
      get variant() {
        return this._variant || inputUtils.VARIANT.STANDARD;
      }
      set variant(value) {
        this._variant = utilsPrivate.normalizeString(value, {
          fallbackValue: inputUtils.VARIANT.STANDARD,
          validValues: [inputUtils.VARIANT.STANDARD, inputUtils.VARIANT.LABEL_INLINE, inputUtils.VARIANT.LABEL_STACKED, inputUtils.VARIANT.LABEL_HIDDEN, VARIANT_LOOKUP]
        });
      }
      get items() {
        return this._unprocessedItems;
      }
      set items(items = []) {
        this._unprocessedItems = items;
        this.updateItems(items);
        if (this._connected) {
          if (this._hasDropdownOpened) {
            // The dropdown has already been opened at least once, so process the items immediately
            this.updateItems(items);
            if (this._dropdownVisible) {
              // The dropdown is visible but there are no items to show, close it
              if (this.isDropdownEmpty) {
                this.closeDropdown();
              } else {
                // We have new items, update highlight
                this.highlightDefaultItem();

                // Since the items have changed, the positioning should be recomputed
                // remove-next-line-for-c-namespace
                this.startDropdownAutoPositioning();
              }
            }
          }
          if (this._shouldOpenDropDown) {
            this.openDropdownIfNotEmpty();
          }
        }
      }

      /**
       * Whether disable the highlighting default item behavior
       *
       * @type {boolean}
       * @memberof LightningBaseCombobox
       */
      get disableDefaultHighlight() {
        return this.originDisableDefaultHighlight;
      }
      set disableDefaultHighlight(value) {
        this.originDisableDefaultHighlight = value;
        this.privateDisableDefaultHighlight = utilsPrivate.normalizeBoolean(value);
      }
      highlightInputText() {
        if (this._connected) {
          // Safari has issues with invoking set selection range immediately in the 'focus' handler, instead
          // we'd be doing it in an animation frame. Remove the requestAnimationFrame once/if this is fixed
          // in Safari
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            const {
              inputElement
            } = this;
            inputElement.setSelectionRange(0, inputElement.value.length);
          });
        }
      }
      get showAttribution() {
        return this.attributionLogoUrl;
      }
      focus() {
        if (this._connected) {
          this.inputElement.focus();
        }
      }
      focusAndOpenDropdownIfNotEmpty() {
        if (this._connected) {
          if (!this._inputHasFocus) {
            this.focus();
          }
          this.openDropdownIfNotEmpty();
        }
      }
      blur() {
        if (this._connected) {
          this.inputElement.blur();
        }
      }
      synchronizeA11y() {
        const input = this.inputElement;
        if (!input) {
          return;
        }
        utilsPrivate.synchronizeAttrs(input, {
          [ARIA_LABEL]: this.inputLabel,
          [ARIA_INVALID]: this.computedAriaInvalid,
          [ARIA_ACTIVEDESCENDANT]: this.computedAriaActiveDescendant
        });
        if (this.isConnected) {
          this.connectAriaControls();
        }
      }
      itemId(index) {
        return this.inputId + '-' + index;
      }
      itemIndexFromId(id) {
        // Extracts the index from an item id.
        return parseInt(id.substring(id.lastIndexOf('-') + 1), 10);
      }
      processItem(item) {
        const itemCopy = {};

        // Supported item properties:
        // 'type' (string): option-inline, option-card
        // 'highlight' (boolean): Whether to highlight the item when dropdown opens
        // 'iconName': left icon name
        // 'iconSize': left icon size
        // 'iconAlternativeText': assistive text for the left icon
        // 'rightIconName': right icon name
        // 'rightIconSize': right icon size
        // 'rightIconAlternativeText': assistive text for the right icon
        // 'text': text to display
        // 'subText': sub-text to display (only option-card supports it)
        // 'value': value associated with the option
        // 'checked': has this been chosen by the user.  Different than selected as that is hover.
        itemCopy.type = item.type;
        itemCopy.iconName = item.iconName;
        itemCopy.iconSize = item.iconSize;
        itemCopy.iconAlternativeText = item.iconAlternativeText;
        itemCopy.rightIconName = item.rightIconName;
        itemCopy.rightIconSize = item.rightIconSize;
        itemCopy.rightIconAlternativeText = item.rightIconAlternativeText;
        itemCopy.text = item.text;
        itemCopy.subText = item.subText;
        itemCopy.value = item.value;
        // so that we do not get aria-checked="undefined"
        itemCopy.checked = item.checked || false;

        // extra metadata needed
        itemCopy.selectable = ['option-card', 'option-inline'].indexOf(item.type) >= 0;
        if (itemCopy.selectable) {
          itemCopy.index = this._selectableItems;
          itemCopy.id = this.itemId(itemCopy.index);
          this._selectableItems += 1;
          if (item.highlight) {
            this._highlightedItemIndex = itemCopy.index;
          }
        }
        return itemCopy;
      }
      get isAutocompleteEnabled() {
        return this.autocomplete && this.autocomplete !== 'off';
      }
      get isStandardOrLabelVariant() {
        return [inputUtils.VARIANT.STANDARD, inputUtils.VARIANT.LABEL_INLINE, inputUtils.VARIANT.LABEL_STACKED, inputUtils.VARIANT.LABEL_HIDDEN].includes(this.variant);
      }
      get isDefaultReadOnlyTypes() {
        return this.isStandardOrLabelVariant || this.hasInputPill;
      }

      /**
       * Returns true for comboboxes that never allow user input
       * Used to determine if input or button should be rendered
       */
      get isUserInputDisabled() {
        return this.isStandardOrLabelVariant && !this.isAutocompleteEnabled;
      }
      get _inputAriaReadOnly() {
        // For standard combobox, if the dropdown is open, we must make the input readonly,
        // so the user can type and search in the dropdown list
        // For grouped combobox, the input must remain editable because the search is done through
        // the input.
        if (this._dropdownVisible && this.isStandardOrLabelVariant) {
          return true;
        }
        return (
          // we want Autocomplete to override the "default assumptions"
          // UNLESS the parent component deliberately determines it is readOnly
          this._readonly || !this.isAutocompleteEnabled && this.isDefaultReadOnlyTypes
        );
      }

      /**
       * Do not set aria-activedescendant when editing the text in the combobox.
       * Rest of the times, set it to active element DOM id.
       */
      get computedAriaActiveDescendant() {
        return this.isUserInputDisabled || !this._editingMode ? this._activeElementDomId : undefined;
      }
      get computedAriaAutocomplete() {
        if (this.hasInputPill) {
          // no aria-autocomplete when pill is showing
          return null;
        }
        return this._inputAriaReadOnly ? 'none' : 'list';
      }
      get computedPlaceholder() {
        return this.hasInputPill ? this.inputPill.label : this.placeholder;
      }
      get computedInputValue() {
        return this.hasInputPill ? this.inputPill.label : this.inputText;
      }
      handleListboxScroll(event) {
        // We don't want this to bubble up to the modal which due to event retargeting wouldn't be able
        // to know what is actually being scrolled and thus may lead to the scrolling of the modal
        event.stopPropagation();
        const listbox = event.target;
        const height = listbox.getBoundingClientRect().height;
        const maxScroll = listbox.scrollHeight - height;
        // Account for variation between browsers when it comes to calculation of margins/padding
        const buffer = 20;
        const bottomReached = listbox.scrollTop + buffer >= maxScroll;
        if (bottomReached) {
          this._events.dispatchEndReached();
        }
      }
      get listboxElement() {
        if (!this._listBoxElementCache) {
          this._listBoxElementCache = this.template.querySelector('[role="listbox"]');
        }
        return this._listBoxElementCache;
      }
      get computedUniqueElementId() {
        return this.inputId;
      }
      get dropdownElement() {
        return utilsPrivate.isCSR ? this.template.querySelector('[data-dropdown-element]') : null;
      }
      get i18n() {
        return i18n;
      }
      get computedDropdownTriggerClass() {
        return utils.classSet('slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click').add({
          'slds-is-open': this._dropdownVisible
        }).toString();
      }
      get computedDropdownClass() {
        const alignment = this.dropdownAlignment;
        let dropdownLengthClass = '';
        if (this._dropdownVisible) {
          if (this.dropdownHeight === 'standard') {
            // When viewport height is small(i.e. 11 inch iPad), there may not be enough space to fit 10 items
            // either on top or bottom of the input. Therefore show 7 items instead.
            if (window.innerHeight <= VIEWPORT_HEIGHT_SMALL) {
              dropdownLengthClass = 'slds-dropdown_length-with-icon-7';
            } else {
              dropdownLengthClass = 'slds-dropdown_length-with-icon-10';
            }
          } else if (this.dropdownHeight === 'small') {
            dropdownLengthClass = 'slds-dropdown_length-with-icon-5';
          }
        }
        return utils.classSet(`slds-listbox slds-listbox_vertical slds-dropdown slds-dropdown_fluid ${dropdownLengthClass}`).add({
          'slds-dropdown_left': alignment === 'left' || alignment === 'auto',
          'slds-dropdown_center': alignment === 'center',
          'slds-dropdown_right': alignment === 'right',
          'slds-dropdown_bottom': alignment === 'bottom-center',
          'slds-dropdown_bottom slds-dropdown_right slds-dropdown_bottom-right': alignment === 'bottom-right',
          'slds-dropdown_bottom slds-dropdown_left slds-dropdown_bottom-left': alignment === 'bottom-left'
        }).toString();
      }
      get computedInputClass() {
        const classes = utils.classSet('slds-combobox__input');
        classes.add({
          'slds-input_faux': this.isUserInputDisabled,
          //rendering button
          'fix-slds-input_faux': this.isUserInputDisabled,
          // W-14210059
          'slds-input': !this.isUserInputDisabled,
          //rendering input
          'slds-is-disabled': this.disabled,
          'slds-combobox__input-value': this.computedInputValue,
          'slds-input-has-icon_group-right': !this.computedInputValue && this.showInputActivityIndicator
        });
        return classes.toString();
      }
      get _shouldOpenDropDown() {
        // If items were empty and through a user interaction the dropdown should have opened, and if the
        // component still has the focus we'll open it on items update instead.
        return !this.dropdownDisabled && this._inputHasFocus && this._requestedDropdownOpen;
      }
      get dropdownDisabled() {
        return this.readOnly || this.disabled;
      }
      handleOptionClick(event) {
        if (event.target.hasAttribute('aria-selected')) {
          event.stopPropagation();
          event.preventDefault();
          this.selectOptionAndCloseDropdown(event.target);
        }
      }
      handleOptionMouseEnter(event) {
        if (event.target.hasAttribute('aria-selected')) {
          this._editingMode = false;
          this.highlightOption(event.target);
        }
      }
      handleDropdownMouseLeave() {
        this.removeHighlight();

        // This is to account for when a user makes a mousedown press on the dropdown and then leaves the dropdown
        // area, it would leave the dropdown open even though the focus would no longer be on the input
        if (!this._inputHasFocus) {
          this.closeDropdown();
        }
      }
      handleTriggerClick(event) {
        event.stopPropagation();
        this.allowBlur();
        if (this.dropdownDisabled) {
          return;
        }
        if (!this.hasInputPill) {
          // toggle dropdown only for readonly combobox, only open the dropdown otherwise
          // if it's not already opened.
          if (this._inputAriaReadOnly) {
            if (this._dropdownVisible) {
              this.closeDropdown();
            } else {
              this.openDropdownIfNotEmpty();
            }
          } else {
            this.openDropdownIfNotEmpty();
          }
          this.inputElement.focus();
        }
      }
      handlePillKeyDown(event) {
        if (this.dropdownDisabled) {
          return;
        }
        // 'Del' is IE11 specific, remove once IE11 is no longer supported
        if (event.key === 'Delete' || event.key === 'Del' || event.key === 'Backspace') {
          this.handlePillRemove();
        }
      }
      handleInputKeyDown(event) {
        if (this.dropdownDisabled) {
          return;
        }
        // For details: https://developer.mozilla.org/en-US/docs/Web/API/Element/keydown_event
        // ctrl + option + arrow right should read the next item in the list and should not update aria-activedescendant.
        // skip the updation of aria-activedescendant on ctrl.
        if (event.isComposing || event.keyCode === 229 || event.ctrlKey || event.altKey) {
          return;
        }
        if (this.hasInputPill) {
          this.handlePillKeyDown(event);
        } else {
          handleKeyDownOnInput({
            event,
            currentIndex: this.getCurrentHighlightedOptionIndex(),
            dropdownInterface: this._keyboardInterface
          });
        }
      }
      handleInputClick() {
        this.dispatchEvent(new CustomEvent('inputclick'));
      }
      handleTextChange(event) {
        const inputValue = event.target.value;
        if (this.variant === inputUtils.VARIANT.STANDARD) {
          let selectedItem;
          const itemByValue = this._unprocessedItems.find(item => item.value === inputValue);
          selectedItem = itemByValue;
          if (!itemByValue) {
            const itemByLabel = this._unprocessedItems.find(item => item.value && item.text === inputValue);
            selectedItem = itemByLabel;
          }
          if (selectedItem) {
            this._events.dispatchSelect(selectedItem.value);
          }
        } else {
          this._events.dispatchTextChange(inputValue);
        }
      }
      handleFocus() {
        this._inputHasFocus = true;
        this._events.dispatchFocus();
      }
      handleInput(event) {
        // Do not dispatch any events if the pill is showing, this is specifically an IE11 problem,
        // which fires an 'input' event when the placeholder on an input is changed (which is what happens when
        // the pill is shown). The check can be removed when IE11 is no longer supported.
        if (!this.hasInputPill) {
          this._events.dispatchTextInput(event.target.value);
        }
      }
      handleBlur() {
        this._inputHasFocus = false;
        if (this._cancelBlur) {
          return;
        }
        this.closeDropdown();
        this._events.dispatchBlur();
      }
      handleDropdownMouseDown(event) {
        const mainButton = 0;
        if (event.button === mainButton) {
          this.cancelBlur();
        }
      }
      handleDropdownMouseUp() {
        // We need this to make sure that if a scrollbar is being dragged with the mouse, upon release
        // of the drag we allow blur, otherwise the dropdown would not close on blur since we'd have cancel blur
        // set
        this.allowBlur();
      }
      highlightOption(option) {
        this.removeHighlight();
        if (option) {
          option.highlight();
          this._highlightedOptionElement = option;
          this._highlightedOptionElementId = option.getAttribute('data-item-id');
          // active element is a component id getter works properly
          this._activeElementDomId = option.id;
        }
        this.synchronizeA11y();
      }
      highlightOptionAndScrollIntoView(optionElement) {
        if (this._selectableItems.length === 0 || !optionElement) {
          return;
        }
        this.highlightOption(optionElement);
        scrollIntoViewIfNeeded(optionElement, this.listboxElement);
      }
      removeHighlight() {
        const option = this._highlightedOptionElement;
        if (option) {
          option.removeHighlight();
          this._highlightedOptionElement = null;
          this._highlightedOptionElementId = null;
          this._activeElementDomId = null;
        }
      }
      selectOptionAndCloseDropdown(optionElement) {
        this.closeDropdown();
        this.inputElement.focus();
        const selectedValue = optionElement.getAttribute('data-value');
        this._events.dispatchSelect(selectedValue);
      }
      handleInputSelect(event) {
        event.stopPropagation();
      }
      openDropdownIfNotEmpty() {
        if (this._dropdownVisible) {
          // Already visible
          return;
        }
        const noOptions = !Array.isArray(this.items) || this.items.length === 0;
        // Do not dispatch the open request event if there already was a request to open
        if (noOptions && !this._requestedDropdownOpen) {
          // Dispatch dropdown open request
          this._events.dispatchDropdownOpenRequest();
        }

        // Do not open if there's nothing to show in the dropdown (eg. no options and no dropdown activity indicator)
        if (this.isDropdownEmpty) {
          // We use this attribute to flag whether an attempt has been made via user-interaction
          // to open the dropdown
          this._requestedDropdownOpen = true;
          return;
        }
        if (!this._hasDropdownOpened) {
          if (this._unprocessedItems) {
            this.updateItems(this._unprocessedItems);
          }
          this._hasDropdownOpened = true;
        }
        this._requestedDropdownOpen = false;
        this._dropdownVisible = true;

        // remove-next-line-for-c-namespace
        this.startDropdownAutoPositioning();
        this.highlightDefaultItem();
        this._events.dispatchDropdownOpen();
      }
      closeDropdown() {
        if (!this._dropdownVisible) {
          // Already closed
          return;
        }
        // remove-next-line-for-c-namespace
        this.stopDropdownPositioning();
        this.removeHighlight();
        this._dropdownVisible = false;
      }
      findOptionElementByIndex(index) {
        return this.template.querySelector(`[data-item-id="${this.itemId(index)}"]`);
      }
      allowBlur() {
        this._cancelBlur = false;
      }
      cancelBlur() {
        this._cancelBlur = true;
      }
      getCurrentHighlightedOptionIndex() {
        if (this._highlightedOptionElementId && this._highlightedOptionElementId.length > 0) {
          return this.itemIndexFromId(this._highlightedOptionElementId);
        }
        return -1;
      }
      get inputElement() {
        return utilsPrivate.isCSR ? this.template.querySelector(INPUT_ELEMENT_SELECTOR) : null;
      }

      // remove-next-line-for-c-namespace
      startDropdownAutoPositioning() {
        if (this.dropdownAlignment !== 'auto') {
          return;
        }
        if (!this._autoPosition) {
          this._autoPosition = new positionLibrary.AutoPosition(this);
        }

        // when using dropdown-alignment='auto' positioning and standard variant lighting-combobox
        // the selector for 'target' is determined by this.isUserInputDisabled
        // when TRUE the target is a BUTTON element acting as a faux / fake INPUT element
        // when FALSE the target is an INPUT element
        // NOTE: isUserInputDisabled is NOT determined by combobox.disabled
        // instead isUserInputDisabled is determined by
        // this.isStandardOrLabelVariant && !this.isAutocompleteEnabled (which is an internal variable)
        // this means that the INPUT is often NOT present, and instead a BUTTON is
        // this selector for .start({ target }) is used to
        // position the element from so this.isUserInputDisabled
        // must be taken into account so the proper selector can be used
        // the 'element' below is always the same without IF/ELSE, so there
        // is not a need to switch between selectors
        const selectorToUse = this.isUserInputDisabled ? FAUX_INPUT_BUTTON_ELEMENT_SELECTOR : INPUT_PART_ELEMENT_SELECTOR;
        this._autoPosition.start({
          target: () => this.template.querySelector(selectorToUse),
          element: () => this.template.querySelector('div.slds-dropdown'),
          align: {
            horizontal: positionLibrary.Direction.Left,
            vertical: positionLibrary.Direction.Top
          },
          targetAlign: {
            horizontal: positionLibrary.Direction.Left,
            vertical: positionLibrary.Direction.Bottom
          },
          autoFlip: true,
          alignWidth: true,
          autoShrinkHeight: true,
          minHeight: this._selectableItems < 3 ? SMALL_MIN_HEIGHT : MEDIUM_MIN_HEIGHT,
          keepInViewport: true
        });
      }

      // remove-next-line-for-c-namespace
      stopDropdownPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }
      get hasInputPill() {
        return this.inputPill && Object.keys(this.inputPill).length > 0;
      }
      get isCloseVisible() {
        if (this.disabled) {
          return false;
        }
        return this.hasInputPill;
      }
      handlePillRemove() {
        this.inputElement.focus();
        this._events.dispatchPillRemove(this.inputPill);
      }
      get computedFormElementClass() {
        const hasIcon = this.hasInputPill && this.inputPill.iconName;
        return utils.classSet('slds-combobox__form-element slds-input-has-icon').add({
          'slds-input-has-icon_right': !hasIcon,
          'slds-input-has-icon_left-right': hasIcon
        }).toString();
      }
      get computedAriaExpanded() {
        return this._dropdownVisible ? 'true' : 'false';
      }
      updateItems(items) {
        if (!items) {
          return;
        }
        utilsPrivate.assert(Array.isArray(items), '"items" must be an array');
        this._selectableItems = 0;
        this._highlightedItemIndex = 0;
        this._items = items.map(item => {
          if (item.items) {
            // This is a group
            const groupCopy = {
              label: item.label
            };
            groupCopy.items = item.items.map(groupItem => {
              return this.processItem(groupItem);
            });
            return groupCopy;
          }
          return this.processItem(item);
        });
      }
      highlightDefaultItem() {
        this.removeHighlight();
        if (!this.privateDisableDefaultHighlight && !this._editingMode) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            this.highlightOptionAndScrollIntoView(this.findOptionElementByIndex(this._highlightedItemIndex));
          });
        }
      }
      get isDropdownEmpty() {
        // If the activity indicator is showing then it's not empty
        return !this.showDropdownActivityIndicator && (!Array.isArray(this.items) || this.items.length === 0);
      }
      dropdownKeyboardInterface() {
        const that = this;
        return {
          getTotalOptions() {
            return that._selectableItems;
          },
          selectByIndex(index) {
            that.selectOptionAndCloseDropdown(that.findOptionElementByIndex(index));
          },
          highlightOptionWithIndex(index) {
            that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
          },
          isInputReadOnly() {
            return that._inputAriaReadOnly;
          },
          shouldPreventInputDeletion() {
            return that.isAutocompleteEnabled && that.isDefaultReadOnlyTypes;
          },
          highlightOptionWithText(currentIndex, text) {
            // This only supports a flat structure, groups are not supported
            for (let index = currentIndex + 1; index < that._items.length; index++) {
              const option = that._items[index];
              if (option.selectable && option.text && option.text.toLowerCase().indexOf(text.toLowerCase()) === 0) {
                that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
                return;
              }
            }
            for (let index = 0; index < currentIndex; index++) {
              const option = that._items[index];
              if (option.selectable && option.text && option.text.toLowerCase().indexOf(text.toLowerCase()) === 0) {
                that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
                return;
              }
            }
          },
          isDropdownVisible() {
            return that._dropdownVisible;
          },
          openDropdownIfNotEmpty() {
            that.openDropdownIfNotEmpty();
          },
          closeDropdown() {
            that.closeDropdown();
          },
          setEditingMode(isEditing) {
            that._editingMode = isEditing;
            if (isEditing) {
              that._activeElementDomId = null;
            }
            that.synchronizeA11y();
          }
        };
      }
      get computedAriaInvalid() {
        const ariaInvalid = this.template.host.getAttribute('data-aria-invalid');
        return utilsPrivate.computeAriaInvalid(ariaInvalid, true);
      }
      isShadowRoot(node) {
        return node && node.nodeType === 11;
      }
      parentNodeContainsClass(host, className) {
        let element = host;
        while (element.parentNode) {
          element = this.isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode;
          if (element.classList && element.classList.contains(className)) {
            return true;
          }
        }
        return false;
      }
      overrideDropdownAlignment() {
        let isModal = this.parentNodeContainsClass(this.template.host, 'slds-modal');
        if (isModal) {
          this._dropdownAlignment = 'auto';
        }
      }
      /*LWC compiler v7.1.5*/
    }
    LightningBaseCombobox.delegatesFocus = true;
    LightningBaseCombobox.validationOptOut = ['class'];
    lwc.registerDecorators(LightningBaseCombobox, {
      publicProps: {
        autocomplete: {
          config: 3
        },
        inputText: {
          config: 0
        },
        inputIconName: {
          config: 0
        },
        inputIconSize: {
          config: 0
        },
        inputIconAlternativeText: {
          config: 0
        },
        inputMaxlength: {
          config: 0
        },
        showInputActivityIndicator: {
          config: 0
        },
        required: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        inputLabel: {
          config: 0
        },
        customRole: {
          config: 0
        },
        customAriaHasPopup: {
          config: 0
        },
        accessKey: {
          config: 0
        },
        name: {
          config: 0
        },
        inputPill: {
          config: 0
        },
        attributionLogoUrl: {
          config: 0
        },
        attributionLogoAssistiveText: {
          config: 0
        },
        dropdownAlignment: {
          config: 3
        },
        inputControlsElement: {
          config: 3
        },
        inputDetailsElements: {
          config: 3
        },
        ariaErrorMessageElements: {
          config: 3
        },
        inputDescribedByElements: {
          config: 3
        },
        inputLabelledByElement: {
          config: 3
        },
        rootAriaNode: {
          config: 3
        },
        dropdownHeight: {
          config: 3
        },
        showDropdownActivityIndicator: {
          config: 3
        },
        ariaDisabled: {
          config: 0
        },
        computedAriaDisabled: {
          config: 1
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        variant: {
          config: 3
        },
        items: {
          config: 3
        },
        disableDefaultHighlight: {
          config: 3
        }
      },
      publicMethods: ["highlightInputText", "focus", "focusAndOpenDropdownIfNotEmpty", "blur"],
      track: {
        _items: 1
      },
      fields: ["_showDropdownActivityIndicator", "_disabled", "_dropdownVisible", "_hasDropdownOpened", "_highlightedOptionElementId", "_variant", "_dropdownHeight", "_readonly", "_logoLoaded", "_inputDescribedBy", "_inputAriaControls", "_inputAriaDetails", "_activeElementDomId", "_autocomplete", "_dropdownAlignment", "originDisableDefaultHighlight", "privateDisableDefaultHighlight", "_editingMode", "_connected", "ariaObserver"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(LightningBaseCombobox, {
      tmpl: _tmpl,
      sel: "lightning-base-combobox",
      apiVersion: 62
    });
    function scrollIntoViewIfNeeded(element, scrollingParent) {
      const parentRect = scrollingParent.getBoundingClientRect();
      const findMeRect = element.getBoundingClientRect();
      if (findMeRect.top < parentRect.top) {
        if (element.offsetTop + findMeRect.height < parentRect.height) {
          // If element fits by scrolling to the top, then do that
          scrollingParent.scrollTop = 0;
        } else {
          // Otherwise, top align the element
          scrollingParent.scrollTop = element.offsetTop;
        }
      } else if (findMeRect.bottom > parentRect.bottom) {
        // bottom align the element
        scrollingParent.scrollTop += findMeRect.bottom - parentRect.bottom;
      }
    }

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/timepicker', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/helptext', 'lightning/baseCombobox', '@salesforce/label/LightningDateTimePicker.invalidDate', '@salesforce/label/LightningDateTimePicker.rangeOverflow', '@salesforce/label/LightningDateTimePicker.rangeUnderflow', '@salesforce/label/LightningControl.required', '@salesforce/label/LightningInput.helptextAlternativeText', 'lightning/shadowBaseClassPrivate', 'lightning/internationalizationLibrary', 'lightning/utils', 'lightning/iso8601Utils', 'lightning/utilsPrivate', 'lightning/inputUtils'], (function (exports, lwc, stylesheet0$1, _lightningHelptext, _lightningBaseCombobox, labelInvalidDate, labelRangeOverflow, labelRangeUnderflow, labelRequired, labelHelpTextAlternativeText, LightningShadowBaseClass, internationalizationLibrary, utils, iso8601Utils, utilsPrivate, inputUtils) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningHelptext__default = /*#__PURE__*/_interopDefaultCompat(_lightningHelptext);
  var _lightningBaseCombobox__default = /*#__PURE__*/_interopDefaultCompat(_lightningBaseCombobox);
  var labelInvalidDate__default = /*#__PURE__*/_interopDefaultCompat(labelInvalidDate);
  var labelRangeOverflow__default = /*#__PURE__*/_interopDefaultCompat(labelRangeOverflow);
  var labelRangeUnderflow__default = /*#__PURE__*/_interopDefaultCompat(labelRangeUnderflow);
  var labelRequired__default = /*#__PURE__*/_interopDefaultCompat(labelRequired);
  var labelHelpTextAlternativeText__default = /*#__PURE__*/_interopDefaultCompat(labelHelpTextAlternativeText);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")) + shadowSelector + " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet$1];

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) fieldset" : hostSelector + "[data-render-mode=\"shadow\"] fieldset")), shadowSelector, " {border: 0;margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {position: relative;min-width: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;hyphens: auto;display: inline-block;color: var(--slds-g-color-on-surface-2);font-size: var(--slds-s-label-font-size, var(--slds-g-font-scale-neg-2));padding-inline-end: var(--slds-g-spacing-2);padding-block-start: var(--slds-g-spacing-1);margin-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label:empty")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {clear: inline-start;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-radio", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {display: inline-block;position: relative;padding-block-start: var(--slds-g-spacing-1);vertical-align: top;line-height: var(--slds-g-font-lineheight-1);z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-form-element__helper" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__helper")), shadowSelector, " {font-size: var(--slds-s-helptext-font-size, var(--slds-g-font-scale-neg-2));margin-block-start: calc(var(--slds-g-spacing-1) / 2);display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_edit")), shadowSelector, " .slds-form-element__static", shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " {flex-basis: 0%;border-bottom: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__label", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__legend" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__legend")), shadowSelector, " {font-weight: var(--slds-g-font-weight-7);float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__addon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__addon")), shadowSelector, " {display: inline-block;margin-block-start: 0;margin-block-end: 0;margin-inline-start: var(--slds-g-spacing-2);margin-inline-end: var(--slds-g-spacing-2);align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;word-break: break-word;display: inline-block;font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-neutral-base-10);width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static.slds-text-longform" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static.slds-text-longform")), shadowSelector, " *:last-child", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static:empty")), shadowSelector, " {min-height: calc(var(--slds-g-sizing-6) + 1px);vertical-align: bottom;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static--edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static--edit")), shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-required" : hostSelector + "[data-render-mode=\"shadow\"] .slds-required")), shadowSelector, " {color: var(--slds-g-color-error-1);margin-block-start: 0;margin-block-end: 0;margin-inline-start: calc(var(--slds-g-spacing-1) / 2);margin-inline-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-form-element__help", shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-form-element__help" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) {" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {padding: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__label" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__label" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {width: 100%;flex-basis: 100%;clear: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__icon" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {float: none;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline'].slds-form-element_horizontal) {" : hostSelector + ".slds-form-element_horizontal[variant='label-inline'][data-render-mode=\"shadow\"] {")), "padding: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']).slds-is-edited {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"].slds-is-edited {")), "padding-block-start: var(--slds-g-sizing-6)}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__label" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {float: inline-start;max-width: calc(33% - var(--slds-g-sizing-6));flex-basis: calc(33% - var(--slds-g-sizing-6));flex-grow: 1;margin-block-end: 0;position: relative;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) lightning-helptext" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] lightning-helptext")), shadowSelector, " {float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {margin-inline-start: 33%;clear: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list__column" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list__column")), shadowSelector, " .slds-form-element__label", shadowSelector, " {width: auto;max-width: 100%;flex-basis: auto;float: none;position: relative;padding-inline-start: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__help" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list")), shadowSelector, " {clear: none;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " {display: flex;margin-bottom: var(--slds-g-spacing-1);margin-left: calc(var(--slds-g-spacing-1) * -1);margin-right: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " .slds-form-element__label", shadowSelector, " {padding-top: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element", shadowSelector, " {padding-left: var(--slds-g-spacing-1);padding-right: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_address" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_address")), shadowSelector, " .slds-form-element__row", shadowSelector, " {align-items: flex-end;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-hidden']) .slds-form-element__label" : hostSelector + "[variant='label-hidden'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {display: none}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet2 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1, stylesheet2];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<abbr class="slds-required${0}"${"a0:title"}${2}>*</abbr>`;
  const $fragment2 = lwc.parseFragment`<div${"a0:id"} data-error-message${"c0"} aria-live="polite"${2}>${"t1"}</div>`;
  const stc0 = {
    classMap: {
      "slds-form-element__control": true
    },
    key: 4
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {ncls: api_normalize_class_name, sp: api_static_part, st: api_static_fragment, d: api_dynamic_text, t: api_text, h: api_element, c: api_custom_element, b: api_bind, gid: api_scoped_id} = $api;
    const {_m0, _m1, _m2, _m3, _m4, _m5, _m6} = $ctx;
    return [!$cmp.hasExternalLabel ? api_element("label", {
      className: api_normalize_class_name($cmp.computedLabelClass),
      key: 0
    }, [$cmp.required ? api_static_fragment($fragment1, 2, [api_static_part(0, {
      attrs: {
        "title": $cmp.i18n.required
      }
    }, null)]) : null, api_text(api_dynamic_text($cmp.label))]) : null, !$cmp.hasExternalLabel ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext__default.default, {
      props: {
        "content": $cmp.fieldLevelHelp,
        "alternativeText": $cmp.helptextAlternativeText
      },
      key: 3
    }) : null : null, api_element("div", stc0, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox__default.default, {
      attrs: {
        "data-aria-invalid": $cmp.computedAriaInvalid
      },
      props: {
        "part": "input-container",
        "ariaDisabled": $cmp.ariaDisabled,
        "autocomplete": $cmp.autocomplete,
        "accessKey": $cmp.accessKey,
        "dropdownHeight": "small",
        "name": $cmp.name,
        "variant": "lookup",
        "placeholder": $cmp.placeholder,
        "disabled": $cmp.disabled,
        "readOnly": $cmp.readOnly,
        "required": $cmp.required,
        "items": $cmp.items,
        "inputText": $cmp.displayValue,
        "inputIconName": "utility:clock",
        "inputLabel": $cmp.comboboxLabel,
        "inputControlsElement": $cmp.ariaControlsElement,
        "inputDetailsElements": $cmp.ariaDetailsElements,
        "inputLabelledByElement": $cmp.ariaLabelledByElement,
        "dropdownAlignment": "auto",
        "rootAriaNode": $cmp.rootAriaNode,
        "inputDescribedByElements": $cmp.ariaDescribedByElements,
        "ariaErrorMessageElements": $cmp.ariaErrorMessageElements
      },
      key: 5,
      on: {
        "ready": _m0 || ($ctx._m0 = api_bind($cmp.handleReady)),
        "textchange": _m1 || ($ctx._m1 = api_bind($cmp.handleInputChange)),
        "textinput": _m2 || ($ctx._m2 = api_bind($cmp.handleTextInput)),
        "dropdownopenrequest": _m3 || ($ctx._m3 = api_bind($cmp.handleDropdownOpenRequest)),
        "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
        "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
        "select": _m6 || ($ctx._m6 = api_bind($cmp.handleTimeSelect))
      }
    })]), api_static_fragment($fragment2, 7, [api_static_part(0, {
      className: api_normalize_class_name($cmp.computedClass),
      attrs: {
        "id": api_scoped_id("error-message")
      }
    }, null), api_static_part(1, null, api_dynamic_text($cmp._errorMessage))])];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-2onco8hrliv";
  tmpl.legacyStylesheetToken = "lightning-timepicker_timepicker";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  /* returns the closes time in the list that should be highlighted in case the value is not in the list. E.g.
  - if value is 16:18 and the list has 15 minute intervals, returns 16:30
  */
  function getTimeToHighlight(value, step) {
    const selectedTime = internationalizationLibrary.parseTime(value);
    if (!selectedTime) {
      return null;
    }
    selectedTime.setSeconds(0, 0);
    let closestHour = selectedTime.getHours();
    let closestMinute = selectedTime.getMinutes();
    const mod = closestMinute % step;
    const quotient = Math.floor(closestMinute / step);
    if (mod !== 0) {
      const multiplier = mod < step / 2 ? quotient : quotient + 1;
      closestMinute = multiplier * step;
      if (closestMinute >= 60) {
        if (closestHour === 23) {
          closestMinute -= step;
        } else {
          closestMinute = 0;
          closestHour++;
        }
      }
      selectedTime.setHours(closestHour);
      selectedTime.setMinutes(closestMinute);
    }
    return internationalizationLibrary.getISOTimeString(selectedTime);
  }

  const i18n = {
    invalidDate: labelInvalidDate__default.default,
    rangeOverflow: labelRangeOverflow__default.default,
    rangeUnderflow: labelRangeUnderflow__default.default,
    required: labelRequired__default.default,
    helpTextAlternativeText: labelHelpTextAlternativeText__default.default
  };
  const STEP = 15; // in minutes
  const TIME_STYLE = {
    SHORT: 'short',
    MEDIUM: 'medium',
    LONG: 'long'
  };
  class LightningTimePicker extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      this._disabled = false;
      this._required = false;
      this._displayValue = null;
      this._value = null;
      this._min = void 0;
      this._max = void 0;
      this._items = [];
      this._fieldLevelHelp = void 0;
      this._variant = 'lookup';
      this._mainInputId = void 0;
      this._errorMessage = void 0;
      this._readonly = true;
      this._describedByElements = [];
      this.rootAriaNode = void 0;
      /**
       * Controls auto-filling of the input. Set the attribute to pass
       * through autocomplete values to be interpreted by the browser.
       * By default autocomplete is off to avoid overlap of dropdowns.
       * @type {string}
       */
      this.autocomplete = 'off';
      this.ariaLabelledByElement = void 0;
      this.ariaControlsElement = void 0;
      this.ariaDetailsElements = void 0;
      this.ariaLabel = void 0;
      this.ariaDisabled = void 0;
      this.label = void 0;
      this.name = void 0;
      this.placeholder = '';
      this.accessKey = void 0;
      this.messageWhenValueMissing = void 0;
      this._ariaDescribedByElements = void 0;
      this._timeStyle = TIME_STYLE.SHORT;
      this.ariaErrorMessageElement = void 0;
    }
    get comboboxComponent() {
      return this.template.querySelector('lightning-base-combobox');
    }
    get messageWhenBadInput() {
      return this._messageWhenBadInput || utils.formatLabel(i18n.invalidDate, internationalizationLibrary.getTimeFormatFromStyle(this.timeStyle, true));
    }
    set messageWhenBadInput(message) {
      this._messageWhenBadInput = message;
    }
    get messageWhenRangeOverflow() {
      // using isoValue since the manually entered time could have seconds/milliseconds and the locale format generally doesn't have this precision
      return this._messageWhenRangeOverflow || utils.formatLabel(i18n.rangeOverflow, internationalizationLibrary.normalizeISOTime(this.max, this.timeStyle).isoValue);
    }
    set messageWhenRangeOverflow(message) {
      this._messageWhenRangeOverflow = message;
    }
    get messageWhenRangeUnderflow() {
      return this._messageWhenRangeUnderflow || utils.formatLabel(i18n.rangeUnderflow, internationalizationLibrary.normalizeISOTime(this.min, this.timeStyle).isoValue);
    }
    set messageWhenRangeUnderflow(message) {
      this._messageWhenRangeUnderflow = message;
    }
    set ariaDescribedByElements(el) {
      if (Array.isArray(el)) {
        this._ariaDescribedByElements = el;
      } else {
        this.ariaDescribedByElements = [el];
      }
    }
    get ariaDescribedByElements() {
      return this._ariaDescribedByElements;
    }
    get value() {
      return this._value;
    }
    set value(newValue) {
      const normalizedValue = iso8601Utils.removeTimeZoneSuffix(newValue);
      const normalizedTime = internationalizationLibrary.normalizeISOTime(normalizedValue, this.timeStyle);
      this._value = normalizedTime.isoValue;
      this._displayValue = normalizedTime.displayValue;
    }
    get disabled() {
      return this._disabled;
    }
    set disabled(value) {
      this._disabled = utilsPrivate.normalizeBoolean(value);
    }
    get readOnly() {
      return this._readonly;
    }
    set readOnly(value) {
      this._readonly = utilsPrivate.normalizeBoolean(value);
      if (this._readonly) {
        this._variant = inputUtils.VARIANT.STANDARD;
      }
    }
    get required() {
      return this._required;
    }
    set required(value) {
      this._required = utilsPrivate.normalizeBoolean(value);
    }
    hasBadInput() {
      return !!this._displayValue && this._value === null;
    }
    showHelpMessage(message) {
      if (!message) {
        this.classList.remove('slds-has-error');
        this._errorMessage = '';
      } else {
        this.classList.add('slds-has-error');
        this._errorMessage = message;
      }
    }
    set fieldLevelHelp(value) {
      this._fieldLevelHelp = value;
    }
    get fieldLevelHelp() {
      return this._fieldLevelHelp;
    }
    get variant() {
      return this._variant || inputUtils.VARIANT.STANDARD;
    }
    set variant(value) {
      this._variant = inputUtils.normalizeVariant(value);
      utilsPrivate.reflectAttribute(this, 'variant', this._variant);
    }
    get max() {
      return this._max;
    }
    set max(newValue) {
      this._max = newValue;
      if (this.connected) {
        this.rebuildAndUpdateTimeList();
      }
    }
    get min() {
      return this._min;
    }
    set min(newValue) {
      this._min = newValue;
      if (this.connected) {
        this.rebuildAndUpdateTimeList();
      }
    }

    /**
     * Sets focus on the input element.
     */
    focus() {
      if (this.connected) {
        this.getCombobox().focus();
      }
    }

    /**
     * Removes keyboard focus from the input element.
     */
    blur() {
      if (this.connected) {
        this.getCombobox().blur();
      }
    }
    get timeStyle() {
      return this._timeStyle;
    }
    set timeStyle(value) {
      this._timeStyle = utilsPrivate.normalizeString(value, {
        fallbackValue: TIME_STYLE.SHORT,
        validValues: [TIME_STYLE.SHORT, TIME_STYLE.MEDIUM, TIME_STYLE.LONG]
      });
      const normalizedDate = internationalizationLibrary.normalizeISOTime(this._value, this._timeStyle);
      this._displayValue = normalizedDate.displayValue;
    }
    connectedCallback() {
      super.connectedCallback();
      this._isNativeShadow = utilsPrivate.isNativeComponent(this);
      this.connected = true;
    }
    disconnectedCallback() {
      this.connected = false;
    }
    get ariaErrorMessageElements() {
      const elements = [this.ariaErrorMessageElement];
      if (this._errorMessage) {
        elements.push(this.template.querySelector('[data-error-message]'));
      }
      return elements;
    }
    synchronizeA11y() {
      const label = this.template.querySelector('label');
      utilsPrivate.synchronizeAttrs(label, {
        for: this._mainInputId
      });
    }
    renderedCallback() {
      this.synchronizeA11y();
    }
    get comboboxLabel() {
      // @W-12765711 Set the combobox aria label when no ariaLabel provided in a cross root scenario
      // Required as label 'for' relationship will not work
      return !this.ariaLabel && !this.ariaLabelledByElement && this._isNativeShadow ? this.label : this.ariaLabel;
    }
    get displayValue() {
      return this._displayValue;
    }
    get items() {
      return this._items;
    }
    get i18n() {
      return i18n;
    }
    get isLabelHidden() {
      return this.variant === inputUtils.VARIANT.LABEL_HIDDEN;
    }
    get computedClass() {
      let displayClass = this._errorMessage ? 'slds-show' : 'slds-hide';
      return 'slds-form-element__help ' + displayClass;
    }
    get computedLabelClass() {
      return utils.classSet('slds-form-element__label').add({
        'slds-assistive-text': this.isLabelHidden
      }).toString();
    }
    handleReady(e) {
      this._mainInputId = e.detail.id;
    }
    buildTimeList() {
      // We should always display the options in the short style since m/l will add an extra :00 to the options.
      const timeList = [];
      const minTime = internationalizationLibrary.normalizeISOTime(this.min, TIME_STYLE.SHORT).parsedValue;
      const minHour = minTime ? minTime.getHours() : 0;
      const maxTime = internationalizationLibrary.normalizeISOTime(this.max, TIME_STYLE.SHORT).parsedValue;
      const maxHour = maxTime ? maxTime.getHours() + 1 : 24;
      const date = new Date();
      for (let hour = minHour; hour < maxHour; hour++) {
        for (let minutes = 0; minutes < 60; minutes += STEP) {
          date.setHours(hour, minutes);
          date.setSeconds(0, 0);
          if (this.isBeforeMinTime(date, minTime)) {
            continue; // eslint-disable-line no-continue
          }
          if (this.isAfterMaxTime(date, maxTime)) {
            break;
          }
          const isoTime = internationalizationLibrary.getISOTimeString(date);
          const normalizedTime = internationalizationLibrary.normalizeISOTime(isoTime, TIME_STYLE.SHORT);
          timeList.push({
            type: 'option-inline',
            text: normalizedTime.displayValue,
            value: isoTime
          });
        }
      }
      return timeList;
    }
    get timeList() {
      if (!this._timeList) {
        this._timeList = this.buildTimeList();
      }
      if (!this._value) {
        return this._timeList;
      }
      const timeToHighlight = getTimeToHighlight(this._value, STEP);
      const timeList = this._timeList.map(item => {
        const itemCopy = Object.assign({}, item);
        if (item.value === this._value) {
          itemCopy.iconName = 'utility:check';
          itemCopy.checked = true;
        } else {
          itemCopy.checked = false;
        }
        if (item.value === timeToHighlight) {
          itemCopy.highlight = true;
        }
        return itemCopy;
      });
      return timeList;
    }
    rebuildAndUpdateTimeList() {
      // forcing the time list to be rebuilt
      this._timeList = null;
      this._items = this.timeList;
    }
    getCombobox() {
      return this.template.querySelector('lightning-base-combobox');
    }
    handleFocus() {
      this.dispatchEvent(new CustomEvent('focus'));
    }
    handleBlur() {
      this.dispatchEvent(new CustomEvent('blur'));
    }
    handleInputChange(event) {
      event.preventDefault();
      event.stopPropagation();

      // keeping the display value in sync with the element's value
      this._displayValue = event.detail.text;
      const {
        value,
        style
      } = internationalizationLibrary.parseFormattedTime(this._displayValue);
      this._value = value;
      if (style) {
        this._timeStyle = style;
      }
      this._items = this.timeList;
      this.dispatchChangeEvent();
    }
    handleTextInput(event) {
      event.preventDefault();
      event.stopPropagation();

      // keeping the display value in sync with the element's value
      this._displayValue = event.detail.text;
    }
    handleTimeSelect(event) {
      event.stopPropagation();

      // for some reason this event is fired without detail from grouped-combobox
      if (!event.detail) {
        return;
      }
      this._value = event.detail.value;
      this._displayValue = internationalizationLibrary.normalizeISOTime(this._value, this.timeStyle).displayValue;
      this._items = this.timeList;
      this.dispatchChangeEvent();
    }
    handleDropdownOpenRequest() {
      this._items = this.timeList;
    }
    dispatchChangeEvent() {
      this.dispatchEvent(new CustomEvent('change', {
        composed: true,
        bubbles: true,
        detail: {
          value: this._value
        }
      }));
    }
    isBeforeMinTime(date, minTime) {
      const minDate = minTime || internationalizationLibrary.normalizeISOTime(this.min, TIME_STYLE.SHORT);
      return minDate ? internationalizationLibrary.isBefore(date, minDate, 'minute') : false;
    }
    isAfterMaxTime(date, maxTime) {
      const maxDate = maxTime || internationalizationLibrary.normalizeISOTime(this.max, TIME_STYLE.SHORT);
      return maxDate ? internationalizationLibrary.isAfter(date, maxDate, 'minute') : false;
    }
    get hasExternalLabel() {
      return this.variant === inputUtils.VARIANT.LABEL_HIDDEN && this.ariaLabelledByElement && this.ariaLabelledByElement.length;
    }
    get computedAriaInvalid() {
      const dataAriaInvalid = utilsPrivate.isCSR ? this.template.host.getAttribute('data-aria-invalid') : null;
      const isAriaInvalid = dataAriaInvalid || this._errorMessage;
      return utilsPrivate.computeAriaInvalid(isAriaInvalid, this.value);
    }
    get helptextAlternativeText() {
      return utils.formatLabel(i18n.helpTextAlternativeText, this.label);
    }
    /*LWC compiler v7.1.5*/
  }
  LightningTimePicker.delegatesFocus = true;
  lwc.registerDecorators(LightningTimePicker, {
    publicProps: {
      rootAriaNode: {
        config: 0
      },
      autocomplete: {
        config: 0
      },
      ariaLabelledByElement: {
        config: 0
      },
      ariaControlsElement: {
        config: 0
      },
      ariaDetailsElements: {
        config: 0
      },
      ariaLabel: {
        config: 0
      },
      ariaDisabled: {
        config: 0
      },
      label: {
        config: 0
      },
      name: {
        config: 0
      },
      placeholder: {
        config: 0
      },
      accessKey: {
        config: 0
      },
      comboboxComponent: {
        config: 1
      },
      messageWhenValueMissing: {
        config: 0
      },
      messageWhenBadInput: {
        config: 3
      },
      messageWhenRangeOverflow: {
        config: 3
      },
      messageWhenRangeUnderflow: {
        config: 3
      },
      ariaDescribedByElements: {
        config: 3
      },
      value: {
        config: 3
      },
      disabled: {
        config: 3
      },
      readOnly: {
        config: 3
      },
      required: {
        config: 3
      },
      fieldLevelHelp: {
        config: 3
      },
      variant: {
        config: 3
      },
      max: {
        config: 3
      },
      min: {
        config: 3
      },
      timeStyle: {
        config: 3
      },
      ariaErrorMessageElement: {
        config: 0
      }
    },
    publicMethods: ["hasBadInput", "showHelpMessage", "focus", "blur"],
    track: {
      _disabled: 1,
      _required: 1,
      _displayValue: 1,
      _value: 1,
      _min: 1,
      _max: 1,
      _items: 1,
      _fieldLevelHelp: 1,
      _variant: 1,
      _mainInputId: 1,
      _errorMessage: 1,
      _readonly: 1,
      _describedByElements: 1
    },
    fields: ["_ariaDescribedByElements", "_timeStyle"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningTimePicker, {
    tmpl: _tmpl,
    sel: "lightning-timepicker",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/datetimepicker', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/helptext', 'lightning/datepicker', 'lightning/timepicker', '@salesforce/label/LightningDateTimePicker.dateLabel', '@salesforce/label/LightningDateTimePicker.rangeOverflow', '@salesforce/label/LightningDateTimePicker.rangeUnderflow', '@salesforce/label/LightningDateTimePicker.timeLabel', '@salesforce/label/LightningInput.helptextAlternativeText', '@salesforce/label/LightningDateTimePicker.valueMissingWithDateFormat', '@salesforce/label/LightningDateTimePicker.customErrorWithDateFormat', '@salesforce/i18n/timeZone', 'lightning/shadowBaseClassPrivate', 'lightning/utils', 'lightning/utilsPrivate', 'lightning/internationalizationLibrary', 'lightning/iso8601Utils', 'lightning/inputUtils'], (function (exports, lwc, stylesheet0$1, _lightningHelptext, _lightningDatepicker, _lightningTimepicker, labelDate, labelRangeOverflow, labelRangeUnderflow, labelTime, labelHelpTextAlternativeText, labelValueMissingWithDateFormat, labelCustomErrorWithDateFormat, sfTimeZone, LightningShadowBaseClass, utils, utilsPrivate, internationalizationLibrary, iso8601Utils, inputUtils) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningHelptext__default = /*#__PURE__*/_interopDefaultCompat(_lightningHelptext);
  var _lightningDatepicker__default = /*#__PURE__*/_interopDefaultCompat(_lightningDatepicker);
  var _lightningTimepicker__default = /*#__PURE__*/_interopDefaultCompat(_lightningTimepicker);
  var labelDate__default = /*#__PURE__*/_interopDefaultCompat(labelDate);
  var labelRangeOverflow__default = /*#__PURE__*/_interopDefaultCompat(labelRangeOverflow);
  var labelRangeUnderflow__default = /*#__PURE__*/_interopDefaultCompat(labelRangeUnderflow);
  var labelTime__default = /*#__PURE__*/_interopDefaultCompat(labelTime);
  var labelHelpTextAlternativeText__default = /*#__PURE__*/_interopDefaultCompat(labelHelpTextAlternativeText);
  var labelValueMissingWithDateFormat__default = /*#__PURE__*/_interopDefaultCompat(labelValueMissingWithDateFormat);
  var labelCustomErrorWithDateFormat__default = /*#__PURE__*/_interopDefaultCompat(labelCustomErrorWithDateFormat);
  var sfTimeZone__default = /*#__PURE__*/_interopDefaultCompat(sfTimeZone);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {display: flex;align-items: center;gap: var(--sds-c-inputtext-spacing-gap, var(--sds-s-input-spacing-gap));min-height: var(--sds-c-inputtext-sizing-height, var(--sds-s-input-sizing-height));padding-inline-start: var(\n --sds-c-inputtext-spacing-inlinestart,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-spacing-inlineend,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-spacing-blockstart,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-spacing-blockend,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );background: var(--sds-c-inputtext-color-background, var(--sds-s-input-color-background));border-block-start: var(\n --sds-c-inputtext-sizing-border-blockstart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockstart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-start: var(\n --sds-c-inputtext-sizing-border-inlinestart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlinestart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-end: var(\n --sds-c-inputtext-sizing-border-inlineend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlineend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-block-end: var(\n --sds-c-inputtext-sizing-border-blockend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-radius: var(--sds-c-inputtext-radius-border, var(--sds-s-input-radius-border));box-shadow: var(--sds-c-inputtext-shadow, var(--sds-s-input-shadow));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, " {width: 100%;height: 100%;padding: 0;font-size: var(--sds-c-inputtext-font-size, var(--sds-s-input-font-size));color: var(--sds-c-inputtext-text-color, var(--sds-s-input-text-color));line-height: 1;border: none;background: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][active]) [part~='input-container']" : hostSelector + "[active][data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-active,\n var(--sds-s-input-color-background-active)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-active,\n var(--sds-s-input-color-border-active)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-active, var(--sds-s-input-shadow-active));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, "::placeholder {color: var(--sds-c-inputtext-text-color-placeholder, var(--sds-s-input-text-color-placeholder));font-style: var(--sds-c-inputtext-font-style-placeholder, var(--sds-s-input-font-style-placeholder));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']:focus-within" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-focus,\n var(--sds-s-input-color-border-focus, revert)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-focus, var(--sds-s-input-shadow-focus));--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-focus,\n var(--sds-s-input-color-background-focus, revert)\n );--sds-c-inputtext-text-color: var(\n --sds-c-inputtext-text-color-focus,\n var(--sds-s-input-text-color-focus, revert)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']:focus")), shadowSelector, " {outline: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {display: inline-flex;align-items: center;gap: var(--sds-c-inputtext-label-spacing-gap, var(--sds-s-label-spacing-gap));padding-inline-start: var(\n --sds-c-inputtext-label-spacing-inlinestart,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-label-spacing-inlineend,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-label-spacing-blockstart,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-label-spacing-blockend,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );color: var(--sds-c-inputtext-label-color, var(--sds-s-label-color));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {font-size: var(--sds-c-inputtext-label-font-size, var(--sds-s-label-font-size));font-weight: var(--sds-c-inputtext-label-font-weight, var(--sds-s-label-font-weight));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='help-text visible']" : hostSelector + "[data-render-mode=\"shadow\"] [part='help-text visible']")), shadowSelector, " {font-size: var(--sds-c-inputtext-helptext-font-size, var(--sds-s-helptext-font-size));color: var(--sds-c-inputtext-helptext-text-color, var(--sds-s-helptext-text-color));padding-inline-start: var(\n --sds-c-inputtext-helptext-spacing-inlinestart,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-helptext-spacing-inlineend,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-helptext-spacing-blockstart,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-helptext-spacing-blockend,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) {" : hostSelector + "[disabled][data-render-mode=\"shadow\"] {")), "--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-disabled,\n var(--sds-s-input-color-background-disabled)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-disabled,\n var(--sds-s-input-color-border-disabled)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][label-hidden]) [part='label-container']" : hostSelector + "[label-hidden][data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-inputtext-icon-color-foreground,\n var(--slds-g-color-on-surface-1)\n );--slds-c-icon-sizing: var(--slds-c-inputtext-icon-sizing, 14px);--sds-c-inputtext-sizing-height: var(\n --slds-c-inputtext-sizing-height,\n var(--slds-g-sizing-9)\n );--sds-c-inputtext-color-background: var(\n --slds-c-inputtext-color-background,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-color-background-focus: var(\n --slds-c-inputtext-color-background-focus,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-text-color: var(--slds-c-inputtext-text-color);--sds-c-inputtext-font-size: var(\n --slds-c-inputtext-font-size,\n var(--slds-g-font-size-base)\n );--sds-c-inputtext-text-color-placeholder: var(\n --slds-c-inputtext-text-color-placeholder,\n var(--slds-g-color-on-surface-1)\n );--sds-c-inputtext-color-border: var(\n --slds-c-inputtext-color-border,\n var(--slds-g-color-border-2)\n );--sds-c-inputtext-sizing-border: var(--slds-c-inputtext-sizing-border);--sds-c-inputtext-radius-border: var(\n --slds-c-inputtext-radius-border,\n var(--slds-g-radius-border-2)\n );display: flex;flex-wrap: wrap;flex-direction: column;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {flex: 1 0 100%;align-items: stretch;--sds-c-inputtext-spacing-inline: 0;--sds-c-inputtext-spacing-block: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']")), shadowSelector, " {border: none;display: inline-block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " .slds-input__icon:not(button)", shadowSelector, " {pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input'][type='range']")), shadowSelector, " {min-height: calc(1.875rem + (1px * 2));margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:focus-within" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 3px var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;border-width: var(--sds-c-inputtext-sizing-border, var(--slds-g-sizing-border-1));border-color: var(--sds-c-inputtext-color-border, var(--slds-g-color-border-2));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {padding-inline-start: var(\n --slds-c-inputtext-spacing-inlinestart,\n var(--slds-g-spacing-3));padding-inline-end: var(\n --slds-c-inputtext-spacing-inlineend,\n var(--slds-g-spacing-4));height: unset;font-family: var(--slds-g-font-family);}", ((useActualHostSelector ? ":host(:not([disabled])) [part=\"input-container\"]:focus-within" + shadowSelector + ", :host(:not([disabled])) [part=\"input-container\"]:active" : hostSelector + ":not([disabled]) [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + ":not([disabled]) [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part='input-text']" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-spacing-inline-start-readonly: 0;--sds-c-inputtext-color-border-focus: transparent;--slds-c-inputtext-color-border: transparent;--slds-c-inputtext-color-background: transparent;--slds-c-inputtext-color-background-focus: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:active" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-disabled-container-2);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: transparent;outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-text']" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-shadow: 0 0 0 var(--slds-g-sizing-border-1) inset\n var(--slds-g-color-error-1);--slds-c-inputtext-color-border: var(--slds-g-color-border-error-1);--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-input-has-icon" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " {--slds-c-input-color-background: var(--slds-s-input-color-background-invalid);--slds-c-input-color-border: var(--slds-g-color-border-error-1);--slds-c-input-text-color: var(--slds-s-input-color-invalid);background-clip: padding-box;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {fill: var(--slds-g-color-error-1);color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-container']:focus-within" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-shadow:\n var(--slds-g-color-error-base-50) 0 0 0 var(--slds-g-sizing-border-1) inset,\n 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-border-error-1);--sds-c-inputtext-color-border: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-container']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][disabled]) [part='input']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-container']" + shadowSelector + "," + hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {cursor: not-allowed;--sds-c-inputtext-color-background: var(--slds-s-input-color-background-disabled, var(--slds-g-color-disabled-container-1));--sds-c-inputtext-color-border: var(--slds-g-color-border-disabled-1);--sds-c-inputtext-text-color: var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-text']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-text-color-placeholder:\n var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " [part='label']", shadowSelector, " {padding-block-start: var(--slds-g-spacing-1);padding-inline-end: var(--slds-g-spacing-2);color: var(\n --slds-c-inputtext-label-color,\n var(--slds-g-color-on-surface-2)\n );margin-block-end: var(--slds-g-sizing-1);display: inline-flex;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='start']" : hostSelector + "[data-render-mode=\"shadow\"] [part='start']")), shadowSelector, " {--slds-c-icon-spacing-inlineend: var(--slds-g-spacing-2);}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-text']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='label']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {float: left;max-width: calc(33% - 1.125rem);padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-container']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='inline-help']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='inline-help']")), shadowSelector, " {float: left;padding-block-start: var(--slds-g-spacing-1);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) input[type=\"search\"]" : hostSelector + "[data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {left: var(--slds-g-spacing-3);fill: var(--slds-g-color-on-surface-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-accent-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-input__icon", shadowSelector, " {width: 0.875rem;height: 0.875rem;position: absolute;top: 50%;margin-top: -0.4375rem;line-height: 1;border: 0;z-index: 2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_left", shadowSelector, " {inset-inline-start: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right")), shadowSelector, " {--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_right", shadowSelector, " {inset-inline-end: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet$1];

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) fieldset" : hostSelector + "[data-render-mode=\"shadow\"] fieldset")), shadowSelector, " {border: 0;margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {position: relative;min-width: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;hyphens: auto;display: inline-block;color: var(--slds-g-color-on-surface-2);font-size: var(--slds-s-label-font-size, var(--slds-g-font-scale-neg-2));padding-inline-end: var(--slds-g-spacing-2);padding-block-start: var(--slds-g-spacing-1);margin-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label:empty")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {clear: inline-start;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-radio", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {display: inline-block;position: relative;padding-block-start: var(--slds-g-spacing-1);vertical-align: top;line-height: var(--slds-g-font-lineheight-1);z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-form-element__helper" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__helper")), shadowSelector, " {font-size: var(--slds-s-helptext-font-size, var(--slds-g-font-scale-neg-2));margin-block-start: calc(var(--slds-g-spacing-1) / 2);display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_edit")), shadowSelector, " .slds-form-element__static", shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " {flex-basis: 0%;border-bottom: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__label", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__legend" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__legend")), shadowSelector, " {font-weight: var(--slds-g-font-weight-7);float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__addon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__addon")), shadowSelector, " {display: inline-block;margin-block-start: 0;margin-block-end: 0;margin-inline-start: var(--slds-g-spacing-2);margin-inline-end: var(--slds-g-spacing-2);align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;word-break: break-word;display: inline-block;font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-neutral-base-10);width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static.slds-text-longform" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static.slds-text-longform")), shadowSelector, " *:last-child", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static:empty")), shadowSelector, " {min-height: calc(var(--slds-g-sizing-6) + 1px);vertical-align: bottom;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static--edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static--edit")), shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-required" : hostSelector + "[data-render-mode=\"shadow\"] .slds-required")), shadowSelector, " {color: var(--slds-g-color-error-1);margin-block-start: 0;margin-block-end: 0;margin-inline-start: calc(var(--slds-g-spacing-1) / 2);margin-inline-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-form-element__help", shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-form-element__help" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) {" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {padding: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__label" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__label" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {width: 100%;flex-basis: 100%;clear: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__icon" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {float: none;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline'].slds-form-element_horizontal) {" : hostSelector + ".slds-form-element_horizontal[variant='label-inline'][data-render-mode=\"shadow\"] {")), "padding: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']).slds-is-edited {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"].slds-is-edited {")), "padding-block-start: var(--slds-g-sizing-6)}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__label" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {float: inline-start;max-width: calc(33% - var(--slds-g-sizing-6));flex-basis: calc(33% - var(--slds-g-sizing-6));flex-grow: 1;margin-block-end: 0;position: relative;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) lightning-helptext" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] lightning-helptext")), shadowSelector, " {float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {margin-inline-start: 33%;clear: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list__column" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list__column")), shadowSelector, " .slds-form-element__label", shadowSelector, " {width: auto;max-width: 100%;flex-basis: auto;float: none;position: relative;padding-inline-start: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__help" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list")), shadowSelector, " {clear: none;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " {display: flex;margin-bottom: var(--slds-g-spacing-1);margin-left: calc(var(--slds-g-spacing-1) * -1);margin-right: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " .slds-form-element__label", shadowSelector, " {padding-top: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element", shadowSelector, " {padding-left: var(--slds-g-spacing-1);padding-right: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_address" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_address")), shadowSelector, " .slds-form-element__row", shadowSelector, " {align-items: flex-end;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-hidden']) .slds-form-element__label" : hostSelector + "[variant='label-hidden'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {display: none}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet2 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1, stylesheet2];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<legend${"c0"}${2}>${"t1"}</legend>`;
  const $fragment2 = lwc.parseFragment`<div data-error-message${"a0:id"}${"c0"} aria-live="polite"${2}>${"t1"}</div>`;
  const stc0 = {
    classMap: {
      "slds-form": true
    },
    attrs: {
      "tabindex": "-1"
    },
    key: 0
  };
  const stc1 = {
    classMap: {
      "slds-form-element": true,
      "slds-form-element_compound": true
    },
    key: 1
  };
  const stc2 = {
    classMap: {
      "slds-form-element__control": true
    },
    key: 5
  };
  const stc3 = {
    classMap: {
      "slds-form-element__group": true
    },
    key: 6
  };
  const stc4 = {
    classMap: {
      "slds-form-element__row": true
    },
    key: 7
  };
  const stc5 = {
    "slds-form-element": true
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {ncls: api_normalize_class_name, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment, c: api_custom_element, b: api_bind, h: api_element, gid: api_scoped_id} = $api;
    const {_m0, _m1, _m2, _m3, _m4, _m5} = $ctx;
    return [api_element("div", stc0, [api_element("fieldset", stc1, [!$cmp.hasExternalLabel ? api_static_fragment($fragment1, 3, [api_static_part(0, {
      className: api_normalize_class_name($cmp.computedLabelClass)
    }, null), api_static_part(1, null, api_dynamic_text($cmp.label))]) : null, !$cmp.hasExternalLabel ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext__default.default, {
      props: {
        "content": $cmp.fieldLevelHelp,
        "alternativeText": $cmp.helptextAlternativeText
      },
      key: 4
    }) : null : null, api_element("div", stc2, [api_element("div", stc3, [api_element("div", stc4, [api_custom_element("lightning-datepicker", _lightningDatepicker__default.default, {
      classMap: stc5,
      attrs: {
        "data-aria-invalid": $cmp.computedDateAriaInvalid
      },
      props: {
        "autocomplete": $cmp.autocomplete,
        "accessKey": $cmp.dateAccessKey,
        "min": $cmp.dateMin,
        "max": $cmp.dateMax,
        "label": $cmp.i18n.date,
        "name": $cmp.name,
        "placeholder": $cmp.placeholder,
        "readOnly": $cmp.readOnly,
        "disabled": $cmp.disabled,
        "dateStyle": $cmp.dateStyle,
        "required": $cmp.required,
        "ariaErrorMessageElement": $cmp.errorMessageElement,
        "ariaDisabled": $cmp.ariaDisabled,
        "variant": $cmp.childVariant,
        "rootAriaNode": $cmp.rootAriaNode,
        "externalErrorMessage": $cmp.customErrorMessage
      },
      key: 8,
      on: {
        "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleDatepickerFocus)),
        "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleDatepickerBlur)),
        "change": _m2 || ($ctx._m2 = api_bind($cmp.handleDateChange))
      }
    }), api_custom_element("lightning-timepicker", _lightningTimepicker__default.default, {
      classMap: stc5,
      attrs: {
        "data-aria-invalid": $cmp.computedTimeAriaInvalid
      },
      props: {
        "autocomplete": $cmp.autocomplete,
        "accessKey": $cmp.timeAccessKey,
        "label": $cmp.i18n.time,
        "name": $cmp.name,
        "timeStyle": $cmp.timeStyle,
        "placeholder": $cmp.placeholder,
        "readOnly": $cmp.readOnly,
        "required": $cmp.required,
        "disabled": $cmp.disabled,
        "ariaErrorMessageElement": $cmp.errorMessageElement,
        "ariaDisabled": $cmp.ariaDisabled,
        "variant": $cmp.childVariant,
        "rootAriaNode": $cmp.rootAriaNode
      },
      key: 9,
      on: {
        "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleTimepickerFocus)),
        "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleTimepickerBlur)),
        "change": _m5 || ($ctx._m5 = api_bind($cmp.handleTimeChange))
      }
    })])])]), api_static_fragment($fragment2, 11, [api_static_part(0, {
      className: api_normalize_class_name($cmp.computedClass),
      attrs: {
        "id": api_scoped_id("errormessage")
      }
    }, null), api_static_part(1, null, api_dynamic_text($cmp.customErrorMessage))])])])];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-326m1b941ni";
  tmpl.legacyStylesheetToken = "lightning-datetimepicker_datetimepicker";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  const i18n = {
    date: labelDate__default.default,
    rangeOverflow: labelRangeOverflow__default.default,
    rangeUnderflow: labelRangeUnderflow__default.default,
    time: labelTime__default.default,
    helpTextAlternativeText: labelHelpTextAlternativeText__default.default,
    valueMissingWithDateFormat: labelValueMissingWithDateFormat__default.default,
    customErrorWithDateFormat: labelCustomErrorWithDateFormat__default.default
  };
  class LightningDateTimePicker extends LightningShadowBaseClass__default.default {
    // getters and setters necessary to trigger sync
    set timeAriaControls(val) {
      this._timeAriaControls = val;
      this.synchronizeA11y();
    }
    get timeAriaControls() {
      return this._timeAriaControls;
    }

    // getters and setters necessary to trigger sync
    set timeAriaDetails(val) {
      this._timeAriaDetails = val;
      this.synchronizeA11y();
    }
    get timeAriaDetails() {
      return this._timeAriaDetails;
    }
    set timeAriaLabelledBy(val) {
      this._timeAriaLabelledBy = val;
      this.synchronizeA11y();
    }
    get timeAriaLabelledBy() {
      return this._timeAriaLabelledBy;
    }
    set timeAriaDescribedBy(val) {
      this._timeAriaDescribedBy = val;
      this.synchronizeA11y();
    }
    get timeAriaDescribedBy() {
      return this._timeAriaDescribedBy;
    }
    get messageWhenValueMissing() {
      if (this._messageWhenValueMissing) {
        return utils.formatLabel(this.i18n.customErrorWithDateFormat, this._messageWhenValueMissing, this.dateFormat);
      }
      return utils.formatLabel(this.i18n.valueMissingWithDateFormat, this.dateFormat);
    }
    set messageWhenValueMissing(message) {
      this._messageWhenValueMissing = message;
    }
    get messageWhenBadInput() {
      if (this._messageWhenBadInput) {
        return utils.formatLabel(this.i18n.customErrorWithDateFormat, this._messageWhenBadInput, this.dateFormat);
      } else if (this.hasBadDateInput) {
        return this.getDatepicker().messageWhenBadInput;
      } else if (this.hasBadTimeInput) {
        return this.getTimepicker().messageWhenBadInput;
      }
      return null;
    }
    set messageWhenBadInput(message) {
      this._messageWhenBadInput = message;
    }
    get messageWhenRangeOverflow() {
      if (this._messageWhenRangeOverflow) {
        return utils.formatLabel(this.i18n.customErrorWithDateFormat, this._messageWhenRangeOverflow, this.dateFormat);
      }
      return utils.formatLabel(i18n.rangeOverflow, this.formattedMax);
    }
    set messageWhenRangeOverflow(message) {
      this._messageWhenRangeOverflow = message;
    }
    get messageWhenRangeUnderflow() {
      if (this._messageWhenRangeUnderflow) {
        return utils.formatLabel(this.i18n.customErrorWithDateFormat, this._messageWhenRangeUnderflow, this.dateFormat);
      }
      return utils.formatLabel(i18n.rangeUnderflow, this.formattedMin);
    }
    set messageWhenRangeUnderflow(message) {
      this._messageWhenRangeUnderflow = message;
    }
    get max() {
      return this.maxValue;
    }
    set max(newValue) {
      this.maxValue = newValue;
      this.calculateFormattedMaxValue();
    }
    get min() {
      return this.minValue;
    }
    set min(newValue) {
      this.minValue = newValue;
      this.calculateFormattedMinValue();
    }
    get value() {
      return this._value;
    }
    set value(newValue) {
      // This is required to ensure the value is not set on the element SSR pre-hydration (@W-12680613)
      if (this.connected) {
        this.setDateAndTimeValues(newValue);
      } else {
        // we set the values in connectedCallback to make sure timezone is available.
        this._initialValue = newValue;
      }
    }
    get timezone() {
      return this._timezone;
    }
    set timezone(newValue) {
      this._timezone = newValue;
      if (this.connected) {
        this.updateValuesForTimezone();
      }
    }

    /**
     * Returns time zone if one is set, otherwise returns
     * the Salesforce time zone when Aura localization is
     * available, and the system's time zone otherwise
     */
    get normalizedTimezone() {
      if (this.timezone) {
        return this.timezone;
      } else if (internationalizationLibrary.isAuraL10NAvailable) {
        return sfTimeZone__default.default;
      }
      return Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    get disabled() {
      return this._disabled;
    }
    set disabled(value) {
      this._disabled = utilsPrivate.normalizeBoolean(value);
    }
    get readOnly() {
      return this._readonly;
    }
    set readOnly(value) {
      this._readonly = utilsPrivate.normalizeBoolean(value);
    }
    get required() {
      return this._required;
    }
    set required(value) {
      this._required = utilsPrivate.normalizeBoolean(value);
    }
    set fieldLevelHelp(value) {
      this._fieldLevelHelp = value;
    }
    get fieldLevelHelp() {
      return this._fieldLevelHelp;
    }
    get variant() {
      return this._variant || inputUtils.VARIANT.STANDARD;
    }
    set variant(value) {
      this._variant = inputUtils.normalizeVariant(value);
      utilsPrivate.reflectAttribute(this, 'variant', this._variant);
    }

    /**
     * The child date and time picker components should have the standard variant, unless variant is label-hidden
     * See W-15101132
     */
    get childVariant() {
      return this._variant === inputUtils.VARIANT.LABEL_HIDDEN ? this._variant : inputUtils.VARIANT.STANDARD;
    }

    /**
     * Sets focus on the date input element.
     */
    focus() {
      if (this.connected) {
        this.getDatepicker().focus();
      }
    }

    /**
     * Removes keyboard focus from the input elements.
     */
    blur() {
      if (this.connected) {
        this.getDatepicker().blur();
        this.getTimepicker().blur();
      }
    }
    hasBadInput() {
      return this.connected && (this.hasBadDateInput || this.hasBadTimeInput);
    }
    get hasBadDateInput() {
      return this.getDatepicker()?.hasBadInput();
    }
    get hasMissingDateTimeInput() {
      return this.required && (!this._dateValue || !this._timeValue);
    }
    get hasBadTimeInput() {
      const timeBadInput = this.getTimepicker()?.hasBadInput();
      const timeMissing = this.required && this._dateValue && !this._timeValue;
      return timeMissing || timeBadInput;
    }
    showHelpMessage(message) {
      if (!this.connected) {
        return;
      }
      if (!message) {
        this.clearHelpMessage();
        return;
      }
      if (this.hasMissingDateTimeInput) {
        this.clearHelpMessage();
        utilsPrivate.reflectAttribute(this.getDatepicker(), 'invalid', true);
        utilsPrivate.reflectAttribute(this.getTimeCombobox(), 'invalid', true);
      }
      if (this.hasBadDateInput && !this._messageWhenBadInput) {
        this.clearHelpMessage();
        utilsPrivate.reflectAttribute(this.getDatepicker(), 'invalid', this.hasBadDateInput);
        this.getDatepicker().showHelpMessage(message);
        return;
      }
      if (this.hasBadTimeInput && !this._messageWhenBadInput) {
        this.clearHelpMessage();
        utilsPrivate.reflectAttribute(this.getTimepicker(), 'invalid', this.hasBadTimeInput);
        utilsPrivate.reflectAttribute(this.getTimeCombobox(), 'invalid', true);
        this.getTimepicker().showHelpMessage(message);
        return;
      }
      this.classList.add('slds-has-error');
      this._customErrorMessage = message;
    }
    clearHelpMessage() {
      this.classList.remove('slds-has-error');
      this._customErrorMessage = '';
      this.getDatepicker().showHelpMessage('');
      this.getDatepicker().removeAttribute('invalid');
      this.getTimepicker().showHelpMessage('');
      this.getTimepicker().removeAttribute('invalid');
      this.getTimeCombobox().removeAttribute('invalid');
    }
    get isLabelHidden() {
      return this.variant === inputUtils.VARIANT.LABEL_HIDDEN;
    }
    get computedLabelClass() {
      return utils.classSet('slds-form-element__legend slds-form-element__label').add({
        'slds-assistive-text': this.isLabelHidden
      }).toString();
    }
    get dateFormat() {
      return internationalizationLibrary.getDateFormatFromStyle(this.dateStyle, true);
    }
    get i18n() {
      return i18n;
    }
    get customErrorMessage() {
      return this._customErrorMessage;
    }
    get dateMin() {
      return this._dateMin;
    }
    get dateMax() {
      return this._dateMax;
    }
    get computedClass() {
      let displayClass = this._customErrorMessage ? 'slds-show' : 'slds-hide';
      return 'slds-form-element__help ' + displayClass;
    }
    get errorMessageElement() {
      return utilsPrivate.isCSR ? this.template.querySelector('[data-error-message]') : null;
    }
    get hasExternalLabel() {
      return this.variant === inputUtils.VARIANT.LABEL_HIDDEN && this.timeAriaLabelledBy && this.timeAriaLabelledBy.length && this.dateAriaLabelledBy && this.dateAriaLabelledBy.length;
    }
    constructor() {
      super();
      this._rendered = false;
      this._messageWhenValueMissing = void 0;
      this.connected = false;
      this._disabled = false;
      this._readonly = false;
      this._required = false;
      this._fieldLevelHelp = void 0;
      this._variant = void 0;
      this._value = null;
      this._customErrorMessage = '';
      this._timezone = null;
      this._dateMin = void 0;
      this._dateMax = void 0;
      this.label = void 0;
      this.name = void 0;
      this.placeholder = '';
      this.dateStyle = void 0;
      this.timeStyle = void 0;
      this.timeAriaLabel = void 0;
      this.ariaDisabled = void 0;
      this.rootAriaNode = void 0;
      /**
       * Controls auto-filling of the input. Set the attribute to pass
       * through autocomplete values to be interpreted by the browser.
       * By default autocomplete is off to avoid overlap of dropdowns.
       * @type {string}
       */
      this.autocomplete = 'off';
      this.dateAriaControls = void 0;
      this.dateAriaDetails = void 0;
      this.dateAriaLabel = void 0;
      this.dateAriaLabelledBy = void 0;
      this.dateAriaDescribedBy = void 0;
      this.dateAccessKey = void 0;
      this.timeAccessKey = void 0;
      this.uniqueId = inputUtils.generateUniqueId();
    }
    synchronizeA11y() {
      if (!utilsPrivate.isCSR) {
        return;
      }
      const datepicker = this.template.querySelector('lightning-datepicker');
      const timepicker = this.template.querySelector('lightning-timepicker');
      if (datepicker) {
        utilsPrivate.synchronizeAttrs(datepicker, {
          ariaLabelledByElement: this.dateAriaLabelledBy,
          ariaDescribedByElements: this.dateAriaDescribedBy,
          ariaControlsElement: this.dateAriaControls,
          ariaDetailsElements: this.dateAriaDetails,
          'aria-label': this.dateAriaLabel
        });
      }
      if (timepicker) {
        utilsPrivate.synchronizeAttrs(timepicker, {
          ariaLabelledByElement: this.timeAriaLabelledBy,
          ariaDescribedByElements: this.timeAriaDescribedBy,
          ariaControlsElement: this.timeAriaControls,
          ariaDetailsElements: this.timeAriaDetails,
          'aria-label': this.timeAriaLabel
        });
      }
    }
    connectedCallback() {
      super.connectedCallback();
      this.connected = true;

      // we set the initial values here in order to make sure timezone is available.
      this.updateValuesForTimezone(this._initialValue);
      this.interactingState = new inputUtils.InteractingState({
        debounceInteraction: true
      });
      this.interactingState.onenter(() => {
        this.dispatchEvent(new CustomEvent('focus'));
      });
      this.interactingState.onleave(() => {
        this.dispatchEvent(new CustomEvent('blur'));
      });
    }
    renderedCallback() {
      this._rendered = true;
      this.updateValuesForTimezone(this.value);
      this.synchronizeA11y();
    }
    disconnectedCallback() {
      this._rendered = false;
      this.connected = false;
    }
    getTimepicker() {
      /**
       * Checking the component is rendered is required in the SSR context to ensure that
       * the client does not select the element before it has been hydrated (@W-12680613)
       */
      return this._rendered ? this.template.querySelector('lightning-timepicker') : null;
    }
    getTimeCombobox() {
      return this._rendered ? this.getTimepicker().shadowRoot.querySelector('lightning-base-combobox') : null;
    }
    getDatepicker() {
      return this._rendered ? this.template.querySelector('lightning-datepicker') : null;
    }
    handleDatepickerFocus() {
      this._dateFocus = true;
      this.interactingState.enter();
    }
    handleTimepickerFocus() {
      this._timeFocus = true;
      this.interactingState.enter();
    }
    handleDatepickerBlur() {
      this._dateFocus = false;

      // timepicker fires focus before datepicker fires blur
      if (!this._timeFocus) {
        this.interactingState.leave();
      }
    }
    handleTimepickerBlur() {
      this._timeFocus = false;

      // datepicker fires focus before timepicker fires blur
      if (!this._dateFocus) {
        this.interactingState.leave();
      }
    }
    handleDateChange(event) {
      event.stopPropagation();
      if (!event.detail) {
        return;
      }
      this._dateValue = event.detail.value;
      if (this._dateValue) {
        this._timeValue = this._timeValue || internationalizationLibrary.getCurrentTimeString(this.normalizedTimezone);
        this.setTimepickerValue(this._timeValue);
      }
      this.updateValue();
    }
    handleTimeChange(event) {
      event.stopPropagation();
      if (!event.detail) {
        return;
      }
      this._timeValue = event.detail.value;
      this.updateValue();
    }
    updateValue() {
      const dateValue = this._dateValue;
      const timeValue = this._timeValue;
      if (dateValue && timeValue) {
        const dateTimeString = dateValue + iso8601Utils.TIME_SEPARATOR + timeValue;
        this._value = internationalizationLibrary.normalizeFormattedDateTime(dateTimeString, this.normalizedTimezone);
        this.dispatchChangeEvent();
      } else if (!dateValue) {
        this._value = null;
        this.dispatchChangeEvent();
      }
    }
    dispatchChangeEvent() {
      this.dispatchEvent(new CustomEvent('change', {
        composed: true,
        bubbles: true,
        detail: {
          value: this._value
        }
      }));
    }
    updateValuesForTimezone(datetimeValue) {
      this.setDateAndTimeValues(datetimeValue || this._value);
      this.calculateFormattedMinValue();
      this.calculateFormattedMaxValue();
    }
    setDateAndTimeValues(value) {
      const normalizedValue = internationalizationLibrary.normalizeISODateTime(value, this.normalizedTimezone).isoValue;
      const isDateOnly = normalizedValue && value.indexOf(iso8601Utils.TIME_SEPARATOR) < 0;
      if (isDateOnly) {
        this._dateValue = value;
        this._value = this._dateValue;
        this.setDatepickerValue(value);
        return;
      }
      const dateAndTime = this.separateDateTime(normalizedValue);
      this._dateValue = dateAndTime && dateAndTime[0];
      this._timeValue = dateAndTime && dateAndTime[1];
      this._value = value;
      this.setDatepickerValue(this._dateValue);
      this.setTimepickerValue(this._timeValue);
    }
    setDatepickerValue(value) {
      const datepicker = this.getDatepicker();
      if (datepicker) {
        datepicker.value = value;
      }
    }
    setTimepickerValue(value) {
      const timepicker = this.getTimepicker();
      if (timepicker) {
        timepicker.value = value;
      }
    }
    calculateFormattedMinValue() {
      if (!this.min) {
        return;
      }
      const normalizedDate = internationalizationLibrary.normalizeISODateTime(this.min, this.normalizedTimezone);
      this._dateMin = this.separateDateTime(normalizedDate.isoValue)[0];
      this.formattedMin = normalizedDate.displayValue;
    }
    calculateFormattedMaxValue() {
      if (!this.max) {
        return;
      }
      const normalizedDate = internationalizationLibrary.normalizeISODateTime(this.max, this.normalizedTimezone);
      this._dateMax = this.separateDateTime(normalizedDate.isoValue)[0];
      this.formattedMax = normalizedDate.displayValue;
    }
    separateDateTime(isoString) {
      return typeof isoString === 'string' ? isoString.split(iso8601Utils.TIME_SEPARATOR) : null;
    }
    get computedDateAriaInvalid() {
      return utilsPrivate.computeAriaInvalid(this._customErrorMessage, this._dateValue);
    }
    get computedTimeAriaInvalid() {
      return utilsPrivate.computeAriaInvalid(this._customErrorMessage, this._timeValue);
    }
    get helptextAlternativeText() {
      return utils.formatLabel(i18n.helpTextAlternativeText, this.label);
    }
    /*LWC compiler v7.1.5*/
  }
  LightningDateTimePicker.delegatesFocus = true;
  lwc.registerDecorators(LightningDateTimePicker, {
    publicProps: {
      label: {
        config: 0
      },
      name: {
        config: 0
      },
      placeholder: {
        config: 0
      },
      dateStyle: {
        config: 0
      },
      timeStyle: {
        config: 0
      },
      timeAriaLabel: {
        config: 0
      },
      ariaDisabled: {
        config: 0
      },
      rootAriaNode: {
        config: 0
      },
      autocomplete: {
        config: 0
      },
      timeAriaControls: {
        config: 3
      },
      timeAriaDetails: {
        config: 3
      },
      timeAriaLabelledBy: {
        config: 3
      },
      timeAriaDescribedBy: {
        config: 3
      },
      dateAriaControls: {
        config: 0
      },
      dateAriaDetails: {
        config: 0
      },
      dateAriaLabel: {
        config: 0
      },
      dateAriaLabelledBy: {
        config: 0
      },
      dateAriaDescribedBy: {
        config: 0
      },
      dateAccessKey: {
        config: 0
      },
      timeAccessKey: {
        config: 0
      },
      messageWhenValueMissing: {
        config: 3
      },
      messageWhenBadInput: {
        config: 3
      },
      messageWhenRangeOverflow: {
        config: 3
      },
      messageWhenRangeUnderflow: {
        config: 3
      },
      max: {
        config: 3
      },
      min: {
        config: 3
      },
      value: {
        config: 3
      },
      timezone: {
        config: 3
      },
      disabled: {
        config: 3
      },
      readOnly: {
        config: 3
      },
      required: {
        config: 3
      },
      fieldLevelHelp: {
        config: 3
      },
      variant: {
        config: 3
      }
    },
    publicMethods: ["focus", "blur", "hasBadInput", "showHelpMessage"],
    track: {
      _disabled: 1,
      _readonly: 1,
      _required: 1,
      _fieldLevelHelp: 1,
      _variant: 1,
      _value: 1,
      _customErrorMessage: 1,
      _timezone: 1,
      _dateMin: 1,
      _dateMax: 1
    },
    fields: ["_rendered", "_messageWhenValueMissing", "connected"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningDateTimePicker, {
    tmpl: _tmpl,
    sel: "lightning-datetimepicker",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/numberUtils', ['exports', '@salesforce/i18n/number.groupingSeparator', '@salesforce/i18n/number.decimalSeparator', 'lightning/internationalizationLibrary', 'lightning/inputUtils', 'lightning/utilsPrivate'], (function (exports, groupingSeparator, decimalSeparator, internationalizationLibrary, inputUtils, utilsPrivate) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var groupingSeparator__default = /*#__PURE__*/_interopDefaultCompat(groupingSeparator);
    var decimalSeparator__default = /*#__PURE__*/_interopDefaultCompat(decimalSeparator);

    const VALID_NUMBER_CHARACTERS_EXPRESSION = new RegExp(
    // eslint-disable-next-line no-useless-escape
    '^[-+0-9kKmMbBtTeE.,\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9' + '\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF' + '\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF' + '\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9' + '\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9' + '\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89' + '\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49' + '\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909' + '\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9' + ']$');
    const SHORTCUT_FACTORS = {
      k: 3,
      m: 6,
      b: 9,
      t: 12
    };
    const SHORTCUTS = ['k', 'm', 'b', 't'];
    const NUMBER_SYMBOLS = ['+', '-'];
    function toIsoDecimal(numberAsString) {
      const result = transformLocalizedNumberToIsoDecimal(numberAsString);
      if (isNaN(result)) {
        return '';
      }
      return result;
    }
    function isValidNumber(numberAsString) {
      return !isNaN(transformLocalizedNumberToIsoDecimal(numberAsString));
    }
    function fromIsoDecimal(numberAsString) {
      return internationalizationLibrary.toLocalizedDigits(numberAsString.replace('.', decimalSeparator__default.default));
    }

    // TODO: Too many options, simplify
    function increaseNumberByStep({
      value,
      increment,
      step,
      fractionDigits
    }) {
      const startingValue = value === '' || value == null ? '0' : value;
      const stepAsFloat = parseFloat(step);
      let result;
      if (isNaN(stepAsFloat)) {
        result = parseFloat(startingValue) + increment;
      } else {
        // ideally we'd round the value to the closest correct step, so that if say the step is '2', and the
        // current value is '1' it would increment to '2' instead of '3', since the former would be the valid
        // number given the step constraint, however this would significantly complicate the code, keeping
        // it simple for now.
        const increaseBy = increment * stepAsFloat;
        result = parseFloat(startingValue) + increaseBy;
      }
      return result.toFixed(fractionDigits);
    }
    function calculateFractionDigitsFromStep(step) {
      let calculatedFractionDigits;
      if (step) {
        const stepAsString = String(step).toLowerCase();
        if (stepAsString !== 'any') {
          // lowering the case because we're checking for exponent format as well
          let fractionDigits = 0;
          if (stepAsString.indexOf('.') >= 0 && stepAsString.indexOf('e') < 0) {
            const fractionalPart = stepAsString.split('.')[1];
            // we're parsing to account for cases where the step is
            // '1.0', or '1.000', etc.
            if (parseInt(fractionalPart, 10) > 0) {
              fractionDigits = fractionalPart.length;
            }
          } else if (stepAsString.indexOf('e-') > 0) {
            // exponent form eg. 1.5e-5
            const splitOnExponent = stepAsString.split('e-');
            const fractionalPart = splitOnExponent[0].split('.')[1];
            const exponentPart = splitOnExponent[1];
            const fractionalPartLength = fractionalPart ? fractionalPart.length : 0;
            fractionDigits = parseInt(exponentPart, 10) + fractionalPartLength;
          }
          calculatedFractionDigits = fractionDigits;
        }
      }
      return calculatedFractionDigits;
    }
    function formatNumber(numberAsString, options) {
      if (inputUtils.isEmptyString(numberAsString)) {
        return '';
      }
      let formattedValue = numberAsString;
      let inputValue = numberAsString;

      // set formatter style & default options
      const formatStyle = options.style;
      const formatOptions = {
        style: formatStyle
      };
      formatOptions.minimumFractionDigits = options.minimumFractionDigits;
      formatOptions.maximumFractionDigits = options.maximumFractionDigits;
      if (formatStyle === 'percent-fixed') {
        // percent-fixed just uses percent format and divides the value by 100
        // before passing to the library, this is to deal with the
        // fact that percentages in salesforce are 0-100, not 0-1
        formatOptions.style = 'percent';
        const inputValueAsString = inputValue.toString();
        const normalisedNumberInPercent = parseFloat(inputValue) / 100;

        // If the number contains fraction digits and is not in an exponent format
        if (inputValueAsString.indexOf('.') > 0 && inputValueAsString.indexOf('e') < 0) {
          // Depending on the input number, division by 100 may lead to rounding errors
          // (e.g 0.785 / 100 is 0.007850000000000001), so we need to round back
          // to the correct precision, that is - existing number of fractional digits
          // plus extra 2 for division by 100.
          inputValue = normalisedNumberInPercent.toFixed(inputValueAsString.split('.')[1].length + 2);
        } else {
          inputValue = normalisedNumberInPercent;
        }
      }
      try {
        formattedValue = internationalizationLibrary.numberFormat(formatOptions).format(inputValue) || '';
      } catch (ignore) {
        // ignore any errors
      }
      return formattedValue;
    }

    // Exporting only to test, separators are only overridden in the tests
    function transformLocalizedNumberToIsoDecimal(numberAsString, separators) {
      if (numberAsString == null || numberAsString.length === 0) {
        return '';
      }
      const decimalSymbol = separators ? separators.decimalSeparator : decimalSeparator__default.default;
      const groupingSymbol = separators ? separators.groupSeparator : groupingSeparator__default.default;

      // remove the grouping separator
      let result = numberAsString.split(groupingSymbol).join('');
      if (decimalSymbol !== '.') {
        // replace the local decimal separator with a
        result = result.replace(decimalSymbol, '.');
      }
      return expandShortcuts(addLeadingZeroIfNeeded(internationalizationLibrary.fromLocalizedDigits(result)));
    }
    function isValidNumberCharacter(character) {
      return VALID_NUMBER_CHARACTERS_EXPRESSION.test(character);
    }

    /**
     * validate the string-typed number and return the number string
     * @param {String} value, number string to be validated
     * @returns a valid number in string-typed, otherwise, empty string
     */
    function stringifyNumber(value) {
      const numericValue = typeof value === 'string' ? Number(value) : value;
      const normalizedNumber = utilsPrivate.normalizeNumber(numericValue);
      return normalizedNumber === undefined ? '' : String(value);
    }
    function hasValidNumberSymbol(value) {
      const validSymbols = NUMBER_SYMBOLS.join('');
      const matchSymbols = new RegExp(`[${validSymbols}]`);
      return value.match(matchSymbols) ? true : false;
    }
    function hasValidNumberShortcut(value) {
      const result = value.toLowerCase().trim();
      const kmb = SHORTCUTS.join('');
      // Cannot have two shortcuts /([kmb])/g
      const matchShortcuts = new RegExp(`([${kmb}])`, 'g');
      const shortcutMatch = result.match(matchShortcuts);
      if (shortcutMatch && shortcutMatch.length > 1) {
        return false;
      }
      // Must end with 'm', 'k', 'b' and more than just a single letter
      const matchEndsWith = new RegExp(`[${kmb}]$`);
      const endsWithShortcut = result.match(matchEndsWith) !== null;
      // has 'm' / 'k' / 'b' and more than just them (ie. result of 'm' / 'k' / 'b' are not valid.
      return endsWithShortcut && result.length > 1;
    }

    // Exported for testing only
    function expandShortcuts(isoValue) {
      if (!hasValidNumberShortcut(isoValue)) {
        return isoValue;
      }
      let result = isoValue.toLowerCase().trim();
      const shortcut = result.charAt(result.length - 1);
      // remove the suffix
      result = result.substring(0, result.length - 1);
      if (isNaN(result)) {
        return isoValue;
      }
      const parts = result.split('.');
      let fractionDigits = 0;
      const hasDecimalPart = parts.length > 1;
      if (hasDecimalPart) {
        fractionDigits = parts[1].length;
      }
      const exponent = SHORTCUT_FACTORS[shortcut];
      // since multiplication may result in loss of precision on javascript's part,
      // we're calculating here the number of fraction digits needed and formatting
      // the number at that
      const newFractionDigits = Math.max(0, fractionDigits - exponent);
      return parseFloat(result * Math.pow(10, exponent)).toFixed(newFractionDigits);
    }
    function addLeadingZeroIfNeeded(result) {
      // If the number starts with +. OR  -. OR . ; insert a 0 before the decimal separator.
      // eg. -.2 -> -0.2
      const decimalSeparatorLocation = result.indexOf('.');
      if (decimalSeparatorLocation === 0 || decimalSeparatorLocation === 1) {
        const firstCharacter = result.charAt(0);
        if (firstCharacter === '+' || firstCharacter === '-' || firstCharacter === '.') {
          result = result.substring(0, decimalSeparatorLocation) + '0' + result.substring(decimalSeparatorLocation);
        }
      }
      return result;
    }

    /*
        Returns a number of decimal places
        ex:
            decimalPlaces('.05') -> 2
            decimalPlaces('.5') -> 1
            decimalPlaces('1') -> 0
            decimalPlaces('25e-100') -> 100
            decimalPlaces('2.5e-99') -> 100
            decimalPlaces('.5e1') -> 0
            decimalPlaces('.25e1') -> 1
    */
    function getDecimalPlaces(num) {
      const match = ('' + num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
      if (!match) {
        return 0;
      }
      return Math.max(0,
      // Number of digits right of decimal point.
      (match[1] ? match[1].length : 0) - (
      // Adjust for scientific notation.
      match[2] ? +match[2] : 0));
    }

    exports.calculateFractionDigitsFromStep = calculateFractionDigitsFromStep;
    exports.expandShortcuts = expandShortcuts;
    exports.formatNumber = formatNumber;
    exports.fromIsoDecimal = fromIsoDecimal;
    exports.getDecimalPlaces = getDecimalPlaces;
    exports.hasValidNumberShortcut = hasValidNumberShortcut;
    exports.hasValidNumberSymbol = hasValidNumberSymbol;
    exports.increaseNumberByStep = increaseNumberByStep;
    exports.isValidNumber = isValidNumber;
    exports.isValidNumberCharacter = isValidNumberCharacter;
    exports.stringifyNumber = stringifyNumber;
    exports.toIsoDecimal = toIsoDecimal;
    exports.transformLocalizedNumberToIsoDecimal = transformLocalizedNumberToIsoDecimal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/primitiveInputRadio', ['exports', 'lwc', 'lightning/utils', 'lightning/inputUtils', 'lightning/utilsPrivate', 'lightning/shadowBaseClassPrivate'], (function (exports, lwc, utils, inputUtils, utilsPrivate, LightningShadowBaseClass) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

    const $fragment1 = lwc.parseFragment`<div class="slds-form-element__control${0}"${2}><span class="slds-radio${0}"${2}><input type="radio"${"a2:id"}${"a2:aria-keyshortcuts"}${"a2:aria-disabled"}${"a2:aria-roledescription"}${"a2:aria-invalid"}${"a2:accesskey"}${"a2:name"}${"a2:required"}${"a2:readonly"}${"a2:disabled"}${"a2:aria-label"}${3}><label${"a3:for"} class="slds-radio__label${0}"${2}><span class="slds-radio_faux${0}"${2}></span><span${"c5"}${2}>${"t6"}</span></label></span></div>`;
    const $fragment2 = lwc.parseFragment`<div${"a0:id"} class="slds-form-element__help${0}" data-help-message part="help-text" role="status"${2}><span class="slds-assistive-text${0}"${2}>${"t2"}</span>${"t3"}</div>`;
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {b: api_bind, gid: api_scoped_id, ncls: api_normalize_class_name, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment} = $api;
      const {_m0, _m1, _m2} = $ctx;
      return [api_static_fragment($fragment1, 1, [api_static_part(2, {
        on: {
          "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
        },
        attrs: {
          "id": api_scoped_id("radio"),
          "aria-keyshortcuts": $cmp.ariaKeyShortcuts,
          "aria-disabled": $cmp.ariaDisabled,
          "aria-roledescription": $cmp.ariaRoleDescription,
          "aria-invalid": $cmp.ariaInvalid,
          "accesskey": $cmp.accessKey,
          "name": $cmp.name,
          "required": $cmp.required ? "" : null,
          "readonly": $cmp.readOnly ? "" : null,
          "disabled": $cmp.disabled ? "" : null,
          "aria-label": $cmp.ariaLabel
        }
      }, null), api_static_part(3, {
        attrs: {
          "for": api_scoped_id("radio")
        }
      }, null), api_static_part(5, {
        className: api_normalize_class_name($cmp.computedLabelClass)
      }, null), api_static_part(6, null, api_dynamic_text($cmp.label))]), $cmp.helpMessage ? api_static_fragment($fragment2, 3, [api_static_part(0, {
        attrs: {
          "id": api_scoped_id("help-message")
        }
      }, null), api_static_part(2, null, api_dynamic_text($cmp.label)), api_static_part(3, null, api_dynamic_text($cmp.helpMessage))]) : null];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-4943usg6b6";
    tmpl.legacyStylesheetToken = "lightning-primitiveInputRadio_primitiveInputRadio";
    lwc.freezeTemplate(tmpl);

    class LightningPrimitiveInputRadio extends LightningShadowBaseClass__default.default {
      constructor(...args) {
        super(...args);
        this.variant = void 0;
        this.ariaInvalid = void 0;
        this.ariaKeyShortcuts = void 0;
        this.ariaDisabled = void 0;
        this.ariaRoleDescription = void 0;
        this.accessKey = void 0;
        this.name = void 0;
        this.required = void 0;
        this.readOnly = void 0;
        this.disabled = void 0;
        this.label = void 0;
        this.ariaLabel = void 0;
        this.helpMessage = void 0;
      }
      get checked() {
        return this._checked;
      }

      /**
       * Sets the checked state of the input and reflects the attribute if required.
       */
      set checked(value) {
        this._setChecked(value);
      }
      get ariaDescribedByElements() {
        return this.template.querySelector('[data-help-message]');
      }
      get isNativeShadow() {
        return this._isNativeShadow;
      }
      get inputElement() {
        if (!this._cachedInputElement) {
          let inputElement = this.template.querySelector('input');
          this._cachedInputElement = inputElement;
        }
        return this._cachedInputElement;
      }
      get isLabelHidden() {
        return this.variant === inputUtils.VARIANT.LABEL_HIDDEN;
      }
      get computedLabelClass() {
        return utils.classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }
      _setChecked(value) {
        value = Boolean(value);
        this._checked = value;
        if (this.rendered && this.inputElement.checked !== this._checked) {
          this.inputElement.checked = this._checked;
        }
      }
      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }
      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }
      handleChange(event) {
        this._setChecked(event.target.checked);
        const changeEvent = new CustomEvent('change', {
          bubbles: true,
          composed: true,
          detail: {
            checked: event.target.checked
          }
        });
        this.dispatchEvent(changeEvent);
      }
      connectedCallback() {
        super.connectedCallback();
        this._isNativeShadow = utilsPrivate.isNativeComponent(this);
      }
      renderedCallback() {
        if (!this.rendered) {
          this.inputElement.checked = this.checked;
        }
        this.rendered = true;
      }
      disconnectedCallback() {
        this._cachedInputElement = undefined;
        this.rendered = false;
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(LightningPrimitiveInputRadio, {
      publicProps: {
        variant: {
          config: 0
        },
        ariaInvalid: {
          config: 0
        },
        ariaKeyShortcuts: {
          config: 0
        },
        ariaDisabled: {
          config: 0
        },
        ariaRoleDescription: {
          config: 0
        },
        accessKey: {
          config: 0
        },
        name: {
          config: 0
        },
        required: {
          config: 0
        },
        readOnly: {
          config: 0
        },
        disabled: {
          config: 0
        },
        label: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        helpMessage: {
          config: 0
        },
        checked: {
          config: 3
        },
        ariaDescribedByElements: {
          config: 1
        },
        isNativeShadow: {
          config: 1
        },
        inputElement: {
          config: 1
        }
      }
    });
    const __lwc_component_class_internal = lwc.registerComponent(LightningPrimitiveInputRadio, {
      tmpl: _tmpl,
      sel: "lightning-primitive-input-radio",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/label/LightningColorPicker.a11yDefaultText', ['@view/forgotPassword/labels'], m => m[49]);
LWR.define('@salesforce/label/LightningColorPicker.cancelButton', ['@view/forgotPassword/labels'], m => m[50]);
LWR.define('@salesforce/label/LightningColorPickerPanel.customTab', ['@view/forgotPassword/labels'], m => m[51]);
LWR.define('@salesforce/label/LightningColorPickerPanel.defaultTab', ['@view/forgotPassword/labels'], m => m[52]);
LWR.define('@salesforce/label/LightningColorPicker.doneButton', ['@view/forgotPassword/labels'], m => m[53]);
(function() { LWR.define('lightning/button', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/primitiveIcon', 'lightning/utils', 'lightning/utilsPrivate', 'lightning/primitiveButton'], (function (exports, lwc, stylesheet0$1, _lightningPrimitiveIcon, utils, utilsPrivate, LightningPrimitiveButton) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningPrimitiveIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveIcon);
  var LightningPrimitiveButton__default = /*#__PURE__*/_interopDefaultCompat(LightningPrimitiveButton);

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return "*" + shadowSelector + ",*" + shadowSelector + "::before,*" + shadowSelector + "::after {box-sizing: border-box;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {display: inline-flex;gap: var(--sds-c-button-spacing-gap, var(--sds-s-button-spacing-gap));background: var(--sds-c-button-color-background, var(--sds-s-button-color-background));color: var(--sds-c-button-text-color, var(--sds-s-button-color));font-weight: var(--sds-c-button-font-weight, var(--sds-s-button-font-weight));font-size: var(--sds-c-button-font-size, var(--sds-s-button-font-size, inherit));line-height: var(--sds-c-button-font-lineheight);height: var(--sds-c-button-sizing-height);width: var(--sds-c-button-sizing-width);padding-inline-start: var(\n --sds-c-button-spacing-inlinestart,\n var(\n --sds-c-button-spacing-inline,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-inline, var(--sds-s-button-spacing)))\n )\n );padding-inline-end: var(\n --sds-c-button-spacing-inlineend,\n var(\n --sds-c-button-spacing-inline,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-inline, var(--sds-s-button-spacing)))\n )\n );padding-block-start: var(\n --sds-c-button-spacing-blockstart,\n var(\n --sds-c-button-spacing-block,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-block, var(--sds-s-button-spacing)))\n )\n );padding-block-end: var(\n --sds-c-button-spacing-blockend,\n var(\n --sds-c-button-spacing-block,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-block, var(--sds-s-button-spacing)))\n )\n );border-width: var(--sds-c-button-sizing-border, var(--sds-s-button-sizing-border, 1px));border-style: solid;border-color: var(--sds-c-button-color-border, var(--sds-s-button-color-border, currentColor));border-start-start-radius: var(\n --sds-c-button-radius-border-startstart,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-startstart, var(--sds-s-button-radius-border))\n )\n );border-start-end-radius: var(\n --sds-c-button-radius-border-startend,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-startend, var(--sds-s-button-radius-border))\n )\n );border-end-start-radius: var(\n --sds-c-button-radius-border-endstart,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-endstart, var(--sds-s-button-radius-border))\n )\n );border-end-end-radius: var(\n --sds-c-button-radius-border-endend,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-endend, var(--sds-s-button-radius-border))\n )\n );box-shadow: var(--sds-c-button-shadow, var(--sds-s-button-shadow));text-decoration: var(--sds-c-button-font-decoration);white-space: normal;user-select: none;align-items: center;justify-content: center;appearance: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:hover" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:hover")) + shadowSelector + " {--sds-c-button-text-color: var(--sds-c-button-text-color-hover, var(--sds-s-button-color-hover, revert));--sds-c-button-color-background: var(\n --sds-c-button-color-background-hover,\n var(--sds-s-button-color-background-hover, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-hover,\n var(--sds-s-button-color-border-hover, revert)\n );--sds-c-button-shadow: var(--sds-c-button-shadow-hover, var(--sds-s-button-shadow-hover, revert));cursor: pointer;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:focus")) + shadowSelector + " {--sds-c-button-color-background: var(\n --sds-c-button-color-background-focus,\n var(--sds-s-button-color-background-focus, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-focus,\n var(--sds-s-button-color-border-focus, revert)\n );--sds-c-button-text-color: var(--sds-c-button-text-color-focus, var(--sds-s-button-color-focus, revert));--sds-c-button-shadow: var(--sds-c-button-shadow-focus, var(--sds-s-button-shadow-focus, revert));outline: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:active")) + shadowSelector + " {--sds-c-button-text-color: var(--sds-c-button-text-color-active, var(--sds-s-button-color-active, revert));--sds-c-button-color-background: var(\n --sds-c-button-color-background-active,\n var(--sds-s-button-color-background-active, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-active,\n var(--sds-s-button-color-border-active, revert)\n );--sds-c-button-shadow: var(--sds-c-button-shadow-active, var(--sds-s-button-shadow-active, revert));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " {--sds-c-button-text-color: var(--sds-c-button-text-color-disabled);--sds-c-button-color-background: var(--sds-c-button-color-background-disabled);--sds-c-button-color-border: var(--sds-c-button-color-border-disabled);--sds-c-button-shadow: var(--sds-c-button-shadow-disabled);pointer-events: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " *" + shadowSelector + " {pointer-events: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='button'][aria-pressed='true']" : hostSelector + "[data-render-mode=\"shadow\"] [part='button'][aria-pressed='true']")) + shadowSelector + " {--sds-c-button-color-background: var(--sds-c-button-color-background-pressed, revert);--sds-c-button-color-border: var(--sds-c-button-color-border-pressed, revert);--sds-c-button-text-color: var(--sds-c-button-text-color-pressed, revert);--sds-c-button-shadow: var(--sds-c-button-shadow-pressed, revert);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {gap: var(--slds-g-spacing-2);--slds-c-icon-sizing-border: 0;--slds-c-icon-sizing: 0.875rem;--slds-c-icon-color-foreground: currentcolor;--sds-c-button-font-lineheight: var(\n --slds-c-button-neutral-font-lineheight,\n var(--slds-s-button-font-lineheight, 1.875rem)\n );--sds-c-button-spacing-inline: var(\n --slds-c-button-neutral-spacing-inline,\n var(--slds-s-button-spacing-inline, var(--slds-g-spacing-4));\n );--sds-c-button-spacing-block: var(--slds-c-button-neutral-spacing-block);--sds-c-button-radius-border-startstart: var(\n --slds-c-button-radius-border-startstart,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-startstart, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-endstart: var(\n --slds-c-button-radius-border-endstart,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-endstart, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-startend: var(\n --slds-c-button-radius-border-startend,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-startend, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-endend: var(\n --slds-c-button-radius-border-endend,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-endend, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-color-background: var(\n --slds-c-button-neutral-color-background,\n var(--slds-g-color-surface-container-1)\n );--sds-c-button-color-background-hover: var(\n --slds-c-button-neutral-color-background-hover,\n var(--slds-g-color-surface-container-2)\n );--sds-c-button-color-background-focus: var(--slds-c-button-neutral-color-background-focus, var(--slds-g-color-surface-container-2));--sds-c-button-color-background-active: var(\n --slds-c-button-neutral-color-background-active,\n var(--slds-g-color-surface-container-2)\n );--sds-c-button-color-border: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-2));--sds-c-button-color-border-hover: var(\n --slds-c-button-neutral-color-border-hover,\n var(--slds-g-color-border-2)\n );--sds-c-button-color-border-focus: var(\n --slds-c-button-neutral-color-border-focus,\n var(--slds-g-color-border-2)\n );--sds-c-button-color-border-active: var(\n --slds-c-button-neutral-color-border-active,\n var(--slds-g-color-border-2)\n );--sds-c-button-text-color: var(--slds-c-button-neutral-text-color, var(--slds-g-color-accent-2));--sds-c-button-text-color-hover: var(--slds-c-button-neutral-text-color-hover, var(--slds-s-button-color-hover, var(--slds-g-color-accent-3)));--sds-c-button-text-color-focus: var(--slds-c-button-neutral-text-color-focus, var(--slds-g-color-accent-3));--sds-c-button-text-color-active: var(\n --slds-c-button-neutral-text-color-active,\n var(--slds-g-color-accent-3)\n );--sds-c-button-shadow: var(--slds-c-button-neutral-shadow);--sds-c-button-shadow-focus: var(--slds-c-button-neutral-shadow-focus);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " {--sds-c-button-color-border-disabled: var(--slds-g-color-border-disabled-1);--sds-c-button-text-color-disabled: var(--slds-g-color-on-disabled-1);--sds-c-button-color-background-disabled: var(--slds-g-color-disabled-container-1);pointer-events: auto;cursor: default;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-color-background: var(\n --slds-c-button-brand-color-background,\n var(--slds-g-color-accent-container-1)\n );--slds-c-button-neutral-color-background-hover: var(\n --slds-c-button-brand-color-background-hover,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-background-focus: var(\n --slds-c-button-brand-color-background-focus,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-background-active: var(\n --slds-c-button-brand-color-background-active,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-border: var(\n --slds-c-button-brand-color-border,\n var(--slds-g-color-border-accent-1)\n );--slds-c-button-neutral-color-border-hover: var(\n --slds-c-button-brand-color-border-hover,\n var(--slds-g-color-border-accent-2)\n );--slds-c-button-neutral-color-border-focus: var(\n --slds-c-button-brand-color-border-focus,\n var(--slds-g-color-border-accent-2)\n );--slds-c-button-neutral-color-border-active: var(\n --slds-c-button-brand-color-border-active,\n var(--slds-g-color-border-accent-2)\n );--sds-c-button-text-color: var(--slds-c-button-brand-text-color, var(--slds-g-color-on-accent-1));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand-outline']) [part~='button']" : hostSelector + "[variant='brand-outline'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-color-border: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']" : hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-color-background: transparent;--slds-c-button-neutral-color-background-hover: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-active: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-text-color: var(--slds-g-color-on-accent-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-accent-2);--slds-c-button-neutral-text-color-active: var(--slds-g-color-accent-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']:disabled" : hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " {--sds-c-button-color-background: transparent;--sds-c-button-color-border: var(--slds-g-color-border-disabled-2);--sds-c-button-text-color: var(--slds-g-color-disabled-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']" : hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-color-background: var(--slds-g-color-error-container-1);--slds-c-button-neutral-color-background-hover: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-border-error-1);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-error-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-error-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-error-2);--sds-c-button-text-color: var(--slds-g-color-on-error-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='success']) [part~='button']" : hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-color-background: var(--slds-g-color-success-container-1);--slds-c-button-neutral-color-background-hover: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-border-success-1);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-success-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-success-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-success-2);--slds-c-button-neutral-text-color: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-focus: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-active: var(--slds-g-color-on-success-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='destructive-text']) [part~='button']" : hostSelector + "[variant='destructive-text'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-text-color: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-focus: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-active: var(--slds-g-color-error-1);--slds-c-button-neutral-color-border-hover: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));--slds-c-button-neutral-color-border-focus: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));--slds-c-button-neutral-color-border-active: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='success']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']:disabled" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " {--sds-c-button-color-background: var(--slds-g-color-disabled-container-2);--sds-c-button-color-border: var(--slds-g-color-border-disabled-1);--sds-c-button-text-color: var(--slds-g-color-on-disabled-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='base']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='text']) [part~='button']" : hostSelector + "[variant='base'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='text'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + "{--sds-c-button-spacing-inline: 0;--slds-c-button-neutral-text-color: var(--slds-g-color-accent-2);--slds-c-button-neutral-color-border: transparent;--slds-c-button-neutral-color-border-hover: transparent;--slds-c-button-neutral-color-border-focus: transparent;--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-background: transparent;--slds-c-button-neutral-color-background-hover: transparent;--slds-c-button-neutral-color-background-focus: transparent;--slds-c-button-neutral-color-background-active: transparent;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='base']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='text']) [part~='button']:disabled" : hostSelector + "[variant='base'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='text'][data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " {--sds-c-button-color-background: transparent;--sds-c-button-color-border: transparent;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][stretch]) [part~='button']" : hostSelector + "[stretch][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--sds-c-button-sizing-width: 100%;justify-content: center;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='brand-outline']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='success']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive-text']) [part~='button']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='brand-outline'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='destructive-text'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {justify-content: center;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='start']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='start']")) + shadowSelector + " {display: inline-flex;padding-inline-end: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='end']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='end']")) + shadowSelector + " {display: inline-flex;padding-inline-start: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")) + shadowSelector + " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button_reset" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button_reset")) + shadowSelector + " {font-size: inherit;color: inherit;line-height: inherit;padding: 0;background: transparent;border: 0;text-align: inherit;}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1];

  var _implicitStylesheets = [stylesheet0];

  function tmpl($api, $cmp, $slotset, $ctx) {
    const {ncls: api_normalize_class_name, ti: api_tab_index, b: api_bind, c: api_custom_element, d: api_dynamic_text, t: api_text, h: api_element} = $api;
    const {_m0, _m1, _m2} = $ctx;
    return [api_element("button", {
      className: api_normalize_class_name($cmp.computedButtonClass),
      attrs: {
        "disabled": $cmp.disabled ? "" : null,
        "aria-disabled": $cmp.disabled,
        "name": $cmp.name,
        "accesskey": $cmp.accessKey,
        "title": $cmp.title,
        "type": $cmp.normalizedType,
        "value": $cmp.value,
        "aria-atomic": $cmp.computedAriaAtomic,
        "aria-busy": $cmp.computedAriaBusy,
        "aria-label": $cmp.ariaLabel,
        "aria-expanded": $cmp.computedAriaExpanded,
        "aria-haspopup": $cmp.computedAriaHasPopup,
        "aria-live": $cmp.computedAriaLive,
        "aria-pressed": $cmp.computedAriaPressed,
        "aria-relevant": $cmp.computedAriaRelevant,
        "part": "button",
        "tabindex": api_tab_index($cmp.tabIndex)
      },
      key: 0,
      on: {
        "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleButtonFocus)),
        "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleButtonBlur)),
        "click": _m2 || ($ctx._m2 = api_bind($cmp.handleButtonClick))
      }
    }, [$cmp.showIconLeft ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon__default.default, {
      props: {
        "part": "start",
        "iconName": $cmp.iconName,
        "svgClass": $cmp.computedIconClass,
        "variant": "bare"
      },
      key: 1
    }) : null, api_text(api_dynamic_text($cmp.label)), $cmp.showIconRight ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon__default.default, {
      props: {
        "part": "end",
        "iconName": $cmp.iconName,
        "svgClass": $cmp.computedIconClass,
        "variant": "bare"
      },
      key: 2
    }) : null])];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-31cthfl1g6j";
  tmpl.legacyStylesheetToken = "lightning-button_button";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  // Goal: Move all this to a utility

  /**
   * Added on click.
   */
  const CLICK_CLASS = 'slds-kx-is-animating-from-click';

  /**
   * Kinetics Types.
   */
  const KineticsType = {
    Underline: 'underline',
    Ripple: 'ripple'
  };

  /**
   * Map variants to the Kinetics attributes.
   */
  const variantKinectAttributes = {
    base: {
      'kx-scope': 'button',
      'kx-type': KineticsType.Underline
    },
    neutral: {
      'kx-scope': 'button-neutral',
      'kx-type': KineticsType.Ripple
    },
    brand: {
      'kx-scope': 'button-brand',
      'kx-type': KineticsType.Ripple
    },
    'brand-outline': {
      'kx-scope': 'button-outline',
      'kx-type': KineticsType.Ripple
    },
    destructive: {
      'kx-scope': 'button-filled',
      'kx-type': KineticsType.Ripple
    },
    'destructive-text': {
      'kx-scope': 'button-outline',
      'kx-type': KineticsType.Ripple
    },
    inverse: {
      'kx-scope': 'button-outline',
      'kx-type': KineticsType.Ripple
    },
    success: {
      'kx-scope': 'button-filled',
      'kx-type': KineticsType.Ripple
    }
  };

  /**
   * Retrieve a list of attributes by the variant.
   *
   * @param {string} variant
   */
  function getKineticsAttributes(variant) {
    if (!variant) {
      console.warn('getKineticsAttributes: variant is required');
      return [];
    }
    const attributes = [];
    const map = variantKinectAttributes[variant];
    Object.keys(map).forEach(attribute => {
      attributes.push({
        name: attribute,
        value: map[attribute]
      });
    });
    return attributes;
  }
  const previousTimeRef = {};
  const requestRef = {};
  const previousPointerRef = {};
  const pointerRef = {};

  /**
   * Get component name from kx-scope.
   *
   * @param {HtmlElement} element Element
   */
  function getComponentName(element) {
    const kxScope = element.getAttribute('kx-scope');
    const match = kxScope ? kxScope.match(/^(\w+)/) : null;
    return match ? match[1] : '';
  }

  /**
   * Set x, y CSS Mouse mouse position.
   *
   * @param {HtmlElement} element Element
   */
  function setCssVariables(element) {
    if (!pointerRef || !pointerRef.current || pointerRef.current === previousPointerRef.current) {
      return;
    }
    const {
      offsetX,
      offsetY
    } = pointerRef.current;
    const component = getComponentName(element);
    element.style.setProperty(`--slds-kx-${component}-pointer-position-x`, `${offsetX}px`);
    const kxType = element.getAttribute('kx-type');
    if (kxType !== KineticsType.Underline) {
      element.style.setProperty(`--slds-kx-${component}-pointer-position-y`, `${offsetY}px`);
    }
  }

  /**
   * Cleanup CSS Variables.
   *
   * @param {HtmlElement} element Element
   */
  function removeCssVariables(element) {
    if (!element) {
      return;
    }
    const component = getComponentName(element);
    element.style.removeProperty(`--slds-kx-${component}-pointer-position-x`);
    element.style.removeProperty(`--slds-kx-${component}-pointer-position-y`);
  }
  function handleMouseMove(event) {
    if (!event) {
      return;
    }
    const {
      offsetX,
      offsetY
    } = event;
    pointerRef.current = {
      offsetX,
      offsetY
    };
  }
  function handleMouseEnter(event) {
    const {
      target
    } = event;
    enterAnimate(target);
  }

  /**
   * Attach animation logic.
   *
   * @param {HtmlElement} element Element
   */
  function animate(element) {
    if (!element) {
      return;
    }
    element.addEventListener('mouseenter', handleMouseEnter);
  }
  function enterAnimate(element, timestamp) {
    const kxType = element.getAttribute('kx-type');
    function handleClick() {
      clickAnimate(element);
    }
    function handleMouseLeave() {
      window.cancelAnimationFrame(requestRef.current);
      element.removeEventListener('mousemove', handleMouseMove);
      element.removeEventListener('click', handleClick);
      element.removeEventListener('mouseleave', handleMouseLeave);
      // eslint-disable-next-line @lwc/lwc/no-async-operation
      setTimeout(() => {
        removeCssVariables(element);
      }, 250);
    }
    if (!timestamp) {
      if (kxType !== KineticsType.Underline) {
        element.addEventListener('click', handleClick);
      }
      element.addEventListener('mouseleave', handleMouseLeave);
      element.addEventListener('mousemove', handleMouseMove);
    }
    if (previousTimeRef.current !== undefined) {
      setCssVariables(element);
      previousPointerRef.current = pointerRef.current;
    }
    previousTimeRef.current = timestamp;
    // eslint-disable-next-line @lwc/lwc/no-async-operation
    requestRef.current = window.requestAnimationFrame(timestamp2 => {
      enterAnimate(element, timestamp2);
    });
  }
  let cacheHandleAnimationEnd;
  function getSingletonHandleAnimationEnd(element) {
    if (cacheHandleAnimationEnd) {
      return cacheHandleAnimationEnd;
    }
    cacheHandleAnimationEnd = function () {
      element.classList.remove(CLICK_CLASS);
      element.removeEventListener('animationend', cacheHandleAnimationEnd);
    };
    return cacheHandleAnimationEnd;
  }
  function clickAnimate(element) {
    const handleAnimationEnd = getSingletonHandleAnimationEnd(element);
    element.removeEventListener('animationend', handleAnimationEnd);
    element.classList.remove(CLICK_CLASS);
    // Restart a css animation allowing another animationend event.
    // Why? Rapidly clicking the button for a smooth ripple.
    // eslint-disable-next-line no-void
    void element.offsetWidth;
    element.addEventListener('animationend', handleAnimationEnd);
    element.classList.add(CLICK_CLASS);
  }

  /**
   * A clickable element used to perform an action.
   */
  class LightningButton extends LightningPrimitiveButton__default.default {
    constructor(...args) {
      super(...args);
      this._normalizedVariant = 'neutral';
      this._stretch = false;
      /**
       * The name for the button element.
       * This value is optional and can be used to identify the button in a callback.
       *
       * @type {string}
       */
      this.name = void 0;
      /**
       * The value for the button element.
       * This value is optional and can be used when submitting a form.
       *
       * @type {string}
       */
      this.value = void 0;
      /**
       * The text to be displayed inside the button.
       *
       * @type {string}
       */
      this.label = void 0;
      /**
       * Reserved for internal use only. Use the global tabindex attribute instead.
       * Set tab index to -1 to prevent focus on the button during tab navigation.
       * The default value is 0, which makes the button focusable during tab navigation.
       * @type {number}
       */
      this.tabIndex = void 0;
      /**
       * The Lightning Design System name of the icon.
       * Names are written in the format 'utility:down' where 'utility' is the category,
       * and 'down' is the specific icon to be displayed.
       *
       * @type {string}
       */
      this.iconName = void 0;
      /**
       * Describes the position of the icon with respect to the button label.
       * Options include left and right.
       * This value defaults to left.
       *
       * @type {string}
       * @default left
       */
      this.iconPosition = 'left';
      this._originalStretch = false;
      this._normalizedStretch = false;
      /**
       * Specifies the type of button.
       * Valid values are button, reset, and submit.
       * This value defaults to button.
       *
       * @type {string}
       * @default button
       */
      this.type = 'button';
      this._disableAnimation = false;
    }
    /**
     * The variant changes the appearance of the button.
     * Accepted variants include base, neutral, brand, brand-outline, destructive, destructive-text, inverse, and success.
     * This value defaults to neutral.
     *
     * @type {string}
     * @default neutral
     */
    get variant() {
      return this.originalVariant;
    }
    set variant(value) {
      this.originalVariant = value;
      this._normalizedVariant = utilsPrivate.normalizeString(value, {
        fallbackValue: 'neutral',
        validValues: ['base', 'neutral', 'brand', 'brand-outline', 'destructive', 'destructive-text', 'inverse', 'success']
      });
      utilsPrivate.reflectAttribute(this, 'variant', this._normalizedVariant);
    }
    /**
     * Setting it to true allows the button to take up the entire available width.
     * This value defaults to false.
     *
     * @type {boolean}
     * @default false
     */
    get stretch() {
      return this._originalStretch;
    }
    set stretch(value) {
      this._originalStretch = value;
      this._normalizedStretch = utilsPrivate.normalizeBoolean(value);
      utilsPrivate.reflectAttribute(this, 'stretch', this._normalizedStretch);
    }
    /**
     * Reserved for internal use. If present, disables button animation.
     */
    get disableAnimation() {
      return this._disableAnimation;
    }
    set disableAnimation(value) {
      this._disableAnimation = utilsPrivate.normalizeBoolean(value);
    }
    render() {
      return _tmpl;
    }
    get computedButtonClass() {
      const classes = utils.classSet(super.computedButtonClass);
      return classes.add({
        'slds-button_neutral': this._normalizedVariant === 'neutral',
        'slds-button_brand': this._normalizedVariant === 'brand',
        'slds-button_outline-brand': this._normalizedVariant === 'brand-outline',
        'slds-button_destructive': this._normalizedVariant === 'destructive',
        'slds-button_text-destructive': this._normalizedVariant === 'destructive-text',
        'slds-button_inverse': this._normalizedVariant === 'inverse',
        'slds-button_success': this._normalizedVariant === 'success',
        'slds-button_stretch': this.stretch
      }).toString();
    }
    get normalizedType() {
      return utilsPrivate.normalizeString(this.type, {
        fallbackValue: 'button',
        validValues: ['button', 'reset', 'submit']
      });
    }
    get normalizedIconPosition() {
      return utilsPrivate.normalizeString(this.iconPosition, {
        fallbackValue: 'left',
        validValues: ['left', 'right']
      });
    }
    get showIconLeft() {
      return this.iconName && this.normalizedIconPosition === 'left';
    }
    get showIconRight() {
      return this.iconName && this.normalizedIconPosition === 'right';
    }
    get computedIconClass() {
      return utils.classSet('slds-button__icon').add({
        'slds-button__icon_left': this.normalizedIconPosition === 'left',
        'slds-button__icon_right': this.normalizedIconPosition === 'right'
      }).toString();
    }
    handleButtonFocus() {
      this.dispatchEvent(new CustomEvent('focus'));
    }
    handleButtonBlur() {
      this.dispatchEvent(new CustomEvent('blur'));
    }
    handleButtonClick() {
      // In native shadow mode, parent form can't be submitted from within the
      // shadow boundary, so we need to manually find the parent form and submit.
      // Once TD-0118070 is delivered, we can access the parent form using `elementInternals.form`
      if (!this.template.synthetic && this.normalizedType === 'submit') {
        const form = this.template.host.closest('form');
        if (form) {
          form.requestSubmit();
        }
      }
    }

    /**
     * Sets focus on the button.
     */
    focus() {
      if (this._connected) {
        this.button.focus();
      }
    }

    /**
     * Simulates a mouse click on the button.
     */
    click() {
      if (this._connected) {
        this.button.click();
      }
    }
    get button() {
      return utilsPrivate.isCSR ? this.template.querySelector('button') : null;
    }

    /**
     * Once we are connected, we fire a register event so the button-group (or other) component can register
     * the buttons.
     */
    connectedCallback() {
      super.connectedCallback();
      // Set `data-render-mode` attribute in native shadow mode
      if (!this.template.synthetic) {
        this.setAttribute('data-render-mode', 'shadow');
      }
      if (!this._connected) {
        utilsPrivate.reflectAttribute(this, 'variant', this._normalizedVariant);
        this._connected = true;
      }
    }
    renderedCallback() {
      // initialize aria attributes in primitiveButton
      super.renderedCallback();
      // button inherits from primitiveButton, button.css not working in this case.
      // change host style to disable pointer event.
      this.template.host.style.pointerEvents = this.disabled ? 'none' : '';
      // setup kinetics

      if (!this.disabled && utilsPrivate.hasAnimation() && !this._disableAnimation) {
        const attributes = getKineticsAttributes(this._normalizedVariant);
        attributes.forEach(({
          name,
          value
        }) => {
          this.button.setAttribute(name, value);
        });
        animate(this.button);
      } else {
        const attributes = getKineticsAttributes(this._normalizedVariant);
        attributes.forEach(({
          name
        }) => {
          this.button.removeAttribute(name);
        });
      }
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this._connected = false;
    }
    /*LWC compiler v7.1.5*/
  }
  LightningButton.delegatesFocus = true;
  lwc.registerDecorators(LightningButton, {
    publicProps: {
      name: {
        config: 0
      },
      value: {
        config: 0
      },
      label: {
        config: 0
      },
      tabIndex: {
        config: 0
      },
      variant: {
        config: 3
      },
      iconName: {
        config: 0
      },
      iconPosition: {
        config: 0
      },
      stretch: {
        config: 3
      },
      type: {
        config: 0
      },
      disableAnimation: {
        config: 3
      }
    },
    publicMethods: ["focus", "click"],
    fields: ["_normalizedVariant", "_stretch", "_originalStretch", "_normalizedStretch", "_disableAnimation"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningButton, {
    tmpl: _tmpl,
    sel: "lightning-button",
    apiVersion: 62
  });
  LightningButton.interopMap = {
    exposeNativeEvent: {
      click: true,
      focus: true,
      blur: true
    }
  };

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/label/LightningColorPicker.bInput', ['@view/forgotPassword/labels'], m => m[54]);
LWR.define('@salesforce/label/LightningColorPicker.blueAbbr', ['@view/forgotPassword/labels'], m => m[55]);
LWR.define('@salesforce/label/LightningColorPicker.colorPickerInstructions', ['@view/forgotPassword/labels'], m => m[56]);
LWR.define('@salesforce/label/LightningColorPicker.errorMessage', ['@view/forgotPassword/labels'], m => m[57]);
LWR.define('@salesforce/label/LightningColorPicker.gInput', ['@view/forgotPassword/labels'], m => m[58]);
LWR.define('@salesforce/label/LightningColorPicker.greenAbbr', ['@view/forgotPassword/labels'], m => m[59]);
LWR.define('@salesforce/label/LightningColorPicker.hexLabel', ['@view/forgotPassword/labels'], m => m[60]);
LWR.define('@salesforce/label/LightningColorPicker.hueInput', ['@view/forgotPassword/labels'], m => m[61]);
LWR.define('@salesforce/label/LightningColorPicker.rInput', ['@view/forgotPassword/labels'], m => m[62]);
LWR.define('@salesforce/label/LightningColorPicker.redAbbr', ['@view/forgotPassword/labels'], m => m[63]);
(function() { LWR.define('lightning/colorPickerCustom', ['exports', 'lwc', 'lightning/sldsCommon', '@salesforce/label/LightningColorPicker.bInput', '@salesforce/label/LightningColorPicker.blueAbbr', '@salesforce/label/LightningColorPicker.colorPickerInstructions', '@salesforce/label/LightningColorPicker.errorMessage', '@salesforce/label/LightningColorPicker.gInput', '@salesforce/label/LightningColorPicker.greenAbbr', '@salesforce/label/LightningColorPicker.hexLabel', '@salesforce/label/LightningColorPicker.hueInput', '@salesforce/label/LightningColorPicker.rInput', '@salesforce/label/LightningColorPicker.redAbbr', '@salesforce/client/formFactor', 'lightning/shadowBaseClassPrivate', 'lightning/utilsPrivate', 'lightning/inputUtils'], (function (exports, lwc, stylesheet0$1, labelBInput, labelBlueAbbr, labelColorPickerInstructions, labelErrorMessage, labelGInput, labelGreenAbbr, labelHexLabel, labelHueInput, labelRInput, labelRedAbbr, formFactorPropertyName, LightningShadowBaseClass, utilsPrivate, inputUtils) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var labelBInput__default = /*#__PURE__*/_interopDefaultCompat(labelBInput);
  var labelBlueAbbr__default = /*#__PURE__*/_interopDefaultCompat(labelBlueAbbr);
  var labelColorPickerInstructions__default = /*#__PURE__*/_interopDefaultCompat(labelColorPickerInstructions);
  var labelErrorMessage__default = /*#__PURE__*/_interopDefaultCompat(labelErrorMessage);
  var labelGInput__default = /*#__PURE__*/_interopDefaultCompat(labelGInput);
  var labelGreenAbbr__default = /*#__PURE__*/_interopDefaultCompat(labelGreenAbbr);
  var labelHexLabel__default = /*#__PURE__*/_interopDefaultCompat(labelHexLabel);
  var labelHueInput__default = /*#__PURE__*/_interopDefaultCompat(labelHueInput);
  var labelRInput__default = /*#__PURE__*/_interopDefaultCompat(labelRInput);
  var labelRedAbbr__default = /*#__PURE__*/_interopDefaultCompat(labelRedAbbr);
  var formFactorPropertyName__default = /*#__PURE__*/_interopDefaultCompat(formFactorPropertyName);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {display: flex;align-items: center;gap: var(--sds-c-inputtext-spacing-gap, var(--sds-s-input-spacing-gap));min-height: var(--sds-c-inputtext-sizing-height, var(--sds-s-input-sizing-height));padding-inline-start: var(\n --sds-c-inputtext-spacing-inlinestart,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-spacing-inlineend,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-spacing-blockstart,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-spacing-blockend,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );background: var(--sds-c-inputtext-color-background, var(--sds-s-input-color-background));border-block-start: var(\n --sds-c-inputtext-sizing-border-blockstart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockstart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-start: var(\n --sds-c-inputtext-sizing-border-inlinestart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlinestart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-end: var(\n --sds-c-inputtext-sizing-border-inlineend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlineend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-block-end: var(\n --sds-c-inputtext-sizing-border-blockend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-radius: var(--sds-c-inputtext-radius-border, var(--sds-s-input-radius-border));box-shadow: var(--sds-c-inputtext-shadow, var(--sds-s-input-shadow));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, " {width: 100%;height: 100%;padding: 0;font-size: var(--sds-c-inputtext-font-size, var(--sds-s-input-font-size));color: var(--sds-c-inputtext-text-color, var(--sds-s-input-text-color));line-height: 1;border: none;background: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][active]) [part~='input-container']" : hostSelector + "[active][data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-active,\n var(--sds-s-input-color-background-active)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-active,\n var(--sds-s-input-color-border-active)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-active, var(--sds-s-input-shadow-active));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, "::placeholder {color: var(--sds-c-inputtext-text-color-placeholder, var(--sds-s-input-text-color-placeholder));font-style: var(--sds-c-inputtext-font-style-placeholder, var(--sds-s-input-font-style-placeholder));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']:focus-within" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-focus,\n var(--sds-s-input-color-border-focus, revert)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-focus, var(--sds-s-input-shadow-focus));--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-focus,\n var(--sds-s-input-color-background-focus, revert)\n );--sds-c-inputtext-text-color: var(\n --sds-c-inputtext-text-color-focus,\n var(--sds-s-input-text-color-focus, revert)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']:focus")), shadowSelector, " {outline: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {display: inline-flex;align-items: center;gap: var(--sds-c-inputtext-label-spacing-gap, var(--sds-s-label-spacing-gap));padding-inline-start: var(\n --sds-c-inputtext-label-spacing-inlinestart,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-label-spacing-inlineend,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-label-spacing-blockstart,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-label-spacing-blockend,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );color: var(--sds-c-inputtext-label-color, var(--sds-s-label-color));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {font-size: var(--sds-c-inputtext-label-font-size, var(--sds-s-label-font-size));font-weight: var(--sds-c-inputtext-label-font-weight, var(--sds-s-label-font-weight));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='help-text visible']" : hostSelector + "[data-render-mode=\"shadow\"] [part='help-text visible']")), shadowSelector, " {font-size: var(--sds-c-inputtext-helptext-font-size, var(--sds-s-helptext-font-size));color: var(--sds-c-inputtext-helptext-text-color, var(--sds-s-helptext-text-color));padding-inline-start: var(\n --sds-c-inputtext-helptext-spacing-inlinestart,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-helptext-spacing-inlineend,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-helptext-spacing-blockstart,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-helptext-spacing-blockend,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) {" : hostSelector + "[disabled][data-render-mode=\"shadow\"] {")), "--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-disabled,\n var(--sds-s-input-color-background-disabled)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-disabled,\n var(--sds-s-input-color-border-disabled)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][label-hidden]) [part='label-container']" : hostSelector + "[label-hidden][data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-inputtext-icon-color-foreground,\n var(--slds-g-color-on-surface-1)\n );--slds-c-icon-sizing: var(--slds-c-inputtext-icon-sizing, 14px);--sds-c-inputtext-sizing-height: var(\n --slds-c-inputtext-sizing-height,\n var(--slds-g-sizing-9)\n );--sds-c-inputtext-color-background: var(\n --slds-c-inputtext-color-background,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-color-background-focus: var(\n --slds-c-inputtext-color-background-focus,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-text-color: var(--slds-c-inputtext-text-color);--sds-c-inputtext-font-size: var(\n --slds-c-inputtext-font-size,\n var(--slds-g-font-size-base)\n );--sds-c-inputtext-text-color-placeholder: var(\n --slds-c-inputtext-text-color-placeholder,\n var(--slds-g-color-on-surface-1)\n );--sds-c-inputtext-color-border: var(\n --slds-c-inputtext-color-border,\n var(--slds-g-color-border-2)\n );--sds-c-inputtext-sizing-border: var(--slds-c-inputtext-sizing-border);--sds-c-inputtext-radius-border: var(\n --slds-c-inputtext-radius-border,\n var(--slds-g-radius-border-2)\n );display: flex;flex-wrap: wrap;flex-direction: column;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {flex: 1 0 100%;align-items: stretch;--sds-c-inputtext-spacing-inline: 0;--sds-c-inputtext-spacing-block: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']")), shadowSelector, " {border: none;display: inline-block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " .slds-input__icon:not(button)", shadowSelector, " {pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input'][type='range']")), shadowSelector, " {min-height: calc(1.875rem + (1px * 2));margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:focus-within" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 3px var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;border-width: var(--sds-c-inputtext-sizing-border, var(--slds-g-sizing-border-1));border-color: var(--sds-c-inputtext-color-border, var(--slds-g-color-border-2));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {padding-inline-start: var(\n --slds-c-inputtext-spacing-inlinestart,\n var(--slds-g-spacing-3));padding-inline-end: var(\n --slds-c-inputtext-spacing-inlineend,\n var(--slds-g-spacing-4));height: unset;font-family: var(--slds-g-font-family);}", ((useActualHostSelector ? ":host(:not([disabled])) [part=\"input-container\"]:focus-within" + shadowSelector + ", :host(:not([disabled])) [part=\"input-container\"]:active" : hostSelector + ":not([disabled]) [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + ":not([disabled]) [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part='input-text']" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-spacing-inline-start-readonly: 0;--sds-c-inputtext-color-border-focus: transparent;--slds-c-inputtext-color-border: transparent;--slds-c-inputtext-color-background: transparent;--slds-c-inputtext-color-background-focus: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:active" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-disabled-container-2);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: transparent;outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-text']" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-shadow: 0 0 0 var(--slds-g-sizing-border-1) inset\n var(--slds-g-color-error-1);--slds-c-inputtext-color-border: var(--slds-g-color-border-error-1);--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-input-has-icon" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " {--slds-c-input-color-background: var(--slds-s-input-color-background-invalid);--slds-c-input-color-border: var(--slds-g-color-border-error-1);--slds-c-input-text-color: var(--slds-s-input-color-invalid);background-clip: padding-box;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {fill: var(--slds-g-color-error-1);color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-container']:focus-within" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-shadow:\n var(--slds-g-color-error-base-50) 0 0 0 var(--slds-g-sizing-border-1) inset,\n 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-border-error-1);--sds-c-inputtext-color-border: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-container']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][disabled]) [part='input']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-container']" + shadowSelector + "," + hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {cursor: not-allowed;--sds-c-inputtext-color-background: var(--slds-s-input-color-background-disabled, var(--slds-g-color-disabled-container-1));--sds-c-inputtext-color-border: var(--slds-g-color-border-disabled-1);--sds-c-inputtext-text-color: var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-text']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-text-color-placeholder:\n var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " [part='label']", shadowSelector, " {padding-block-start: var(--slds-g-spacing-1);padding-inline-end: var(--slds-g-spacing-2);color: var(\n --slds-c-inputtext-label-color,\n var(--slds-g-color-on-surface-2)\n );margin-block-end: var(--slds-g-sizing-1);display: inline-flex;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='start']" : hostSelector + "[data-render-mode=\"shadow\"] [part='start']")), shadowSelector, " {--slds-c-icon-spacing-inlineend: var(--slds-g-spacing-2);}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-text']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='label']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {float: left;max-width: calc(33% - 1.125rem);padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-container']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='inline-help']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='inline-help']")), shadowSelector, " {float: left;padding-block-start: var(--slds-g-spacing-1);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) input[type=\"search\"]" : hostSelector + "[data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {left: var(--slds-g-spacing-3);fill: var(--slds-g-color-on-surface-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-accent-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-input__icon", shadowSelector, " {width: 0.875rem;height: 0.875rem;position: absolute;top: 50%;margin-top: -0.4375rem;line-height: 1;border: 0;z-index: 2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_left", shadowSelector, " {inset-inline-start: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right")), shadowSelector, " {--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_right", shadowSelector, " {inset-inline-end: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet$1];

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='color-picker-custom']" : hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker-custom']")) + shadowSelector + " .slds-assistive-text" + shadowSelector + " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='color-picker-custom']" : hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker-custom']")) + shadowSelector + " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-1);--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__input-custom-hex" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__input-custom-hex")) + shadowSelector + " {flex: none;width: 4.2rem;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-m-bottom_small" : hostSelector + "[data-render-mode=\"shadow\"] .slds-m-bottom_small")) + shadowSelector + " {margin-block-end: var(--slds-g-spacing-3);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__range-indicator" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__range-indicator")) + shadowSelector + " {transform: translate3d(-0.375rem, 0.375rem, 0);cursor: pointer;position: absolute;height: var(--slds-g-spacing-3);width: var(--slds-g-spacing-3);border: var(--slds-g-sizing-border-2) solid var(--slds-g-color-surface-container-1);border-radius: 50%;box-shadow: 0 2px 4px 4px rgba(0, 0, 0, 16%), inset 0 2px 4px 4px rgba(0, 0, 0, 16%);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__range-indicator:focus" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__range-indicator:focus")) + shadowSelector + " {outline: none;box-shadow: 0 0 3px var(--slds-g-color-accent-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__hue-and-preview" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__hue-and-preview")) + shadowSelector + " {display: flex;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__hue-slider" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__hue-slider")) + shadowSelector + " {appearance: none;cursor: pointer;flex: 1;margin: 0;padding: 0;height: var(--slds-g-spacing-5);width: 100%;border: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);border-radius: var(--slds-g-spacing-1);background: linear-gradient(\n to right,\n red,\n #ff1500,\n #ff2b00,\n #ff4000,\n #f50,\n #ff6a00,\n #ff8000,\n #ff9500,\n #fa0,\n #ffbf00,\n #ffd500,\n #ffea00,\n yellow,\n #eaff00,\n #d5ff00,\n #bfff00,\n #af0,\n #95ff00,\n #80ff00,\n #6aff00,\n #5f0,\n #40ff00,\n #2bff00,\n #15ff00,\n lime,\n #00ff15,\n #00ff2b,\n #00ff40,\n #0f5,\n #00ff6a,\n #00ff80,\n #00ff95,\n #0fa,\n #00ffbf,\n #00ffd5,\n #00ffea,\n aqua,\n #00eaff,\n #00d5ff,\n deepskyblue,\n #0af,\n #0095ff,\n #0080ff,\n #006aff,\n #05f,\n #0040ff,\n #002bff,\n #0015ff,\n blue,\n #1500ff,\n #2b00ff,\n #4000ff,\n #50f,\n #6a00ff,\n #8000ff,\n #9500ff,\n #a0f,\n #bf00ff,\n #d500ff,\n #ea00ff,\n fuchsia,\n #ff00ea,\n #ff00d5,\n #ff00bf,\n #f0a,\n #ff0095,\n #ff0080,\n #ff006a,\n #f05,\n #ff0040,\n #ff002b,\n #ff0015\n );}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__hue-slider" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__hue-slider")) + shadowSelector + "::-webkit-slider-thumb {appearance: none;cursor: pointer;height: calc(var(--slds-g-spacing-5) - (1px * 2));width: 0.375rem;border: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-2);border-radius: var(--slds-g-radius-border-1);background: var(--slds-g-color-surface-container-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__hue-slider" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__hue-slider")) + shadowSelector + "::-moz-range-thumb {appearance: none;box-sizing: border-box;cursor: pointer;height: calc(var(--slds-g-spacing-5) - (1px * 2));width: 0.375rem;border: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-2);border-radius: var(--slds-g-radius-border-1);background: var(--slds-g-color-neutral-base-95);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__hue-slider:focus" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__hue-slider:focus")) + shadowSelector + "::-webkit-slider-thumb {box-shadow: 0 0 5px var(--slds-g-color-accent-2);border: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__hue-slider:focus" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__hue-slider:focus")) + shadowSelector + "::-moz-range-thumb {box-shadow: 0 0 5px var(--slds-g-color-accent-2);border: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__hue-slider:active" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__hue-slider:active")) + shadowSelector + "::-webkit-slider-thumb {box-shadow: 0 0 5px var(--slds-g-color-accent-2);border: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__hue-slider:active" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__hue-slider:active")) + shadowSelector + "::-moz-range-thumb {box-shadow: 0 0 5px var(--slds-g-color-accent-2);border: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__hue-slider:focus" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__hue-slider:focus")) + shadowSelector + " {outline: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-swatch" : hostSelector + "[data-render-mode=\"shadow\"] .slds-swatch")) + shadowSelector + " {margin-inline-start: var(--slds-g-spacing-1);height: var(--slds-g-spacing-5);width: var(--slds-g-spacing-5);border: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);border-radius: var(--slds-g-spacing-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__custom-inputs" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__custom-inputs")) + shadowSelector + " {display: flex;padding-block-start: var(--slds-g-spacing-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__custom-inputs" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__custom-inputs")) + shadowSelector + " > div" + shadowSelector + " {margin-inline-end: var(--slds-g-spacing-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")) + shadowSelector + " {border-color: var(--slds-g-color-border-error-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help")) + shadowSelector + " {padding-block-start: var(--slds-g-spacing-2);padding-inline-start: var(--slds-g-spacing-1);color: var(--slds-g-color-error-1);font-size: var(--slds-g-spacing-3);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) abbr[title]" : hostSelector + "[data-render-mode=\"shadow\"] abbr[title]")) + shadowSelector + " {text-decoration: none;}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet2 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1, stylesheet2];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<p${"a0:id"} class="slds-assistive-text${0}"${2}>${"t1"}</p>`;
  const $fragment2 = lwc.parseFragment`<div class="slds-m-bottom_small${0}" data-id="color-gradient"${"s0"}${2}><canvas${"a1:width"}${"a1:height"}${3}></canvas><a data-id="color-anchor" href="javascript:void(0)" class="slds-color-picker__range-indicator${0}" style="position: absolute; display: inline;" aria-live="assertive" aria-atomic="true"${"a2:aria-describedby"}${2}><span class="slds-assistive-text${0}"${2}>${"t4"}</span></a></div>`;
  const $fragment3 = lwc.parseFragment`<label class="slds-assistive-text${0}"${"a0:for"}${2}>${"t1"}</label>`;
  const $fragment4 = lwc.parseFragment`<span class="slds-swatch${0}" data-id="color-preview"${"s0"}${2}><span class="slds-assistive-text${0}" aria-hidden="true"${2}>${"t2"}</span></span>`;
  const $fragment5 = lwc.parseFragment`<label part="label" class="slds-form-element__label${0}"${"a0:for"}${2}>${"t1"}</label>`;
  const $fragment6 = lwc.parseFragment`<label part="label" class="slds-form-element__label${0}"${"a0:for"}${2}><abbr${"a1:title"}${3}>${"t2"}</abbr></label>`;
  const $fragment7 = lwc.parseFragment`<label part="label" class="slds-form-element__label${0}"${"a0:for"}${2}><abbr${"a1:title"}${3}>${"t2"}</abbr></label>`;
  const $fragment8 = lwc.parseFragment`<label part="label" class="slds-form-element__label${0}"${"a0:for"}${2}><abbr${"a1:title"}${3}>${"t2"}</abbr></label>`;
  const $fragment9 = lwc.parseFragment`<div class="slds-form-element__help${0}" aria-live="assertive"${2}>${"t1"}</div>`;
  const stc0 = {
    classMap: {
      "slds-color-picker__custom": true
    },
    attrs: {
      "part": "color-picker-custom"
    },
    key: 0
  };
  const stc1 = {
    classMap: {
      "slds-color-picker__hue-and-preview": true
    },
    key: 5
  };
  const stc2 = {
    "slds-color-picker__hue-slider": true
  };
  const stc3 = {
    classMap: {
      "slds-color-picker__custom-inputs": true
    },
    key: 11
  };
  const stc4 = {
    classMap: {
      "slds-form-element": true,
      "slds-color-picker__input-custom-hex": true
    },
    attrs: {
      "part": "input-text"
    },
    key: 12
  };
  const stc5 = {
    classMap: {
      "slds-form-element__control": true
    },
    attrs: {
      "part": "input-container"
    },
    key: 15
  };
  const stc6 = {
    "slds-input": true
  };
  const stc7 = {
    classMap: {
      "slds-form-element": true
    },
    attrs: {
      "part": "input-text"
    },
    key: 17
  };
  const stc8 = {
    classMap: {
      "slds-form-element__control": true
    },
    attrs: {
      "part": "input-container"
    },
    key: 20
  };
  const stc9 = {
    classMap: {
      "slds-form-element": true
    },
    attrs: {
      "part": "input-text"
    },
    key: 22
  };
  const stc10 = {
    classMap: {
      "slds-form-element__control": true
    },
    attrs: {
      "part": "input-container"
    },
    key: 25
  };
  const stc11 = {
    classMap: {
      "slds-form-element": true
    },
    attrs: {
      "part": "input-text"
    },
    key: 27
  };
  const stc12 = {
    classMap: {
      "slds-form-element__control": true
    },
    attrs: {
      "part": "input-container"
    },
    key: 30
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {gid: api_scoped_id, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment, b: api_bind, h: api_element} = $api;
    const {_m0, _m1, _m2, _m3, _m4, _m5, _m6, _m7, _m8, _m9, _m10} = $ctx;
    return [api_element("div", stc0, [api_static_fragment($fragment1, 2, [api_static_part(0, {
      attrs: {
        "id": api_scoped_id("color-picker-instructions")
      }
    }, null), api_static_part(1, null, api_dynamic_text($cmp.i18n.colorPickerInstructions))]), api_static_fragment($fragment2, 4, [api_static_part(0, {
      on: {
        "mousedown": _m1 || ($ctx._m1 = api_bind($cmp.handleMouseDown))
      },
      style: $cmp.gradientStyle
    }, null), api_static_part(1, {
      attrs: {
        "width": $cmp.canvasRect.x,
        "height": $cmp.canvasRect.y
      }
    }, null), api_static_part(2, {
      on: {
        "mousedrag": _m2 || ($ctx._m2 = api_bind($cmp.handlePreventDefault)),
        "mousedown": _m3 || ($ctx._m3 = api_bind($cmp.handlePreventDefault)),
        "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleKeydown))
      },
      attrs: {
        "aria-describedby": api_scoped_id("color-picker-instructions")
      }
    }, null), api_static_part(4, null, api_dynamic_text($cmp._hex))]), api_element("div", stc1, [api_static_fragment($fragment3, 7, [api_static_part(0, {
      attrs: {
        "for": api_scoped_id("rainbow")
      }
    }, null), api_static_part(1, null, api_dynamic_text($cmp.i18n.hueInput))]), api_element("input", {
      classMap: stc2,
      attrs: {
        "data-id": "hue-slider",
        "type": "range",
        "min": "0",
        "max": "360",
        "id": api_scoped_id("rainbow")
      },
      props: {
        "value": $cmp._hueValue
      },
      key: 8,
      on: {
        "mousedown": _m5 || ($ctx._m5 = api_bind($cmp.handleDrag)),
        "change": _m6 || ($ctx._m6 = api_bind($cmp.onChange))
      }
    }), api_static_fragment($fragment4, 10, [api_static_part(0, {
      style: $cmp.thumbnailStyle
    }, null), api_static_part(2, null, api_dynamic_text($cmp._hex))])]), api_element("div", stc3, [api_element("div", stc4, [api_static_fragment($fragment5, 14, [api_static_part(0, {
      attrs: {
        "for": api_scoped_id("input")
      }
    }, null), api_static_part(1, null, api_dynamic_text($cmp.i18n.hexLabel))]), api_element("div", stc5, [api_element("input", {
      classMap: stc6,
      attrs: {
        "data-primary-input": "",
        "type": "text",
        "id": api_scoped_id("input"),
        "part": "input",
        "minlength": "4",
        "maxlength": "7",
        "pattern": "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$",
        "placeholder": "#FFFFFF"
      },
      props: {
        "value": $cmp._hex
      },
      key: 16,
      on: {
        "change": _m7 || ($ctx._m7 = api_bind($cmp.handleHexChange))
      }
    })])]), api_element("div", stc7, [api_static_fragment($fragment6, 19, [api_static_part(0, {
      attrs: {
        "for": api_scoped_id("red")
      }
    }, null), api_static_part(1, {
      attrs: {
        "title": $cmp.i18n.redAbbr
      }
    }, null), api_static_part(2, null, api_dynamic_text($cmp.i18n.rInput))]), api_element("div", stc8, [api_element("input", {
      classMap: stc6,
      attrs: {
        "type": "text",
        "id": api_scoped_id("red"),
        "data-color-name": "red",
        "part": "input",
        "placeholder": "255"
      },
      props: {
        "value": $cmp._rgb.red
      },
      key: 21,
      on: {
        "change": _m8 || ($ctx._m8 = api_bind($cmp.handleRgbChange))
      }
    })])]), api_element("div", stc9, [api_static_fragment($fragment7, 24, [api_static_part(0, {
      attrs: {
        "for": api_scoped_id("green")
      }
    }, null), api_static_part(1, {
      attrs: {
        "title": $cmp.i18n.greenAbbr
      }
    }, null), api_static_part(2, null, api_dynamic_text($cmp.i18n.gInput))]), api_element("div", stc10, [api_element("input", {
      classMap: stc6,
      attrs: {
        "type": "text",
        "id": api_scoped_id("green"),
        "data-color-name": "green",
        "part": "input",
        "placeholder": "255"
      },
      props: {
        "value": $cmp._rgb.green
      },
      key: 26,
      on: {
        "change": _m9 || ($ctx._m9 = api_bind($cmp.handleRgbChange))
      }
    })])]), api_element("div", stc11, [api_static_fragment($fragment8, 29, [api_static_part(0, {
      attrs: {
        "for": api_scoped_id("blue")
      }
    }, null), api_static_part(1, {
      attrs: {
        "title": $cmp.i18n.blueAbbr
      }
    }, null), api_static_part(2, null, api_dynamic_text($cmp.i18n.bInput))]), api_element("div", stc12, [api_element("input", {
      classMap: stc6,
      attrs: {
        "type": "text",
        "id": api_scoped_id("blue"),
        "data-color-name": "blue",
        "part": "input",
        "placeholder": "255"
      },
      props: {
        "value": $cmp._rgb.blue
      },
      key: 31,
      on: {
        "change": _m10 || ($ctx._m10 = api_bind($cmp.handleRgbChange))
      }
    })])])]), $cmp._errorMessage ? api_static_fragment($fragment9, 33, [api_static_part(1, null, api_dynamic_text($cmp._errorMessage))]) : null])];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-5mnumbh5e5i";
  tmpl.legacyStylesheetToken = "lightning-colorPickerCustom_colorPickerCustom";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  function fullHexValue(hex) {
    if (Array.isArray(hex) && hex.length > 0) {
      hex = hex[0];
    }
    if (hex && hex.length <= 6 && hex.charAt(0) !== '#') {
      hex = '#' + hex;
    }
    const isInputValid = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex);
    if (!isInputValid) {
      hex = '#000000';
    }
    // Converting 3 digit hex color to 6 digit hex color
    if (hex.length === 4) {
      hex = '#' + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2) + hex.charAt(3) + hex.charAt(3);
    }
    return hex;
  }
  function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(fullHexValue(hex));
    if (!result) {
      return null;
    }
    return {
      red: parseInt(result[1], 16),
      green: parseInt(result[2], 16),
      blue: parseInt(result[3], 16)
    };
  }
  function rgbToHex(rgb) {
    const r = rgb.red;
    const g = rgb.green;
    const b = rgb.blue;
    const bin = r << 16 | g << 8 | b;
    return function (hex) {
      return new Array(7 - hex.length).join('0') + hex;
    }(bin.toString(16).toUpperCase());
  }
  function rgbToHsl(rgb) {
    const r1 = rgb.red / 255;
    const g1 = rgb.green / 255;
    const b1 = rgb.blue / 255;
    const maxColor = Math.max(r1, g1, b1);
    const minColor = Math.min(r1, g1, b1);
    // Calculate L:
    let L = (maxColor + minColor) / 2;
    let S = 0;
    let H = 0;
    if (maxColor !== minColor) {
      // Calculate S:
      if (L < 0.5) {
        S = (maxColor - minColor) / (maxColor + minColor);
      } else {
        S = (maxColor - minColor) / (2.0 - maxColor - minColor);
      }

      // Calculate H:
      if (r1 === maxColor) {
        const x = g1 - b1,
          y = maxColor - minColor;
        H = x / y;
      } else if (g1 === maxColor) {
        const x = b1 - r1,
          y = maxColor - minColor,
          z = x / y;
        H = 2.0 + z;
      } else {
        const x = r1 - g1,
          y = maxColor - minColor,
          z = x / y;
        H = 4.0 + z;
      }
    }
    L *= 100;
    S *= 100;
    H *= 60;
    if (H < 0) {
      H += 360;
    }
    const result = {
      hue: H,
      saturation: S,
      lightness: L
    };
    return result;
  }
  function rgbToPosition(rgb, canvas) {
    const hsv = rgbToHsv(rgb);
    const saturation = hsv.saturation / 100,
      brightness = hsv.brightness / 100;
    const x = canvas.x * saturation;
    const y = canvas.y * (1 - brightness);
    return {
      x,
      y
    };
  }
  function rgbToHsv(rgb) {
    const r = rgb.red / 255;
    const g = rgb.green / 255;
    const b = rgb.blue / 255;
    const max = Math.max(r, g, b),
      min = Math.min(r, g, b);
    const d = max - min,
      s = max === 0 ? 0 : d / max,
      v = max;
    let h, x, y;
    if (max === min) {
      h = 0;
    } else {
      switch (max) {
        case r:
          x = g - b;
          y = x / d;
          h = y + (g < b ? 6 : 0);
          break;
        case g:
          x = b - r;
          y = x / d;
          h = y + 2;
          break;
        case b:
          x = r - g;
          y = x / d;
          h = y + 4;
          break;
      }
      h /= 6;
    }
    const result = {
      hue: h * 360,
      saturation: s * 100,
      brightness: v * 100
    };
    return result;
  }

  const i18n = {
    bInput: labelBInput__default.default,
    blueAbbr: labelBlueAbbr__default.default,
    colorPickerInstructions: labelColorPickerInstructions__default.default,
    errorMessage: labelErrorMessage__default.default,
    gInput: labelGInput__default.default,
    greenAbbr: labelGreenAbbr__default.default,
    hexLabel: labelHexLabel__default.default,
    hueInput: labelHueInput__default.default,
    rInput: labelRInput__default.default,
    redAbbr: labelRedAbbr__default.default
  };
  const CANVAS = {
    x: 198,
    y: 80
  };
  class LightningColorPickerCustom extends LightningShadowBaseClass__default.default {
    constructor() {
      super();
      this._hueValue = null;
      this._rgb = {
        red: '86',
        green: '121',
        blue: '192'
      };
      this._hex = '#5679C0';
      this._errorMessage = null;
      this._currentColor = null;
      this._initialized = false;
      this.uniqueId = inputUtils.generateUniqueId();
    }
    renderedCallback() {
      if (!this._initialized) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          // (*1*)
          if (formFactorPropertyName__default.default !== 'Large') {
            /**
             * We need to wait for one more animation frame and invoke .focus()
             * in iOS. This is because the positionLibray.js initially sets the position
             * of this color-picker element to "top: 0px" and then later repositions it asynchronously
             * it the next animation frames. The first (*1*) rAF callback is fired between
             * setting "top: 0px" and then later repositioning it. Calling .focus() in this callback
             * triggers a re-paint step and the page is scrolled to the top due to "top: 0px" being
             * present in the styles. To avoid this, we can delay the next re-paint after color-picker
             * is repositioned correctly by positionLibrary.js. Hence we wait for next animation frame
             * and then call .focus() to trigger the next re-paint after the color-picker is repositioned correctly
             * which was initially positioned with "top: 0px" by positionLibrary.js
             */
            // eslint-disable-next-line @lwc/lwc/no-async-operation
            requestAnimationFrame(() => this.focus());
          } else {
            this.focus();
          }
        });
        this.gradient();
        this.handleUpdateAnchor();
        this._initialized = true;
      }
    }
    get currentColor() {
      return this._currentColor;
    }
    set currentColor(value) {
      const fullHex = fullHexValue(value);
      this._currentColor = value;
      this._hex = fullHex;
      this._rgb = hexToRgb(fullHex);

      // W-13851481 bug-fix: if canvas open, update it
      if (this._canvas) {
        const hue = rgbToHsl(this._rgb).hue;
        const position = this.rgbToPosition(this._rgb);
        const selectedColor = `#${rgbToHex(this._rgb)}`;
        this.updateRainbow(hue);
        this.setCanvasColor(hue);
        this.setCanvasCursor(position.x, position.y);
        this.updateSelectedColor(selectedColor);
      }
    }
    focus() {
      this.anchorElement.focus();
    }
    get i18n() {
      return i18n;
    }
    get thumbnailStyle() {
      return `background: ${this._hex || 'hsl(220, 46%, 55%)'};`;
    }
    get gradientStyle() {
      return 'position: relative;';
    }
    get canvasRect() {
      return CANVAS;
    }
    get anchorElement() {
      return this.template.querySelector('*[data-id="color-anchor"]');
    }
    get thumbnailElement() {
      return this.template.querySelector('*[data-id="color-preview"]');
    }
    get gradientElement() {
      return this.template.querySelector('*[data-id="color-gradient"]');
    }
    handlePreventDefault(event) {
      event.preventDefault();
    }
    selectColor(event) {
      this.dispatchEvent(
      // eslint-disable-next-line lightning-global/no-custom-event-bubbling
      new CustomEvent('updatecolor', {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail: {
          color: event.target.innerText
        }
      }));
    }
    handleMouseDown(event) {
      event.preventDefault();
      this.onMouseDrag(event, true);
    }
    handleDrag(event) {
      this.onMouseDrag(event, false);
    }
    onChange() {
      this.rainbowCursor();
    }
    parseAndLimit(value) {
      let out = value;
      if (!value || parseInt(value, 10) < 0 || isNaN(value)) {
        out = 0;
      } else if (parseInt(value, 10) > 255) {
        out = 255;
      }
      return out;
    }
    handleRgbChange(event) {
      const target = event.currentTarget;
      const value = this.parseAndLimit(target.value);
      // Fix for no rerender on second bad value attempt
      target.value = value;
      const color = target.getAttribute('data-color-name');
      if (color === 'red') {
        this._rgb.red = value;
      } else if (color === 'green') {
        this._rgb.green = value;
      } else if (color === 'blue') {
        this._rgb.blue = value;
      }
      const rgb = this._rgb;
      const hue = rgbToHsl(rgb).hue;
      const position = this.rgbToPosition(rgb);
      const selectedColor = `#${rgbToHex(rgb)}`;
      this.updateRainbow(hue);
      this.setCanvasColor(hue);
      this.setCanvasCursor(position.x, position.y);
      this.updateSelectedColor(selectedColor);
    }
    handleHexChange(event) {
      const isInputValid = event.srcElement.validity.valid;
      if (isInputValid) {
        const selectedColor = fullHexValue(event.target.value);
        this.classList.remove('slds-has-error');
        this._errorMessage = null;
        const rgb = hexToRgb(selectedColor);
        this._rgb = rgb;
        const hue = rgbToHsl(rgb).hue;
        const position = this.rgbToPosition(rgb);
        this.updateRainbow(hue);
        this.setCanvasColor(hue);
        this.setCanvasCursor(position.x, position.y);
        this.updateSelectedColor(selectedColor);
      } else {
        event.srcElement.classList.add('slds-has-error');
        this._errorMessage = inputUtils.getErrorMessage(event.srcElement.validity, {
          patternMismatch: this.i18n.errorMessage
        });
      }
    }
    updateSelectedColor(selectedColor) {
      this.template.querySelector(`[data-primary-input]`).classList.remove('slds-has-error');
      this._errorMessage = null;
      this._hex = selectedColor;
      this.dispatchEvent(
      // eslint-disable-next-line lightning-global/no-custom-event-bubbling
      new CustomEvent('updateselectedcolor', {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail: {
          color: selectedColor
        }
      }));
    }
    onMouseDrag(event, isGradientCursor) {
      const that = this;
      let drag = false;
      if (isGradientCursor) {
        this.getColorFromGradient(event);
      } else {
        this.rainbowCursor();
      }
      if (this._mousedown && this._mousemove && this._mouseup) {
        return;
      }
      that._mousedown = function () {
        drag = true;
        this._cursorActive = true;
      };
      that._mouseup = function () {
        drag = false;
        this._cursorActive = false;
        window.removeEventListener('mousedown', that._mousedown);
        window.removeEventListener('mouseup', that._mouseup);
        window.removeEventListener('mousemove', that._mousemove);
        that._mousedown = null;
        that._mouseup = null;
        that._mousemove = null;
      };
      that._mousemove = function (evt) {
        if (drag && isGradientCursor) {
          that.getColorFromGradient(evt);
        } else if (drag) {
          that.rainbowCursor();
        }
      };
      window.addEventListener('mousedown', that._mousedown);
      window.addEventListener('mouseup', that._mouseup);
      window.addEventListener('mousemove', that._mousemove);
    }
    gradient() {
      const hue = rgbToHsl(this._rgb).hue;
      this.canvasContext();
      this.setCanvasColor(hue);
      this.updateRainbow(hue);
    }
    getColorFromGradient(event) {
      let cursorPosition;
      if (event.type === 'keydown' && event.key !== 'Tab') {
        cursorPosition = this.gradientCursorPositionFromKeydown(event);
      } else if (event.type === 'mousedown' || event.type === 'mousemove') {
        cursorPosition = this.gradientCursorPosition(event);
      } else {
        return;
      }
      const x = cursorPosition.x;
      const y = cursorPosition.y;

      // Get the current HUE value and update the canvas & cursor
      this.setCanvasColor(this._hueValue);

      // set color from gradient
      this.setRGBValues(x, y);
    }
    rainbowCursor() {
      const rainbow = this.template.querySelector('*[data-id="hue-slider"]');
      const position = this._cachePosition || this.rgbToPosition(this._rgb);
      this.setCanvasColor(rainbow.value);
      this.setRGBValues(position.x, position.y);
      this.updateRainbow(rainbow.value);
    }
    updateRainbow(hue) {
      this._hueValue = hue;
    }
    handleUpdateAnchor() {
      const position = this._cachePosition || this.rgbToPosition(this._rgb);
      const anchor = this.anchorElement;
      const offset = anchor.offsetWidth / 2;
      const x = position.x - offset + 5;
      const y = position.y - offset - 5;
      const xPercent = x / this._canvas.width * 100;
      const yPercent = y / this._canvas.height * 100;
      anchor.style.left = `${xPercent}%`;
      anchor.style.top = `${yPercent}%`;
    }
    gradientCursorPosition(event) {
      const canvas = this._canvas;
      const gradientCanvas = canvas.getBoundingClientRect();
      let x = event.clientX - gradientCanvas.left;
      let y = event.clientY - gradientCanvas.top;
      if (x > gradientCanvas.width) {
        x = gradientCanvas.width - 1;
      }
      if (x < 0) {
        x = 0;
      }
      if (y > gradientCanvas.height) {
        y = gradientCanvas.height;
      }
      if (y < 0) {
        y = 0;
      }

      /*
       * Caching the position x & y in the component so that we can use it when moving the rainbow slider
       * instead of calculating the position of x & y each time.
       */
      this._cachePosition = {
        x,
        y
      };
      return {
        x,
        y
      };
    }
    gradientCursorPositionFromKeydown(event) {
      event.preventDefault();
      const canvas = this._canvas;
      const gradientCanvas = canvas.getBoundingClientRect();
      const keyCode = event.keyCode;
      let x, y;
      if (!this._cachePosition) {
        this._cachePosition = this.rgbToPosition(this._rgb);
      }
      const positionMap = {};
      positionMap[utilsPrivate.keyCodes.left] = {
        x: -1,
        y: 0
      };
      positionMap[utilsPrivate.keyCodes.up] = {
        x: 0,
        y: -1
      };
      positionMap[utilsPrivate.keyCodes.right] = {
        x: +1,
        y: 0
      };
      positionMap[utilsPrivate.keyCodes.down] = {
        x: 0,
        y: +1
      };
      const transform = positionMap[keyCode] ? positionMap[keyCode] : {
        x: 0,
        y: 0
      };
      x = this._cachePosition.x + transform.x;
      y = this._cachePosition.y + transform.y;
      if (x > gradientCanvas.width) {
        x = gradientCanvas.width - 1;
      }
      if (x < 0) {
        x = 0;
      }
      if (y > gradientCanvas.height) {
        y = gradientCanvas.height;
      }
      if (y < 0) {
        y = 0;
      }

      /*
       * Caching the position x & y in the component so that we can use it when moving the rainbow slider
       * instead of calculating the position of x & y each time.
       */
      this._cachePosition = {
        x,
        y
      };
      return {
        x,
        y
      };
    }
    setRGBValues(x, y) {
      const ctx = this._canvasCtx;
      const imageData = ctx.getImageData(x, y, 1, 1).data;
      const rgb = {
        red: imageData[0],
        green: imageData[1],
        blue: imageData[2]
      };
      const color = `#${rgbToHex(rgb)}`;
      this._rgb = rgb;
      this.updateSelectedColor(color);
      this.handleUpdateAnchor();
    }
    setCanvasColor(hue) {
      const ctx = this._canvasCtx;
      // don't map the gradient onto extreme left and right to make extremes have their max values
      const white = ctx.createLinearGradient(1, 0, this.canvasRect.x - 1, 0);
      white.addColorStop(0, 'rgb(255,255,255)');
      white.addColorStop(1, 'hsl(' + hue + ', 100%, 50%)');
      ctx.fillStyle = white;
      ctx.fillRect(0, 0, this.canvasRect.x, this.canvasRect.y);

      // starting y is the first line to avoid blending the black into the hue, thus
      // making extreme values unselectable
      const black = ctx.createLinearGradient(0, 1, 0, this.canvasRect.y);
      black.addColorStop(0, 'rgba(0,0,0,0)');
      black.addColorStop(1, 'rgb(0,0,0)');
      ctx.fillStyle = black;
      ctx.fillRect(0, 0, this.canvasRect.x, this.canvasRect.y);
    }
    setCanvasCursor(x, y) {
      const position = {
        x,
        y
      };
      const anchor = this.anchorElement;
      const offset = anchor.offsetWidth / 2;
      x = position.x - offset + 5;
      y = position.y - offset - 5;
      const xPercent = x / this._canvas.width * 100;
      const yPercent = y / this._canvas.height * 100;
      anchor.style.left = `${xPercent}%`;
      anchor.style.top = `${yPercent}%`;
    }
    canvasContext() {
      this._canvas = this.template.querySelector('canvas');
      this._canvasCtx = this._canvas.getContext('2d');
      this._cursorActive = false;
    }
    handleKeydown(event) {
      this.getColorFromGradient(event);
    }
    rgbToPosition(rgb) {
      return rgbToPosition(rgb, this.canvasRect);
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(LightningColorPickerCustom, {
    publicProps: {
      currentColor: {
        config: 3
      }
    },
    publicMethods: ["focus"],
    track: {
      _hueValue: 1,
      _rgb: 1,
      _hex: 1,
      _errorMessage: 1,
      _currentColor: 1
    },
    fields: ["_initialized"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningColorPickerCustom, {
    tmpl: _tmpl,
    sel: "lightning-color-picker-custom",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/colorPickerPanel', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/colorPickerCustom', 'lightning/button', '@salesforce/label/LightningColorPicker.cancelButton', '@salesforce/label/LightningColorPickerPanel.customTab', '@salesforce/label/LightningColorPickerPanel.defaultTab', '@salesforce/label/LightningColorPicker.doneButton', 'lightning/shadowBaseClassPrivate', 'lightning/utils', 'lightning/utilsPrivate'], (function (exports, lwc, stylesheet0$1, _lightningColorPickerCustom, _lightningButton, labelCancelButton, labelCustomTab, labelDefaultTab, labelDoneButton, LightningShadowBaseClass, utils, utilsPrivate) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
    var _lightningColorPickerCustom__default = /*#__PURE__*/_interopDefaultCompat(_lightningColorPickerCustom);
    var _lightningButton__default = /*#__PURE__*/_interopDefaultCompat(_lightningButton);
    var labelCancelButton__default = /*#__PURE__*/_interopDefaultCompat(labelCancelButton);
    var labelCustomTab__default = /*#__PURE__*/_interopDefaultCompat(labelCustomTab);
    var labelDefaultTab__default = /*#__PURE__*/_interopDefaultCompat(labelDefaultTab);
    var labelDoneButton__default = /*#__PURE__*/_interopDefaultCompat(labelDoneButton);
    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

    function stylesheet$2(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return ((useActualHostSelector ? ":host:not([data-render-mode]) .fix-slds-color-picker__selector-footer" : hostSelector + ":not([data-render-mode]) .fix-slds-color-picker__selector-footer")) + shadowSelector + " > lightning-button" + shadowSelector + " {flex: 1;}";
      /*LWC compiler v7.1.5*/
    }
    var stylesheet0 = [stylesheet$2];

    function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")) + shadowSelector + " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-m-left_x-small" : hostSelector + "[data-render-mode=\"shadow\"] .slds-m-left_x-small")) + shadowSelector + " {margin-inline-start: var(--slds-g-spacing-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__selector" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__selector")) + shadowSelector + " {margin-block-start: var(--slds-g-spacing-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__selector.slds-popover" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__selector.slds-popover")) + shadowSelector + " {width: 14rem;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__selector-footer" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__selector-footer")) + shadowSelector + " {display: flex;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-color-picker__selector-footer" : hostSelector + "[data-render-mode=\"shadow\"] .slds-color-picker__selector-footer")) + shadowSelector + " lightning-button" + shadowSelector + " {width: 100%;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-is-absolute" : hostSelector + "[data-render-mode=\"shadow\"] .slds-is-absolute")) + shadowSelector + " {position: absolute;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-show" : hostSelector + "[data-render-mode=\"shadow\"] .slds-show")) + shadowSelector + " {display: block;}";
      /*LWC compiler v7.1.5*/
    }
    var stylesheet1$1 = [stylesheet$1];

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover")) + shadowSelector + " {position: relative;border-radius: var(--slds-g-radius-border-2);width: var(--slds-g-sizing-15);min-height: calc(var(--slds-g-sizing-5) * 2);z-index: var(--slds-c-popover-position-zindex, 6000);background-color: var(--slds-c-popover-color-background,\n var(--slds-g-color-surface-container-1));display: inline-block;box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 16%);border: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover__meta" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover__meta")) + shadowSelector + " {margin-block-end: var(--slds-g-sizing-4);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover__body" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover__body")) + shadowSelector + " {padding-block: var(--slds-g-spacing-2);padding-inline: var(--slds-g-spacing-3);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover__body" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover__body")) + shadowSelector + " .slds-popover__header" + shadowSelector + " {padding-block: 0 var(--slds-g-sizing-3);padding-inline: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover__body" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-popover__header" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-popover__footer" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover__body" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-popover__header" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-popover__footer")) + shadowSelector + " {position: relative;padding-block: var(--slds-g-spacing-2);padding-inline: var(--slds-g-spacing-3);word-wrap: break-word;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover__header" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover__header")) + shadowSelector + " {border-bottom: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover__footer" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover__footer")) + shadowSelector + " {border-block-start: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);background-color: var(--slds--g-color-surface-container-2);border-end-start-radius: inherit;border-end-end-radius: inherit;padding-block: var(--slds-g-spacing-2);padding-inline: var(--slds-g-spacing-3);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover__footer_form" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover__footer_form")) + shadowSelector + " {text-align: center;background: var(--slds-g-color-surface-container-2);border-radius: 0 0 var(--slds-g-radius-border-2) var(--slds-g-radius-border-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover__body_small" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover__body_small")) + shadowSelector + " {max-height: var(--slds-g-sizing-14);overflow-y: auto;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover__close" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover__close")) + shadowSelector + " {position: relative;margin-block: var(--slds-g-spacing-1);margin-inline: var(--slds-g-spacing-1);z-index: calc(var(--slds-c-popover-position-zindex, 6000) + 1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover_small" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover_small")) + shadowSelector + " {max-width: var(--slds-g-sizing-14);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover_medium" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover_medium")) + shadowSelector + " {min-width: var(--slds-g-sizing-15);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover_large" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover_large")) + shadowSelector + " {min-width: 25rem;max-width: 512px;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover[class*=\"theme_\"]" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover[class*=\"theme_\"]")) + shadowSelector + " {border: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover")) + shadowSelector + " *:last-child" + shadowSelector + " {margin-bottom: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover_full-width" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover_full-width")) + shadowSelector + " {width: 100%;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover_hide" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover_hide")) + shadowSelector + " {display: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover_dark" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover_dark")) + shadowSelector + " {background-color: var(--slds-g-color-accent-container-3);color: var(--slds-g-color-on-accent-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover_dark" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover_dark")) + shadowSelector + " .slds-badge" + shadowSelector + " {background-color: var(--slds-g-color-surface-container-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover_dark" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover_dark")) + shadowSelector + " .slds-popover__close" + shadowSelector + " {color: var(--slds-g-color-on-accent-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover_dark" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover_dark")) + shadowSelector + " .slds-icon-text-default" + shadowSelector + " {fill: var(--slds-g-color-on-accent-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-popover_dark" : hostSelector + "[data-render-mode=\"shadow\"] .slds-popover_dark")) + shadowSelector + " .slds-popover__footer" + shadowSelector + " {border-top-color: var(--slds-g-color-border-accent-2);background-color: var(--slds-g-color-on-accent-2);}";
      /*LWC compiler v7.1.5*/
    }
    var stylesheet2 = [stylesheet];

    var stylesheet1 = [stylesheet0__default.default, stylesheet1$1, stylesheet2];

    var _implicitStylesheets = [stylesheet0, stylesheet1];

    const stc0 = {
      "slds-popover": true,
      "slds-color-picker__selector": true,
      "slds-show": true,
      "slds-is-absolute": true
    };
    const stc1 = {
      "slds-popover__body": true
    };
    const stc2 = {
      classMap: {
        "slds-popover__footer": true
      },
      key: 3
    };
    const stc3 = {
      classMap: {
        "slds-color-picker__selector-footer": true,
        "fix-slds-color-picker__selector-footer": true
      },
      key: 4
    };
    const stc4 = {
      "slds-m-left_x-small": true
    };
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {gid: api_scoped_id, b: api_bind, c: api_custom_element, h: api_element} = $api;
      const {_m0, _m1, _m2, _m3} = $ctx;
      return [api_element("section", {
        classMap: stc0,
        attrs: {
          "role": "dialog",
          "aria-label": "Choose a color",
          "aria-describedby": api_scoped_id("dialog-body-id")
        },
        key: 0,
        on: {
          "updateselectedcolor": _m0 || ($ctx._m0 = api_bind($cmp.handleUpdateSelectedColor)),
          "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handleKeydown))
        }
      }, [api_element("div", {
        classMap: stc1,
        attrs: {
          "tabindex": "0",
          "id": api_scoped_id("dialog-body-id")
        },
        key: 1
      }, [api_custom_element("lightning-color-picker-custom", _lightningColorPickerCustom__default.default, {
        props: {
          "currentColor": $cmp.currentColor
        },
        key: 2
      })]), api_element("footer", stc2, [api_element("div", stc3, [api_custom_element("lightning-button", _lightningButton__default.default, {
        props: {
          "label": $cmp.i18n.cancelButton,
          "name": "cancel",
          "stretch": true
        },
        key: 5,
        on: {
          "click": _m2 || ($ctx._m2 = api_bind($cmp.handleCancelClick))
        }
      }), api_custom_element("lightning-button", _lightningButton__default.default, {
        classMap: stc4,
        props: {
          "variant": "brand",
          "label": $cmp.i18n.doneButton,
          "name": "done",
          "stretch": true
        },
        key: 6,
        on: {
          "click": _m3 || ($ctx._m3 = api_bind($cmp.handleDoneClick))
        }
      })])])])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-40plt1npuv1";
    tmpl.legacyStylesheetToken = "lightning-colorPickerPanel_colorPickerPanel";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    const i18n = {
      cancelButton: labelCancelButton__default.default,
      customTab: labelCustomTab__default.default,
      defaultTab: labelDefaultTab__default.default,
      doneButton: labelDoneButton__default.default
    };
    const DEFAULT_COLOR = '#000000';
    class LightningColorPickerPanel extends LightningShadowBaseClass__default.default {
      constructor(...args) {
        super(...args);
        this.currentColor = void 0;
        this._isCustomTabActive = false;
        this._selectedColor = null;
      }
      connectedCallback() {
        super.connectedCallback();
        this._selectedColor = this.currentColor || DEFAULT_COLOR;
      }
      get i18n() {
        return i18n;
      }
      get computedClassDefault() {
        return utils.classSet({
          'slds-tabs_default__item': true,
          'slds-is-active': !this._isCustomTabActive
        }).toString();
      }
      get computedClassCustom() {
        return utils.classSet({
          'slds-tabs_default__item': true,
          'slds-is-active': this._isCustomTabActive
        }).toString();
      }
      get ariaSelectedDefault() {
        return !this._isCustomTabActive.toString();
      }
      get ariaSelectedCustom() {
        return this._isCustomTabActive.toString();
      }
      handleTabChange(event) {
        event.preventDefault();
        const tabElement = event.currentTarget;
        if (tabElement.classList.contains('slds-is-active')) {
          return;
        }
        this._isCustomTabActive = tabElement.title !== i18n.defaultTab;
      }
      handleUpdateSelectedColor(event) {
        this._selectedColor = event.detail.color;
      }
      dispatchUpdateColorEventWithColor(color) {
        this.dispatchEvent(
        // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatecolor', {
          composed: true,
          bubbles: true,
          detail: {
            color
          }
        }));
      }
      handleDoneClick() {
        this.dispatchUpdateColorEventWithColor(this._selectedColor);
      }
      handleCancelClick() {
        this.dispatchUpdateColorEventWithColor(this.currentColor);
      }
      handleKeydown(event) {
        if (event.keyCode === utilsPrivate.keyCodes.escape) {
          event.preventDefault();
          this.dispatchUpdateColorEventWithColor(this.currentColor);
        } else if (event.shiftKey && event.keyCode === utilsPrivate.keyCodes.tab && event.srcElement.dataset.id === 'color-anchor') {
          event.preventDefault();
          this.template.querySelector('button[name="done"]').focus();
        } else if (!event.shiftKey && event.keyCode === utilsPrivate.keyCodes.tab && event.srcElement.name === 'done') {
          event.preventDefault();
          this.template.querySelector('lightning-color-picker-custom').focus();
        }
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(LightningColorPickerPanel, {
      publicProps: {
        currentColor: {
          config: 0
        }
      },
      track: {
        _isCustomTabActive: 1,
        _selectedColor: 1
      }
    });
    const __lwc_component_class_internal = lwc.registerComponent(LightningColorPickerPanel, {
      tmpl: _tmpl,
      sel: "lightning-color-picker-panel",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/primitiveColorpickerButton', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/primitiveIcon', 'lightning/colorPickerPanel', '@salesforce/label/LightningColorPicker.a11yTriggerText', '@salesforce/label/LightningColorPicker.a11yDefaultText', 'lightning/shadowBaseClassPrivate', 'lightning/positionLibrary', 'lightning/utilsPrivate'], (function (exports, lwc, stylesheet0$1, _lightningPrimitiveIcon, _lightningColorPickerPanel, labelA11yTriggerText, labelA11yDefaultText, LightningShadowBaseClass, positionLibrary, utilsPrivate) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningPrimitiveIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveIcon);
  var _lightningColorPickerPanel__default = /*#__PURE__*/_interopDefaultCompat(_lightningColorPickerPanel);
  var labelA11yTriggerText__default = /*#__PURE__*/_interopDefaultCompat(labelA11yTriggerText);
  var labelA11yDefaultText__default = /*#__PURE__*/_interopDefaultCompat(labelA11yDefaultText);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='color-picker-button']" : hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker-button']")) + shadowSelector + " {--slds-c-icon-color-foreground: var(--slds-g-color-on-surface-1);--slds-c-icon-sizing: 0.875rem;vertical-align: top;padding-inline: var(--slds-g-spacing-2);padding-block: 0.3rem;background: var(--slds-g-color-surface-container-1);line-height: 1;margin-inline-end: var(--slds-g-spacing-1);border-color: var(--slds-g-color-border-2);justify-content: center;flex-shrink: 0;position: relative;display: inline-flex;align-items: center;border-style: solid;border-width: var(--slds-g-sizing-border-1);border-radius: var(--slds-g-radius-border-2);cursor: pointer;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='color-picker-button']:hover" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='color-picker-button']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker-button']:hover" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker-button']:focus")) + shadowSelector + " {--slds-c-icon-color-foreground: var(--slds-s-button-color-hover, var(--slds-g-color-accent-3))\n }" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='color-picker-button']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker-button']:focus")) + shadowSelector + " {box-shadow: 0 0 3px var(--slds-s-button-shadow-focus);outline: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='color-picker-button']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker-button']:active")) + shadowSelector + " {border-color: var(--slds-g-color-accent-3);--slds-c-icon-color-foreground: var(--slds-g-color-accent-4);outline: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='color-picker-button']" : hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker-button']")) + shadowSelector + " .slds-swatch" + shadowSelector + " {display: inline-block;vertical-align: middle;height: 1.25rem;width: 1.25rem;border-radius: var(--slds-g-radius-border-1);box-shadow: inset 0 0 1px rgb(0 0 0 / 40%);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='color-picker-button']" : hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker-button']")) + shadowSelector + " .slds-assistive-text" + shadowSelector + " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='color-picker-button']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='color-picker-button']")) + shadowSelector + " {--slds-c-icon-color-foreground: var(--slds-g-color-disabled-1);pointer-events: none;border-color: transparent;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='color-picker-button']" : hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker-button']")) + shadowSelector + " + .panel" + shadowSelector + " {display: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='color-picker-button']" : hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker-button']")) + shadowSelector + " + .panel-open" + shadowSelector + " {display: block;width: 250px;height: 270px;background-color: grey;}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<span class="slds-swatch${0}" data-id="thumbnail"${"s0"}${2}><span class="slds-assistive-text${0}"${2}>${"t2"}</span></span>`;
  const $fragment2 = lwc.parseFragment`<span class="slds-assistive-text a11y-color-value${0}"${2}>${"t1"}</span>`;
  const stc0 = {
    "slds-button": true,
    "slds-color-picker__summary-button": true,
    "slds-button_icon": true,
    "slds-button_icon-more": true
  };
  const stc1 = {
    props: {
      "iconName": "utility:down",
      "svgClass": "slds-button__icon slds-button__icon_small",
      "variant": "bare"
    },
    key: 3
  };
  const stc2 = {
    "color-picker-panel": true
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {b: api_bind, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment, c: api_custom_element, h: api_element} = $api;
    const {_m0, _m1} = $ctx;
    return [api_element("button", {
      classMap: stc0,
      attrs: {
        "type": "button",
        "part": "color-picker-button",
        "disabled": $cmp.disabled ? "" : null,
        "aria-disabled": $cmp.ariaDisabled
      },
      key: 0,
      on: {
        "click": _m0 || ($ctx._m0 = api_bind($cmp.handleColorPickerToggleClick))
      }
    }, [api_static_fragment($fragment1, 2, [api_static_part(0, {
      style: $cmp.colorInputStyle
    }, null), api_static_part(2, null, api_dynamic_text($cmp.i18n.a11yTriggerText))]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon__default.default, stc1), api_static_fragment($fragment2, 5, [api_static_part(1, null, api_dynamic_text($cmp.assistiveValue))])]), $cmp._isColorPickerPanelOpen ? api_custom_element("lightning-color-picker-panel", _lightningColorPickerPanel__default.default, {
      classMap: stc2,
      props: {
        "currentColor": $cmp.value
      },
      key: 6,
      on: {
        "updatecolor": _m1 || ($ctx._m1 = api_bind($cmp.handleUpdateColorEvent))
      }
    }) : null];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-1ob50kcdi1r";
  tmpl.legacyStylesheetToken = "lightning-primitiveColorpickerButton_primitiveColorpickerButton";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  const i18n = {
    a11yTriggerText: labelA11yTriggerText__default.default,
    a11yDefaultText: labelA11yDefaultText__default.default
  };
  class PrimitiveColorpickerButton extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      this._isColorPickerPanelOpen = false;
      this._value = '';
      this._disabled = false;
      this.ariaDisabled = void 0;
    }
    get value() {
      return this._value;
    }
    set value(value) {
      this._value = value;
    }
    get assistiveValue() {
      return this.value ? this.value : this.i18n.a11yDefaultText;
    }

    /**
     * If present, the input field is disabled and users cannot interact with it.
     * @type {boolean}
     * @default false
     */
    get disabled() {
      return this._disabled;
    }
    set disabled(value) {
      this._disabled = utilsPrivate.normalizeBoolean(value);
      utilsPrivate.reflectAttribute(this, 'disabled', this.disabled);
    }
    focus() {
      const button = this.template.querySelector('button');
      return button && button.focus();
    }
    blur() {
      const button = this.template.querySelector('button');
      return button && button.blur();
    }
    get colorInputStyle() {
      return `background: ${this.value || '#5679C0'};`;
    }
    handleColorPickerToggleClick(event) {
      event.preventDefault();
      this._isColorPickerPanelOpen = !this._isColorPickerPanelOpen;
      if (this._isColorPickerPanelOpen) {
        this.startColorPickerPositioning();
      } else {
        this.stopColorPickerPositioning();
      }
    }
    startColorPickerPositioning() {
      if (!this._autoPosition) {
        this._autoPosition = new positionLibrary.AutoPosition(this);
      }
      this._autoPosition.start({
        target: () => this.template.querySelector('button.slds-color-picker__summary-button'),
        element: () => this.template.querySelector('lightning-color-picker-panel').shadowRoot.querySelector('section'),
        align: {
          horizontal: positionLibrary.Direction.Left,
          vertical: positionLibrary.Direction.Top
        },
        targetAlign: {
          horizontal: positionLibrary.Direction.Left,
          vertical: positionLibrary.Direction.Bottom
        },
        autoFlip: true
      });
    }
    stopColorPickerPositioning() {
      if (this._autoPosition) {
        this._autoPosition.stop();
      }
    }
    handleUpdateColorEvent(event) {
      event.stopPropagation();
      const detail = event.detail;
      this._isColorPickerPanelOpen = false;
      this.stopColorPickerPositioning();
      this.dispatchEvent(new CustomEvent('change', {
        detail
      }));
    }
    get i18n() {
      return i18n;
    }
    /*LWC compiler v7.1.5*/
  }
  PrimitiveColorpickerButton.delegatesFocus = true;
  lwc.registerDecorators(PrimitiveColorpickerButton, {
    publicProps: {
      ariaDisabled: {
        config: 0
      },
      value: {
        config: 3
      },
      assistiveValue: {
        config: 1
      },
      disabled: {
        config: 3
      }
    },
    publicMethods: ["focus", "blur"],
    track: {
      _isColorPickerPanelOpen: 1,
      _value: 1,
      _disabled: 1
    }
  });
  const __lwc_component_class_internal = lwc.registerComponent(PrimitiveColorpickerButton, {
    tmpl: _tmpl,
    sel: "lightning-primitive-colorpicker-button",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/primitiveInputColor', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/helptext', 'lightning/primitiveColorpickerButton', 'lightning/shadowBaseClassPrivate', 'lightning/utils', 'lightning/inputUtils', 'lightning/utilsPrivate'], (function (exports, lwc, stylesheet0$1, _lightningHelptext, _lightningPrimitiveColorpickerButton, LightningShadowBaseClass, utils, inputUtils, utilsPrivate) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningHelptext__default = /*#__PURE__*/_interopDefaultCompat(_lightningHelptext);
  var _lightningPrimitiveColorpickerButton__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveColorpickerButton);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

  function stylesheet$2(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) fieldset" : hostSelector + "[data-render-mode=\"shadow\"] fieldset")), shadowSelector, " {border: 0;margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {position: relative;min-width: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;hyphens: auto;display: inline-block;color: var(--slds-g-color-on-surface-2);font-size: var(--slds-s-label-font-size, var(--slds-g-font-scale-neg-2));padding-inline-end: var(--slds-g-spacing-2);padding-block-start: var(--slds-g-spacing-1);margin-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label:empty")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {clear: inline-start;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-radio", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {display: inline-block;position: relative;padding-block-start: var(--slds-g-spacing-1);vertical-align: top;line-height: var(--slds-g-font-lineheight-1);z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-form-element__helper" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__helper")), shadowSelector, " {font-size: var(--slds-s-helptext-font-size, var(--slds-g-font-scale-neg-2));margin-block-start: calc(var(--slds-g-spacing-1) / 2);display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_edit")), shadowSelector, " .slds-form-element__static", shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " {flex-basis: 0%;border-bottom: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__label", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__legend" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__legend")), shadowSelector, " {font-weight: var(--slds-g-font-weight-7);float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__addon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__addon")), shadowSelector, " {display: inline-block;margin-block-start: 0;margin-block-end: 0;margin-inline-start: var(--slds-g-spacing-2);margin-inline-end: var(--slds-g-spacing-2);align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;word-break: break-word;display: inline-block;font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-neutral-base-10);width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static.slds-text-longform" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static.slds-text-longform")), shadowSelector, " *:last-child", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static:empty")), shadowSelector, " {min-height: calc(var(--slds-g-sizing-6) + 1px);vertical-align: bottom;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static--edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static--edit")), shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-required" : hostSelector + "[data-render-mode=\"shadow\"] .slds-required")), shadowSelector, " {color: var(--slds-g-color-error-1);margin-block-start: 0;margin-block-end: 0;margin-inline-start: calc(var(--slds-g-spacing-1) / 2);margin-inline-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-form-element__help", shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-form-element__help" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) {" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {padding: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__label" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__label" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {width: 100%;flex-basis: 100%;clear: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__icon" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {float: none;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline'].slds-form-element_horizontal) {" : hostSelector + ".slds-form-element_horizontal[variant='label-inline'][data-render-mode=\"shadow\"] {")), "padding: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']).slds-is-edited {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"].slds-is-edited {")), "padding-block-start: var(--slds-g-sizing-6)}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__label" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {float: inline-start;max-width: calc(33% - var(--slds-g-sizing-6));flex-basis: calc(33% - var(--slds-g-sizing-6));flex-grow: 1;margin-block-end: 0;position: relative;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) lightning-helptext" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] lightning-helptext")), shadowSelector, " {float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {margin-inline-start: 33%;clear: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list__column" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list__column")), shadowSelector, " .slds-form-element__label", shadowSelector, " {width: auto;max-width: 100%;flex-basis: auto;float: none;position: relative;padding-inline-start: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__help" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list")), shadowSelector, " {clear: none;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " {display: flex;margin-bottom: var(--slds-g-spacing-1);margin-left: calc(var(--slds-g-spacing-1) * -1);margin-right: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " .slds-form-element__label", shadowSelector, " {padding-top: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element", shadowSelector, " {padding-left: var(--slds-g-spacing-1);padding-right: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_address" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_address")), shadowSelector, " .slds-form-element__row", shadowSelector, " {align-items: flex-end;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-hidden']) .slds-form-element__label" : hostSelector + "[variant='label-hidden'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {display: none}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet$2];

  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {display: flex;align-items: center;gap: var(--sds-c-inputtext-spacing-gap, var(--sds-s-input-spacing-gap));min-height: var(--sds-c-inputtext-sizing-height, var(--sds-s-input-sizing-height));padding-inline-start: var(\n --sds-c-inputtext-spacing-inlinestart,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-spacing-inlineend,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-spacing-blockstart,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-spacing-blockend,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );background: var(--sds-c-inputtext-color-background, var(--sds-s-input-color-background));border-block-start: var(\n --sds-c-inputtext-sizing-border-blockstart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockstart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-start: var(\n --sds-c-inputtext-sizing-border-inlinestart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlinestart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-end: var(\n --sds-c-inputtext-sizing-border-inlineend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlineend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-block-end: var(\n --sds-c-inputtext-sizing-border-blockend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-radius: var(--sds-c-inputtext-radius-border, var(--sds-s-input-radius-border));box-shadow: var(--sds-c-inputtext-shadow, var(--sds-s-input-shadow));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, " {width: 100%;height: 100%;padding: 0;font-size: var(--sds-c-inputtext-font-size, var(--sds-s-input-font-size));color: var(--sds-c-inputtext-text-color, var(--sds-s-input-text-color));line-height: 1;border: none;background: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][active]) [part~='input-container']" : hostSelector + "[active][data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-active,\n var(--sds-s-input-color-background-active)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-active,\n var(--sds-s-input-color-border-active)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-active, var(--sds-s-input-shadow-active));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, "::placeholder {color: var(--sds-c-inputtext-text-color-placeholder, var(--sds-s-input-text-color-placeholder));font-style: var(--sds-c-inputtext-font-style-placeholder, var(--sds-s-input-font-style-placeholder));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']:focus-within" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-focus,\n var(--sds-s-input-color-border-focus, revert)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-focus, var(--sds-s-input-shadow-focus));--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-focus,\n var(--sds-s-input-color-background-focus, revert)\n );--sds-c-inputtext-text-color: var(\n --sds-c-inputtext-text-color-focus,\n var(--sds-s-input-text-color-focus, revert)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']:focus")), shadowSelector, " {outline: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {display: inline-flex;align-items: center;gap: var(--sds-c-inputtext-label-spacing-gap, var(--sds-s-label-spacing-gap));padding-inline-start: var(\n --sds-c-inputtext-label-spacing-inlinestart,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-label-spacing-inlineend,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-label-spacing-blockstart,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-label-spacing-blockend,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );color: var(--sds-c-inputtext-label-color, var(--sds-s-label-color));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {font-size: var(--sds-c-inputtext-label-font-size, var(--sds-s-label-font-size));font-weight: var(--sds-c-inputtext-label-font-weight, var(--sds-s-label-font-weight));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='help-text visible']" : hostSelector + "[data-render-mode=\"shadow\"] [part='help-text visible']")), shadowSelector, " {font-size: var(--sds-c-inputtext-helptext-font-size, var(--sds-s-helptext-font-size));color: var(--sds-c-inputtext-helptext-text-color, var(--sds-s-helptext-text-color));padding-inline-start: var(\n --sds-c-inputtext-helptext-spacing-inlinestart,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-helptext-spacing-inlineend,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-helptext-spacing-blockstart,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-helptext-spacing-blockend,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) {" : hostSelector + "[disabled][data-render-mode=\"shadow\"] {")), "--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-disabled,\n var(--sds-s-input-color-background-disabled)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-disabled,\n var(--sds-s-input-color-border-disabled)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][label-hidden]) [part='label-container']" : hostSelector + "[label-hidden][data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-inputtext-icon-color-foreground,\n var(--slds-g-color-on-surface-1)\n );--slds-c-icon-sizing: var(--slds-c-inputtext-icon-sizing, 14px);--sds-c-inputtext-sizing-height: var(\n --slds-c-inputtext-sizing-height,\n var(--slds-g-sizing-9)\n );--sds-c-inputtext-color-background: var(\n --slds-c-inputtext-color-background,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-color-background-focus: var(\n --slds-c-inputtext-color-background-focus,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-text-color: var(--slds-c-inputtext-text-color);--sds-c-inputtext-font-size: var(\n --slds-c-inputtext-font-size,\n var(--slds-g-font-size-base)\n );--sds-c-inputtext-text-color-placeholder: var(\n --slds-c-inputtext-text-color-placeholder,\n var(--slds-g-color-on-surface-1)\n );--sds-c-inputtext-color-border: var(\n --slds-c-inputtext-color-border,\n var(--slds-g-color-border-2)\n );--sds-c-inputtext-sizing-border: var(--slds-c-inputtext-sizing-border);--sds-c-inputtext-radius-border: var(\n --slds-c-inputtext-radius-border,\n var(--slds-g-radius-border-2)\n );display: flex;flex-wrap: wrap;flex-direction: column;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {flex: 1 0 100%;align-items: stretch;--sds-c-inputtext-spacing-inline: 0;--sds-c-inputtext-spacing-block: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']")), shadowSelector, " {border: none;display: inline-block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " .slds-input__icon:not(button)", shadowSelector, " {pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input'][type='range']")), shadowSelector, " {min-height: calc(1.875rem + (1px * 2));margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:focus-within" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 3px var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;border-width: var(--sds-c-inputtext-sizing-border, var(--slds-g-sizing-border-1));border-color: var(--sds-c-inputtext-color-border, var(--slds-g-color-border-2));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {padding-inline-start: var(\n --slds-c-inputtext-spacing-inlinestart,\n var(--slds-g-spacing-3));padding-inline-end: var(\n --slds-c-inputtext-spacing-inlineend,\n var(--slds-g-spacing-4));height: unset;font-family: var(--slds-g-font-family);}", ((useActualHostSelector ? ":host(:not([disabled])) [part=\"input-container\"]:focus-within" + shadowSelector + ", :host(:not([disabled])) [part=\"input-container\"]:active" : hostSelector + ":not([disabled]) [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + ":not([disabled]) [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part='input-text']" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-spacing-inline-start-readonly: 0;--sds-c-inputtext-color-border-focus: transparent;--slds-c-inputtext-color-border: transparent;--slds-c-inputtext-color-background: transparent;--slds-c-inputtext-color-background-focus: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:active" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-disabled-container-2);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: transparent;outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-text']" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-shadow: 0 0 0 var(--slds-g-sizing-border-1) inset\n var(--slds-g-color-error-1);--slds-c-inputtext-color-border: var(--slds-g-color-border-error-1);--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-input-has-icon" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " {--slds-c-input-color-background: var(--slds-s-input-color-background-invalid);--slds-c-input-color-border: var(--slds-g-color-border-error-1);--slds-c-input-text-color: var(--slds-s-input-color-invalid);background-clip: padding-box;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {fill: var(--slds-g-color-error-1);color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-container']:focus-within" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-shadow:\n var(--slds-g-color-error-base-50) 0 0 0 var(--slds-g-sizing-border-1) inset,\n 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-border-error-1);--sds-c-inputtext-color-border: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-container']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][disabled]) [part='input']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-container']" + shadowSelector + "," + hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {cursor: not-allowed;--sds-c-inputtext-color-background: var(--slds-s-input-color-background-disabled, var(--slds-g-color-disabled-container-1));--sds-c-inputtext-color-border: var(--slds-g-color-border-disabled-1);--sds-c-inputtext-text-color: var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-text']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-text-color-placeholder:\n var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " [part='label']", shadowSelector, " {padding-block-start: var(--slds-g-spacing-1);padding-inline-end: var(--slds-g-spacing-2);color: var(\n --slds-c-inputtext-label-color,\n var(--slds-g-color-on-surface-2)\n );margin-block-end: var(--slds-g-sizing-1);display: inline-flex;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='start']" : hostSelector + "[data-render-mode=\"shadow\"] [part='start']")), shadowSelector, " {--slds-c-icon-spacing-inlineend: var(--slds-g-spacing-2);}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-text']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='label']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {float: left;max-width: calc(33% - 1.125rem);padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-container']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='inline-help']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='inline-help']")), shadowSelector, " {float: left;padding-block-start: var(--slds-g-spacing-1);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) input[type=\"search\"]" : hostSelector + "[data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {left: var(--slds-g-spacing-3);fill: var(--slds-g-color-on-surface-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-accent-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-input__icon", shadowSelector, " {width: 0.875rem;height: 0.875rem;position: absolute;top: 50%;margin-top: -0.4375rem;line-height: 1;border: 0;z-index: 2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_left", shadowSelector, " {inset-inline-start: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right")), shadowSelector, " {--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_right", shadowSelector, " {inset-inline-end: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet2 = [stylesheet$1];

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='color-picker']" : hostSelector + "[data-render-mode=\"shadow\"] [part='color-picker']")) + shadowSelector + " {position: relative;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")) + shadowSelector + " {flex-direction: row;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")) + shadowSelector + " > *:first-child" + shadowSelector + " {margin-inline-end: var(--slds-g-spacing-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")) + shadowSelector + " {flex: 0 0 6rem;margin-inline-end: var(--slds-g-spacing-2);}@media (width >= 48em) {" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-text']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-text']")) + shadowSelector + " {display: flex;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-container']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-container']")) + shadowSelector + " {margin-inline-start: 0%}}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet3 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1, stylesheet2, stylesheet3];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<abbr class="slds-required${0}"${"a0:title"}${2}>*</abbr>`;
  const $fragment2 = lwc.parseFragment`<div class="slds-color-picker__summary-input${0}" part="input-container"${2}><input type="text"${"a1:id"} class="slds-input${0}" part="input"${"a1:name"}${"a1:autocomplete"}${"a1:accesskey"}${"a1:aria-label"}${"a1:aria-invalid"}${"a1:aria-keyshortcuts"}${"a1:aria-disabled"}${"a1:disabled"} minlength="4" maxlength="7"${"a1:placeholder"}${"a1:pattern"}${2}></div>`;
  const $fragment3 = lwc.parseFragment`<div${"a0:id"} class="slds-form-element__help${0}" data-help-message part="help-text" role="status"${2}><span class="slds-assistive-text${0}"${2}>${"t2"}</span>${"t3"}</div>`;
  const stc0 = {
    classMap: {
      "slds-color-picker": true
    },
    attrs: {
      "part": "color-picker"
    },
    key: 0
  };
  const stc1 = {
    classMap: {
      "slds-form-element": true,
      "slds-color-picker__summary": true
    },
    key: 1
  };
  const stc2 = {
    classMap: {
      "slds-form-element__control": true
    },
    attrs: {
      "part": "input-text"
    },
    key: 6
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {ncls: api_normalize_class_name, gid: api_scoped_id, sp: api_static_part, st: api_static_fragment, d: api_dynamic_text, t: api_text, h: api_element, c: api_custom_element, b: api_bind} = $api;
    const {_m0, _m1, _m2, _m3, _m4, _m5, _m6} = $ctx;
    return [api_element("div", stc0, [api_element("div", stc1, [!$cmp.hasExternalLabel ? api_element("label", {
      className: api_normalize_class_name($cmp.computedColorLabelClass),
      attrs: {
        "for": api_scoped_id("color")
      },
      key: 2
    }, [$cmp.required ? api_static_fragment($fragment1, 4, [api_static_part(0, {
      attrs: {
        "title": $cmp.required
      }
    }, null)]) : null, api_text(api_dynamic_text($cmp.label))]) : null, !$cmp.hasExternalLabel ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext__default.default, {
      props: {
        "content": $cmp.fieldLevelHelp,
        "alternativeText": $cmp.helptextAlternativeText
      },
      key: 5
    }) : null : null, api_element("div", stc2, [api_custom_element("lightning-primitive-colorpicker-button", _lightningPrimitiveColorpickerButton__default.default, {
      props: {
        "value": $cmp.value,
        "disabled": $cmp.disabled,
        "ariaDisabled": $cmp.ariaDisabled
      },
      key: 7,
      on: {
        "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
        "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
        "change": _m2 || ($ctx._m2 = api_bind($cmp.handleColorChange))
      }
    }), api_static_fragment($fragment2, 9, [api_static_part(1, {
      on: {
        "blur": _m3 || ($ctx._m3 = api_bind($cmp.handleBlur)),
        "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
        "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange)),
        "input": _m6 || ($ctx._m6 = api_bind($cmp.handleInput))
      },
      attrs: {
        "id": api_scoped_id("color"),
        "name": $cmp.name,
        "autocomplete": $cmp.autocomplete,
        "accesskey": $cmp.accessKey,
        "aria-label": $cmp.ariaLabel,
        "aria-invalid": $cmp.ariaInvalid,
        "aria-keyshortcuts": $cmp.ariaKeyShortcuts,
        "aria-disabled": $cmp.ariaDisabled,
        "disabled": $cmp.disabled ? "" : null,
        "placeholder": $cmp.placeholder,
        "pattern": $cmp.pattern
      }
    }, null)])])])]), $cmp.helpMessage ? api_static_fragment($fragment3, 11, [api_static_part(0, {
      attrs: {
        "id": api_scoped_id("help-message")
      }
    }, null), api_static_part(2, null, api_dynamic_text($cmp.label)), api_static_part(3, null, api_dynamic_text($cmp.helpMessage))]) : null];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-3oouck6ago4";
  tmpl.legacyStylesheetToken = "lightning-primitiveInputColor_primitiveInputColor";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  class LightningPrimitiveInputColor extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      this.hasExternalLabel = void 0;
      this.required = void 0;
      this.accessKey = void 0;
      this.label = void 0;
      this.fieldLevelHelp = void 0;
      this.helptextAlternativeText = void 0;
      this.helpMessage = void 0;
      this.disabled = void 0;
      this.name = void 0;
      this.autocomplete = void 0;
      this.ariaLabel = void 0;
      this.ariaInvalid = void 0;
      this.ariaDisabled = void 0;
      this.ariaKeyShortcuts = void 0;
      this.placeholder = void 0;
      this.pattern = void 0;
      this.variant = void 0;
      this._value = '';
      this.rendered = false;
      this.initialValueSet = false;
    }
    focus() {
      if (this.rendered) {
        this.inputElement.focus();
      }
    }
    get value() {
      return this._value;
    }
    set value(value) {
      this._value = this.normalizeInput(value);
      if (this.rendered && this.inputElement.value !== this._value) {
        this.setInputValue(this._value);
      }
    }
    get inputElement() {
      if (!this.cachedInputElement) {
        let inputElement = this.template.querySelector('input');
        this.cachedInputElement = inputElement;
      }
      return this.cachedInputElement;
    }
    get describedByElements() {
      return this.template.querySelector('[data-help-message]');
    }
    get isNativeShadow() {
      return this._isNativeShadow;
    }

    /********* COMPONENT CALLBACKS *********/

    connectedCallback() {
      super.connectedCallback();
      this._isNativeShadow = utilsPrivate.isNativeComponent(this);
    }
    disconnectedCallback() {
      this.rendered = false;
      this.initialValueSet = false;
      this.cachedInputElement = undefined;
    }
    renderedCallback() {
      this.rendered = true;
      if (!this.initialValueSet) {
        this.inputElement.value = this._value;
        this.initialValueSet = true;
      }
      utilsPrivate.reflectAttribute(this, 'disabled', this.disabled);
      utilsPrivate.reflectAttribute(this, 'invalid', !!this.helpMessage);
      utilsPrivate.reflectAttribute(this, 'variant', this.variant);
    }

    /**
     * This value is used to compute the label's class which depends on the variant of the component
     */
    get computedColorLabelClass() {
      return utils.classSet('slds-form-element__label slds-color-picker__summary-label').add({
        'slds-assistive-text': this.isLabelHidden
      });
    }
    get isLabelHidden() {
      return this.variant === inputUtils.VARIANT.LABEL_HIDDEN;
    }

    /********* ACTION HANDLERS *********/

    handleBlur() {
      this.dispatchEvent(new CustomEvent('blur'));
    }
    handleFocus() {
      this.dispatchEvent(new CustomEvent('focus'));
    }
    handleChange(event) {
      event.stopPropagation();
      this.dispatchCommitEvent();
      this.dispatchChangeEvent();
    }

    /**
     * This event handler is used whenever a new color is selected and sets the inputElement's
     * value to the selectedColor, while focusing on the color picker button.
     * @param {*} event
     */
    handleColorChange(event) {
      const selectedColor = event.detail.color;
      if (selectedColor !== this.inputElement.value) {
        this.setInputValue(selectedColor);
        this._value = selectedColor;
        this.focus();
        this.dispatchChangeEventWithDetail({
          value: selectedColor
        });
        this.dispatchCommitEvent();
      }
      this.template.querySelector('lightning-primitive-colorpicker-button').focus();
    }
    handleInput(event) {
      event.stopPropagation();
      this.dispatchChangeEvent();
    }

    /********* EVENT DISPATCHERS *********/

    dispatchChangeEventWithDetail(detail) {
      this.dispatchEvent(new CustomEvent('change', {
        composed: true,
        bubbles: true,
        detail
      }));
    }
    dispatchChangeEvent() {
      const detail = {
        value: this.inputElement.value
      };
      this._value = detail.value;
      this.dispatchChangeEventWithDetail(detail);
    }
    dispatchCommitEvent() {
      this.dispatchEvent(new CustomEvent('commit'));
    }

    /********* VALUE UPDATERS *********/

    setInputValue(value) {
      this.inputElement.value = value;
    }

    /********* HELPER METHODS *********/

    /**
     * TODO: lightning/inputUtils methods should be utilized in the second run of the input
     *       breakdown initiative.
     */
    normalizeInput(value) {
      if (typeof value === 'number' || typeof value === 'string') {
        return String(value);
      }
      return '';
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(LightningPrimitiveInputColor, {
    publicProps: {
      hasExternalLabel: {
        config: 0
      },
      required: {
        config: 0
      },
      accessKey: {
        config: 0
      },
      label: {
        config: 0
      },
      fieldLevelHelp: {
        config: 0
      },
      helptextAlternativeText: {
        config: 0
      },
      helpMessage: {
        config: 0
      },
      disabled: {
        config: 0
      },
      name: {
        config: 0
      },
      autocomplete: {
        config: 0
      },
      ariaLabel: {
        config: 0
      },
      ariaInvalid: {
        config: 0
      },
      ariaDisabled: {
        config: 0
      },
      ariaKeyShortcuts: {
        config: 0
      },
      placeholder: {
        config: 0
      },
      pattern: {
        config: 0
      },
      variant: {
        config: 0
      },
      value: {
        config: 3
      },
      inputElement: {
        config: 1
      },
      describedByElements: {
        config: 1
      },
      isNativeShadow: {
        config: 1
      }
    },
    publicMethods: ["focus"],
    fields: ["_value", "rendered", "initialValueSet"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningPrimitiveInputColor, {
    tmpl: _tmpl,
    sel: "lightning-primitive-input-color",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/sldsGenAiUtils', ['exports'], (function (exports) {

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return ((useActualHostSelector ? ":host(.gen-ai-enabled) {" : hostSelector + ".gen-ai-enabled {")) + "padding: 0;margin-bottom: 0;}";
      /*LWC compiler v7.1.5*/
    }
    var sldsGenAiUtils = [stylesheet];

    exports.default = sldsGenAiUtils;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/primitiveInputCheckboxButton', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/utilsPrivate', 'lightning/shadowBaseClassPrivate'], (function (exports, lwc, stylesheet0$1, utilsPrivate, LightningShadowBaseClass) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part=\"faux-button\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part=\"faux-button\"]")) + shadowSelector + " {width: var(--slds-g-sizing-9);height: var(--slds-g-sizing-9);display: inline-flex;align-items: center;justify-content: center;border-radius: var(--slds-g-radius-border-2);border: var(--slds-g-sizing-border-1) solid var(--slds-c-inputcheckboxbutton-color-border, var(--slds-g-color-border-2));background-color: var(--slds-c-inputcheckboxbutton-color-background, var(--slds-g-color-surface-container-1));cursor: pointer;position: relative;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part=\"faux-button\"]" + shadowSelector + "::before,:host([data-render-mode=\"shadow\"]) [part=\"faux-button\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part=\"faux-button\"]" + shadowSelector + "::before," + hostSelector + "[data-render-mode=\"shadow\"] [part=\"faux-button\"]")) + shadowSelector + "::after {content: \"\";position: absolute;inset: 0;height: calc(var(--slds-g-sizing-9) * 0.875 / 2);width: calc(var(--slds-g-sizing-9) * 0.125 / 2);margin: auto;background-color: var(--slds-c-inputcheckboxbutton-mark-color-foreground, var(--slds-g-color-accent-2));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part=\"faux-button\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part=\"faux-button\"]")) + shadowSelector + "::after {height: calc(var(--slds-g-sizing-9) * 0.125 / 2);width: calc(var(--slds-g-sizing-9) * 0.875 / 2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]:focus-within) [part=\"faux-button\"]" : hostSelector + ":focus-within[data-render-mode=\"shadow\"] [part=\"faux-button\"]")) + shadowSelector + " {box-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--slds-c-inputcheckboxbutton-color-border: var(--slds-g-color-border-accent-1);--slds-c-inputcheckboxbutton-color-border-checked: var(--slds-g-color-border-accent-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part=\"faux-button\"]:hover" : hostSelector + "[data-render-mode=\"shadow\"] [part=\"faux-button\"]:hover")) + shadowSelector + " {--slds-c-inputcheckboxbutton-color-background: var(--slds-g-color-surface-container-2);--slds-c-inputcheckboxbutton-color-background-checked: var(--slds-g-color-accent-container-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part=\"faux-button\"]" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part=\"faux-button\"]")) + shadowSelector + " {cursor: default;--slds-c-inputcheckboxbutton-color-border: var(--slds-g-color-border-disabled-1);--slds-c-inputcheckboxbutton-color-background: var(--slds-g-color-disabled-container-1);--slds-c-inputcheckboxbutton-mark-color-foreground: var(--slds-g-color-on-disabled-1);--slds-c-inputcheckboxbutton-color-border-checked: var(--slds-g-color-border-disabled-1);--slds-c-inputcheckboxbutton-color-background-checked: var(--slds-g-color-disabled-container-2);--slds-c-inputcheckboxbutton-mark-color-foreground-checked: var(--slds-g-color-on-disabled-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][checked]) [part=\"faux-button\"]" : hostSelector + "[checked][data-render-mode=\"shadow\"] [part=\"faux-button\"]")) + shadowSelector + " {--slds-c-inputcheckboxbutton-color-border: var(--slds-c-inputcheckboxbutton-color-border-checked, transparent);--slds-c-inputcheckboxbutton-color-background: var(--slds-c-inputcheckboxbutton-color-background-checked, var(--slds-g-color-accent-container-2));--slds-c-inputcheckboxbutton-mark-color-foreground: var(--slds-c-inputcheckboxbutton-mark-color-foreground-checked, var(--slds-g-color-on-accent-1));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][checked]) [part=\"faux-button\"]" : hostSelector + "[checked][data-render-mode=\"shadow\"] [part=\"faux-button\"]")) + shadowSelector + "::before {left: calc(var(--slds-g-sizing-9) * 0.3125 / 2);width: calc(var(--slds-g-sizing-9) * 0.125 / 2);height: calc(var(--slds-g-sizing-9) / 2);transform: rotate(40deg);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][checked]) [part=\"faux-button\"]" : hostSelector + "[checked][data-render-mode=\"shadow\"] [part=\"faux-button\"]")) + shadowSelector + "::after {top: calc(var(--slds-g-sizing-9) * 0.3125 / 2);left: calc(var(--slds-g-sizing-9) * -0.625 / 2);width: calc(var(--slds-g-sizing-9) * 0.5625 / 2);height: calc(var(--slds-g-sizing-9) * 0.125 / 2);transform: rotate(40deg);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='help-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='help-text']")) + shadowSelector + " {font-size: var(--slds-g-font-scale-neg-3);padding-block-start: 0.125rem;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='help-text']" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='help-text']")) + shadowSelector + " {color: var(--slds-g-color-error-base-50);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")) + shadowSelector + " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1$1 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1$1];

  var stylesheet1 = [stylesheet0__default.default, stylesheet1$1];

  var _implicitStylesheets = [stylesheet0, stylesheet1];

  const $fragment1 = lwc.parseFragment`<div class="slds-checkbox_add-button${0}" part="input-checkbox-button"${2}><input type="checkbox"${"a1:id"}${"a1:aria-label"}${"a1:aria-keyshortcuts"}${"a1:aria-disabled"}${"a1:aria-roledescription"}${"a1:aria-invalid"}${"a1:accesskey"} class="slds-assistive-text${0}"${"a1:name"}${"a1:required"}${"a1:readonly"}${"a1:disabled"} part="checkbox"${2}><label${"a2:for"} class="slds-checkbox_faux${0}" part="faux-button"${2}><span class="slds-assistive-text${0}" part="label"${2}>${"t4"}</span></label></div>`;
  const $fragment2 = lwc.parseFragment`<div${"a0:id"} class="slds-form-element__help${0}" data-help-message part="help-text" role="status"${2}><span class="slds-assistive-text${0}"${2}>${"t2"}</span>${"t3"}</div>`;
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {b: api_bind, gid: api_scoped_id, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment} = $api;
    const {_m0, _m1, _m2, _m3} = $ctx;
    return [api_static_fragment($fragment1, 1, [api_static_part(1, {
      on: {
        "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
        "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
        "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange)),
        "click": _m3 || ($ctx._m3 = api_bind($cmp.handleClick))
      },
      attrs: {
        "id": api_scoped_id("checkbox-button"),
        "aria-label": $cmp.ariaLabel,
        "aria-keyshortcuts": $cmp.ariaKeyShortcuts,
        "aria-disabled": $cmp.ariaDisabled,
        "aria-roledescription": $cmp.ariaRoleDescription,
        "aria-invalid": $cmp.ariaInvalid,
        "accesskey": $cmp.accessKey,
        "name": $cmp.name,
        "required": $cmp.required ? "" : null,
        "readonly": $cmp.readOnly ? "" : null,
        "disabled": $cmp.disabled ? "" : null
      }
    }, null), api_static_part(2, {
      attrs: {
        "for": api_scoped_id("checkbox-button")
      }
    }, null), api_static_part(4, null, api_dynamic_text($cmp.label))]), $cmp._helpMessage ? api_static_fragment($fragment2, 3, [api_static_part(0, {
      attrs: {
        "id": api_scoped_id("help-message")
      }
    }, null), api_static_part(2, null, api_dynamic_text($cmp.label)), api_static_part(3, null, api_dynamic_text($cmp._helpMessage))]) : null];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-49ug9a33g5f";
  tmpl.legacyStylesheetToken = "lightning-primitiveInputCheckboxButton_primitiveInputCheckboxButton";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  class LightningPrimitiveInputColor extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      this.ariaLabel = void 0;
      this.ariaInvalid = void 0;
      this.accessKey = void 0;
      this.name = void 0;
      this.required = void 0;
      this.readOnly = void 0;
      this.label = void 0;
      this.ariaKeyShortcuts = void 0;
      this.ariaDisabled = void 0;
      this.ariaRoleDescription = void 0;
      this._checked = false;
      this._disabled = false;
      this._helpMessage = '';
      this.rendered = false;
      this.initialValueSet = false;
    }
    /**
     * If present, the checkbox is selected.
     * @type {boolean}
     * @default false
     */
    get checked() {
      // checkable inputs can be part of a named group, in that case there won't be a change event thrown and so
      // the internal tracking _checked would be out of sync with the actual input value.
      if (this.initialValueSet) {
        return this.inputElement.checked;
      }
      return this._checked;
    }
    set checked(value) {
      this._checked = utilsPrivate.normalizeBoolean(value);
      if (this.rendered) {
        this.inputElement.checked = this._checked;
      }
      utilsPrivate.reflectAttribute(this, 'checked', this.checked);
    }

    /**
     * If present, the input field is disabled and users cannot interact with it.
     * @type {boolean}
     * @default false
     */
    get disabled() {
      return this._disabled;
    }
    set disabled(value) {
      this._disabled = utilsPrivate.normalizeBoolean(value);
      utilsPrivate.reflectAttribute(this, 'disabled', this.disabled);
    }
    get helpMessage() {
      return this._helpMessage;
    }
    set helpMessage(message) {
      this._helpMessage = message;
      utilsPrivate.reflectAttribute(this, 'invalid', !!message);
    }
    get inputElement() {
      if (!this.cachedInputElement) {
        let inputElement = this.template.querySelector('input');
        this.cachedInputElement = inputElement;
      }
      return this.cachedInputElement;
    }
    get ariaDescribedByElements() {
      return this.template.querySelector('[data-help-message]');
    }
    get isNativeShadow() {
      return this._isNativeShadow;
    }

    /********* COMPONENT CALLBACKS *********/

    connectedCallback() {
      super.connectedCallback();
      this._isNativeShadow = utilsPrivate.isNativeComponent(this);
    }
    disconnectedCallback() {
      this.cachedInputElement = undefined;
      this.initialValueSet = false;
      this.rendered = false;
    }
    renderedCallback() {
      this.rendered = true;
      if (!this.initialValueSet) {
        this.inputElement.checked = this._checked;
        this.initialValueSet = true;
      }
    }

    /********* ACTION HANDLERS *********/

    handleBlur() {
      this.dispatchEvent(new CustomEvent('blur'));
    }
    handleFocus() {
      this.dispatchEvent(new CustomEvent('focus'));
    }
    handleChange(event) {
      event.stopPropagation();
      this.dispatchCommitEvent();
      this.dispatchChangeEvent();
    }
    handleClick() {
      if (this.template.activeElement === null) {
        this.template.querySelector("[type='checkbox']").focus();
      }
    }

    /********* EVENT DISPATCHERS *********/

    dispatchChangeEventWithDetail(detail) {
      this.dispatchEvent(new CustomEvent('change', {
        composed: true,
        detail
      }));
    }
    dispatchChangeEvent() {
      const detail = {};
      this._checked = this.inputElement.checked;
      utilsPrivate.reflectAttribute(this, 'checked', this._checked);
      detail.checked = this._checked;
      this.dispatchChangeEventWithDetail(detail);
    }
    dispatchCommitEvent() {
      this.dispatchEvent(new CustomEvent('commit'));
    }

    /********* VALUE UPDATERS *********/

    setInputValue(value) {
      this.inputElement.value = value;
    }

    /********* HELPER METHODS *********/

    /**
     * TODO: lightning/inputUtils methods should be utilized in the second run of the input
     *       breakdown initiative.
     */
    normalizeInput(value) {
      if (typeof value === 'number' || typeof value === 'string') {
        return String(value);
      }
      return '';
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(LightningPrimitiveInputColor, {
    publicProps: {
      ariaLabel: {
        config: 0
      },
      ariaInvalid: {
        config: 0
      },
      accessKey: {
        config: 0
      },
      name: {
        config: 0
      },
      required: {
        config: 0
      },
      readOnly: {
        config: 0
      },
      label: {
        config: 0
      },
      ariaKeyShortcuts: {
        config: 0
      },
      ariaDisabled: {
        config: 0
      },
      ariaRoleDescription: {
        config: 0
      },
      checked: {
        config: 3
      },
      disabled: {
        config: 3
      },
      helpMessage: {
        config: 3
      },
      inputElement: {
        config: 1
      },
      ariaDescribedByElements: {
        config: 1
      },
      isNativeShadow: {
        config: 1
      }
    },
    fields: ["_checked", "_disabled", "_helpMessage", "rendered", "initialValueSet"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningPrimitiveInputColor, {
    tmpl: _tmpl,
    sel: "lightning-primitive-input-checkbox-button",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/label/LightningInputFile.bodyText', ['@view/forgotPassword/labels'], m => m[64]);
LWR.define('@salesforce/label/LightningInputFile.buttonLabel', ['@view/forgotPassword/labels'], m => m[65]);
(function() { LWR.define('lightning/primitiveFileDroppableZone', ['exports', 'lwc', 'lightning/shadowBaseClassPrivate', 'lightning/utilsPrivate'], (function (exports, lwc, LightningShadowBaseClass, utilsPrivate) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      return "slot" + shadowSelector + " {display: inline-block;}";
      /*LWC compiler v7.1.5*/
    }
    var _implicitStylesheets = [stylesheet];

    const stc0 = {
      key: 0
    };
    const stc1 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {s: api_slot} = $api;
      return [api_slot("", stc0, stc1, $slotset)];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = [""];
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-206866bm8j1";
    tmpl.legacyStylesheetToken = "lightning-primitiveFileDroppableZone_primitiveFileDroppableZone";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    class LightningPrimitiveFileDroppableZone extends LightningShadowBaseClass__default.default {
      get disabled() {
        return this._disabled || false;
      }
      set disabled(value) {
        this._disabled = utilsPrivate.normalizeBoolean(value);
      }
      get multiple() {
        return this._multiple || false;
      }
      set multiple(value) {
        this._multiple = utilsPrivate.normalizeBoolean(value);
      }
      constructor() {
        super();
        this._disabled = void 0;
        this._multiple = void 0;
        if (utilsPrivate.isCSR) {
          this.template.addEventListener('dragover', this.allowDrop.bind(this));
          this.template.addEventListener('dragleave', this.handleDragLeave.bind(this));
          this.template.addEventListener('drop', this.handleOnDrop.bind(this));
        }
      }
      connectedCallback() {
        this.classList.add('slds-file-selector__dropzone');
      }
      setDragOver(dragOver) {
        this.classList.toggle('slds-has-drag-over', dragOver);
      }
      handleDragLeave() {
        this.setDragOver(false);
      }
      handleOnDrop(event) {
        event.preventDefault();
        this.setDragOver(false);
        if (this.disabled) {
          event.stopPropagation();
          return;
        }
        if (!this.meetsMultipleCriteria(event)) {
          event.stopPropagation();
        }
      }
      allowDrop(event) {
        event.preventDefault();
        if (!this.disabled) {
          this.setDragOver(true);
        }
      }
      meetsMultipleCriteria(dragEvent) {
        const files = dragEvent.dataTransfer.files;
        return !(files.length > 1 && !this.multiple);
      }
      /*LWC compiler v7.1.5*/
    }
    LightningPrimitiveFileDroppableZone.validationOptOut = ['class'];
    lwc.registerDecorators(LightningPrimitiveFileDroppableZone, {
      publicProps: {
        disabled: {
          config: 3
        },
        multiple: {
          config: 3
        }
      },
      track: {
        _disabled: 1,
        _multiple: 1
      }
    });
    const __lwc_component_class_internal = lwc.registerComponent(LightningPrimitiveFileDroppableZone, {
      tmpl: _tmpl,
      sel: "lightning-primitive-file-droppable-zone",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/primitiveInputFile', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/primitiveIcon', 'lightning/primitiveFileDroppableZone', 'lightning/shadowBaseClassPrivate', 'lightning/utilsPrivate', '@salesforce/label/LightningControl.required', '@salesforce/label/LightningInputFile.bodyText', '@salesforce/label/LightningInputFile.buttonLabel'], (function (exports, lwc, stylesheet0$1, _lightningPrimitiveIcon, _lightningPrimitiveFileDroppableZone, LightningShadowBaseClass, utilsPrivate, labelRequired, labelInputFileBodyText, labelInputFileButtonLabel) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningPrimitiveIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveIcon);
  var _lightningPrimitiveFileDroppableZone__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveFileDroppableZone);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);
  var labelRequired__default = /*#__PURE__*/_interopDefaultCompat(labelRequired);
  var labelInputFileBodyText__default = /*#__PURE__*/_interopDefaultCompat(labelInputFileBodyText);
  var labelInputFileButtonLabel__default = /*#__PURE__*/_interopDefaultCompat(labelInputFileButtonLabel);

  function stylesheet$2(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part=\"file-selector\"]" : hostSelector + "[data-render-mode=\"shadow\"] [part=\"file-selector\"]")) + shadowSelector + " {display: inline-flex;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-file-selector__dropzone" : hostSelector + "[data-render-mode=\"shadow\"] .slds-file-selector__dropzone")) + shadowSelector + " {padding: calc(var(--slds-g-spacing-1) / 2);border: var(--slds-g-sizing-border-1) dashed var(--slds-g-color-border-base-4, var(--slds-g-color-border-2));border-radius: var(--slds-g-radius-border-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-drag-over" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-drag-over")) + shadowSelector + " {outline: 0;border-color: var(--slds-g-color-brand-base-60, var(--slds-g-color-border-accent-2));box-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);border-style: solid;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part='input']:focus")) + shadowSelector + " ~ .slds-file-selector__body" + shadowSelector + " > .slds-file-selector__button" + shadowSelector + " {box-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input'][disabled]" : hostSelector + "[data-render-mode=\"shadow\"] [part='input'][disabled]")) + shadowSelector + " ~ .slds-file-selector__body" + shadowSelector + " {color: var(--slds-g-color-disabled-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input'][disabled]" : hostSelector + "[data-render-mode=\"shadow\"] [part='input'][disabled]")) + shadowSelector + " ~ .slds-file-selector__body" + shadowSelector + " > .slds-file-selector__button" + shadowSelector + " {background: var(--slds-s-input-color-background-disabled, var(--slds-g-color-disabled-container-1));border-color: var(--slds-g-color-border-disabled-1);color: var(--slds-g-color-on-disabled-2);pointer-events: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input'][disabled]" : hostSelector + "[data-render-mode=\"shadow\"] [part='input'][disabled]")) + shadowSelector + " ~ .slds-file-selector__body" + shadowSelector + " > .slds-file-selector__body-icon" + shadowSelector + " {fill: currentcolor;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-file-selector_files" : hostSelector + "[data-render-mode=\"shadow\"] .slds-file-selector_files")) + shadowSelector + " .slds-file-selector__body" + shadowSelector + " {display: flex;align-items: center;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-file-selector_files" : hostSelector + "[data-render-mode=\"shadow\"] .slds-file-selector_files")) + shadowSelector + " .slds-file-selector__text" + shadowSelector + " {margin-left: var(--slds-g-spacing-2);margin-right: var(--slds-g-spacing-3);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-file-selector__button" : hostSelector + "[data-render-mode=\"shadow\"] .slds-file-selector__button")) + shadowSelector + " {display: inline-flex;align-items: center;}@media (width <= 768px) {" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-medium-show" : hostSelector + "[data-render-mode=\"shadow\"] .slds-medium-show")) + shadowSelector + " {display: none;}}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet$2];

  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return "*" + shadowSelector + ",*" + shadowSelector + "::before,*" + shadowSelector + "::after {box-sizing: border-box;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {display: inline-flex;gap: var(--sds-c-button-spacing-gap, var(--sds-s-button-spacing-gap));background: var(--sds-c-button-color-background, var(--sds-s-button-color-background));color: var(--sds-c-button-text-color, var(--sds-s-button-color));font-weight: var(--sds-c-button-font-weight, var(--sds-s-button-font-weight));font-size: var(--sds-c-button-font-size, var(--sds-s-button-font-size, inherit));line-height: var(--sds-c-button-font-lineheight);height: var(--sds-c-button-sizing-height);width: var(--sds-c-button-sizing-width);padding-inline-start: var(\n --sds-c-button-spacing-inlinestart,\n var(\n --sds-c-button-spacing-inline,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-inline, var(--sds-s-button-spacing)))\n )\n );padding-inline-end: var(\n --sds-c-button-spacing-inlineend,\n var(\n --sds-c-button-spacing-inline,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-inline, var(--sds-s-button-spacing)))\n )\n );padding-block-start: var(\n --sds-c-button-spacing-blockstart,\n var(\n --sds-c-button-spacing-block,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-block, var(--sds-s-button-spacing)))\n )\n );padding-block-end: var(\n --sds-c-button-spacing-blockend,\n var(\n --sds-c-button-spacing-block,\n var(--sds-c-button-spacing, var(--sds-s-button-spacing-block, var(--sds-s-button-spacing)))\n )\n );border-width: var(--sds-c-button-sizing-border, var(--sds-s-button-sizing-border, 1px));border-style: solid;border-color: var(--sds-c-button-color-border, var(--sds-s-button-color-border, currentColor));border-start-start-radius: var(\n --sds-c-button-radius-border-startstart,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-startstart, var(--sds-s-button-radius-border))\n )\n );border-start-end-radius: var(\n --sds-c-button-radius-border-startend,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-startend, var(--sds-s-button-radius-border))\n )\n );border-end-start-radius: var(\n --sds-c-button-radius-border-endstart,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-endstart, var(--sds-s-button-radius-border))\n )\n );border-end-end-radius: var(\n --sds-c-button-radius-border-endend,\n var(\n --sds-c-button-radius-border,\n var(--sds-s-button-radius-border-endend, var(--sds-s-button-radius-border))\n )\n );box-shadow: var(--sds-c-button-shadow, var(--sds-s-button-shadow));text-decoration: var(--sds-c-button-font-decoration);white-space: normal;user-select: none;align-items: center;justify-content: center;appearance: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:hover" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:hover")) + shadowSelector + " {--sds-c-button-text-color: var(--sds-c-button-text-color-hover, var(--sds-s-button-color-hover, revert));--sds-c-button-color-background: var(\n --sds-c-button-color-background-hover,\n var(--sds-s-button-color-background-hover, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-hover,\n var(--sds-s-button-color-border-hover, revert)\n );--sds-c-button-shadow: var(--sds-c-button-shadow-hover, var(--sds-s-button-shadow-hover, revert));cursor: pointer;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:focus")) + shadowSelector + " {--sds-c-button-color-background: var(\n --sds-c-button-color-background-focus,\n var(--sds-s-button-color-background-focus, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-focus,\n var(--sds-s-button-color-border-focus, revert)\n );--sds-c-button-text-color: var(--sds-c-button-text-color-focus, var(--sds-s-button-color-focus, revert));--sds-c-button-shadow: var(--sds-c-button-shadow-focus, var(--sds-s-button-shadow-focus, revert));outline: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:active")) + shadowSelector + " {--sds-c-button-text-color: var(--sds-c-button-text-color-active, var(--sds-s-button-color-active, revert));--sds-c-button-color-background: var(\n --sds-c-button-color-background-active,\n var(--sds-s-button-color-background-active, revert)\n );--sds-c-button-color-border: var(\n --sds-c-button-color-border-active,\n var(--sds-s-button-color-border-active, revert)\n );--sds-c-button-shadow: var(--sds-c-button-shadow-active, var(--sds-s-button-shadow-active, revert));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " {--sds-c-button-text-color: var(--sds-c-button-text-color-disabled);--sds-c-button-color-background: var(--sds-c-button-color-background-disabled);--sds-c-button-color-border: var(--sds-c-button-color-border-disabled);--sds-c-button-shadow: var(--sds-c-button-shadow-disabled);pointer-events: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " *" + shadowSelector + " {pointer-events: none;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='button'][aria-pressed='true']" : hostSelector + "[data-render-mode=\"shadow\"] [part='button'][aria-pressed='true']")) + shadowSelector + " {--sds-c-button-color-background: var(--sds-c-button-color-background-pressed, revert);--sds-c-button-color-border: var(--sds-c-button-color-border-pressed, revert);--sds-c-button-text-color: var(--sds-c-button-text-color-pressed, revert);--sds-c-button-shadow: var(--sds-c-button-shadow-pressed, revert);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {gap: var(--slds-g-spacing-2);--slds-c-icon-sizing-border: 0;--slds-c-icon-sizing: 0.875rem;--slds-c-icon-color-foreground: currentcolor;--sds-c-button-font-lineheight: var(\n --slds-c-button-neutral-font-lineheight,\n var(--slds-s-button-font-lineheight, 1.875rem)\n );--sds-c-button-spacing-inline: var(\n --slds-c-button-neutral-spacing-inline,\n var(--slds-s-button-spacing-inline, var(--slds-g-spacing-4));\n );--sds-c-button-spacing-block: var(--slds-c-button-neutral-spacing-block);--sds-c-button-radius-border-startstart: var(\n --slds-c-button-radius-border-startstart,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-startstart, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-endstart: var(\n --slds-c-button-radius-border-endstart,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-endstart, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-startend: var(\n --slds-c-button-radius-border-startend,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-startend, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-radius-border-endend: var(\n --slds-c-button-radius-border-endend,\n var(\n --slds-c-button-radius-border,\n var(--slds-s-button-radius-border-endend, var(--slds-s-button-radius-border))\n )\n );--sds-c-button-color-background: var(\n --slds-c-button-neutral-color-background,\n var(--slds-g-color-surface-container-1)\n );--sds-c-button-color-background-hover: var(\n --slds-c-button-neutral-color-background-hover,\n var(--slds-g-color-surface-container-2)\n );--sds-c-button-color-background-focus: var(--slds-c-button-neutral-color-background-focus, var(--slds-g-color-surface-container-2));--sds-c-button-color-background-active: var(\n --slds-c-button-neutral-color-background-active,\n var(--slds-g-color-surface-container-2)\n );--sds-c-button-color-border: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-2));--sds-c-button-color-border-hover: var(\n --slds-c-button-neutral-color-border-hover,\n var(--slds-g-color-border-2)\n );--sds-c-button-color-border-focus: var(\n --slds-c-button-neutral-color-border-focus,\n var(--slds-g-color-border-2)\n );--sds-c-button-color-border-active: var(\n --slds-c-button-neutral-color-border-active,\n var(--slds-g-color-border-2)\n );--sds-c-button-text-color: var(--slds-c-button-neutral-text-color, var(--slds-g-color-accent-2));--sds-c-button-text-color-hover: var(--slds-c-button-neutral-text-color-hover, var(--slds-s-button-color-hover, var(--slds-g-color-accent-3)));--sds-c-button-text-color-focus: var(--slds-c-button-neutral-text-color-focus, var(--slds-g-color-accent-3));--sds-c-button-text-color-active: var(\n --slds-c-button-neutral-text-color-active,\n var(--slds-g-color-accent-3)\n );--sds-c-button-shadow: var(--slds-c-button-neutral-shadow);--sds-c-button-shadow-focus: var(--slds-c-button-neutral-shadow-focus);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='button']:disabled" : hostSelector + "[data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " {--sds-c-button-color-border-disabled: var(--slds-g-color-border-disabled-1);--sds-c-button-text-color-disabled: var(--slds-g-color-on-disabled-1);--sds-c-button-color-background-disabled: var(--slds-g-color-disabled-container-1);pointer-events: auto;cursor: default;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-color-background: var(\n --slds-c-button-brand-color-background,\n var(--slds-g-color-accent-container-1)\n );--slds-c-button-neutral-color-background-hover: var(\n --slds-c-button-brand-color-background-hover,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-background-focus: var(\n --slds-c-button-brand-color-background-focus,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-background-active: var(\n --slds-c-button-brand-color-background-active,\n var(--slds-g-color-accent-container-2)\n );--slds-c-button-neutral-color-border: var(\n --slds-c-button-brand-color-border,\n var(--slds-g-color-border-accent-1)\n );--slds-c-button-neutral-color-border-hover: var(\n --slds-c-button-brand-color-border-hover,\n var(--slds-g-color-border-accent-2)\n );--slds-c-button-neutral-color-border-focus: var(\n --slds-c-button-brand-color-border-focus,\n var(--slds-g-color-border-accent-2)\n );--slds-c-button-neutral-color-border-active: var(\n --slds-c-button-brand-color-border-active,\n var(--slds-g-color-border-accent-2)\n );--sds-c-button-text-color: var(--slds-c-button-brand-text-color, var(--slds-g-color-on-accent-1));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand-outline']) [part~='button']" : hostSelector + "[variant='brand-outline'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-color-border: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']" : hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-color-background: transparent;--slds-c-button-neutral-color-background-hover: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-surface-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-color-border-active: var(--slds-g-color-neutral-base-100);--slds-c-button-neutral-text-color: var(--slds-g-color-on-accent-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-accent-2);--slds-c-button-neutral-text-color-active: var(--slds-g-color-accent-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']:disabled" : hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " {--sds-c-button-color-background: transparent;--sds-c-button-color-border: var(--slds-g-color-border-disabled-2);--sds-c-button-text-color: var(--slds-g-color-disabled-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']" : hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-color-background: var(--slds-g-color-error-container-1);--slds-c-button-neutral-color-background-hover: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-error-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-border-error-1);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-error-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-error-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-error-2);--sds-c-button-text-color: var(--slds-g-color-on-error-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='success']) [part~='button']" : hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-color-background: var(--slds-g-color-success-container-1);--slds-c-button-neutral-color-background-hover: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-background-focus: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-background-active: var(--slds-g-color-success-container-2);--slds-c-button-neutral-color-border: var(--slds-g-color-border-success-1);--slds-c-button-neutral-color-border-hover: var(--slds-g-color-border-success-2);--slds-c-button-neutral-color-border-focus: var(--slds-g-color-border-success-2);--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-success-2);--slds-c-button-neutral-text-color: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-focus: var(--slds-g-color-on-success-1);--slds-c-button-neutral-text-color-active: var(--slds-g-color-on-success-1);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='destructive-text']) [part~='button']" : hostSelector + "[variant='destructive-text'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--slds-c-button-neutral-text-color: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-hover: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-focus: var(--slds-g-color-error-1);--slds-c-button-neutral-text-color-active: var(--slds-g-color-error-1);--slds-c-button-neutral-color-border-hover: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));--slds-c-button-neutral-color-border-focus: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));--slds-c-button-neutral-color-border-active: var(--slds-c-button-neutral-color-border, var(--slds-g-color-border-1));}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='success']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']:disabled" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " {--sds-c-button-color-background: var(--slds-g-color-disabled-container-2);--sds-c-button-color-border: var(--slds-g-color-border-disabled-1);--sds-c-button-text-color: var(--slds-g-color-on-disabled-2);}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='base']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='text']) [part~='button']" : hostSelector + "[variant='base'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='text'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + "{--sds-c-button-spacing-inline: 0;--slds-c-button-neutral-text-color: var(--slds-g-color-accent-2);--slds-c-button-neutral-color-border: transparent;--slds-c-button-neutral-color-border-hover: transparent;--slds-c-button-neutral-color-border-focus: transparent;--slds-c-button-neutral-color-border-active: var(--slds-g-color-border-accent-2);--slds-c-button-neutral-color-background: transparent;--slds-c-button-neutral-color-background-hover: transparent;--slds-c-button-neutral-color-background-focus: transparent;--slds-c-button-neutral-color-background-active: transparent;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='base']) [part~='button']:disabled" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='text']) [part~='button']:disabled" : hostSelector + "[variant='base'][data-render-mode=\"shadow\"] [part~='button']:disabled" + shadowSelector + "," + hostSelector + "[variant='text'][data-render-mode=\"shadow\"] [part~='button']:disabled")) + shadowSelector + " {--sds-c-button-color-background: transparent;--sds-c-button-color-border: transparent;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][stretch]) [part~='button']" : hostSelector + "[stretch][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {--sds-c-button-sizing-width: 100%;justify-content: center;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='brand']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='brand-outline']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='inverse']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='success']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive']) [part~='button']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='destructive-text']) [part~='button']" : hostSelector + "[variant='brand'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='brand-outline'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='inverse'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='success'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='destructive'][data-render-mode=\"shadow\"] [part~='button']" + shadowSelector + "," + hostSelector + "[variant='destructive-text'][data-render-mode=\"shadow\"] [part~='button']")) + shadowSelector + " {justify-content: center;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='start']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='start']")) + shadowSelector + " {display: inline-flex;padding-inline-end: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='end']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='end']")) + shadowSelector + " {display: inline-flex;padding-inline-start: 0;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")) + shadowSelector + " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}" + ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-button_reset" : hostSelector + "[data-render-mode=\"shadow\"] .slds-button_reset")) + shadowSelector + " {font-size: inherit;color: inherit;line-height: inherit;padding: 0;background: transparent;border: 0;text-align: inherit;}";
    /*LWC compiler v7.1.5*/
  }
  var stylesheet2 = [stylesheet$1];

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) fieldset" : hostSelector + "[data-render-mode=\"shadow\"] fieldset")), shadowSelector, " {border: 0;margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {position: relative;min-width: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;hyphens: auto;display: inline-block;color: var(--slds-g-color-on-surface-2);font-size: var(--slds-s-label-font-size, var(--slds-g-font-scale-neg-2));padding-inline-end: var(--slds-g-spacing-2);padding-block-start: var(--slds-g-spacing-1);margin-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label:empty")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {clear: inline-start;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-radio", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {display: inline-block;position: relative;padding-block-start: var(--slds-g-spacing-1);vertical-align: top;line-height: var(--slds-g-font-lineheight-1);z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-form-element__helper" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__helper")), shadowSelector, " {font-size: var(--slds-s-helptext-font-size, var(--slds-g-font-scale-neg-2));margin-block-start: calc(var(--slds-g-spacing-1) / 2);display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_edit")), shadowSelector, " .slds-form-element__static", shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " {flex-basis: 0%;border-bottom: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__label", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__legend" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__legend")), shadowSelector, " {font-weight: var(--slds-g-font-weight-7);float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__addon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__addon")), shadowSelector, " {display: inline-block;margin-block-start: 0;margin-block-end: 0;margin-inline-start: var(--slds-g-spacing-2);margin-inline-end: var(--slds-g-spacing-2);align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;word-break: break-word;display: inline-block;font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-neutral-base-10);width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static.slds-text-longform" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static.slds-text-longform")), shadowSelector, " *:last-child", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static:empty")), shadowSelector, " {min-height: calc(var(--slds-g-sizing-6) + 1px);vertical-align: bottom;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static--edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static--edit")), shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-required" : hostSelector + "[data-render-mode=\"shadow\"] .slds-required")), shadowSelector, " {color: var(--slds-g-color-error-1);margin-block-start: 0;margin-block-end: 0;margin-inline-start: calc(var(--slds-g-spacing-1) / 2);margin-inline-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-form-element__help", shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-form-element__help" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) {" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {padding: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__label" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__label" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {width: 100%;flex-basis: 100%;clear: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__icon" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {float: none;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline'].slds-form-element_horizontal) {" : hostSelector + ".slds-form-element_horizontal[variant='label-inline'][data-render-mode=\"shadow\"] {")), "padding: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']).slds-is-edited {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"].slds-is-edited {")), "padding-block-start: var(--slds-g-sizing-6)}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__label" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {float: inline-start;max-width: calc(33% - var(--slds-g-sizing-6));flex-basis: calc(33% - var(--slds-g-sizing-6));flex-grow: 1;margin-block-end: 0;position: relative;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) lightning-helptext" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] lightning-helptext")), shadowSelector, " {float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {margin-inline-start: 33%;clear: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list__column" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list__column")), shadowSelector, " .slds-form-element__label", shadowSelector, " {width: auto;max-width: 100%;flex-basis: auto;float: none;position: relative;padding-inline-start: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__help" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list")), shadowSelector, " {clear: none;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " {display: flex;margin-bottom: var(--slds-g-spacing-1);margin-left: calc(var(--slds-g-spacing-1) * -1);margin-right: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " .slds-form-element__label", shadowSelector, " {padding-top: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element", shadowSelector, " {padding-left: var(--slds-g-spacing-1);padding-right: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_address" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_address")), shadowSelector, " .slds-form-element__row", shadowSelector, " {align-items: flex-end;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-hidden']) .slds-form-element__label" : hostSelector + "[variant='label-hidden'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {display: none}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet3 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1, stylesheet2, stylesheet3];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<abbr class="slds-required${0}"${"a0:title"}${2}>*</abbr>`;
  const $fragment2 = lwc.parseFragment`<input type="file"${"a0:id"}${"a0:aria-label"}${"a0:aria-keyshortcuts"}${"a0:aria-disabled"}${"a0:aria-roledescription"}${"a0:aria-invalid"}${"a0:accesskey"} class="slds-file-selector__input slds-assistive-text${0}"${"a0:accept"}${"a0:multiple"}${"a0:name"}${"a0:required"}${"a0:readonly"}${"a0:disabled"} part="input"${2}>`;
  const $fragment3 = lwc.parseFragment`<span class="slds-file-selector__text slds-medium-show${0}"${2}>${"t1"}</span>`;
  const $fragment4 = lwc.parseFragment`<div${"a0:id"} class="slds-form-element__help${0}" data-help-message part="help-text" role="status"${2}><span class="slds-assistive-text${0}"${2}>${"t2"}</span>${"t3"}</div>`;
  const stc0 = {
    classMap: {
      "slds-form-element__control": true
    },
    key: 3
  };
  const stc1 = {
    "slds-file-selector": true,
    "slds-file-selector_files": true
  };
  const stc2 = {
    "part": "file-selector"
  };
  const stc3 = {
    "slds-file-selector__body": true
  };
  const stc4 = {
    classMap: {
      "slds-file-selector__button": true,
      "slds-button": true,
      "slds-button_neutral": true
    },
    attrs: {
      "part": "button"
    },
    key: 9
  };
  const stc5 = {
    props: {
      "iconName": "utility:upload",
      "variant": "bare",
      "svgClass": "slds-button__icon slds-button__icon_left"
    },
    key: 10
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {gid: api_scoped_id, ncls: api_normalize_class_name, sp: api_static_part, st: api_static_fragment, d: api_dynamic_text, t: api_text, h: api_element, b: api_bind, c: api_custom_element} = $api;
    const {_m0, _m1, _m2, _m3, _m4, _m5, _m6, _m7, _m8} = $ctx;
    return [api_element("span", {
      className: api_normalize_class_name($cmp.labelClass),
      attrs: {
        "id": api_scoped_id("form-label"),
        "data-form-label": ""
      },
      key: 0
    }, [$cmp.required ? api_static_fragment($fragment1, 2, [api_static_part(0, {
      attrs: {
        "title": $cmp.i18n.required
      }
    }, null)]) : null, api_text(api_dynamic_text($cmp.label))]), api_element("div", stc0, [api_element("div", {
      classMap: stc1,
      attrs: stc2,
      key: 4,
      on: {
        "drop": _m0 || ($ctx._m0 = api_bind($cmp.handleDropFiles))
      }
    }, [api_custom_element("lightning-primitive-file-droppable-zone", _lightningPrimitiveFileDroppableZone__default.default, {
      props: {
        "multiple": $cmp.multiple,
        "disabled": $cmp.disabled
      },
      key: 5
    }, [api_static_fragment($fragment2, 7, [api_static_part(0, {
      on: {
        "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
        "focus": _m6 || ($ctx._m6 = api_bind($cmp.handleFocus)),
        "click": _m7 || ($ctx._m7 = api_bind($cmp.handleFileClick)),
        "change": _m8 || ($ctx._m8 = api_bind($cmp.handleChange))
      },
      attrs: {
        "id": api_scoped_id("input-file"),
        "aria-label": $cmp.ariaLabel,
        "aria-keyshortcuts": $cmp.ariaKeyShortcuts,
        "aria-disabled": $cmp.ariaDisabled,
        "aria-roledescription": $cmp.ariaRoleDescription,
        "aria-invalid": $cmp.ariaInvalid,
        "accesskey": $cmp.accessKey,
        "accept": $cmp.accept,
        "multiple": $cmp.multiple ? "" : null,
        "name": $cmp.name,
        "required": $cmp.required ? "" : null,
        "readonly": $cmp.readOnly ? "" : null,
        "disabled": $cmp.disabled ? "" : null
      }
    }, null)]), api_element("label", {
      classMap: stc3,
      attrs: {
        "id": api_scoped_id("file-selector-label"),
        "data-file-selector-label": "",
        "for": api_scoped_id("input-file"),
        "aria-hidden": "true"
      },
      key: 8
    }, [api_element("span", stc4, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon__default.default, stc5), api_text(api_dynamic_text($cmp.i18n.inputFileButtonLabel))]), api_static_fragment($fragment3, 12, [api_static_part(1, null, api_dynamic_text($cmp.i18n.inputFileBodyText))])])])])]), $cmp._helpMessage ? api_static_fragment($fragment4, 14, [api_static_part(0, {
      attrs: {
        "id": api_scoped_id("help-message")
      }
    }, null), api_static_part(2, null, api_dynamic_text($cmp.label)), api_static_part(3, null, api_dynamic_text($cmp._helpMessage))]) : null];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-24ep20h9ret";
  tmpl.legacyStylesheetToken = "lightning-primitiveInputFile_primitiveInputFile";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  const i18n = {
    required: labelRequired__default.default,
    inputFileBodyText: labelInputFileBodyText__default.default,
    inputFileButtonLabel: labelInputFileButtonLabel__default.default
  };
  class LightningPrimitiveInputFile extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      this._files = null;
      this._helpMessage = '';
      /************************* PUBLIC PROPERTIES *************************/
      this.accept = void 0;
      this.accessKey = void 0;
      this.ariaInvalid = void 0;
      this.disabled = void 0;
      this.label = void 0;
      this.labelClass = void 0;
      this.multiple = void 0;
      this.name = void 0;
      this.readOnly = void 0;
      this.required = void 0;
      this.ariaLabel = void 0;
      this.ariaKeyShortcuts = void 0;
      this.ariaDisabled = void 0;
      this.ariaRoleDescription = void 0;
    }
    get files() {
      return this._files;
    }
    get inputElement() {
      return this.template.querySelector('input');
    }
    get ariaDescribedByElements() {
      return this.template.querySelector('[data-help-message]');
    }
    get ariaLabelledByElements() {
      return [this.template.querySelector('[data-form-label]'), this.template.querySelector('[data-file-selector-label]')];
    }
    get isNativeShadow() {
      return this._isNativeShadow;
    }
    get helpMessage() {
      return this._helpMessage;
    }
    set helpMessage(message) {
      this._helpMessage = message;
      utilsPrivate.reflectAttribute(this, 'invalid', !!message);
    }
    get variant() {
      return this._variant;
    }
    set variant(variant) {
      this._variant = variant;
      utilsPrivate.reflectAttribute(this, 'variant', variant);
    }

    /************************* PRIVATE GETTERS *************************/

    get i18n() {
      return i18n;
    }

    /************************** EVENT HANDLERS **************************/

    handleDropFiles(event) {
      this._files = event.dataTransfer && event.dataTransfer.files;
      this.dispatchEvent(new CustomEvent('change'));
      // drop doesn't trigger focus/blur, so use event
      // to call reportValidity instead of interacting state
      this.dispatchEvent(new CustomEvent('reportvalidity'));
    }
    handleBlur() {
      this.dispatchEvent(new CustomEvent('blur'));
    }
    handleFocus() {
      this.dispatchEvent(new CustomEvent('focus'));
    }
    handleFileClick() {
      this.inputElement.value = null;
    }
    handleChange() {
      this._files = this.inputElement.files;
      this.dispatchEvent(new CustomEvent('change'));
    }

    /************************** LIFECYCLE HOOKS **************************/

    connectedCallback() {
      super.connectedCallback();
      this._isNativeShadow = utilsPrivate.isNativeComponent(this);
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(LightningPrimitiveInputFile, {
    publicProps: {
      accept: {
        config: 0
      },
      accessKey: {
        config: 0
      },
      ariaInvalid: {
        config: 0
      },
      disabled: {
        config: 0
      },
      label: {
        config: 0
      },
      labelClass: {
        config: 0
      },
      multiple: {
        config: 0
      },
      name: {
        config: 0
      },
      readOnly: {
        config: 0
      },
      required: {
        config: 0
      },
      ariaLabel: {
        config: 0
      },
      ariaKeyShortcuts: {
        config: 0
      },
      ariaDisabled: {
        config: 0
      },
      ariaRoleDescription: {
        config: 0
      },
      files: {
        config: 1
      },
      inputElement: {
        config: 1
      },
      ariaDescribedByElements: {
        config: 1
      },
      ariaLabelledByElements: {
        config: 1
      },
      isNativeShadow: {
        config: 1
      },
      helpMessage: {
        config: 3
      },
      variant: {
        config: 3
      }
    },
    fields: ["_files", "_helpMessage"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningPrimitiveInputFile, {
    tmpl: _tmpl,
    sel: "lightning-primitive-input-file",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/primitiveInputSimple', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/helptext', 'lightning/primitiveIcon', 'lightning/shadowBaseClassPrivate', '@salesforce/label/LightningControl.required', '@salesforce/label/LightningControl.clear', '@salesforce/label/LightningControl.loading', 'lightning/internationalizationLibrary', 'lightning/numberUtils', 'lightning/inputUtils', 'lightning/utilsPrivate'], (function (exports, lwc, stylesheet0$1, _lightningHelptext, _lightningPrimitiveIcon, LightningShadowBaseClass, labelRequired, labelClearInput, labelLoadingIndicator, internationalizationLibrary, numberUtils, inputUtils, utilsPrivate) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
    var _lightningHelptext__default = /*#__PURE__*/_interopDefaultCompat(_lightningHelptext);
    var _lightningPrimitiveIcon__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveIcon);
    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);
    var labelRequired__default = /*#__PURE__*/_interopDefaultCompat(labelRequired);
    var labelClearInput__default = /*#__PURE__*/_interopDefaultCompat(labelClearInput);
    var labelLoadingIndicator__default = /*#__PURE__*/_interopDefaultCompat(labelLoadingIndicator);

    function stylesheet$2(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      return (useNativeDirPseudoclass ? '' : '[dir="rtl"]') + " input[type=\"tel\"]" + (useNativeDirPseudoclass ? ':dir(rtl)' : '') + shadowSelector + " {direction: ltr;text-align: right;unicode-bidi: embed;}";
      /*LWC compiler v7.1.5*/
    }
    var stylesheet0 = [stylesheet$2];

    function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {display: flex;align-items: center;gap: var(--sds-c-inputtext-spacing-gap, var(--sds-s-input-spacing-gap));min-height: var(--sds-c-inputtext-sizing-height, var(--sds-s-input-sizing-height));padding-inline-start: var(\n --sds-c-inputtext-spacing-inlinestart,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-spacing-inlineend,\n var(--sds-c-inputtext-spacing-inline, var(--sds-s-input-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-spacing-blockstart,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-spacing-blockend,\n var(--sds-c-inputtext-spacing-block, var(--sds-s-input-spacing))\n );background: var(--sds-c-inputtext-color-background, var(--sds-s-input-color-background));border-block-start: var(\n --sds-c-inputtext-sizing-border-blockstart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockstart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-start: var(\n --sds-c-inputtext-sizing-border-inlinestart,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlinestart,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-inline-end: var(\n --sds-c-inputtext-sizing-border-inlineend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-inlineend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-block-end: var(\n --sds-c-inputtext-sizing-border-blockend,\n var(--sds-c-inputtext-sizing-border, var(--sds-g-sizing-border-1, 1px))\n )\n solid\n var(\n --sds-c-inputtext-color-border-blockend,\n var(--sds-c-inputtext-color-border, var(--sds-s-input-color-border, currentColor))\n );border-radius: var(--sds-c-inputtext-radius-border, var(--sds-s-input-radius-border));box-shadow: var(--sds-c-inputtext-shadow, var(--sds-s-input-shadow));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, " {width: 100%;height: 100%;padding: 0;font-size: var(--sds-c-inputtext-font-size, var(--sds-s-input-font-size));color: var(--sds-c-inputtext-text-color, var(--sds-s-input-text-color));line-height: 1;border: none;background: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][active]) [part~='input-container']" : hostSelector + "[active][data-render-mode=\"shadow\"] [part~='input-container']")), shadowSelector, " {--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-active,\n var(--sds-s-input-color-background-active)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-active,\n var(--sds-s-input-color-border-active)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-active, var(--sds-s-input-shadow-active));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']")), shadowSelector, "::placeholder {color: var(--sds-c-inputtext-text-color-placeholder, var(--sds-s-input-text-color-placeholder));font-style: var(--sds-c-inputtext-font-style-placeholder, var(--sds-s-input-font-style-placeholder));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-container']:focus-within" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-focus,\n var(--sds-s-input-color-border-focus, revert)\n );--sds-c-inputtext-shadow: var(--sds-c-inputtext-shadow-focus, var(--sds-s-input-shadow-focus));--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-focus,\n var(--sds-s-input-color-background-focus, revert)\n );--sds-c-inputtext-text-color: var(\n --sds-c-inputtext-text-color-focus,\n var(--sds-s-input-text-color-focus, revert)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input']:focus")), shadowSelector, " {outline: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {display: inline-flex;align-items: center;gap: var(--sds-c-inputtext-label-spacing-gap, var(--sds-s-label-spacing-gap));padding-inline-start: var(\n --sds-c-inputtext-label-spacing-inlinestart,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-label-spacing-inlineend,\n var(--sds-c-inputtext-label-spacing-inline, var(--sds-s-label-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-label-spacing-blockstart,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-label-spacing-blockend,\n var(--sds-c-inputtext-label-spacing-block, var(--sds-s-label-spacing))\n );color: var(--sds-c-inputtext-label-color, var(--sds-s-label-color));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {font-size: var(--sds-c-inputtext-label-font-size, var(--sds-s-label-font-size));font-weight: var(--sds-c-inputtext-label-font-weight, var(--sds-s-label-font-weight));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='help-text visible']" : hostSelector + "[data-render-mode=\"shadow\"] [part='help-text visible']")), shadowSelector, " {font-size: var(--sds-c-inputtext-helptext-font-size, var(--sds-s-helptext-font-size));color: var(--sds-c-inputtext-helptext-text-color, var(--sds-s-helptext-text-color));padding-inline-start: var(\n --sds-c-inputtext-helptext-spacing-inlinestart,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-inline-end: var(\n --sds-c-inputtext-helptext-spacing-inlineend,\n var(--sds-c-inputtext-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-block-start: var(\n --sds-c-inputtext-helptext-spacing-blockstart,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );padding-block-end: var(\n --sds-c-inputtext-helptext-spacing-blockend,\n var(--sds-c-inputtext-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) {" : hostSelector + "[disabled][data-render-mode=\"shadow\"] {")), "--sds-c-inputtext-color-background: var(\n --sds-c-inputtext-color-background-disabled,\n var(--sds-s-input-color-background-disabled)\n );--sds-c-inputtext-color-border: var(\n --sds-c-inputtext-color-border-disabled,\n var(--sds-s-input-color-border-disabled)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][label-hidden]) [part='label-container']" : hostSelector + "[label-hidden][data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--slds-c-icon-color-foreground: var(\n --slds-c-inputtext-icon-color-foreground,\n var(--slds-g-color-on-surface-1)\n );--slds-c-icon-sizing: var(--slds-c-inputtext-icon-sizing, 14px);--sds-c-inputtext-sizing-height: var(\n --slds-c-inputtext-sizing-height,\n var(--slds-g-sizing-9)\n );--sds-c-inputtext-color-background: var(\n --slds-c-inputtext-color-background,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-color-background-focus: var(\n --slds-c-inputtext-color-background-focus,\n var(--slds-g-color-surface-container-1)\n );--sds-c-inputtext-text-color: var(--slds-c-inputtext-text-color);--sds-c-inputtext-font-size: var(\n --slds-c-inputtext-font-size,\n var(--slds-g-font-size-base)\n );--sds-c-inputtext-text-color-placeholder: var(\n --slds-c-inputtext-text-color-placeholder,\n var(--slds-g-color-on-surface-1)\n );--sds-c-inputtext-color-border: var(\n --slds-c-inputtext-color-border,\n var(--slds-g-color-border-2)\n );--sds-c-inputtext-sizing-border: var(--slds-c-inputtext-sizing-border);--sds-c-inputtext-radius-border: var(\n --slds-c-inputtext-radius-border,\n var(--slds-g-radius-border-2)\n );display: flex;flex-wrap: wrap;flex-direction: column;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {flex: 1 0 100%;align-items: stretch;--sds-c-inputtext-spacing-inline: 0;--sds-c-inputtext-spacing-block: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']")), shadowSelector, " {border: none;display: inline-block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " .slds-input__icon:not(button)", shadowSelector, " {pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input'][type='range']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input'][type='range']")), shadowSelector, " {min-height: calc(1.875rem + (1px * 2));margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='input-container'][type='range']:active" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:focus-within" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='input-container'][type='range']:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 3px var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;border-width: var(--sds-c-inputtext-sizing-border, var(--slds-g-sizing-border-1));border-color: var(--sds-c-inputtext-color-border, var(--slds-g-color-border-2));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {padding-inline-start: var(\n --slds-c-inputtext-spacing-inlinestart,\n var(--slds-g-spacing-3));padding-inline-end: var(\n --slds-c-inputtext-spacing-inlineend,\n var(--slds-g-spacing-4));height: unset;font-family: var(--slds-g-font-family);}", ((useActualHostSelector ? ":host(:not([disabled])) [part=\"input-container\"]:focus-within" + shadowSelector + ", :host(:not([disabled])) [part=\"input-container\"]:active" : hostSelector + ":not([disabled]) [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + ":not([disabled]) [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-border-accent-1);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: var(--slds-g-color-surface-container-1);outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part='input-text']" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-spacing-inline-start-readonly: 0;--sds-c-inputtext-color-border-focus: transparent;--slds-c-inputtext-color-border: transparent;--slds-c-inputtext-color-background: transparent;--slds-c-inputtext-color-background-focus: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:focus-within" + shadowSelector + ",:host([data-render-mode=\"shadow\"][readonly]) [part=\"input-container\"]:active" : hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:focus-within" + shadowSelector + "," + hostSelector + "[readonly][data-render-mode=\"shadow\"] [part=\"input-container\"]:active")), shadowSelector, " {--sds-c-inputtext-color-border: var(--slds-g-color-disabled-container-2);--sds-c-inputtext-shadow: 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-accent-2);--sds-c-inputtext-color-background: transparent;outline: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-text']" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-shadow: 0 0 0 var(--slds-g-sizing-border-1) inset\n var(--slds-g-color-error-1);--slds-c-inputtext-color-border: var(--slds-g-color-border-error-1);--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-input-has-icon" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " {--slds-c-input-color-background: var(--slds-s-input-color-background-invalid);--slds-c-input-color-border: var(--slds-g-color-border-error-1);--slds-c-input-text-color: var(--slds-s-input-color-invalid);background-clip: padding-box;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) input[type=\"search\"]" : hostSelector + "[invalid][data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {fill: var(--slds-g-color-error-1);color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='input-container']:focus-within" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='input-container']:focus-within")), shadowSelector, " {--sds-c-inputtext-shadow:\n var(--slds-g-color-error-base-50) 0 0 0 var(--slds-g-sizing-border-1) inset,\n 0 0 var(--slds-g-sizing-border-3) var(--slds-g-color-border-error-1);--sds-c-inputtext-color-border: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-container']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][disabled]) [part='input']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-container']" + shadowSelector + "," + hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input']")), shadowSelector, " {cursor: not-allowed;--sds-c-inputtext-color-background: var(--slds-s-input-color-background-disabled, var(--slds-g-color-disabled-container-1));--sds-c-inputtext-color-border: var(--slds-g-color-border-disabled-1);--sds-c-inputtext-text-color: var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='input-text']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {--sds-c-inputtext-text-color-placeholder:\n var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-text']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " [part='label']", shadowSelector, " {padding-block-start: var(--slds-g-spacing-1);padding-inline-end: var(--slds-g-spacing-2);color: var(\n --slds-c-inputtext-label-color,\n var(--slds-g-color-on-surface-2)\n );margin-block-end: var(--slds-g-sizing-1);display: inline-flex;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='start']" : hostSelector + "[data-render-mode=\"shadow\"] [part='start']")), shadowSelector, " {--slds-c-icon-spacing-inlineend: var(--slds-g-spacing-2);}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-text']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-text']")), shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='label']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='label']")), shadowSelector, " {float: left;max-width: calc(33% - 1.125rem);padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-container']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-container']")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='inline-help']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='inline-help']")), shadowSelector, " {float: left;padding-block-start: var(--slds-g-spacing-1);}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) input[type=\"search\"]" : hostSelector + "[data-render-mode=\"shadow\"] input[type=\"search\"]")), shadowSelector, " + lightning-primitive-icon", shadowSelector, "::part(icon) {left: var(--slds-g-spacing-3);fill: var(--slds-g-color-on-surface-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {background-color: transparent;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon" + shadowSelector + " .slds-button_icon:focus" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-button_icon:hover", shadowSelector, " {--slds-c-icon-color-foreground: var(--slds-g-color-accent-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon")), shadowSelector, " .slds-input__icon", shadowSelector, " {width: 0.875rem;height: 0.875rem;position: absolute;top: 50%;margin-top: -0.4375rem;line-height: 1;border: 0;z-index: 2;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_left", shadowSelector, " {inset-inline-start: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right")), shadowSelector, " {--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_right" + shadowSelector + " .slds-input__icon" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " .slds-input__icon_right", shadowSelector, " {inset-inline-end: var(--slds-g-spacing-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-input-has-icon_left-right" : hostSelector + "[data-render-mode=\"shadow\"] .slds-input-has-icon_left-right")), shadowSelector, " {--slds-c-inputtext-spacing-inlinestart: var(--slds-g-spacing-6);--slds-c-inputtext-spacing-inlineend: var(--slds-g-spacing-6);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}"].join('');
      /*LWC compiler v7.1.5*/
    }
    var stylesheet1$1 = [stylesheet$1];

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) fieldset" : hostSelector + "[data-render-mode=\"shadow\"] fieldset")), shadowSelector, " {border: 0;margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {position: relative;min-width: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;hyphens: auto;display: inline-block;color: var(--slds-g-color-on-surface-2);font-size: var(--slds-s-label-font-size, var(--slds-g-font-scale-neg-2));padding-inline-end: var(--slds-g-spacing-2);padding-block-start: var(--slds-g-spacing-1);margin-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label:empty")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {clear: inline-start;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-radio", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {display: inline-block;position: relative;padding-block-start: var(--slds-g-spacing-1);vertical-align: top;line-height: var(--slds-g-font-lineheight-1);z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-form-element__helper" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__helper")), shadowSelector, " {font-size: var(--slds-s-helptext-font-size, var(--slds-g-font-scale-neg-2));margin-block-start: calc(var(--slds-g-spacing-1) / 2);display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_edit")), shadowSelector, " .slds-form-element__static", shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " {flex-basis: 0%;border-bottom: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__label", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__legend" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__legend")), shadowSelector, " {font-weight: var(--slds-g-font-weight-7);float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__addon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__addon")), shadowSelector, " {display: inline-block;margin-block-start: 0;margin-block-end: 0;margin-inline-start: var(--slds-g-spacing-2);margin-inline-end: var(--slds-g-spacing-2);align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;word-break: break-word;display: inline-block;font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-neutral-base-10);width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static.slds-text-longform" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static.slds-text-longform")), shadowSelector, " *:last-child", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static:empty")), shadowSelector, " {min-height: calc(var(--slds-g-sizing-6) + 1px);vertical-align: bottom;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static--edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static--edit")), shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-required" : hostSelector + "[data-render-mode=\"shadow\"] .slds-required")), shadowSelector, " {color: var(--slds-g-color-error-1);margin-block-start: 0;margin-block-end: 0;margin-inline-start: calc(var(--slds-g-spacing-1) / 2);margin-inline-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-form-element__help", shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-form-element__help" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) {" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {padding: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__label" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__label" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {width: 100%;flex-basis: 100%;clear: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__icon" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {float: none;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline'].slds-form-element_horizontal) {" : hostSelector + ".slds-form-element_horizontal[variant='label-inline'][data-render-mode=\"shadow\"] {")), "padding: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']).slds-is-edited {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"].slds-is-edited {")), "padding-block-start: var(--slds-g-sizing-6)}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__label" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {float: inline-start;max-width: calc(33% - var(--slds-g-sizing-6));flex-basis: calc(33% - var(--slds-g-sizing-6));flex-grow: 1;margin-block-end: 0;position: relative;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) lightning-helptext" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] lightning-helptext")), shadowSelector, " {float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {margin-inline-start: 33%;clear: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list__column" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list__column")), shadowSelector, " .slds-form-element__label", shadowSelector, " {width: auto;max-width: 100%;flex-basis: auto;float: none;position: relative;padding-inline-start: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__help" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list")), shadowSelector, " {clear: none;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " {display: flex;margin-bottom: var(--slds-g-spacing-1);margin-left: calc(var(--slds-g-spacing-1) * -1);margin-right: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " .slds-form-element__label", shadowSelector, " {padding-top: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element", shadowSelector, " {padding-left: var(--slds-g-spacing-1);padding-right: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_address" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_address")), shadowSelector, " .slds-form-element__row", shadowSelector, " {align-items: flex-end;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-hidden']) .slds-form-element__label" : hostSelector + "[variant='label-hidden'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {display: none}"].join('');
      /*LWC compiler v7.1.5*/
    }
    var stylesheet2 = [stylesheet];

    var stylesheet1 = [stylesheet0__default.default, stylesheet1$1, stylesheet2];

    var _implicitStylesheets = [stylesheet0, stylesheet1];

    const $fragment1 = lwc.parseFragment`<abbr class="slds-required${0}"${"a0:title"}${2}>*</abbr>`;
    const $fragment2 = lwc.parseFragment`<input${"a0:accesskey"}${"a0:aria-haspopup"}${"a0:aria-invalid"}${"a0:aria-label"}${"a0:aria-keyshortcuts"}${"a0:aria-disabled"}${"a0:aria-roledescription"}${"a0:aria-autocomplete"}${"a0:aria-expanded"}${"a0:autocomplete"} class="slds-input${0}"${"a0:disabled"}${"a0:id"}${"a0:inputmode"}${"a0:max"}${"a0:maxlength"}${"a0:min"}${"a0:minlength"}${"a0:name"}${"a0:role"} part="input"${"a0:pattern"}${"a0:placeholder"}${"a0:required"}${"a0:readonly"}${"a0:step"}${"a0:type"}${2}>`;
    const $fragment3 = lwc.parseFragment`<div role="status" class="slds-spinner slds-spinner_brand slds-spinner_x-small slds-input__spinner${0}"${2}><span class="slds-assistive-text${0}"${2}>${"t2"}</span><div class="slds-spinner__dot-a${0}"${2}></div><div class="slds-spinner__dot-b${0}"${2}></div></div>`;
    const $fragment4 = lwc.parseFragment`<span class="slds-assistive-text${0}"${2}>${"t1"}</span>`;
    const $fragment5 = lwc.parseFragment`<span class="slds-assistive-text${0}"${2}>${"t1"}</span>`;
    const stc0 = {
      attrs: {
        "part": "input-text"
      },
      ref: "container",
      key: 0
    };
    const stc1 = {
      attrs: {
        "name": "label-end"
      },
      key: 4
    };
    const stc2 = [];
    const stc3 = {
      props: {
        "iconName": "utility:search",
        "variant": "bare",
        "svgClass": "slds-input__icon slds-input__icon_left slds-icon-text-default"
      },
      key: 9
    };
    const stc4 = {
      classMap: {
        "slds-input__icon-group": true,
        "slds-input__icon-group_right": true
      },
      key: 10
    };
    const stc5 = {
      "slds-input__icon": true,
      "slds-input__icon_right": true,
      "slds-button": true,
      "slds-button_icon": true
    };
    const stc6 = {
      "data-element-id": "searchClear"
    };
    const stc7 = {
      props: {
        "iconName": "utility:clear",
        "variant": "bare",
        "svgClass": "slds-button__icon"
      },
      key: 14
    };
    const stc8 = {
      "slds-form-element__help": true
    };
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {ncls: api_normalize_class_name, gid: api_scoped_id, sp: api_static_part, st: api_static_fragment, d: api_dynamic_text, t: api_text, s: api_slot, h: api_element, c: api_custom_element, b: api_bind} = $api;
      const {_m0, _m1, _m2, _m3, _m4, _m5, _m6, _m7, _m8, _m9, _m10, _m11} = $ctx;
      return [api_element("div", stc0, [!$cmp.hasExternalLabel ? api_element("label", {
        className: api_normalize_class_name($cmp.computedLabelClass),
        attrs: {
          "for": api_scoped_id("input"),
          "part": "label"
        },
        key: 1
      }, [$cmp.required ? api_static_fragment($fragment1, 3, [api_static_part(0, {
        attrs: {
          "title": $cmp.i18n.required
        }
      }, null)]) : null, api_text(api_dynamic_text($cmp.label)), api_slot("label-end", stc1, stc2, $slotset)]) : null, !$cmp.hasExternalLabel ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext__default.default, {
        props: {
          "content": $cmp.fieldLevelHelp,
          "alternativeText": $cmp.helptextAlternativeText
        },
        key: 5
      }) : null : null, api_element("div", {
        className: api_normalize_class_name($cmp.computedFormElementClass),
        attrs: {
          "part": "input-container",
          "type": $cmp.internalType
        },
        key: 6
      }, [api_static_fragment($fragment2, 8, [api_static_part(0, {
        on: {
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
          "change": _m6 || ($ctx._m6 = api_bind($cmp.handleChange)),
          "focus": _m7 || ($ctx._m7 = api_bind($cmp.handleFocus)),
          "input": _m8 || ($ctx._m8 = api_bind($cmp.handleInput)),
          "keydown": _m9 || ($ctx._m9 = api_bind($cmp.handleKeyDown))
        },
        attrs: {
          "accesskey": $cmp.accessKey,
          "aria-haspopup": $cmp.ariaHasPopup,
          "aria-invalid": $cmp.ariaInvalid,
          "aria-label": $cmp.ariaLabel,
          "aria-keyshortcuts": $cmp.ariaKeyShortcuts,
          "aria-disabled": $cmp.ariaDisabled,
          "aria-roledescription": $cmp.ariaRoleDescription,
          "aria-autocomplete": $cmp.ariaAutoComplete,
          "aria-expanded": $cmp.ariaExpanded,
          "autocomplete": $cmp.autocomplete,
          "disabled": $cmp.disabled ? "" : null,
          "id": api_scoped_id("input"),
          "inputmode": $cmp.inputMode,
          "max": $cmp.max,
          "maxlength": $cmp.maxLength,
          "min": $cmp.min,
          "minlength": $cmp.minLength,
          "name": $cmp.name,
          "role": $cmp.role,
          "pattern": $cmp.pattern,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required ? "" : null,
          "readonly": $cmp.readOnly ? "" : null,
          "step": $cmp.step,
          "type": $cmp.internalType
        }
      }, null)]), $cmp.isTypeSearch ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon__default.default, stc3) : null, $cmp.isTypeSearch ? api_element("div", stc4, [$cmp.isLoading ? api_static_fragment($fragment3, 12, [api_static_part(2, null, api_dynamic_text($cmp.i18n.loading))]) : null, $cmp.showClearButton ? api_element("button", {
        classMap: stc5,
        attrs: stc6,
        key: 13,
        on: {
          "blur": _m10 || ($ctx._m10 = api_bind($cmp.handleBlur)),
          "click": _m11 || ($ctx._m11 = api_bind($cmp.clearAndSetFocusOnInput))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon__default.default, stc7), api_static_fragment($fragment4, 16, [api_static_part(1, null, api_dynamic_text($cmp.i18n.clear))])]) : null]) : null])]), api_element("div", {
        classMap: stc8,
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": "",
          "part": "help-text",
          "role": "status"
        },
        key: 17
      }, [$cmp._helpMessage ? api_static_fragment($fragment5, 19, [api_static_part(1, null, api_dynamic_text($cmp.label))]) : null, $cmp._helpMessage ? api_text(api_dynamic_text($cmp._helpMessage)) : null])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = ["label-end"];
    tmpl.hasRefs = true;
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-enmikoh2qu";
    tmpl.legacyStylesheetToken = "lightning-primitiveInputSimple_primitiveInputSimple";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    function normalizeDate(value) {
      return internationalizationLibrary.normalizeISODate(value, 'medium').isoValue || '';
    }

    // Converts value to the user's timezone and formats it in a way that will be accepted by the input
    function normalizeUTCDateTime(value, timezone) {
      return internationalizationLibrary.normalizeISODateTime(value, timezone).isoValue || '';
    }
    function normalizeTime(value) {
      return internationalizationLibrary.normalizeISOTime(value, 'short').isoValue || '';
    }

    // parses the input value and converts it back to UTC from the user's timezone
    function normalizeDateTimeToUTC(value, timezone) {
      return internationalizationLibrary.normalizeFormattedDateTime(value, timezone) || '';
    }

    /**
     * Purges the selection cache to the DOM.
     * @param input {HTMLInputElement}
     * @param cache {InputSelectionCache}
     */
    function restoreCacheToInput(input, cache) {
      input.setSelectionRange(cache._selectionStartCached, cache._selectionEndCached);
      cache.clearCache();
    }

    /**
     * This class provides a way to cache text selection in input fields.
     */
    class InputSelectionCache {
      constructor() {
        /**
         * Cached value for selectionStart
         * @type {number|null}
         */
        this._selectionStartCached = null;
        /**
         * Cached value for selectionEnd
         * @type {number|null}
         */
        this._selectionEndCached = null;
      }
      /**
       * Updates the cached values.
       * @param {number} start The start of the selected range
       * @param {number} end The end of the selected range
       * @private
       */
      _cacheSelectionRange(start, end) {
        if (typeof start === 'number' && typeof end === 'number') {
          this._selectionStartCached = start;
          this._selectionEndCached = end;
        }
      }

      /**
       * Clears our cached selection.
       */
      clearCache() {
        this._selectionStartCached = null;
        this._selectionEndCached = null;
      }

      /**
       * True, if the DOM element has selection.
       * @param input {HTMLInputElement} The DOM element to operate on
       */
      hasSelection(input) {
        return input.selectionStart !== null &&
        // If the start and end are the same, that's not selection, it's just the cursor position.
        input.selectionStart !== input.selectionEnd;
      }

      /**
       * True, if selection has been cached.
       */
      isCached() {
        return this._selectionStartCached !== null && this._selectionEndCached !== null;
      }

      /**
       * Cache the current text selection for this input field.
       * We ignore selection range of (0,0) because that indicates no selection and we don't want to restore it later.
       * @param input {HTMLInputElement} The DOM element to operate on
       */
      preserve(input) {
        if (!this.hasSelection(input) && this.isCached()) {
          // We already have cached selection but we're asking to preserve no selection,
          // so we must NOT overwrite our cache with no selection or we can't restore the previously selected text.
          // This happens if the browser doesn't preserve text selection automatically in the input.
          return;
        }

        // Only update cache if there is selection.
        if (this.hasSelection(input)) {
          this._cacheSelectionRange(input.selectionStart, input.selectionEnd);
        }
      }

      /**
       * Restore cached selection. This may happen async, so a promise is returned.
       * @param input {HTMLInputElement} The DOM element to operate on
       * @returns {Promise} A promise to be resolved when the selection is restored.
       *  If the cache was empty, the promise is resolved immediately as a no-op.
       */
      restore(input) {
        // Bail early if we don't have a cached selection.
        if (!this.isCached()) {
          return Promise.resolve();
        }

        // @W-7962838 - Safari has a browser bug where setting the selection on inputs
        // as you focus them keeps it from scrolling into view in certain conditions.
        // This can be worked around by setting the text selection in a new call stack immediately after the focus.
        // https://bugs.webkit.org/show_bug.cgi?id=217350
        if (utilsPrivate.isSafari) {
          return utilsPrivate.timeout(0).then(() => {
            // running async, so revalidate our inputs
            if (this.isCached() && input) {
              restoreCacheToInput(input, this);
            }
          });
        }

        // W-6176985: IE11 input when set value, will move cursor to beginning.
        // This fix is only for input type=number on IE11, and force the cursor to the end.
        if (utilsPrivate.isIE11) {
          const length = input.value.length;
          input.setSelectionRange(length, length);
          return Promise.resolve();
        }
        restoreCacheToInput(input, this);
        return Promise.resolve();
      }
    }

    function normalizeInput(value) {
      if (typeof value === 'number' || typeof value === 'string') {
        return String(value);
      }
      return '';
    }

    const i18n = {
      required: labelRequired__default.default,
      clear: labelClearInput__default.default,
      loading: labelLoadingIndicator__default.default
    };
    const VALID_NUMBER_FORMATTERS = ['decimal', 'percent', 'percent-fixed', 'currency'];
    const DEFAULT_FORMATTER = VALID_NUMBER_FORMATTERS[0];
    class LightningPrimitiveInputSimple extends LightningShadowBaseClass__default.default {
      getHelpMessageElement() {
        return this.template.querySelector('[data-help-message]');
      }
      get ariaDescribedByElements() {
        return this.getHelpMessageElement();
      }
      get ariaErrorMessageElements() {
        return this.getHelpMessageElement();
      }
      get isNativeShadow() {
        return this._isNativeShadow;
      }
      get type() {
        return this._type;
      }
      set type(value) {
        const normalizedValue = utilsPrivate.normalizeString(value);
        this._type = normalizedValue;
        if (this._rendered) {
          // The type is being changed after render, which means the input element may be different (eg. changing
          // from text to 'checkbox', so we need to set the initial value again
          this._initialValueSet = false;
          if (this.isTypeNumber) {
            // If the type has changed, we need to re-parse the value as a number
            this.updateNumberValue(this._value);
          }
        }
      }
      get formatter() {
        return this._formatter;
      }
      set formatter(value) {
        this._formatter = utilsPrivate.normalizeString(value, {
          fallbackValue: DEFAULT_FORMATTER,
          validValues: VALID_NUMBER_FORMATTERS
        });
        this.updateInputDisplayValueIfTypeNumber();
      }
      get formatFractionDigits() {
        return this._formatFractionDigits;
      }
      set formatFractionDigits(value) {
        this._formatFractionDigits = value;
        if (this._rendered && this.isTypeNumber) {
          this.setInputValue(this.displayedValue);
        }
      }
      get step() {
        return this._step;
      }
      set step(value) {
        // 'value' has already been normalized in lightning-input
        this._step = value;

        // Displayed value depends on the format number, so if we're not showing the raw
        // number we should update the value
        if (this._rendered && this.isTypeNumber && !this._showRawNumber && this.inputElement) {
          this.setInputValue(this.displayedValue);
        }
      }
      get helpMessage() {
        return this._helpMessage;
      }
      set helpMessage(message) {
        this._helpMessage = message;
        utilsPrivate.reflectAttribute(this, 'invalid', !!message);
      }
      get value() {
        return this._value;
      }
      set value(value) {
        const previousValue = this._value;
        this._value = normalizeInput(value);
        if (this._rendered) {
          this.validity.badInput;
          if (this.isTypeNumber) {
            this._value = numberUtils.stringifyNumber(value);
            // the extra check for whether the value has changed is done for cases
            // when the same value is set back in a change handler, this is to avoid
            // the raw number from changing formatting under the user
            // (eg. if the user typed 1,000 we want to preserve that formatting as the user
            // types the value)
            if (this._value !== previousValue) {
              this.updateNumberValue(value);
            }
          }

          // Note: The input element itself isn't actually updated during this setter. Instead, lightning-input
          // silently updates the input element with the new value from outside this component. No input/change
          // event is fired, so this is the only place we can update the flag and trust lightning-input to do the
          // right thing.
          this.reflectPopulatedState();
        }
      }
      get inputElement() {
        if (!this.cachedInputElement) {
          let inputElement = this.template.querySelector('input');
          this.cachedInputElement = inputElement;
        }
        return this.cachedInputElement;
      }
      getDisplayedValue() {
        if (this.isTypeNumber) {
          // When only a symbol is entered by the user, set the display value as the user's input.
          // This will not affect the value dispatched by input via the change event, as it only dispatches a valid decimal number.
          // Due to the above, in integrations like input-field, the user's initial input of a symbol
          // like a minus sign will not be overwritten by an empty string value.
          // See description in PR for more details: https://github.com/salesforce-experience-platform/lightning-components/pull/3843
          if (this.inputElement.value.length === 1 && numberUtils.hasValidNumberSymbol(this.inputElement.value)) {
            return this.inputElement.value;
          }

          // If the number is not valid (bad input, step mismatch, etc.) show the raw number as
          // well, otherwise the formatted value ends up being 'NaN' which makes it hard to
          // see mistakes
          if (this._showRawNumber || !this.validity.valid) {
            if (numberUtils.hasValidNumberShortcut(this._numberRawValue) && numberUtils.isValidNumber(this._numberRawValue)) {
              this._numberRawValue = numberUtils.fromIsoDecimal(this._value);
            }
            return this._numberRawValue;
          }
          return numberUtils.formatNumber(this._value, this.buildFormatNumberOptions(this.formatter));
        }
        if (this.isTypeMobileDate || this.isTypeMobileDateTime || this.isTypeMobileTime) {
          return this.normalizeDateTimeString(this._value);
        }
        return this._value;
      }
      getNumberRawValue() {
        return this._numberRawValue;
      }

      /********* PRIVATE VARIABLES *********/

      /********* EVENT HANDLERS *********/
      handleFocus(event) {
        event.stopPropagation();
        if (this._rendered && this.isTypeNumber) {
          this._showRawNumber = true;
          this._selectionCache.preserve(this.inputElement);
          this.inputElement.value = this.displayedValue;
          this._selectionCache.restore(this.inputElement);
        }
        this.dispatchEvent(new CustomEvent('focus'));
      }
      handleBlur(event) {
        event.stopPropagation();
        if (this.validity.valid) {
          this._showRawNumber = false;
        }
        this.dispatchEvent(new CustomEvent('blur'));
      }
      handleKeyDown(event) {
        if (this.isTypeNumber) {
          // we're letting "Shift" through to prevent capital letters, other special symbols for type="number"
          const hasMetaOrCtrlModifier = event.metaKey || event.ctrlKey;
          // need to check that event.key is valid for "autofill" cases
          if (!hasMetaOrCtrlModifier && !this.readOnly && event.key) {
            const key = utilsPrivate.normalizeKeyValue(event.key);
            if (key.length === 1 && !numberUtils.isValidNumberCharacter(key)) {
              event.preventDefault();
            }
            if (key === 'ArrowUp') {
              event.preventDefault();
              this.numberStepUpAndDispatchEvents(1);
            } else if (key === 'ArrowDown') {
              event.preventDefault();
              this.numberStepUpAndDispatchEvents(-1);
            }
          }
        }
      }
      handleInput(event) {
        event.stopPropagation();
        if (this.isTypeNumber) {
          // for invalid numbers the value might stay the same as the user
          // changed the invalid input, so we need to update the raw value
          this._numberRawValue = this.inputElement.value;
        }
        if (this.value === event.target.value) {
          return;
        }
        this.dispatchChangeEvent();
        this.reflectPopulatedState();
      }
      handleChange(event) {
        event.stopPropagation();
        this.dispatchCommitEvent();
        if (this.value === event.target.value) {
          return;
        }
        this.dispatchChangeEvent();
      }

      /**
       * Handle text selection.
       * Dynamically bound to the select event by `renderedCallback`.
       * This allows us to cache text selection in Safari, which doesn't preserve selection.
       */
      handleSelect() {
        if (utilsPrivate.isSafari) {
          this._selectionCache.preserve(this.inputElement);
        }
      }

      /********* EVENT DISPATCHERS *********/

      dispatchCommitEvent() {
        this.dispatchEvent(new CustomEvent('commit'));
      }
      dispatchChangeEvent() {
        // this.interactingState.enter(); // Check for all instances of this and migrate

        const detail = {};

        // the mobile input time/date/datetime components use `primitive-input-simple`
        if (this.isTypeNumber) {
          this._numberRawValue = this.inputElement.value;
          detail.value = numberUtils.toIsoDecimal(this.inputElement.value);
        } else if (this.isTypeMobileDateTime) {
          detail.value = normalizeDateTimeToUTC(this.inputElement.value, this.timezone);
        } else if (this.isTypeMobileTime) {
          detail.value = normalizeTime(this.inputElement.value);
        } else {
          detail.value = this.inputElement.value;
        }

        // this._updateValueAndValidityAttribute(detail.value); > check this

        this._value = detail.value;
        // this._updateProxyInputAttributes('value');

        this.dispatchChangeEventWithDetail(detail);
      }
      dispatchChangeEventWithDetail(detail) {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail
        }));
      }

      /********* TYPE GETTERS *********/
      /**
       * Gets the value for the actual 'type' attribute on the input element.
       */
      get internalType() {
        // Maps number->text to support shorthand input strings like '1k'.
        if (this.isTypeNumber || this.isTypeEmail) {
          return 'text';
        }
        return this.type;
      }
      get isTypeNumber() {
        return this.type === 'number';
      }
      get isTypeEmail() {
        // To test against native change this to type="emails"
        return this.type === 'email';
      }
      get isTypeSearch() {
        return this.type === 'search';
      }
      get isTypeText() {
        return this.type === 'text';
      }

      // the types below are used for the mobile input date/datetime/time components

      get isTypeDate() {
        return this.type === 'date';
      }
      get isTypeDateTime() {
        return this.type === 'datetime' || this.type === 'datetime-local';
      }
      get isTypeTime() {
        return this.type === 'time';
      }
      get isTypeMobileDate() {
        return this.isTypeDate && !utilsPrivate.isDesktopBrowser();
      }
      get isTypeMobileTime() {
        return this.isTypeTime && !utilsPrivate.isDesktopBrowser();
      }
      get isTypeMobileDateTime() {
        return this.isTypeDateTime && !utilsPrivate.isDesktopBrowser();
      }

      /***** GETTERS *****/

      get showClearButton() {
        return this.isTypeSearch && utilsPrivate.isNotUndefinedOrNull(this._value) && this._value !== '';
      }
      get inputMode() {
        if (this.isTypeNumber) {
          return 'decimal';
        } else if (this.isTypeEmail) {
          return 'email';
        }
        return null;
      }
      get displayedValue() {
        if (this.isTypeNumber) {
          return this.getDisplayedValue();
        }

        // the mobile input time/date/datetime components use `primitive-input-simple`
        if (this.isTypeMobileTime || this.isTypeMobileDate || this.isTypeMobileDateTime) {
          return this.normalizeDateTimeString(this._value, this.timezone);
        }
        return this._value;
      }
      normalizeDateTimeString(value) {
        if (this.isTypeDate) {
          return normalizeDate(value);
        } else if (this.isTypeTime) {
          return normalizeTime(value);
        } else if (this.isTypeDateTime) {
          return normalizeUTCDateTime(value, this.timezone);
        }
        return value;
      }
      get i18n() {
        return i18n;
      }
      get computedFormElementClass() {
        return this.isTypeSearch ? 'slds-form-element__control slds-grow slds-input-has-icon slds-input-has-icon_left-right' : 'slds-form-element__control slds-grow';
      }

      /********* NUMBER *********/

      updateNumberValue(value) {
        const newValue = numberUtils.stringifyNumber(value);
        this._value = newValue;
        this._numberRawValue = numberUtils.fromIsoDecimal(newValue);
      }

      /**
       * Increases (if increment is positive, decreases otherwise) the number value of the input by the increment
       * multiple of the given 'step'. Additionally dispatches the 'change' and 'commit' events.
       *
       * @param {Number} increment A multiple of the step to increase, when step is 'any',
       * the step is assumed to be 1.
       * @private
       */
      numberStepUpAndDispatchEvents(increment) {
        if (this._readOnly || this._disabled) {
          return;
        }
        this._value = numberUtils.increaseNumberByStep({
          value: this._value,
          step: this.step,
          increment,
          fractionDigits: this.buildFormatNumberOptions(this.formatter).minimumFractionDigits
        });

        // Raw value is the value the user entered (we preserve a user's input),
        // since we're generating a new value we're overriding it
        this._numberRawValue = numberUtils.fromIsoDecimal(this._value);
        this.setInputValue(this.displayedValue);
        this.dispatchChangeEvent();
        this.dispatchCommitEvent();
      }
      buildFormatNumberOptions(formatter) {
        const options = {
          style: formatter
        };
        // Use the min/max fraction digits from the formatFractionDigits provided by the user if available.
        // Otherwise, use the number of digits calculated from step
        if (this._formatFractionDigits !== undefined) {
          options.minimumFractionDigits = this._formatFractionDigits;
          options.maximumFractionDigits = this._formatFractionDigits;
        } else {
          let digitsFromStep = numberUtils.calculateFractionDigitsFromStep(this._step);
          // if formatting percentages, when calculating digits from step, take into
          // consideration that the formatted number is effectively multiplied by 10^2, ie. 0.1 is 10%
          // so we need to subtract 2 digits;
          if (formatter === 'percent' && typeof digitsFromStep === 'number') {
            digitsFromStep -= 2;
            if (digitsFromStep < 0) {
              digitsFromStep = 0;
            }
          }
          options.minimumFractionDigits = digitsFromStep;
          options.maximumFractionDigits = digitsFromStep;
        }
        return options;
      }
      updateInputDisplayValueIfTypeNumber() {
        // Displayed value depends on the format number, so if we're not showing the raw
        // number we should update the value
        if (this._rendered && this.isTypeNumber && !this._showRawNumber && this.inputElement) {
          this.setInputValue(this.displayedValue);
        }
      }

      /** ---- */

      clearAndSetFocusOnInput(event) {
        // TODO: Discuss this, it seems the wrong thing to do.
        // button is removed from template, but
        // event still is propagated, For example, captured by panel,
        // then cause panel think is clicked outside.
        event.stopPropagation();
        this.setInputValue('');
        this._value = '';
        // this._updateValueAndValidityAttribute('');

        this.inputElement.focus();
        this.dispatchChangeEventWithDetail({
          value: this._value
        });
        this.dispatchCommitEvent();
      }
      setInputValue(value) {
        // set value without dispatching an 'input' event
        utilsPrivate.setDecoratedDragonInputValueWithoutEvent(this.inputElement, value);
        this.reflectPopulatedState();
      }
      reflectPopulatedState() {
        if (this.refs) {
          utilsPrivate.reflectAttribute(this.refs.container, 'populated', !inputUtils.isEmptyString(this._value) || !inputUtils.isEmptyString(this._numberRawValue));
        }
      }
      connectedCallback() {
        super.connectedCallback();
        if (this.isTypeNumber) {
          this.updateNumberValue(this._value);
        }

        // Using this mechanism to communicate to AriaObserver in lightning-input
        // that the primitive is in native shadow and it needs to copy content over
        this._isNativeShadow = utilsPrivate.isNativeComponent(this);
      }
      renderedCallback() {
        // For W-7962838: In Safari, focus doesn't scroll input into view.
        // Attach the event listener used to cache the selected text when selection changes.
        if (utilsPrivate.isSafari) {
          this.inputElement.addEventListener('select', this.handleSelect.bind(this));
        }
        if (!this._initialValueSet && this.inputElement) {
          this._rendered = true;
          if (this.isTypeNumber) {
            this._numberRawValue = numberUtils.fromIsoDecimal(this._value);
          }
          this.setInputValue(this.displayedValue);
          this._initialValueSet = true;
        }
        utilsPrivate.reflectAttribute(this, 'variant', this.variant);
        utilsPrivate.reflectAttribute(this, 'disabled', this.disabled);
        utilsPrivate.reflectAttribute(this, 'readonly', this.readOnly);
      }
      constructor() {
        super();

        // The selection cache allows us an input to remember what text was selected
        // in cases where we change the text on blur or in browsers (Safari) that
        // don't track it properly.
        this._type = void 0;
        this.hasExternalLabel = void 0;
        this.computedLabelClass = void 0;
        this.required = void 0;
        this.label = void 0;
        this.fieldLevelHelp = void 0;
        this.helptextAlternativeText = void 0;
        this.ariaHasPopup = void 0;
        this.accessKey = void 0;
        this.autocomplete = void 0;
        this.isLoading = void 0;
        this.max = void 0;
        this.min = void 0;
        this.maxLength = void 0;
        this.minLength = void 0;
        this.pattern = void 0;
        this.placeholder = void 0;
        this.name = void 0;
        this.readOnly = void 0;
        this.disabled = void 0;
        this.variant = void 0;
        this.validity = void 0;
        this.ariaLabel = void 0;
        this.ariaInvalid = void 0;
        this.timezone = void 0;
        this.ariaKeyShortcuts = void 0;
        this.ariaDisabled = void 0;
        this.ariaRoleDescription = void 0;
        this.ariaExpanded = void 0;
        this.ariaAutoComplete = void 0;
        this.role = void 0;
        this._formatter = DEFAULT_FORMATTER;
        this._showRawNumber = false;
        this._initialValueSet = false;
        this._rendered = void 0;
        this._selectionCache = void 0;
        this._helpMessage = void 0;
        this._step = void 0;
        this._numberRawValue = '';
        this._value = '';
        this._selectionCache = new InputSelectionCache();
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(LightningPrimitiveInputSimple, {
      publicProps: {
        hasExternalLabel: {
          config: 0
        },
        computedLabelClass: {
          config: 0
        },
        required: {
          config: 0
        },
        label: {
          config: 0
        },
        fieldLevelHelp: {
          config: 0
        },
        helptextAlternativeText: {
          config: 0
        },
        ariaHasPopup: {
          config: 0
        },
        accessKey: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        isLoading: {
          config: 0
        },
        max: {
          config: 0
        },
        min: {
          config: 0
        },
        maxLength: {
          config: 0
        },
        minLength: {
          config: 0
        },
        pattern: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        name: {
          config: 0
        },
        readOnly: {
          config: 0
        },
        disabled: {
          config: 0
        },
        variant: {
          config: 0
        },
        validity: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        ariaInvalid: {
          config: 0
        },
        timezone: {
          config: 0
        },
        ariaKeyShortcuts: {
          config: 0
        },
        ariaDisabled: {
          config: 0
        },
        ariaRoleDescription: {
          config: 0
        },
        ariaExpanded: {
          config: 0
        },
        ariaAutoComplete: {
          config: 0
        },
        role: {
          config: 0
        },
        ariaDescribedByElements: {
          config: 1
        },
        ariaErrorMessageElements: {
          config: 1
        },
        isNativeShadow: {
          config: 1
        },
        type: {
          config: 3
        },
        formatter: {
          config: 3
        },
        formatFractionDigits: {
          config: 3
        },
        step: {
          config: 3
        },
        helpMessage: {
          config: 3
        },
        value: {
          config: 3
        },
        inputElement: {
          config: 1
        }
      },
      publicMethods: ["getDisplayedValue", "getNumberRawValue"],
      fields: ["_type", "_formatter", "_showRawNumber", "_initialValueSet", "_rendered", "_selectionCache", "_helpMessage", "_step", "_numberRawValue", "_value"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(LightningPrimitiveInputSimple, {
      tmpl: _tmpl,
      sel: "lightning-primitive-input-simple",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/primitiveInputCheckbox', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/helptext', 'lightning/utils', 'lightning/inputUtils', '@salesforce/label/LightningControl.required', 'lightning/shadowBaseClassPrivate', 'lightning/utilsPrivate'], (function (exports, lwc, stylesheet0$1, _lightningHelptext, utils, inputUtils, labelRequired, LightningShadowBaseClass, utilsPrivate) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var _lightningHelptext__default = /*#__PURE__*/_interopDefaultCompat(_lightningHelptext);
  var labelRequired__default = /*#__PURE__*/_interopDefaultCompat(labelRequired);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return ["*", shadowSelector, ",*", shadowSelector, "::before,*", shadowSelector, "::after {box-sizing: border-box;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='input-checkbox']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='input-checkbox']")), shadowSelector, " {display: inline-flex;align-items: center;gap: var(--sds-c-inputcheckbox-spacing-gap, var(--sds-s-input-spacing-gap));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']")), shadowSelector, " {display: inline-flex;align-items: center;justify-content: center;position: relative;background-color: var(--sds-c-inputcheckbox-color-background, var(--sds-s-input-color-background));box-shadow: var(--sds-c-inputcheckbox-shadow);width: var(--sds-c-inputcheckbox-sizing, 1rem);height: var(--sds-c-inputcheckbox-sizing, 1rem);border: var(--sds-c-inputcheckbox-sizing-border, var(--sds-s-input-sizing-border, 1px)) solid\n var(--sds-c-inputcheckbox-color-border, var(--sds-s-input-color-border, currentColor));border-radius: var(--sds-c-inputcheckbox-radius-border);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:has(:focus)" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:has(:focus)")), shadowSelector, " {--sds-c-inputcheckbox-shadow: var(\n --sds-c-inputcheckbox-shadow-focus,\n var(--sds-s-input-shadow-focus, revert)\n );--sds-c-inputcheckbox-color-background: var(\n --sds-c-inputcheckbox-color-background-focus,\n var(--sds-s-input-color-background-focus, revert)\n );--sds-c-inputcheckbox-color-border: var(\n --sds-c-inputcheckbox-color-border-focus,\n var(--sds-s-input-color-border-focus, revert)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:has(:checked)" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:has(:checked)")), shadowSelector, " {--sds-c-inputcheckbox-shadow: var(--sds-c-inputcheckbox-shadow-checked, revert);--sds-c-inputcheckbox-color-background: var(--sds-c-inputcheckbox-color-background-checked, revert);--sds-c-inputcheckbox-color-border: var(--sds-c-inputcheckbox-color-border-checked, revert);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:has(:indeterminate)" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:has(:indeterminate)")), shadowSelector, " {--sds-c-inputcheckbox-shadow: var(--sds-c-inputcheckbox-shadow-indeterminate, revert);--sds-c-inputcheckbox-color-background: var(--sds-c-inputcheckbox-color-background-indeterminate, revert);--sds-c-inputcheckbox-color-border: var(--sds-c-inputcheckbox-color-border-indeterminate, revert);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='mark']" : hostSelector + "[data-render-mode=\"shadow\"] [part='mark']")), shadowSelector, " {display: inline-flex;opacity: 0;color: var(--sds-c-inputcheckbox-mark-color-foreground, var(--sds-s-mark-color-foreground));background-color: var(--sds-c-inputcheckbox-mark-color-background, var(--sds-s-mark-color-background));width: var(--sds-c-inputcheckbox-mark-sizing, var(--sds-s-mark-sizing, 1em));height: var(--sds-c-inputcheckbox-mark-sizing, var(--sds-s-mark-sizing, 1em));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:has(:checked)" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:has(:checked)")), shadowSelector, " [part='mark']", shadowSelector, " {opacity: 1;--sds-c-inputcheckbox-mark-color-background: var(\n --sds-c-inputcheckbox-mark-color-background-checked,\n var(--sds-s-mark-color-background-checked, revert)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:has(:indeterminate)" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:has(:indeterminate)")), shadowSelector, " [part='mark']", shadowSelector, " {--sds-c-inputcheckbox-mark-color-foreground: var(\n --sds-c-inputcheckbox-mark-color-foreground-indeterminate,\n revert\n );--sds-c-inputcheckbox-mark-color-background: var(\n --sds-c-inputcheckbox-mark-color-background-indeterminate,\n revert\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part~='label']" : hostSelector + "[data-render-mode=\"shadow\"] [part~='label']")), shadowSelector, " {color: var(--sds-c-inputcheckbox-label-color, var(--sds-s-label-color));font-size: var(--sds-c-inputcheckbox-label-font-size, var(--sds-s-label-font-size));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][label-hidden]) [part~='label']" : hostSelector + "[label-hidden][data-render-mode=\"shadow\"] [part~='label']")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='help-text visible']" : hostSelector + "[data-render-mode=\"shadow\"] [part='help-text visible']")), shadowSelector, " {font-size: var(--sds-c-inputcheckbox-helptext-font-size, var(--sds-s-helptext-font-size));color: var(--sds-c-inputcheckbox-helptext-text-color, var(--sds-s-helptext-color));padding-inline-start: var(\n --sds-c-inputcheckbox-helptext-spacing-inlinestart,\n var(--sds-c-inputcheckbox-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-inline-end: var(\n --sds-c-inputcheckbox-helptext-spacing-inlineend,\n var(--sds-c-inputcheckbox-helptext-spacing-inline, var(--sds-s-helptext-spacing))\n );padding-block-start: var(\n --sds-c-inputcheckbox-helptext-spacing-blockstart,\n var(--sds-c-inputcheckbox-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );padding-block-end: var(\n --sds-c-inputcheckbox-helptext-spacing-blockend,\n var(--sds-c-inputcheckbox-helptext-spacing-block, var(--sds-s-helptext-spacing))\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) input[type='checkbox']" : hostSelector + "[data-render-mode=\"shadow\"] input[type='checkbox']")), shadowSelector, " {position: absolute;width: 100%;height: 100%;margin: 0;z-index: 1;opacity: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-checkbox']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-checkbox']")), shadowSelector, " {--_slds-c-inputcheckbox-shadow: var(--slds-c-checkbox-shadow);--_slds-c-inputcheckbox-shadow-focus: var(--slds-c-checkbox-shadow-focus);--_slds-c-inputcheckbox-color-background: var(--slds-c-checkbox-color-background);--_slds-c-inputcheckbox-color-background-checked: var(--slds-c-checkbox-color-background-checked);--_slds-c-inputcheckbox-color-border: var(--slds-c-checkbox-color-border);--_slds-c-inputcheckbox-color-border-checked: var(--slds-c-checkbox-color-border-checked);--_slds-c-inputcheckbox-color-border-focus: var(--slds-c-checkbox-color-border-focus);--_slds-c-inputcheckbox-mark-color-foreground: var(--slds-c-checkbox-mark-color-foreground);--_slds-c-inputcheckbox-radius-border: var(--slds-c-checkbox-radius-border);display: flex;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='label-container']" : hostSelector + "[data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {display: block;padding-inline-end: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='input-checkbox']" : hostSelector + "[data-render-mode=\"shadow\"] [part='input-checkbox']")), shadowSelector, " [part='label']", shadowSelector, " {color: var(--_slds-c-inputcheckbox-label-color, var(--slds-g-color-on-surface-2));margin-block-end: 0;padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-inline-start: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']")), shadowSelector, " {width: 1px;height: 1px;border: 0;clip: rect(0 0 0 0);margin: -1px;overflow: hidden;padding: 0;position: absolute;pointer-events: auto;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='indicator']" : hostSelector + "[data-render-mode=\"shadow\"] [part='indicator']")), shadowSelector, " {display: inline-block;position: relative;width: 1rem;height: 1rem;border-radius: var(--_slds-c-inputcheckbox-radius-border, var(--slds-g-radius-border-1));border: var(--_slds-c-inputcheckbox-sizing-border, var(--slds-g-sizing-border-1)) solid\n var(--_slds-c-inputcheckbox-color-border, var(--slds-g-color-border-2));background-color: var(--_slds-c-inputcheckbox-color-background, var(--slds-g-color-surface-container-1));box-shadow: var(--_slds-c-inputcheckbox-shadow);transition: border 0.1s linear, background-color 0.1s linear;vertical-align: middle;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][checked]) [part='indicator']" : hostSelector + "[checked][data-render-mode=\"shadow\"] [part='indicator']")), shadowSelector, "::after {content: '';height: calc(1rem / 4);width: calc(1rem / 2);position: absolute;top: 50%;left: 50%;transform: translate3d(-50%, -50%, 0) rotate(-45deg);border-bottom: 2px solid\n var(--_slds-c-inputcheckbox-mark-color-foreground, var(--slds-g-color-border-accent-2));border-left: 2px solid var(--_slds-c-inputcheckbox-mark-color-foreground, var(--slds-g-color-border-accent-2));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][checked]) [part='indicator']" : hostSelector + "[checked][data-render-mode=\"shadow\"] [part='indicator']")), shadowSelector, " {--_slds-c-inputcheckbox-color-background: var(--_slds-c-inputcheckbox-color-background-checked);--_slds-c-inputcheckbox-color-border: var(--_slds-c-inputcheckbox-color-border-checked);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][disabled]) [part='indicator']" : hostSelector + "[disabled][data-render-mode=\"shadow\"] [part='indicator']")), shadowSelector, " {--_slds-c-inputcheckbox-color-background: var(\n --_slds-c-inputcheckbox-color-background-disabled,\n var(--slds-g-color-disabled-container-2)\n );--_slds-c-inputcheckbox-color-border: var(--_slds-c-inputcheckbox-color-border-disabled, var(--slds-g-color-border-disabled-1));--_slds-c-inputcheckbox-mark-color-foreground: var(\n --_slds-c-inputcheckbox-mark-color-foreground-disabled,\n var(--slds-g-color-on-disabled-2)\n );}", ((useActualHostSelector ? ":host(:not([disabled])) input:focus-within" : hostSelector + ":not([disabled]) input:focus-within")), shadowSelector, " + .slds-checkbox__label", shadowSelector, " [part='indicator']", shadowSelector, " {--_slds-c-inputcheckbox-color-background: var(--_slds-c-inputcheckbox-color-background-focus);--_slds-c-inputcheckbox-color-border: var(\n --_slds-c-inputcheckbox-color-border-focus,\n var(--slds-g-color-accent-2)\n );--_slds-c-inputcheckbox-shadow: var(\n --_slds-c-inputcheckbox-shadow-focus,\n 0 0 3px var(--slds-g-color-accent-2)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='indicator']" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='indicator']")), shadowSelector, " {--_slds-c-inputcheckbox-sizing-border: var(\n --_slds-c-inputcheckbox-sizing-border-invalid,\n var(--slds-g-sizing-border-2)\n );--_slds-c-inputcheckbox-color-border: var(\n --_slds-c-inputcheckbox-color-border-invalid,\n var(--slds-g-color-border-error-1)\n );--_slds-c-inputcheckbox-mark-color-foreground: var(\n --_slds-c-inputcheckbox-mark-color-foreground-invalid,\n var(--slds-g-color-error-1)\n );}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) [part='help-text']" : hostSelector + "[invalid][data-render-mode=\"shadow\"] [part='help-text']")), shadowSelector, " {color: var(--_slds-c-inputcheckbox-helptext-color-invalid, var(--slds-g-color-error-1));}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='label-container']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='label-container']")), shadowSelector, " {float: left;max-width: calc(33% - 1.125rem);padding-block-start: var(--slds-g-spacing-1);padding-inline-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='input-checkbox']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='input-checkbox']")), shadowSelector, " {display: block;margin-inline-start: 33%;padding-block: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='inline-help']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='inline-help']")), shadowSelector, " {float: left;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='indicator']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='indicator']")), shadowSelector, " {display: block;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) [part='checkbox']" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) [part='checkbox']" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] [part='checkbox']" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] [part='checkbox']")), shadowSelector, " {width: 1rem;height: 1rem;margin: 0;clip: auto;opacity: 0;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet$1];

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) fieldset" : hostSelector + "[data-render-mode=\"shadow\"] fieldset")), shadowSelector, " {border: 0;margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {position: relative;min-width: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;hyphens: auto;display: inline-block;color: var(--slds-g-color-on-surface-2);font-size: var(--slds-s-label-font-size, var(--slds-g-font-scale-neg-2));padding-inline-end: var(--slds-g-spacing-2);padding-block-start: var(--slds-g-spacing-1);margin-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label:empty")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {clear: inline-start;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-radio", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {display: inline-block;position: relative;padding-block-start: var(--slds-g-spacing-1);vertical-align: top;line-height: var(--slds-g-font-lineheight-1);z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-form-element__helper" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__helper")), shadowSelector, " {font-size: var(--slds-s-helptext-font-size, var(--slds-g-font-scale-neg-2));margin-block-start: calc(var(--slds-g-spacing-1) / 2);display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_edit")), shadowSelector, " .slds-form-element__static", shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " {flex-basis: 0%;border-bottom: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__label", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__legend" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__legend")), shadowSelector, " {font-weight: var(--slds-g-font-weight-7);float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__addon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__addon")), shadowSelector, " {display: inline-block;margin-block-start: 0;margin-block-end: 0;margin-inline-start: var(--slds-g-spacing-2);margin-inline-end: var(--slds-g-spacing-2);align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;word-break: break-word;display: inline-block;font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-neutral-base-10);width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static.slds-text-longform" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static.slds-text-longform")), shadowSelector, " *:last-child", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static:empty")), shadowSelector, " {min-height: calc(var(--slds-g-sizing-6) + 1px);vertical-align: bottom;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static--edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static--edit")), shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-required" : hostSelector + "[data-render-mode=\"shadow\"] .slds-required")), shadowSelector, " {color: var(--slds-g-color-error-1);margin-block-start: 0;margin-block-end: 0;margin-inline-start: calc(var(--slds-g-spacing-1) / 2);margin-inline-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-form-element__help", shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-form-element__help" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) {" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {padding: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__label" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__label" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {width: 100%;flex-basis: 100%;clear: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__icon" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {float: none;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline'].slds-form-element_horizontal) {" : hostSelector + ".slds-form-element_horizontal[variant='label-inline'][data-render-mode=\"shadow\"] {")), "padding: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']).slds-is-edited {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"].slds-is-edited {")), "padding-block-start: var(--slds-g-sizing-6)}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__label" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {float: inline-start;max-width: calc(33% - var(--slds-g-sizing-6));flex-basis: calc(33% - var(--slds-g-sizing-6));flex-grow: 1;margin-block-end: 0;position: relative;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) lightning-helptext" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] lightning-helptext")), shadowSelector, " {float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {margin-inline-start: 33%;clear: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list__column" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list__column")), shadowSelector, " .slds-form-element__label", shadowSelector, " {width: auto;max-width: 100%;flex-basis: auto;float: none;position: relative;padding-inline-start: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__help" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list")), shadowSelector, " {clear: none;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " {display: flex;margin-bottom: var(--slds-g-spacing-1);margin-left: calc(var(--slds-g-spacing-1) * -1);margin-right: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " .slds-form-element__label", shadowSelector, " {padding-top: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element", shadowSelector, " {padding-left: var(--slds-g-spacing-1);padding-right: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_address" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_address")), shadowSelector, " .slds-form-element__row", shadowSelector, " {align-items: flex-end;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-hidden']) .slds-form-element__label" : hostSelector + "[variant='label-hidden'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {display: none}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet2 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1, stylesheet2];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<abbr class="slds-required${0}"${"a0:title"}${2}>*</abbr>`;
  const $fragment2 = lwc.parseFragment`<span${"c0"}${2}>${"t1"}</span>`;
  const $fragment3 = lwc.parseFragment`<abbr class="slds-required${0}"${"a0:title"}${2}>*</abbr>`;
  const $fragment4 = lwc.parseFragment`<input type="checkbox" part="checkbox"${"a0:id"}${"a0:aria-label"}${"a0:aria-keyshortcuts"}${"a0:aria-disabled"}${"a0:aria-roledescription"}${"a0:aria-invalid"}${"a0:accesskey"}${"a0:name"}${"a0:required"}${"a0:readonly"}${"a0:disabled"}${3}>`;
  const $fragment5 = lwc.parseFragment`<span part="indicator" class="slds-checkbox_faux${0}"${2}></span>`;
  const $fragment6 = lwc.parseFragment`<label${"a0:for"} part="label-container" class="slds-checkbox__label${0}"${2}><span part="indicator" class="slds-checkbox_faux${0}"${2}></span><span part="label"${"c2"}${2}>${"t3"}</span></label>`;
  const $fragment7 = lwc.parseFragment`<div${"a0:id"} class="slds-form-element__help${0}" data-help-message part="help-text" role="status"${2}><span class="slds-assistive-text${0}"${2}>${"t2"}</span>${"t3"}</div>`;
  const stc0 = {
    "slds-checkbox__label": true
  };
  const stc1 = {
    classMap: {
      "slds-form-element__control": true,
      "slds-grow": true
    },
    key: 6
  };
  const stc2 = {
    "part": "input-checkbox"
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {gid: api_scoped_id, sp: api_static_part, st: api_static_fragment, ncls: api_normalize_class_name, d: api_dynamic_text, h: api_element, c: api_custom_element, b: api_bind} = $api;
    const {_m0, _m1, _m2, _m3, _m4, _m5, _m6, _m7} = $ctx;
    return [!$cmp.isStandardVariant ? api_element("label", {
      classMap: stc0,
      attrs: {
        "for": api_scoped_id("checkbox"),
        "part": "label-container"
      },
      key: 0
    }, [$cmp.required ? api_static_fragment($fragment1, 2, [api_static_part(0, {
      attrs: {
        "title": $cmp.labelRequired
      }
    }, null)]) : null, api_static_fragment($fragment2, 4, [api_static_part(0, {
      className: api_normalize_class_name($cmp.computedLabelClass)
    }, null), api_static_part(1, null, api_dynamic_text($cmp.label))])]) : null, !$cmp.isStandardVariant ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext__default.default, {
      props: {
        "content": $cmp.fieldLevelHelp,
        "alternativeText": $cmp.helptextAlternativeText
      },
      key: 5
    }) : null : null, api_element("div", stc1, [api_element("span", {
      className: api_normalize_class_name($cmp.computedCheckboxClass),
      attrs: stc2,
      key: 7
    }, [$cmp.isStandardVariant ? $cmp.required ? api_static_fragment($fragment3, 9, [api_static_part(0, {
      attrs: {
        "title": $cmp.labelRequired
      }
    }, null)]) : null : null, api_static_fragment($fragment4, 11, [api_static_part(0, {
      on: {
        "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleBlur)),
        "focus": _m5 || ($ctx._m5 = api_bind($cmp.handleFocus)),
        "change": _m6 || ($ctx._m6 = api_bind($cmp.handleChange)),
        "click": _m7 || ($ctx._m7 = api_bind($cmp.handleClick))
      },
      attrs: {
        "id": api_scoped_id("checkbox"),
        "aria-label": $cmp.ariaLabel,
        "aria-keyshortcuts": $cmp.ariaKeyShortcuts,
        "aria-disabled": $cmp.ariaDisabled,
        "aria-roledescription": $cmp.ariaRoleDescription,
        "aria-invalid": $cmp.ariaInvalid,
        "accesskey": $cmp.accessKey,
        "name": $cmp.name,
        "required": $cmp.required ? "" : null,
        "readonly": $cmp.readOnly ? "" : null,
        "disabled": $cmp.disabled ? "" : null
      }
    }, null)]), !$cmp.isStandardVariant ? api_static_fragment($fragment5, 13) : null, $cmp.isStandardVariant ? api_static_fragment($fragment6, 15, [api_static_part(0, {
      attrs: {
        "for": api_scoped_id("checkbox")
      }
    }, null), api_static_part(2, {
      className: api_normalize_class_name($cmp.computedLabelClass)
    }, null), api_static_part(3, null, api_dynamic_text($cmp.label))]) : null, $cmp.isStandardVariant ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext__default.default, {
      props: {
        "content": $cmp.fieldLevelHelp,
        "alternativeText": $cmp.helptextAlternativeText
      },
      key: 16
    }) : null : null])]), $cmp.helpMessage ? api_static_fragment($fragment7, 18, [api_static_part(0, {
      attrs: {
        "id": api_scoped_id("help-message")
      }
    }, null), api_static_part(2, null, api_dynamic_text($cmp.label)), api_static_part(3, null, api_dynamic_text($cmp.helpMessage))]) : null];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-16hle61jt7i";
  tmpl.legacyStylesheetToken = "lightning-primitiveInputCheckbox_primitiveInputCheckbox";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  class LightningPrimitiveInputCheckbox extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      this.required = void 0;
      this.readOnly = void 0;
      this.label = void 0;
      this.labelHidden = void 0;
      this.helptextAlternativeText = void 0;
      this.fieldLevelHelp = void 0;
      this.ariaInvalid = void 0;
      this.ariaLabel = void 0;
      this.accessKey = void 0;
      this.name = void 0;
      this.disabled = void 0;
      this.ariaKeyShortcuts = void 0;
      this.ariaDisabled = void 0;
      this.ariaRoleDescription = void 0;
      this.labelRequired = labelRequired__default.default;
      this._helpMessage = void 0;
    }
    get checked() {
      return this._checked;
    }
    set checked(value) {
      this._setChecked(value);
    }
    get helpMessage() {
      return this._helpMessage;
    }
    set helpMessage(message) {
      this._helpMessage = message;
      utilsPrivate.reflectAttribute(this, 'invalid', !!message);
    }
    get variant() {
      return this._variant;
    }
    set variant(variant) {
      this._variant = variant;
      utilsPrivate.reflectAttribute(this, 'variant', variant);
    }
    get inputElement() {
      if (!this.cachedInputElement) {
        let inputElement = this.template.querySelector('input');
        this.cachedInputElement = inputElement;
      }
      return this.cachedInputElement;
    }
    get describedByElements() {
      return this.template.querySelector('[data-help-message]');
    }
    get isNativeShadow() {
      return this._isNativeShadow;
    }
    get isStandardVariant() {
      return this.variant === inputUtils.VARIANT.STANDARD || this.variant === inputUtils.VARIANT.LABEL_HIDDEN;
    }
    get isLabelHidden() {
      return this.variant === inputUtils.VARIANT.LABEL_HIDDEN;
    }
    get computedCheckboxClass() {
      return utils.classSet('slds-checkbox').add({
        'slds-checkbox_standalone': !this.isStandardVariant
      }).toString();
    }
    get computedLabelClass() {
      return utils.classSet('slds-form-element__label').add({
        'slds-assistive-text': this.isLabelHidden
      }).toString();
    }
    handleBlur() {
      this.dispatchEvent(new CustomEvent('blur'));
    }
    handleFocus() {
      this.dispatchEvent(new CustomEvent('focus'));
    }
    _setChecked(value) {
      value = Boolean(value);
      this._checked = value;
      utilsPrivate.reflectAttribute(this, 'checked', this.checked);
      if (this.rendered && this.inputElement.checked !== value) {
        this.inputElement.checked = this._checked;
      }
    }
    handleChange(event) {
      this._setChecked(event.target.checked);
      const changeEvent = new CustomEvent('change', {
        detail: {
          composed: true,
          bubbles: true,
          checked: event.target.checked
        }
      });
      this.dispatchEvent(changeEvent);
    }
    handleClick() {
      if (this.template.activeElement === null) {
        this.template.querySelector("[type='checkbox']").focus();
      }
    }
    connectedCallback() {
      super.connectedCallback();
      this._isNativeShadow = utilsPrivate.isNativeComponent(this);
    }
    renderedCallback() {
      if (!this.rendered) {
        this.inputElement.checked = this.checked;
      }
      utilsPrivate.reflectAttribute(this, 'disabled', this.disabled);
      this.rendered = true;
    }
    disconnectedCallback() {
      this.cachedInputElement = undefined;
      this.rendered = false;
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(LightningPrimitiveInputCheckbox, {
    publicProps: {
      required: {
        config: 0
      },
      readOnly: {
        config: 0
      },
      label: {
        config: 0
      },
      labelHidden: {
        config: 0
      },
      helptextAlternativeText: {
        config: 0
      },
      fieldLevelHelp: {
        config: 0
      },
      ariaInvalid: {
        config: 0
      },
      ariaLabel: {
        config: 0
      },
      accessKey: {
        config: 0
      },
      name: {
        config: 0
      },
      disabled: {
        config: 0
      },
      ariaKeyShortcuts: {
        config: 0
      },
      ariaDisabled: {
        config: 0
      },
      ariaRoleDescription: {
        config: 0
      },
      checked: {
        config: 3
      },
      helpMessage: {
        config: 3
      },
      variant: {
        config: 3
      },
      inputElement: {
        config: 1
      },
      describedByElements: {
        config: 1
      },
      isNativeShadow: {
        config: 1
      }
    },
    fields: ["labelRequired", "_helpMessage"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningPrimitiveInputCheckbox, {
    tmpl: _tmpl,
    sel: "lightning-primitive-input-checkbox",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/primitiveInputToggle', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/shadowBaseClassPrivate', 'lightning/utilsPrivate', 'lightning/inputUtils', '@salesforce/label/LightningControl.required'], (function (exports, lwc, stylesheet0$1, LightningShadowBaseClass, utilsPrivate, inputUtils, labelRequired) {

  function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

  var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
  var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);
  var labelRequired__default = /*#__PURE__*/_interopDefaultCompat(labelRequired);

  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) fieldset" : hostSelector + "[data-render-mode=\"shadow\"] fieldset")), shadowSelector, " {border: 0;margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {position: relative;min-width: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;hyphens: auto;display: inline-block;color: var(--slds-g-color-on-surface-2);font-size: var(--slds-s-label-font-size, var(--slds-g-font-scale-neg-2));padding-inline-end: var(--slds-g-spacing-2);padding-block-start: var(--slds-g-spacing-1);margin-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label:empty")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {clear: inline-start;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-radio", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {display: inline-block;position: relative;padding-block-start: var(--slds-g-spacing-1);vertical-align: top;line-height: var(--slds-g-font-lineheight-1);z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-form-element__helper" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__helper")), shadowSelector, " {font-size: var(--slds-s-helptext-font-size, var(--slds-g-font-scale-neg-2));margin-block-start: calc(var(--slds-g-spacing-1) / 2);display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_edit")), shadowSelector, " .slds-form-element__static", shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " {flex-basis: 0%;border-bottom: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__label", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__legend" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__legend")), shadowSelector, " {font-weight: var(--slds-g-font-weight-7);float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__addon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__addon")), shadowSelector, " {display: inline-block;margin-block-start: 0;margin-block-end: 0;margin-inline-start: var(--slds-g-spacing-2);margin-inline-end: var(--slds-g-spacing-2);align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;word-break: break-word;display: inline-block;font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-neutral-base-10);width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static.slds-text-longform" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static.slds-text-longform")), shadowSelector, " *:last-child", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static:empty")), shadowSelector, " {min-height: calc(var(--slds-g-sizing-6) + 1px);vertical-align: bottom;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static--edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static--edit")), shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-required" : hostSelector + "[data-render-mode=\"shadow\"] .slds-required")), shadowSelector, " {color: var(--slds-g-color-error-1);margin-block-start: 0;margin-block-end: 0;margin-inline-start: calc(var(--slds-g-spacing-1) / 2);margin-inline-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-form-element__help", shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-form-element__help" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) {" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {padding: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__label" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__label" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {width: 100%;flex-basis: 100%;clear: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__icon" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {float: none;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline'].slds-form-element_horizontal) {" : hostSelector + ".slds-form-element_horizontal[variant='label-inline'][data-render-mode=\"shadow\"] {")), "padding: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']).slds-is-edited {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"].slds-is-edited {")), "padding-block-start: var(--slds-g-sizing-6)}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__label" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {float: inline-start;max-width: calc(33% - var(--slds-g-sizing-6));flex-basis: calc(33% - var(--slds-g-sizing-6));flex-grow: 1;margin-block-end: 0;position: relative;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) lightning-helptext" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] lightning-helptext")), shadowSelector, " {float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {margin-inline-start: 33%;clear: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list__column" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list__column")), shadowSelector, " .slds-form-element__label", shadowSelector, " {width: auto;max-width: 100%;flex-basis: auto;float: none;position: relative;padding-inline-start: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__help" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list")), shadowSelector, " {clear: none;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " {display: flex;margin-bottom: var(--slds-g-spacing-1);margin-left: calc(var(--slds-g-spacing-1) * -1);margin-right: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " .slds-form-element__label", shadowSelector, " {padding-top: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element", shadowSelector, " {padding-left: var(--slds-g-spacing-1);padding-right: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_address" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_address")), shadowSelector, " .slds-form-element__row", shadowSelector, " {align-items: flex-end;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-hidden']) .slds-form-element__label" : hostSelector + "[variant='label-hidden'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {display: none}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet1 = [stylesheet$1];

  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? ("[" + token + "]") : "";
    var hostSelector = token ? ("[" + token + "-host]") : "";
    return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox-toggle']" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox-toggle']")), shadowSelector, " {width: 100%;display: flex}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-checkbox_off" : hostSelector + "[data-render-mode=\"shadow\"] .slds-checkbox_off")), shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-checkbox_on" : hostSelector + "[data-render-mode=\"shadow\"] .slds-checkbox_on")), shadowSelector, " {display: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-checkbox_faux_container" : hostSelector + "[data-render-mode=\"shadow\"] .slds-checkbox_faux_container")), shadowSelector, " {font-size: var(--slds-g-font-scale-neg-4);color: var(--slds-g-color-on-surface-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='indicator']" : hostSelector + "[data-render-mode=\"shadow\"] [part='indicator']")), shadowSelector, "{display: block;position: relative;width: var(--slds-g-sizing-10);height: var(--slds-g-sizing-7);border-width: var(--slds-g-sizing-border-1);border-style: solid;border-color: var(--slds-c-checkbox-toggle-color-border, var(--slds-g-color-neutral-base-60));padding: var(--slds-g-sizing-1);background-color: var(--slds-c-checkbox-toggle-color-background, var(--slds-g-color-neutral-base-60));border-radius: var(--slds-c-checkbox-toggle-radius-border, 15rem);box-shadow: var(--slds-c-checkbox-toggle-shadow);transition: background-color 0.2s cubic-bezier(0.75, 0, 0.08, 1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='indicator']:hover" : hostSelector + "[data-render-mode=\"shadow\"] [part='indicator']:hover")), shadowSelector, " {--slds-c-checkbox-toggle-color-background: var(--slds-c-checkbox-toggle-color-background-hover, var(--slds-g-color-neutral-base-50));--slds-c-checkbox-toggle-color-border: var(--slds-c-checkbox-toggle-color-border-hover);cursor: pointer;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='indicator']" : hostSelector + "[data-render-mode=\"shadow\"] [part='indicator']")), shadowSelector, "::after {content: '';position: absolute;top: 1px;left: 1px;width: var(--slds-g-sizing-6);height: var(--slds-g-sizing-6);background-color: var(--slds-c-checkbox-toggle-switch-color-background, var(--slds-g-color-surface-container-1));border-radius: var(--slds-c-checkbox-toggle-radius-border, 15rem);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']")), shadowSelector, " {height: 1px;width: 1px;border: 0;clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 100% 0%);margin: -1px;overflow: hidden;padding: 0;position: absolute;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [type='checkbox']:focus" + shadowSelector + "+.slds-checkbox_faux_container" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [type='checkbox']:focus" : hostSelector + "[data-render-mode=\"shadow\"] [type='checkbox']:focus" + shadowSelector + "+.slds-checkbox_faux_container" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [type='checkbox']:focus")), shadowSelector, "+.slds-checkbox_faux_container", shadowSelector, ">[part='indicator']:hover", shadowSelector, " {--slds-c-checkbox-toggle-color-background: var(--slds-g-color-neutral-base-50);--slds-c-checkbox-toggle-shadow: var(--slds-g-shadow-5);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:checked:focus" + shadowSelector + " + .slds-checkbox_faux_container" + shadowSelector + " > [part='indicator']" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='checkbox']:checked:focus" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:checked:focus" + shadowSelector + " + .slds-checkbox_faux_container" + shadowSelector + " > [part='indicator']" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:checked:focus")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " > [part='indicator']:hover", shadowSelector, " {--slds-c-checkbox-toggle-color-background: var(--slds-c-checkbox-toggle-color-background-checked-focus, var(--slds-g-color-accent-container-3));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:checked" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:checked")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " .slds-checkbox_off", shadowSelector, " {display: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:checked" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:checked")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " .slds-checkbox_on", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:checked" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:checked")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " > [part='indicator']", shadowSelector, " {--slds-c-checkbox-toggle-color-border: var(--slds-g-color-border-accent-2);--slds-c-checkbox-toggle-color-background: var(--slds-g-color-accent-container-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:checked" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:checked")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " > [part='indicator']:hover", shadowSelector, " {--slds-c-checkbox-toggle-color-background: var(--slds-g-color-accent-container-3);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:checked" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:checked")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " > [part='indicator']", shadowSelector, "::before {content: '';position: absolute;top: 1px;right: 1px;width: var(--slds-g-sizing-6);height: var(--slds-g-sizing-6);background-color: var(--slds-c-checkbox-toggle-switch-color-background-checked, var(--slds-c-checkbox-toggle-switch-color-background, var(--slds-g-color-surface-container-1)));border-radius: var(--slds-c-checkbox-toggle-radius-border, 15rem);transition: transform 0.2s cubic-bezier(0.75, 0, 0.08, 1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox']:checked" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox']:checked")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " > [part='indicator']", shadowSelector, "::after {--slds-c-checkbox-toggle-switch-color-background: transparent;--slds-c-checkbox-toggle-radius-border: 0;content: ' ';position: absolute;top: 0.25rem;left: 0.6rem;height: 0.7rem;width: 0.45rem;border-bottom-width: var(--slds-g-sizing-border-2);border-bottom-style: solid;border-bottom-color: var(--slds-c-checkbox-toggle-mark-color-foreground, var(--slds-g-color-neutral-base-100));border-right-width: var(--slds-g-sizing-border-2);border-right-style: solid;border-right-color: var(--slds-c-checkbox-toggle-mark-color-foreground, var(--slds-g-color-neutral-base-100));transform: rotate(45deg);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox'][disabled]" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox'][disabled]")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " > [part='indicator']", shadowSelector, " {background-color: var(--slds-g-color-disabled-container-2, var(--slds-g-color-neutral-base-80));border-color: var(--slds-g-color-border-disabled-1, var(--slds-g-color-neutral-base-80));pointer-events: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox'][disabled]" + shadowSelector + " + .slds-checkbox_faux_container" + shadowSelector + " > [part='indicator']" + shadowSelector + "::after,:host([data-render-mode=\"shadow\"]) [part='checkbox'][disabled]:checked" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox'][disabled]" + shadowSelector + " + .slds-checkbox_faux_container" + shadowSelector + " > [part='indicator']" + shadowSelector + "::after," + hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox'][disabled]:checked")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " > [part='indicator']", shadowSelector, "::before {background-color: var(--slds-g-color-on-disabled-2, var(--slds-g-color-neutral-base-60));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox'][disabled]" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox'][disabled]")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " > [part='indicator']", shadowSelector, "::after {--slds-c-checkbox-toggle-mark-color-foreground: var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox'][disabled]" + shadowSelector + " + .slds-checkbox_faux_container" + shadowSelector + " > [part='indicator']:hover" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) [part='checkbox'][disabled]" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox'][disabled]" + shadowSelector + " + .slds-checkbox_faux_container" + shadowSelector + " > [part='indicator']:hover" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox'][disabled]")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " > [part='indicator']:focus", shadowSelector, " {background-color: var(--slds-g-color-disabled-1, var(--slds-g-color-disabled-2));cursor: default;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) [part='checkbox'][disabled]:checked" : hostSelector + "[data-render-mode=\"shadow\"] [part='checkbox'][disabled]:checked")), shadowSelector, " + .slds-checkbox_faux_container", shadowSelector, " > [part='indicator']", shadowSelector, "::after {background-color: transparent;--slds-c-checkbox-toggle-mark-color-foreground: var(--slds-g-color-on-disabled-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-assistive-text" : hostSelector + "[data-render-mode=\"shadow\"] .slds-assistive-text")), shadowSelector, " {position: absolute !important;margin: -1px !important;border: 0 !important;padding: 0 !important;width: 1px !important;height: 1px !important;overflow: hidden !important;clip: rect(0 0 0 0) !important;text-transform: none !important;white-space: nowrap !important;}"].join('');
    /*LWC compiler v7.1.5*/
  }
  var stylesheet2 = [stylesheet];

  var stylesheet0 = [stylesheet0__default.default, stylesheet1, stylesheet2];

  var _implicitStylesheets = [stylesheet0];

  const $fragment1 = lwc.parseFragment`<abbr class="slds-required${0}"${"a0:title"}${2}>*</abbr>`;
  const $fragment2 = lwc.parseFragment`<span${"c0"}${2}>${"t1"}</span>`;
  const $fragment3 = lwc.parseFragment`<input type="checkbox"${"a0:id"} part="checkbox"${"a0:accesskey"}${"a0:aria-label"}${"a0:aria-keyshortcuts"}${"a0:aria-disabled"}${"a0:aria-roledescription"}${"a0:aria-invalid"}${"a0:disabled"}${"a0:name"}${"a0:readonly"}${"a0:required"}${3}>`;
  const $fragment4 = lwc.parseFragment`<span${"a0:id"} data-toggle-description class="slds-checkbox_faux_container${0}"${2}><span class="slds-checkbox_faux${0}" part="indicator"${2}></span><span class="slds-checkbox_on${0}"${2}>${"t3"}</span><span class="slds-checkbox_off${0}"${2}>${"t5"}</span></span>`;
  const $fragment5 = lwc.parseFragment`<div${"a0:id"} class="slds-form-element__help${0}" data-help-message part="help-text" role="status"${2}><span class="slds-assistive-text${0}"${2}>${"t2"}</span>${"t3"}</div>`;
  const stc0 = {
    classMap: {
      "slds-form-element__control": true
    },
    key: 0
  };
  const stc1 = {
    "slds-checkbox_toggle": true,
    "slds-grid": true
  };
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {gid: api_scoped_id, sp: api_static_part, st: api_static_fragment, ncls: api_normalize_class_name, d: api_dynamic_text, b: api_bind, h: api_element} = $api;
    const {_m0, _m1, _m2, _m3, _m4, _m5, _m6, _m7} = $ctx;
    return [api_element("div", stc0, [api_element("label", {
      classMap: stc1,
      attrs: {
        "for": api_scoped_id("checkbox-toggle"),
        "part": "checkbox-toggle"
      },
      key: 1
    }, [$cmp.required ? api_static_fragment($fragment1, 3, [api_static_part(0, {
      attrs: {
        "title": $cmp.labelRequired
      }
    }, null)]) : null, api_static_fragment($fragment2, 5, [api_static_part(0, {
      className: api_normalize_class_name($cmp.computedLabelClass)
    }, null), api_static_part(1, null, api_dynamic_text($cmp.label))]), api_static_fragment($fragment3, 7, [api_static_part(0, {
      on: {
        "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleBlur)),
        "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange)),
        "focus": _m6 || ($ctx._m6 = api_bind($cmp.handleFocus)),
        "click": _m7 || ($ctx._m7 = api_bind($cmp.handleClick))
      },
      attrs: {
        "id": api_scoped_id("checkbox-toggle"),
        "accesskey": $cmp.accessKey,
        "aria-label": $cmp.ariaLabel,
        "aria-keyshortcuts": $cmp.ariaKeyShortcuts,
        "aria-disabled": $cmp.ariaDisabled,
        "aria-roledescription": $cmp.ariaRoleDescription,
        "aria-invalid": $cmp.ariaInvalid,
        "disabled": $cmp.disabled ? "" : null,
        "name": $cmp.name,
        "readonly": $cmp.readOnly ? "" : null,
        "required": $cmp.required ? "" : null
      }
    }, null)]), api_static_fragment($fragment4, 9, [api_static_part(0, {
      attrs: {
        "id": api_scoped_id("toggle-description")
      }
    }, null), api_static_part(3, null, api_dynamic_text($cmp.messageToggleActive)), api_static_part(5, null, api_dynamic_text($cmp.messageToggleInactive))])])]), $cmp._helpMessage ? api_static_fragment($fragment5, 11, [api_static_part(0, {
      attrs: {
        "id": api_scoped_id("help-message")
      }
    }, null), api_static_part(2, null, api_dynamic_text($cmp.label)), api_static_part(3, null, api_dynamic_text($cmp._helpMessage))]) : null];
    /*LWC compiler v7.1.5*/
  }
  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetToken = "lwc-1fmklhh3ll6";
  tmpl.legacyStylesheetToken = "lightning-primitiveInputToggle_primitiveInputToggle";
  if (_implicitStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
  }
  lwc.freezeTemplate(tmpl);

  const i18n = {
    required: labelRequired__default.default
  };
  class LightningPrimitiveInputToggle extends LightningShadowBaseClass__default.default {
    constructor(...args) {
      super(...args);
      this._checked = void 0;
      this._value = '';
      this._ariaLabel = void 0;
      this._cachedInputElement = void 0;
      this._helpMessage = '';
      this._messageToggleActive = void 0;
      this._messageToggleInactive = void 0;
      this.initialRender = false;
      this.accessKey = void 0;
      this.disabled = void 0;
      this.label = void 0;
      this.name = void 0;
      this.readOnly = void 0;
      this.required = void 0;
      this.ariaInvalid = void 0;
      this.ariaKeyShortcuts = void 0;
      this.ariaDisabled = void 0;
      this.ariaRoleDescription = void 0;
      /**
       * Text shown for the active state of a toggle. The default is "Active".
       * @type {string}
       */
      this.messageToggleActive = void 0;
      /**
       * Text shown for the inactive state of a toggle. The default is "Inactive".
       * @type {string}
       */
      this.messageToggleInactive = void 0;
    }
    get value() {
      return this._value;
    }
    set value(newValue) {
      // value can only be a string
      this._value = typeof newValue === 'number' || typeof newValue === 'string' ? String(newValue) : '';
    }
    get checked() {
      if (this.initialRender) {
        return this.inputElement.checked;
      }
      return this._checked;
    }
    set checked(value) {
      value = Boolean(value);
      this._checked = value;
      if (this.initialRender) {
        this.inputElement.checked = this._checked;
      }
    }
    get ariaDescribedByElements() {
      return [this.template.querySelector('[data-help-message]'), this.template.querySelector('data-toggle-description')];
    }
    get isNativeShadow() {
      return this._isNativeShadow;
    }
    get ariaLabel() {
      return this._ariaLabel;
    }
    set ariaLabel(value) {
      this._ariaLabel = utilsPrivate.normalizeAriaAttribute(value);
    }
    get inputElement() {
      // cache the input in order to reduce dom queries
      if (!this._cachedInputElement) {
        let inputElement = this.template.querySelector('input');
        this._cachedInputElement = inputElement;
      }
      return this._cachedInputElement;
    }
    get helpMessage() {
      return this._helpMessage;
    }
    set helpMessage(message) {
      this._helpMessage = message;
      utilsPrivate.reflectAttribute(this, 'invalid', Boolean(message));
    }
    get variant() {
      return this._variant;
    }
    set variant(variant) {
      this._variant = variant;
      utilsPrivate.reflectAttribute(this, 'variant', variant);
    }
    get computedLabelClass() {
      return this.variant === inputUtils.VARIANT.LABEL_HIDDEN ? 'slds-form-element__label slds-assistive-text' : 'slds-form-element__label';
    }
    get i18n() {
      return i18n;
    }
    handleBlur() {
      this.dispatchEvent(new CustomEvent('blur'));
    }
    handleFocus() {
      this.dispatchEvent(new CustomEvent('focus'));
    }
    handleChange(event) {
      this._checked = event.target.checked;
      const changeEvent = new CustomEvent('change', {
        detail: {
          checked: event.target.checked
        }
      });
      this.dispatchEvent(changeEvent);
    }
    handleClick() {
      if (this.template.activeElement === null) {
        this.template.querySelector("[type='checkbox']").focus();
      }
    }
    connectedCallback() {
      super.connectedCallback();
      this._isNativeShadow = utilsPrivate.isNativeComponent(this);
    }
    renderedCallback() {
      if (!this.initialRender) {
        this.inputElement.checked = this.checked;
        this.inputElement.value = this._value;
        this.initialRender = true;
      }
    }
    disconnectedCallback() {
      this._cachedInputElement = undefined;
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(LightningPrimitiveInputToggle, {
    publicProps: {
      accessKey: {
        config: 0
      },
      disabled: {
        config: 0
      },
      label: {
        config: 0
      },
      name: {
        config: 0
      },
      readOnly: {
        config: 0
      },
      required: {
        config: 0
      },
      ariaInvalid: {
        config: 0
      },
      ariaKeyShortcuts: {
        config: 0
      },
      ariaDisabled: {
        config: 0
      },
      ariaRoleDescription: {
        config: 0
      },
      messageToggleActive: {
        config: 0
      },
      messageToggleInactive: {
        config: 0
      },
      value: {
        config: 3
      },
      checked: {
        config: 3
      },
      ariaDescribedByElements: {
        config: 1
      },
      isNativeShadow: {
        config: 1
      },
      ariaLabel: {
        config: 3
      },
      inputElement: {
        config: 1
      },
      helpMessage: {
        config: 3
      },
      variant: {
        config: 3
      }
    },
    fields: ["_checked", "_value", "_ariaLabel", "_cachedInputElement", "_helpMessage", "_messageToggleActive", "_messageToggleInactive", "initialRender"]
  });
  const __lwc_component_class_internal = lwc.registerComponent(LightningPrimitiveInputToggle, {
    tmpl: _tmpl,
    sel: "lightning-primitive-input-toggle",
    apiVersion: 62
  });

  exports.default = __lwc_component_class_internal;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('lightning/input', ['exports', 'lwc', 'lightning/sldsCommon', 'lightning/sldsGenAiUtils', 'lightning/primitiveInputSimple', 'lightning/primitiveInputToggle', 'lightning/primitiveInputCheckbox', 'lightning/primitiveInputCheckboxButton', 'lightning/primitiveInputRadio', 'lightning/primitiveInputFile', 'lightning/primitiveInputColor', 'lightning/datepicker', 'lightning/timepicker', 'lightning/datetimepicker', '@salesforce/label/LightningColorPicker.a11yTriggerText', '@salesforce/label/LightningControl.activeCapitalized', '@salesforce/label/LightningControl.inactiveCapitalized', '@salesforce/label/LightningControl.required', '@salesforce/label/LightningControl.clear', '@salesforce/label/LightningControl.loading', '@salesforce/label/LightningInputNumber.incrementCounter', '@salesforce/label/LightningInputNumber.decrementCounter', '@salesforce/label/LightningInput.helptextAlternativeText', '@salesforce/i18n/timeZone', '@salesforce/client/formFactor', 'lightning/utils', 'lightning/utilsPrivate', 'lightning/ariaObserver', 'lightning/internationalizationLibrary', 'lightning/numberUtils', 'lightning/inputUtils', 'lightning/shadowBaseClassPrivate'], (function (exports, lwc, stylesheet0$1, stylesheet2, _lightningPrimitiveInputSimple, _lightningPrimitiveInputToggle, _lightningPrimitiveInputCheckbox, _lightningPrimitiveInputCheckboxButton, _lightningPrimitiveInputRadio, _lightningPrimitiveInputFile, _lightningPrimitiveInputColor, _lightningDatepicker, _lightningTimepicker, _lightningDatetimepicker, labelA11yTriggerText, labelMessageToggleActive, labelMessageToggleInactive, labelRequired, labelClearInput, labelLoadingIndicator, labelNumberIncrementCounter, labelNumberDecrementCounter, labelHelpTextAlternativeText, userTimeZone, formFactor, utils, utilsPrivate, AriaObserver, internationalizationLibrary, numberUtils, inputUtils, LightningShadowBaseClass) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var stylesheet0__default = /*#__PURE__*/_interopDefaultCompat(stylesheet0$1);
    var stylesheet2__default = /*#__PURE__*/_interopDefaultCompat(stylesheet2);
    var _lightningPrimitiveInputSimple__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveInputSimple);
    var _lightningPrimitiveInputToggle__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveInputToggle);
    var _lightningPrimitiveInputCheckbox__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveInputCheckbox);
    var _lightningPrimitiveInputCheckboxButton__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveInputCheckboxButton);
    var _lightningPrimitiveInputRadio__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveInputRadio);
    var _lightningPrimitiveInputFile__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveInputFile);
    var _lightningPrimitiveInputColor__default = /*#__PURE__*/_interopDefaultCompat(_lightningPrimitiveInputColor);
    var _lightningDatepicker__default = /*#__PURE__*/_interopDefaultCompat(_lightningDatepicker);
    var _lightningTimepicker__default = /*#__PURE__*/_interopDefaultCompat(_lightningTimepicker);
    var _lightningDatetimepicker__default = /*#__PURE__*/_interopDefaultCompat(_lightningDatetimepicker);
    var labelA11yTriggerText__default = /*#__PURE__*/_interopDefaultCompat(labelA11yTriggerText);
    var labelMessageToggleActive__default = /*#__PURE__*/_interopDefaultCompat(labelMessageToggleActive);
    var labelMessageToggleInactive__default = /*#__PURE__*/_interopDefaultCompat(labelMessageToggleInactive);
    var labelRequired__default = /*#__PURE__*/_interopDefaultCompat(labelRequired);
    var labelClearInput__default = /*#__PURE__*/_interopDefaultCompat(labelClearInput);
    var labelLoadingIndicator__default = /*#__PURE__*/_interopDefaultCompat(labelLoadingIndicator);
    var labelNumberIncrementCounter__default = /*#__PURE__*/_interopDefaultCompat(labelNumberIncrementCounter);
    var labelNumberDecrementCounter__default = /*#__PURE__*/_interopDefaultCompat(labelNumberDecrementCounter);
    var labelHelpTextAlternativeText__default = /*#__PURE__*/_interopDefaultCompat(labelHelpTextAlternativeText);
    var userTimeZone__default = /*#__PURE__*/_interopDefaultCompat(userTimeZone);
    var formFactor__default = /*#__PURE__*/_interopDefaultCompat(formFactor);
    var AriaObserver__default = /*#__PURE__*/_interopDefaultCompat(AriaObserver);
    var LightningShadowBaseClass__default = /*#__PURE__*/_interopDefaultCompat(LightningShadowBaseClass);

    function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return ((useActualHostSelector ? ":host {" : hostSelector + " {")) + "display: block;}" + (useNativeDirPseudoclass ? '' : '[dir="rtl"]') + " input[type=\"tel\"]" + (useNativeDirPseudoclass ? ':dir(rtl)' : '') + shadowSelector + " {direction: ltr;text-align: right;unicode-bidi: embed;}";
      /*LWC compiler v7.1.5*/
    }
    var stylesheet0 = [stylesheet$1];

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return [((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) fieldset" : hostSelector + "[data-render-mode=\"shadow\"] fieldset")), shadowSelector, " {border: 0;margin: 0;padding: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {position: relative;min-width: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;hyphens: auto;display: inline-block;color: var(--slds-g-color-on-surface-2);font-size: var(--slds-s-label-font-size, var(--slds-g-font-scale-neg-2));padding-inline-end: var(--slds-g-spacing-2);padding-block-start: var(--slds-g-spacing-1);margin-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__label:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__label:empty")), shadowSelector, " {margin: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {clear: inline-start;position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__control" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-radio", shadowSelector, " {display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {display: inline-block;position: relative;padding-block-start: var(--slds-g-spacing-1);vertical-align: top;line-height: var(--slds-g-font-lineheight-1);z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__icon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " .slds-button_icon", shadowSelector, " {position: relative;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__help" + shadowSelector + ",:host([data-render-mode=\"shadow\"]) .slds-form-element__helper" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__help" + shadowSelector + "," + hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__helper")), shadowSelector, " {font-size: var(--slds-s-helptext-font-size, var(--slds-g-font-scale-neg-2));margin-block-start: calc(var(--slds-g-spacing-1) / 2);display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_edit")), shadowSelector, " .slds-form-element__static", shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " {flex-basis: 0%;border-bottom: var(--slds-g-sizing-border-1) solid var(--slds-g-color-border-1);margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-block-start: calc(var(--slds-g-spacing-1) / 2);padding-block-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_readonly" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_readonly")), shadowSelector, " .slds-form-element__label", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__legend" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__legend")), shadowSelector, " {font-weight: var(--slds-g-font-weight-7);float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__addon" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__addon")), shadowSelector, " {display: inline-block;margin-block-start: 0;margin-block-end: 0;margin-inline-start: var(--slds-g-spacing-2);margin-inline-end: var(--slds-g-spacing-2);align-self: center;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static")), shadowSelector, " {overflow-wrap: break-word;word-wrap: break-word;word-break: break-word;display: inline-block;font-size: var(--slds-g-font-scale-neg-1);font-weight: var(--slds-g-font-weight-4);color: var(--slds-g-color-neutral-base-10);width: 100%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static.slds-text-longform" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static.slds-text-longform")), shadowSelector, " *:last-child", shadowSelector, " {margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static:empty" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static:empty")), shadowSelector, " {min-height: calc(var(--slds-g-sizing-6) + 1px);vertical-align: bottom;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element__static--edit" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element__static--edit")), shadowSelector, " {width: calc(100% - var(--slds-g-sizing-7));}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-required" : hostSelector + "[data-render-mode=\"shadow\"] .slds-required")), shadowSelector, " {color: var(--slds-g-color-error-1);margin-block-start: 0;margin-block-end: 0;margin-inline-start: calc(var(--slds-g-spacing-1) / 2);margin-inline-end: calc(var(--slds-g-spacing-1) / 2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-has-error" : hostSelector + "[data-render-mode=\"shadow\"] .slds-has-error")), shadowSelector, " .slds-form-element__help", shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][invalid]) .slds-form-element__help" : hostSelector + "[invalid][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {color: var(--slds-g-color-error-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) {" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element")), shadowSelector, " {padding: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__label" + shadowSelector + ",:host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__label" + shadowSelector + "," + hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__control" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {width: 100%;flex-basis: 100%;clear: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-stacked']) .slds-form-element__icon" : hostSelector + "[variant='label-stacked'][data-render-mode=\"shadow\"] .slds-form-element__icon")), shadowSelector, " {float: none;padding-block-start: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] {")), "display: block;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline'].slds-form-element_horizontal) {" : hostSelector + ".slds-form-element_horizontal[variant='label-inline'][data-render-mode=\"shadow\"] {")), "padding: var(--slds-g-spacing-1);margin-block-end: var(--slds-g-spacing-2);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']).slds-is-edited {" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"].slds-is-edited {")), "padding-block-start: var(--slds-g-sizing-6)}@media (width >= 48em) {", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__label" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {float: inline-start;max-width: calc(33% - var(--slds-g-sizing-6));flex-basis: calc(33% - var(--slds-g-sizing-6));flex-grow: 1;margin-block-end: 0;position: relative;z-index: 1;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) lightning-helptext" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] lightning-helptext")), shadowSelector, " {float: inline-start;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " {margin-inline-start: 33%;clear: none;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__control" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__control")), shadowSelector, " .slds-form-element__control", shadowSelector, " {padding-inline-start: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list__column" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list__column")), shadowSelector, " .slds-form-element__label", shadowSelector, " {width: auto;max-width: 100%;flex-basis: auto;float: none;position: relative;padding-inline-start: 0;margin-block-end: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-form-element__help" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-form-element__help")), shadowSelector, " {margin-inline-start: 33%;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-inline']) .slds-dueling-list" : hostSelector + "[variant='label-inline'][data-render-mode=\"shadow\"] .slds-dueling-list")), shadowSelector, " {clear: none;}}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " {display: flex;margin-bottom: var(--slds-g-spacing-1);margin-left: calc(var(--slds-g-spacing-1) * -1);margin-right: calc(var(--slds-g-spacing-1) * -1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element__row", shadowSelector, " .slds-form-element__label", shadowSelector, " {padding-top: 0;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_compound" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_compound")), shadowSelector, " .slds-form-element", shadowSelector, " {padding-left: var(--slds-g-spacing-1);padding-right: var(--slds-g-spacing-1);}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"]) .slds-form-element_address" : hostSelector + "[data-render-mode=\"shadow\"] .slds-form-element_address")), shadowSelector, " .slds-form-element__row", shadowSelector, " {align-items: flex-end;}", ((useActualHostSelector ? ":host([data-render-mode=\"shadow\"][variant='label-hidden']) .slds-form-element__label" : hostSelector + "[variant='label-hidden'][data-render-mode=\"shadow\"] .slds-form-element__label")), shadowSelector, " {display: none}"].join('');
      /*LWC compiler v7.1.5*/
    }
    var stylesheet1$1 = [stylesheet];

    var stylesheet1 = [stylesheet0__default.default, stylesheet1$1];

    var _implicitStylesheets = [stylesheet0, stylesheet1, stylesheet2__default.default];

    const $fragment1 = lwc.parseFragment`<div${"a0:id"}${"c0"} data-help-message part="help-text" role="status"${2}>${"t1"}</div>`;
    const stc0 = {
      "exportparts": "input-text, input-container, input"
    };
    const stc1 = {
      slotAssignment: "label-end",
      attrs: {
        "name": "label-end"
      },
      key: 1
    };
    const stc2 = [];
    const stc3 = {
      "exportparts": "indicator"
    };
    const stc4 = {
      "exportparts": "button"
    };
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {b: api_bind, s: api_slot, c: api_custom_element, gid: api_scoped_id, ncls: api_normalize_class_name, d: api_dynamic_text, sp: api_static_part, st: api_static_fragment} = $api;
      const {_m0, _m1, _m2, _m3, _m4, _m5, _m6, _m7, _m8, _m9, _m10, _m11, _m12, _m13, _m14, _m15, _m16, _m17, _m18, _m19, _m20, _m21, _m22, _m23, _m24, _m25, _m26, _m27, _m28, _m29, _m30, _m31, _m32} = $ctx;
      return [$cmp.isTypeSimple ? api_custom_element("lightning-primitive-input-simple", _lightningPrimitiveInputSimple__default.default, {
        attrs: stc0,
        props: {
          "accessKey": $cmp.accesskey,
          "ariaHasPopup": $cmp.ariaHasPopup,
          "ariaKeyShortcuts": $cmp.ariaKeyShortcuts,
          "ariaDisabled": $cmp.ariaDisabled,
          "ariaRoleDescription": $cmp.ariaRoleDescription,
          "ariaInvalid": $cmp.computedAriaInvalid,
          "ariaLabel": $cmp.computedAriaLabel,
          "ariaExpanded": $cmp.ariaExpanded,
          "ariaAutoComplete": $cmp.ariaAutoComplete,
          "autocomplete": $cmp.autocomplete,
          "computedLabelClass": $cmp.computedLabelClass,
          "disabled": $cmp.disabled,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "formatter": $cmp.formatter,
          "formatFractionDigits": $cmp.formatFractionDigits,
          "hasExternalLabel": $cmp.hasExternalLabel,
          "helptextAlternativeText": $cmp.helptextAlternativeText,
          "helpMessage": $cmp._helpMessage,
          "isLoading": $cmp.isLoading,
          "label": $cmp.label,
          "max": $cmp.normalizedMax,
          "maxLength": $cmp.maxLength,
          "min": $cmp.normalizedMin,
          "minLength": $cmp.minLength,
          "name": $cmp.name,
          "pattern": $cmp.pattern,
          "placeholder": $cmp.placeholder,
          "readOnly": $cmp.readOnly,
          "required": $cmp.required,
          "role": $cmp.role,
          "step": $cmp.step,
          "type": $cmp.type,
          "timezone": $cmp.timezone,
          "variant": $cmp.variant,
          "value": $cmp.value,
          "validity": $cmp.validity
        },
        key: 0,
        on: {
          "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handlePrimitiveInputChange)),
          "commit": _m3 || ($ctx._m3 = api_bind($cmp.handleCommit))
        }
      }, [api_slot("label-end", stc1, stc2, $slotset)]) : null, $cmp.isTypeToggle ? api_custom_element("lightning-primitive-input-toggle", _lightningPrimitiveInputToggle__default.default, {
        attrs: stc3,
        props: {
          "accessKey": $cmp.accesskey,
          "ariaLabel": $cmp.computedAriaLabel,
          "ariaKeyShortcuts": $cmp.ariaKeyShortcuts,
          "ariaDisabled": $cmp.ariaDisabled,
          "ariaRoleDescription": $cmp.ariaRoleDescription,
          "ariaInvalid": $cmp.computedAriaInvalid,
          "checked": $cmp.checked,
          "disabled": $cmp.disabled,
          "helpMessage": $cmp._helpMessage,
          "label": $cmp.label,
          "messageToggleActive": $cmp.messageToggleActive,
          "messageToggleInactive": $cmp.messageToggleInactive,
          "name": $cmp.name,
          "readOnly": $cmp.readOnly,
          "required": $cmp.required,
          "value": $cmp.value,
          "variant": $cmp.variant
        },
        key: 2,
        on: {
          "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleBlur)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange)),
          "focus": _m6 || ($ctx._m6 = api_bind($cmp.handleFocus))
        }
      }) : null, $cmp.isTypeCheckbox ? api_custom_element("lightning-primitive-input-checkbox", _lightningPrimitiveInputCheckbox__default.default, {
        attrs: stc3,
        props: {
          "accessKey": $cmp.accesskey,
          "ariaLabel": $cmp.computedAriaLabel,
          "ariaKeyShortcuts": $cmp.ariaKeyShortcuts,
          "ariaDisabled": $cmp.ariaDisabled,
          "ariaRoleDescription": $cmp.ariaRoleDescription,
          "ariaInvalid": $cmp.computedAriaInvalid,
          "checked": $cmp.checked,
          "disabled": $cmp.disabled,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "helpMessage": $cmp._helpMessage,
          "helptextAlternativeText": $cmp.helptextAlternativeText,
          "label": $cmp.label,
          "labelHidden": $cmp.labelHidden,
          "name": $cmp.name,
          "readOnly": $cmp.readOnly,
          "required": $cmp.required,
          "variant": $cmp.variant
        },
        key: 3,
        on: {
          "blur": _m7 || ($ctx._m7 = api_bind($cmp.handleBlur)),
          "change": _m8 || ($ctx._m8 = api_bind($cmp.handleChange)),
          "focus": _m9 || ($ctx._m9 = api_bind($cmp.handleFocus))
        }
      }) : null, $cmp.isTypeCheckboxButton ? api_custom_element("lightning-primitive-input-checkbox-button", _lightningPrimitiveInputCheckboxButton__default.default, {
        props: {
          "label": $cmp.label,
          "ariaLabel": $cmp.ariaLabel,
          "ariaKeyShortcuts": $cmp.ariaKeyShortcuts,
          "ariaDisabled": $cmp.ariaDisabled,
          "ariaRoleDescription": $cmp.ariaRoleDescription,
          "ariaInvalid": $cmp.computedAriaInvalid,
          "required": $cmp.required,
          "accessKey": $cmp.accesskey,
          "disabled": $cmp.disabled,
          "name": $cmp.name,
          "readOnly": $cmp.readOnly,
          "checked": $cmp.checked,
          "helpMessage": $cmp._helpMessage
        },
        key: 4,
        on: {
          "blur": _m10 || ($ctx._m10 = api_bind($cmp.handleBlur)),
          "focus": _m11 || ($ctx._m11 = api_bind($cmp.handleFocus)),
          "change": _m12 || ($ctx._m12 = api_bind($cmp.handleChange))
        }
      }) : null, $cmp.isTypeRadio ? api_custom_element("lightning-primitive-input-radio", _lightningPrimitiveInputRadio__default.default, {
        attrs: stc3,
        props: {
          "accessKey": $cmp.accesskey,
          "ariaInvalid": $cmp.computedAriaInvalid,
          "ariaKeyShortcuts": $cmp.ariaKeyShortcuts,
          "ariaDisabled": $cmp.ariaDisabled,
          "ariaRoleDescription": $cmp.ariaRoleDescription,
          "ariaLabel": $cmp.ariaLabel,
          "disabled": $cmp.disabled,
          "helpMessage": $cmp._helpMessage,
          "label": $cmp.label,
          "name": $cmp.name,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "variant": $cmp.variant
        },
        key: 5,
        on: {
          "blur": _m13 || ($ctx._m13 = api_bind($cmp.handleBlur)),
          "change": _m14 || ($ctx._m14 = api_bind($cmp.handleChange)),
          "focus": _m15 || ($ctx._m15 = api_bind($cmp.handleFocus))
        }
      }) : null, $cmp.isTypeFile ? api_custom_element("lightning-primitive-input-file", _lightningPrimitiveInputFile__default.default, {
        attrs: stc4,
        props: {
          "accept": $cmp.accept,
          "accessKey": $cmp.accesskey,
          "ariaInvalid": $cmp.computedAriaInvalid,
          "ariaKeyShortcuts": $cmp.ariaKeyShortcuts,
          "ariaDisabled": $cmp.ariaDisabled,
          "ariaRoleDescription": $cmp.ariaRoleDescription,
          "ariaLabel": $cmp.computedAriaLabel,
          "disabled": $cmp.disabled,
          "helpMessage": $cmp._helpMessage,
          "label": $cmp.label,
          "labelClass": $cmp.computedLabelClass,
          "multiple": $cmp.multiple,
          "name": $cmp.name,
          "readOnly": $cmp.readOnly,
          "required": $cmp.required,
          "variant": $cmp.variant
        },
        key: 6,
        on: {
          "reportvalidity": _m16 || ($ctx._m16 = api_bind($cmp.reportValidity)),
          "blur": _m17 || ($ctx._m17 = api_bind($cmp.handleBlur)),
          "focus": _m18 || ($ctx._m18 = api_bind($cmp.handleFocus)),
          "change": _m19 || ($ctx._m19 = api_bind($cmp.handlePrimitiveInputFileChange))
        }
      }) : null, $cmp.isTypeColor ? api_custom_element("lightning-primitive-input-color", _lightningPrimitiveInputColor__default.default, {
        props: {
          "label": $cmp.label,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "helpMessage": $cmp._helpMessage,
          "helptextAlternativeText": $cmp.helptextAlternativeText,
          "hasExternalLabel": $cmp.hasExternalLabel,
          "required": $cmp.required,
          "accessKey": $cmp.accesskey,
          "disabled": $cmp.disabled,
          "name": $cmp.name,
          "autocomplete": $cmp.autocomplete,
          "placeholder": $cmp.placeholder,
          "pattern": $cmp.pattern,
          "ariaLabel": $cmp.ariaLabel,
          "ariaInvalid": $cmp.computedAriaInvalid,
          "ariaKeyShortcuts": $cmp.ariaKeyShortcuts,
          "ariaDisabled": $cmp.ariaDisabled,
          "value": $cmp.value,
          "variant": $cmp.variant
        },
        key: 7,
        on: {
          "blur": _m20 || ($ctx._m20 = api_bind($cmp.handleBlur)),
          "commit": _m21 || ($ctx._m21 = api_bind($cmp.handleCommit)),
          "focus": _m22 || ($ctx._m22 = api_bind($cmp.handleFocus)),
          "change": _m23 || ($ctx._m23 = api_bind($cmp.handlePrimitiveInputChange))
        }
      }) : null, $cmp.isTypeDesktopDate ? api_custom_element("lightning-datepicker", _lightningDatepicker__default.default, {
        props: {
          "max": $cmp.max,
          "min": $cmp.min,
          "label": $cmp.label,
          "name": $cmp.name,
          "accessKey": $cmp.accesskey,
          "variant": $cmp.variant,
          "ariaLabel": $cmp.ariaLabel,
          "ariaDisabled": $cmp.ariaDisabled,
          "dateStyle": $cmp.dateStyle,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "autocomplete": $cmp.autocomplete,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled,
          "rootAriaNode": $cmp.templateRootNode
        },
        key: 8,
        on: {
          "change": _m24 || ($ctx._m24 = api_bind($cmp.handleChange)),
          "blur": _m25 || ($ctx._m25 = api_bind($cmp.handleBlur)),
          "focus": _m26 || ($ctx._m26 = api_bind($cmp.handleFocus))
        }
      }) : null, $cmp.isTypeDesktopTime ? api_custom_element("lightning-timepicker", _lightningTimepicker__default.default, {
        props: {
          "max": $cmp.max,
          "min": $cmp.min,
          "label": $cmp.label,
          "name": $cmp.name,
          "accessKey": $cmp.accesskey,
          "ariaLabel": $cmp.ariaLabel,
          "ariaDisabled": $cmp.ariaDisabled,
          "variant": $cmp.variant,
          "timeStyle": $cmp.timeStyle,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "autocomplete": $cmp.autocomplete,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled,
          "rootAriaNode": $cmp.templateRootNode
        },
        key: 9,
        on: {
          "change": _m27 || ($ctx._m27 = api_bind($cmp.handleChange)),
          "blur": _m28 || ($ctx._m28 = api_bind($cmp.handleBlur)),
          "focus": _m29 || ($ctx._m29 = api_bind($cmp.handleFocus))
        }
      }) : null, $cmp.isTypeDesktopDateTime ? api_custom_element("lightning-datetimepicker", _lightningDatetimepicker__default.default, {
        props: {
          "dateAriaControls": $cmp.dateAriaControls,
          "dateAriaLabel": $cmp.dateAriaLabel,
          "dateAriaLabelledBy": $cmp.dateAriaLabelledBy,
          "dateAriaDescribedBy": $cmp.dateAriaDescribedBy,
          "dateAriaDetails": $cmp.dateAriaDetails,
          "ariaDisabled": $cmp.ariaDisabled,
          "dateStyle": $cmp.dateStyle,
          "timeStyle": $cmp.timeStyle,
          "dateAccessKey": $cmp.dateAccessKey,
          "timeAccessKey": $cmp.timeAccessKey,
          "timeAriaControls": $cmp.timeAriaControls,
          "timeAriaLabel": $cmp.timeAriaLabel,
          "timeAriaLabelledBy": $cmp.timeAriaLabelledBy,
          "timeAriaDescribedBy": $cmp.timeAriaDescribedBy,
          "timeAriaDetails": $cmp.timeAriaDetails,
          "max": $cmp.max,
          "min": $cmp.min,
          "timezone": $cmp.timezone,
          "label": $cmp.label,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "autocomplete": $cmp.autocomplete,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled,
          "rootAriaNode": $cmp.templateRootNode
        },
        key: 10,
        on: {
          "change": _m30 || ($ctx._m30 = api_bind($cmp.handleChange)),
          "blur": _m31 || ($ctx._m31 = api_bind($cmp.handleBlur)),
          "focus": _m32 || ($ctx._m32 = api_bind($cmp.handleFocus))
        }
      }) : null, $cmp.shouldShowHelpMessage ? api_static_fragment($fragment1, 12, [api_static_part(0, {
        className: api_normalize_class_name($cmp.computedHelpMessageClass),
        attrs: {
          "id": api_scoped_id("help-message")
        }
      }, null), api_static_part(1, null, api_dynamic_text($cmp._helpMessage))]) : null];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = ["label-end"];
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-66unc5l95ad";
    tmpl.legacyStylesheetToken = "lightning-input_input";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    function normalizeDate(value) {
      return internationalizationLibrary.normalizeISODate(value, 'medium').isoValue || '';
    }

    // Converts value to the user's timezone and formats it in a way that will be accepted by the input
    function normalizeUTCDateTime(value, timezone) {
      return internationalizationLibrary.normalizeISODateTime(value, timezone).isoValue || '';
    }
    function normalizeTime(value) {
      return internationalizationLibrary.normalizeISOTime(value, 'short').isoValue || '';
    }

    // parses the input value and converts it back to UTC from the user's timezone
    function normalizeDateTimeToUTC(value, timezone) {
      return internationalizationLibrary.normalizeFormattedDateTime(value, timezone) || '';
    }

    const i18n = {
      a11yTriggerText: labelA11yTriggerText__default.default,
      messageToggleActive: labelMessageToggleActive__default.default,
      messageToggleInactive: labelMessageToggleInactive__default.default,
      numberIncrementCounter: labelNumberIncrementCounter__default.default,
      numberDecrementCounter: labelNumberDecrementCounter__default.default,
      required: labelRequired__default.default,
      clear: labelClearInput__default.default,
      loading: labelLoadingIndicator__default.default,
      helpTextAlternativeText: labelHelpTextAlternativeText__default.default
    };
    const ARIA_CONTROLS = 'aria-controls';
    const ARIA_DETAILS = 'aria-details';
    const ARIA_LABEL = 'aria-label';
    const ARIA_LABELLEDBY = 'aria-labelledby';
    const ARIA_DESCRIBEDBY = 'aria-describedby';
    const ARIA_ERRORMESSAGE = 'aria-errormessage';

    /*
     * This component supports the regular native input types, with the addition of toggle, checkbox-button and color.
     * Furthermore the file type supports a droppable zone, search has a clear button, number has formatting.
     * Input changes (native oninput event) triggers an onchange event,
     *     the native even is stopped, the dispatched custom event has a value that points to the state of the component
     *     in case of files it's the files uploaded (via droppable zone or through the upload button),
     *     checked for radio and checkbox, checkbox-button, and just straight input's value for everything else
     *
     *
     * _Toggle_ (always has an aria-describedby, on error has an additional one, default label text for active and inactive
     * states)
     * _File_ (as it has a droppable zone, the validity returned would have to be valid - unless a custom error message was
     *    passed)
     * _Search_ (it has the clear button and the icon)
     * _Number_ (formatting when not in focus, when in focus shows raw value)
     *
     * */

    const VALID_INPUT_TYPES = ['checkbox', 'checkbox-button', 'date', 'datetime', 'time', 'email', 'file', 'password', 'search', 'tel', 'url', 'number', 'text', 'radio', 'toggle', 'color', 'range',
    // the following types are not listed as supported
    // as of 246, but have historically worked and are
    // relied on by customers
    'datetime-local', 'month', 'week'];
    const VALID_NUMBER_FORMATTERS = ['decimal', 'percent', 'percent-fixed', 'currency'];
    const DEFAULT_FORMATTER = VALID_NUMBER_FORMATTERS[0];

    /**
     * Represents interactive controls that accept user input depending on the type attribute.
     */
    class LightningInput extends LightningShadowBaseClass__default.default {
      /**
       * Controls auto-filling of the field. Use this attribute with
       * email, search, tel, text, and url input types only. Set the attribute to pass
       * through autocomplete values to be interpreted by the browser.
       * @type {string}
       */
      get autocomplete() {
        if (this.isAutoCompleteSupported) {
          return this._autocomplete;
        }
        if (this.isTypeDate || this.isTypeDateTime || this.isTypeTime) {
          // When type='date' or type='datetime' or type='time'
          // the value of autocomplete is 'off'
          return 'off';
        }
        return undefined;
      }
      set autocomplete(value) {
        this._autocomplete = value;
      }

      /**
       * The display style of the date when type='date' or type='datetime'. Valid values are
       * short, medium (default), and long. The format of each style is specific to the locale.
       * On mobile devices this attribute has no effect.
       * @type {string}
       * @default medium
       */

      constructor() {
        super();
        /**
         * Text that is displayed when the field is empty, to prompt the user for a valid entry. Use this attribute with date, email, number, password, search, tel, text, time, and url input types only.
         * @type {string}
         *
         */
        this.placeholder = void 0;
        /**
         * Specifies the name of an input element.
         * @type {string}
         *
         */
        this.name = void 0;
        /**
         * Text label for the input.
         * @type {string}
         * @required
         *
         */
        this.label = void 0;
        /**
         * Error message to be displayed when a bad input is detected. The badInput error can be returned for invalid input for any input type.
         * @type {string}
         *
         */
        this.messageWhenBadInput = void 0;
        /**
         * Error message to be displayed when a pattern mismatch is detected. The patternMismatch error can be returned when you specify a pattern for email, password, search, tel, text, or url input types.
         * @type {string}
         *
         */
        this.messageWhenPatternMismatch = void 0;
        /**
         * Error message to be displayed when a range overflow is detected. The rangeOverflow error can be returned when you specify a max value for number or range input types.
         * @type {string}
         *
         */
        this.messageWhenRangeOverflow = void 0;
        /**
         * Error message to be displayed when a range underflow is detected. The rangeUnderflow error can be returned when you specify a min value for number or range input types.
         * @type {string}
         *
         */
        this.messageWhenRangeUnderflow = void 0;
        /**
         * Error message to be displayed when a step mismatch is detected. The stepMismatch error can be returned when you specify a step value for number and range input types.
         * @type {string}
         *
         */
        this.messageWhenStepMismatch = void 0;
        /**
         * Error message to be displayed when the value is too short. The tooShort error can be returned when you specify a min-length value for email, password, search, tel, text, and url input types.
         * @type {string}
         *
         */
        this.messageWhenTooShort = void 0;
        /**
         * Error message to be displayed when the value is too long. The tooLong error can be returned when you specify a max-length value for email, password, search, tel, text, and url input types.
         * @type {string}
         *
         */
        this.messageWhenTooLong = void 0;
        /**
         * Error message to be displayed when a type mismatch is detected. The typeMismatch error can be returned for the email and url input types.
         * @type {string}
         *
         */
        this.messageWhenTypeMismatch = void 0;
        /**
         * Error message to be displayed when the value is missing. The valueMissing error can be returned when you specify the required attribute for any input type.
         * @type {string}
         *
         */
        this.messageWhenValueMissing = void 0;
        /**
         * Text shown for the active state of a toggle. The default is "Active".
         * @type {string}
         */
        this.messageToggleActive = i18n.messageToggleActive;
        /**
         * Text shown for the inactive state of a toggle. The default is "Inactive".
         * @type {string}
         */
        this.messageToggleInactive = i18n.messageToggleInactive;
        /**
         * Describes the input to assistive technologies.
         * @type {string}
         */
        this.ariaLabel = void 0;
        this.dateStyle = void 0;
        /**
         * The display style of the time when type='time' or type='datetime'. Valid values are
         * short (default), medium, and long. Currently, medium and long styles look the same.
         * On mobile devices this attribute has no effect.
         * @type {string}
         * @default short
         *
         */
        this.timeStyle = void 0;
        /**
         * Describes the date input to assistive technologies when type='datetime'. On mobile devices,
         * this label is merged with aria-label and time-aria-label to describe the native date time input.
         * @type {string}
         *
         */
        this.dateAriaLabel = void 0;
        /**
         * Describes the time input to assistive technologies when type='datetime'. On mobile devices,
         * this label is merged with aria-label and date-aria-label to describe the native date time input.
         * @type {string}
         *
         */
        this.timeAriaLabel = void 0;
        /**
         * Sets a key that can be used to access the date picker when you use the datetime type.
         * @type {string}
         *
         */
        this.dateAccessKey = void 0;
        /**
         * Sets a key that can be used to access the time picker when you use the datetime type.
         * @type {string}
         *
         */
        this.timeAccessKey = void 0;
        this._timeAriaDescribedBy = void 0;
        this._timeAriaLabelledBy = void 0;
        this._timeAriaControls = void 0;
        this._dateAriaControls = void 0;
        this._timeAriaDetails = void 0;
        this._dateAriaDetails = void 0;
        this._dateAriaDescribedBy = void 0;
        this._dateAriaLabelledBy = void 0;
        this._value = '';
        this._type = 'text';
        this._pattern = void 0;
        this._max = void 0;
        this._min = void 0;
        this._step = void 0;
        this._disabled = false;
        this._readOnly = false;
        this._required = false;
        this._checked = false;
        this._isLoading = false;
        this._multiple = false;
        this._timezone = false;
        this._helpMessage = null;
        this._isColorPickerPanelOpen = false;
        this._fieldLevelHelp = void 0;
        this._accesskey = void 0;
        this._maxLength = void 0;
        this._minLength = void 0;
        this._accept = void 0;
        this._variant = void 0;
        this._ariaInvalid = void 0;
        this._autocomplete = void 0;
        this._shouldShowHelpMessage = true;
        this._helpMessageChanged = false;
        this._formatter = DEFAULT_FORMATTER;
        this._initialValueSet = false;
        this._rendered = void 0;
        /**
         * Reserved for internal use.
         * @type {number}
         *
         */
        this.formatFractionDigits = void 0;
        /**
         * Specifies the value of the aria-haspopup attribute
         */
        this.ariaHasPopup = void 0;
        /**
         * Specifies the value of the aria-keyshortcuts attribute
         * @type {string}
         */
        this.ariaKeyShortcuts = void 0;
        /**
         * Specifies the value of the aria-disabled attribute
         * @type {boolean}
         */
        this.ariaDisabled = void 0;
        /**
         * Specifies the value of the aria-roledescription attribute
         * @type {string}
         */
        this.ariaRoleDescription = void 0;
        /**
         * Specifies the value of the aria-expanded attribute, only valid on type simple
         * @type {string}
         */
        this.ariaExpanded = void 0;
        /**
         * Specifies the value of the aria-autocomplete, only valid on type simple
         * @type {string}
         */
        this.ariaAutoComplete = void 0;
        this.ariaObserver = new AriaObserver__default.default(this);

        // Native Shadow Root will return [native code].
        // Our synthetic method will return the function source.
        this._isNativeShadow = utilsPrivate.isNativeComponent(this);
      }
      connectedCallback() {
        if (!this.ariaObserver) {
          this.ariaObserver = new AriaObserver__default.default(this);
        }
        // Manually track connected state because this.template.isConnected can be false
        // when input is created using createElement and inserted into dom manually.
        // i.e. create an input element and pass it to showCustomOverlay
        // Remove this state and the one in AriaObserver once the issue is fixed.
        // PR: https://github.com/salesforce/lwc/pull/1798

        this.classList.add('slds-form-element');
        this.updateClassListForVariant();
        this.validateRequiredAttributes();
        this.interactingState = new inputUtils.InteractingState();
        this.interactingState.onleave(() => this.reportValidity());
      }
      disconnectedCallback() {
        this._rendered = false;
        this._initialValueSet = false;
        this._cachedInputElement = undefined;
        this.cachedPrimitiveComponent = undefined;
        if (this.ariaObserver) {
          this.ariaObserver.disconnect();
          this.ariaObserver = undefined;
        }
      }
      renderedCallback() {
        if (this.isConnected) {
          this.ariaObserver.sync(this.isNativeShadow);

          // If the help message changed, the help message element needs to be (un)related
          if (this._helpMessageChanged) {
            this.connectAriaDescribedBy();
            this.connectAriaErrorMessage();
            this._helpMessageChanged = false;
          }
          if (!this._rendered) {
            this.connectAriaDescribedBy();
            this.connectAriaErrorMessage();
            this.connectAriaLabelledBy();
            this.connectAriaControls();
            this.connectAriaDetails();
          }
        }
        if (!this._initialValueSet && this._inputElement) {
          this._rendered = true;
          this._setInputValue(this._displayedValue);
          if (this.isTypeCheckable) {
            this._inputElement.checked = this._checked;
          }
          this._initialValueSet = true;
        }
        this._synchronizeA11y();
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the
       * time input when type='datetime'. On mobile devices, this is merged with aria-controls
       * and date-aria-controls to describe the native date time input.
       * @type {string}
       */
      get timeAriaControls() {
        return this._timeAriaControls;
      }
      set timeAriaControls(references) {
        this._timeAriaControls = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._timeAriaControls = reference;
        });
      }

      /**
       * A space-separated list of IDs of elements that provide details of the
       * date input when type='datetime'.
       * @type {string}
       *
       */
      get timeAriaDetails() {
        return this._timeAriaDetails;
      }
      set timeAriaDetails(references) {
        this._timeAriaDetails = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._timeAriaDetails = reference;
        });
      }

      /**
       * A space-separated list of element IDs that provide labels for the date input when type='datetime'.
       * On mobile devices, this is merged with aria-labelled-by and time-aria-labelled-by to describe
       * the native date time input.
       * @type {string}
       */
      get dateAriaLabelledBy() {
        return this._dateAriaLabelledBy;
      }
      set dateAriaLabelledBy(references) {
        this._dateAriaLabelledBy = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._dateAriaLabelledBy = reference;
        });
      }

      /**
       * A space-separated list of element IDs that provide labels for the time input when type='datetime'.
       * On mobile devices, this is merged with aria-labelled-by and date-aria-labelled-by to describe
       * the native date time input.
       * @type {string}
       *
       */
      get timeAriaLabelledBy() {
        return this._timeAriaLabelledBy;
      }
      set timeAriaLabelledBy(references) {
        this._timeAriaLabelledBy = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._timeAriaLabelledBy = reference;
        });
      }

      /**
       * A space-separated list of element IDs that provide descriptive labels for the time input when
       * type='datetime'. On mobile devices, this is merged with aria-described-by and date-aria-described-by
       * to describe the native date time input.
       *  @type {string}
       *
       */
      get timeAriaDescribedBy() {
        return this._timeAriaDescribedBy;
      }
      set timeAriaDescribedBy(references) {
        this._timeAriaDescribedBy = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._timeAriaDescribedBy = reference;
        });
      }

      /**
       * A space-separated list of element IDs whose presence or content is controlled by the
       * date input when type='datetime'. On mobile devices, this is merged with aria-controls
       * and time-aria-controls to describe the native date time input.
       * @type {string}
       *
       */
      get dateAriaControls() {
        return this._dateAriaControls;
      }
      set dateAriaControls(references) {
        this._dateAriaControls = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._dateAriaControls = reference;
        });
      }

      /**
       * A space-separated list of IDs of elements that provide details of the
       * date input when type='datetime'.
       * @type {string}
       *
       */
      get dateAriaDetails() {
        return this._dateAriaDetails;
      }
      set dateAriaDetails(references) {
        this._dateAriaDetails = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._dateAriaDetails = reference;
        });
      }

      /**
       * A space-separated list of element IDs that provide descriptive labels for the date input when
       * type='datetime'. On mobile devices, this is merged with aria-described-by and time-aria-described-by
       * to describe the native date time input.
       * @type {string}
       */
      get dateAriaDescribedBy() {
        return this._dateAriaDescribedBy;
      }
      set dateAriaDescribedBy(references) {
        this._dateAriaDescribedBy = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._dateAriaDescribedBy = reference;
        });
      }

      /**
       * A space-separated list of element IDs whose presence or content is controlled by the input.
       * @type {string}
       */
      get ariaControls() {
        return this._ariaControls;
      }
      set ariaControls(references) {
        this._ariaControls = references;
        if (this._rendered) {
          this.connectAriaControls();
        }
      }

      /**
       * A space-separated list of IDs of elements that provide details for the input.
       * @type {string}
       */
      get ariaDetails() {
        return this._ariaControls;
      }
      set ariaDetails(references) {
        this._ariaDetails = references;
        if (this._rendered) {
          this.connectAriaDetails();
        }
      }

      /**
       * A space-separated list of element IDs that provide labels for the input.
       * @type {string}
       */
      get ariaLabelledBy() {
        // native shadow version returns the mirrored values
        return this._rendered && this.isNativeShadow ? this._inputElement.getAttribute(ARIA_LABELLEDBY) : this._ariaLabelledBy;
      }
      set ariaLabelledBy(references) {
        this._ariaLabelledBy = references;
        if (this._rendered) {
          this.connectAriaLabelledBy();
        }
      }

      /**
       * A space-separated list of element IDs that provide descriptive labels for the input.
       * @type {string}
       */
      get ariaDescribedBy() {
        // native shadow version returns the mirrored values
        return this._rendered && this.isNativeShadow ? this._inputElement.getAttribute(ARIA_DESCRIBEDBY) : this._ariaDescribedBy;
      }
      set ariaDescribedBy(references) {
        this._ariaDescribedBy = references;
        if (this._rendered) {
          this.connectAriaDescribedBy();
        }
      }

      /**
       * A space-separated list of element IDs that provide descriptive error-message for input.
       * @returns {string}
       */
      get ariaErrorMessage() {
        return this._rendered && this.isNativeShadow ? this._inputElement.getAttribute(ARIA_ERRORMESSAGE) : this._ariaErrorMessage;
      }
      set ariaErrorMessage(references) {
        this._ariaErrorMessage = references;
        if (this._rendered) {
          this.connectAriaErrorMessage();
        }
      }
      get isNativeShadow() {
        return this._primitiveComponent?.isNativeShadow || this._isNativeShadow;
      }

      /**
       * Connect aria-labelledby to the ariaObserver.
       */
      connectAriaLabelledBy() {
        if (this._primitiveComponent) {
          this.ariaObserver.connect({
            attribute: ARIA_LABELLEDBY,
            targetNode: this._inputElement,
            relatedNodes: this._primitiveComponent.ariaLabelledByElements,
            relatedNodeIds: this._ariaLabelledBy
          });
        }
      }

      /**
       * Connect aria-describedby to the ariaObserver.
       */
      connectAriaDescribedBy() {
        if (this._primitiveComponent) {
          this.ariaObserver.connect({
            attribute: ARIA_DESCRIBEDBY,
            targetNode: this._inputElement,
            relatedNodes: this._primitiveComponent.ariaDescribedByElements,
            relatedNodeIds: this._ariaDescribedBy
          });
        }
      }

      /**
       * Connect aria-errormessage to the ariaObserver
       */
      connectAriaErrorMessage() {
        if (this._primitiveComponent) {
          this.ariaObserver.connect({
            attribute: ARIA_ERRORMESSAGE,
            targetNode: this._inputElement,
            relatedNodes: this._primitiveComponent.ariaErrorMessageElements,
            relatedNodeIds: this._ariaErrorMessage
          });
        }
      }

      /**
       * Connect aria-controls to the ariaObserver.
       */
      connectAriaControls() {
        if (this._primitiveComponent) {
          this.ariaObserver.connect({
            attribute: ARIA_CONTROLS,
            targetNode: this._inputElement,
            relatedNodeIds: this._ariaControls
          });
        }
      }

      /**
       * Connect aria-details to the ariaObserver.
       */
      connectAriaDetails() {
        if (this._primitiveComponent) {
          this.ariaObserver.connect({
            attribute: ARIA_DETAILS,
            targetNode: this._inputElement,
            relatedNodeIds: this._ariaDetails
          });
        }
      }

      /**
       * A Boolean value for aria-invalid.
       * @type {boolean}
       */
      get ariaInvalid() {
        return this._ariaInvalid;
      }
      set ariaInvalid(value) {
        let _value = typeof value == 'undefined' ? undefined : utilsPrivate.normalizeBoolean(value); /* Preserving Backward compatibility donot set any aria-invalid when not specified by user */
        this._ariaInvalid = _value;
      }
      /**
       * String value with the formatter to be used for number input. Valid values include
       * decimal, percent, percent-fixed, and currency.
       * @type {string}
       */
      get formatter() {
        // Formatters are applicable to the number type
        // If the primitive exists, retrieve value from primitive-input-simple
        if (this.isTypeNumber && this._primitiveComponent) {
          return this._primitiveComponent.formatter;
        }
        return this._formatter;
      }
      set formatter(value) {
        this._formatter = value;

        // If the primitive exists, retrieve value from primitive-input-simple
        // The primitive will normalize the value
        if (this.isTypeNumber && this._primitiveComponent) {
          this._primitiveComponent.formatter = this._formatter;
        }
      }

      /**
       * The type of the input. Valid values are checkbox, checkbox-button,
       * color, date, datetime, time, email, file, password, range, search,
       * tel, url, number, and toggle. This value defaults to text.
       * @type {string}
       * @default text
       */
      get type() {
        return this._type;
      }
      set type(value) {
        const wasTypeSimple = this.isTypeSimple;
        const normalizedValue = utilsPrivate.normalizeString(value);
        this._type = normalizedValue === 'datetime' ? 'datetime-local' : normalizedValue;

        // preserve old behavior of defaulting to 'text' if user supplies an invalid type.
        if (!this._validateType(normalizedValue)) {
          this._type = 'text';
        }

        // If the type change was not primitive to primitive, we must update the cached component.
        if (!wasTypeSimple || !this.isTypeSimple) {
          this._primitiveComponentRefreshNeeded = true;
        }

        // If the type change was not primitive to primitive, we must update the cached component.
        if (!wasTypeSimple || !this.isTypeSimple) {
          this._primitiveComponentRefreshNeeded = true;
        }
        this._primitiveComponentRefreshNeeded = true;
        this._inputElementRefreshNeeded = true;
        if (this._rendered) {
          // The type is being changed after render, which means the input element may be different (eg. changing
          // from text to 'checkbox', so we need to set the initial value again
          this._initialValueSet = false;

          // Reconnect aria attributes as the parentSelector is based on the input type
          this.connectAriaLabelledBy();
          this.connectAriaDescribedBy();
          this.connectAriaErrorMessage();
          this.connectAriaControls();
          this.connectAriaDetails();
        }
        this._updateProxyInputAttributes(['type', 'value', 'max', 'min', 'required', 'pattern']);
      }

      /**
       * For the search type only. If present, a spinner is displayed to indicate that data is loading.
       * @type {boolean}
       * @default false
       */
      get isLoading() {
        return this._isLoading;
      }
      set isLoading(value) {
        this._isLoading = utilsPrivate.normalizeBoolean(value);
      }

      /**
       * Specifies the regular expression that the input's value is checked against.
       * This attribute is supported for email, password, search, tel, text, and url types.
       * @type {string}
       *
       */
      get pattern() {
        if (this.isTypeColor) {
          return '^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$';
        }
        return this._pattern;
      }
      set pattern(value) {
        this._pattern = value;
        this._updateProxyInputAttributes('pattern');
      }

      /**
       * The maximum number of characters allowed in the field.
       * Use this attribute with email, password, search, tel, text, and url input types only.
       * @type {number}
       */
      get maxLength() {
        return this._maxLength;
      }
      set maxLength(value) {
        this._maxLength = value;
        this._updateProxyInputAttributes('maxlength');
      }

      /**
       * Specifies the types of files that the server accepts. Use this attribute with file input type only.
       * @type {string}
       */
      get accept() {
        return this._accept;
      }
      set accept(value) {
        this._accept = value;
        this._updateProxyInputAttributes('accept');
      }

      /**
       * The minimum number of characters allowed in the field.
       * Use this attribute with email, password, search, tel, text, and url input types only.
       * @type {number}
       */
      get minLength() {
        return this._minLength;
      }
      set minLength(value) {
        this._minLength = value;
        this._updateProxyInputAttributes('minlength');
      }

      // number and date/time
      /**
       * The maximum acceptable value for the input.  Use this attribute with number,
       * range, date, time, and datetime input types only. For number and range type, the max value is a
       * decimal number. For the date, time, and datetime types, the max value must use a valid string for the type.
       * @type {decimal|string}
       */
      get max() {
        return this._max;
      }
      set max(value) {
        this._max = value;
        this._updateProxyInputAttributes('max');
      }

      /**
       * The minimum acceptable value for the input. Use this attribute with number,
       * range, date, time, and datetime input types only. For number and range types, the min value
       * is a decimal number. For the date, time, and datetime types, the min value must use a valid string for the type.
       * @type {decimal|string}
       */
      get min() {
        return this._min;
      }
      set min(value) {
        this._min = value;
        this._updateProxyInputAttributes('min');
      }

      /**
       * Granularity of the value, specified as a positive floating point number.
       * Use this attribute with number and range input types only.
       * Use 'any' when granularity is not a concern. This value defaults to 1.
       * @type {decimal|string}
       * @default 1
       */
      get step() {
        // This should be reconsidered as it in effect disabled any step support for datetime/time types on mobile
        if (this.isTypeDateTime || this.isTypeTime) {
          return 'any';
        }
        // It should probably default to '1' instead, but this means that we'd be explicitly passing step='1' to the
        // native input
        return this._step;
      }
      set step(value) {
        if (typeof value === 'string' && value.toLowerCase() === 'any') {
          this._step = 'any';
        } else {
          this._step = utilsPrivate.isUndefinedOrNull(value) || isNaN(value) ? undefined : String(value);
        }
        this._updateProxyInputAttributes('step');
      }

      /**
       * If present, the checkbox is selected.
       * @type {boolean}
       * @default false
       */
      get checked() {
        // checkable inputs can be part of a named group, in that case there won't be a change event thrown and so
        // the internal tracking _checked would be out of sync with the actual input value.
        const inputElement = this._inputElement;
        if (this.isTypeCheckable && this._initialValueSet && inputElement) {
          return inputElement.checked;
        }
        return this._checked;
      }
      set checked(value) {
        this._checked = utilsPrivate.normalizeBoolean(value);
        if (this._rendered) {
          // get the component from the correct getter once
          const inputElement = this.isTypeCheckbox ? this._primitiveComponent : this._inputElement;
          // only set if the element exists
          if (inputElement) {
            inputElement.checked = this._checked;
          }
        }

        // Update proxy input should be set after _inputElement is updated.
        // because when update proxy input, it will use this.checked.
        // if not update this._inputElement, will lead to inconsistent state.
        this._updateProxyInputAttributes('checked');
        utilsPrivate.reflectAttribute(this, 'checked', this._checked);
      }

      /**
       * Specifies that a user can enter more than one value. Use this attribute with file and email input types only.
       * @type {boolean}
       * @default false
       */
      get multiple() {
        return this._multiple;
      }
      set multiple(value) {
        this._multiple = utilsPrivate.normalizeBoolean(value);
        this._updateProxyInputAttributes('multiple');
      }

      /**
       * Specifies the value of an input element.
       * @type {object}
       */
      get value() {
        // If the component is not yet rendered, use the set value.
        if (this.isTypeSimple && this._rendered) {
          const subcomponent = this._primitiveComponent;
          if (subcomponent) {
            return subcomponent.value;
          }
        }
        return this._value;
      }
      set value(value) {
        // Setting value of a type='file' isn't allowed
        if (!this.isTypeFile) {
          this._value = inputUtils.normalizeInput(value);

          // The template binding will update the primitive value on first paint
          if (this._rendered) {
            if (this.isTypeSimple) {
              const subcomponent = this._primitiveComponent;
              if (subcomponent) {
                subcomponent.value = this._value;
              }
            }
            if (this._inputElement.value !== this._displayedValue) {
              // Again, due to the interop layer we need to check whether the value being set
              // is different, otherwise we're duplicating the sets on the input, which result
              // in different bugs like Japanese IME duplication of characters in Safari (likely a browser bug) or
              // character position re-set in IE11.
              this._setInputValue(this._displayedValue);
            }
          }
          this._updateProxyInputAttributes('value');
        }
      }

      /**
       * The variant changes the appearance of an input field.
       * Accepted variants include standard, label-inline, label-hidden, and label-stacked.
       * This value defaults to standard, which displays the label above the field.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and input field.
       * Use label-stacked to place the label above the input field.
       * @type {string}
       * @default standard
       */
      get variant() {
        return this._variant || inputUtils.VARIANT.STANDARD;
      }
      set variant(value) {
        this._variant = inputUtils.normalizeVariant(value);
        this.updateClassListForVariant();
        utilsPrivate.reflectAttribute(this, 'variant', this._variant);
      }

      /**
       * If present, the input field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */
      get disabled() {
        return this._disabled;
      }
      set disabled(value) {
        this._disabled = utilsPrivate.normalizeBoolean(value);
        this._updateProxyInputAttributes('disabled');
        utilsPrivate.reflectAttribute(this, 'disabled', this.disabled);
      }

      /**
       * If present, the input field is read-only and cannot be edited by users.
       * @type {boolean}
       * @default false
       */
      get readOnly() {
        return this._readOnly;
      }
      set readOnly(value) {
        this._readOnly = utilsPrivate.normalizeBoolean(value);
        this._updateProxyInputAttributes('readonly');
        utilsPrivate.reflectAttribute(this, 'readonly', this.readOnly);
      }

      /**
       * If present, the input field must be filled out before the form is submitted.
       * @type {boolean}
       * @default false
       */
      get required() {
        return this._required;
      }
      set required(value) {
        this._required = utilsPrivate.normalizeBoolean(value);
        this._updateProxyInputAttributes('required');
      }

      /**
       * Specifies the time zone used when type='datetime' only. This value defaults to the user's Salesforce time zone setting.
       * @type {string}
       *
       */
      get timezone() {
        return this._timezone || userTimeZone__default.default;
      }
      set timezone(value) {
        this._timezone = value;
        // mobile date/time normalization of value/max/min depends on timezone, so we need to update here as well
        this._updateProxyInputAttributes(['value', 'max', 'min']);
      }

      /**
       * Help text detailing the purpose and function of the input.
       * This attribute isn't supported for file, toggle, and checkbox-button types.
       * @type {string}
       *
       */
      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      /**
       * Specifies a shortcut key to activate or focus an element.
       * @type {string}
       *
       */
      get accessKey() {
        return this._accesskey;
      }
      set accessKey(newValue) {
        this._accesskey = newValue;
      }

      /**
       * A FileList that contains selected files. Use this attribute with the file input type only.
       * @type {object}
       *
       */
      get files() {
        if (this.isTypeFile) {
          return this._primitiveComponent.files;
        }
        return null;
      }

      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */
      get validity() {
        return this._constraint.validity;
      }

      /**
       * Not moving selectionStart and selectionEnd to the inner component. Looks like
       * one of the expected error/fail cases is that the component throws an error in the console,
       * if the user attempts to set it on a non-supported type (like range, file, checkbox).
       * That can only happen from `lightning-input`. To avoid duplicating code, it's best to keep
       * this here.
       */

      /**
       * Specifies the index of the first character to select in the input element.
       * This attribute is supported only for text type.
       * Use with selection-end to programmatically set or read the position of
       * selected text.
       */
      get selectionStart() {
        if (this._inputElement && 'selectionStart' in this._inputElement) {
          return this._inputElement.selectionStart;
        }
        return undefined;
      }
      set selectionStart(index) {
        if (this._inputElement && 'selectionStart' in this._inputElement) {
          this._inputElement.selectionStart = index;
        }
      }
      /**
       * Specifies the index of the last character to select in the input element.
       * This attribute is supported only for text type.
       * Use with selection-start to programmatically set or read the position of
       * selected text.
       */
      get selectionEnd() {
        if (this._inputElement && 'selectionEnd' in this._inputElement) {
          return this._inputElement.selectionEnd;
        }
        return undefined;
      }
      set selectionEnd(index) {
        if (this._inputElement && 'selectionEnd' in this._inputElement) {
          this._inputElement.selectionEnd = index;
        }
      }

      /**
       * The role set on lightning-primitive-input-simple to allow external developers to have a type="text"
       * and role="combobox" if lightning-combobox does not meet their requirements.
       * @type {string}
       */
      get role() {
        return this._role;
      }
      set role(value) {
        if (value === 'combobox') {
          this._role = 'combobox';
        } else {
          console.warn("<lightning-input> The role attribute value is invalid. Options are: 'combobox'");
        }
      }

      /**
       * Checks if the input is valid.
       * @returns {boolean} Indicates whether the element meets all constraint validations.
       */
      checkValidity() {
        return this._constraint.checkValidity();
      }

      /**
       * Sets a custom error message to be displayed when a form is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       */
      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }

      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */
      reportValidity() {
        return this._constraint.reportValidity(message => {
          if (this.isTypeDesktopTime) {
            utilsPrivate.reflectAttribute(this._inputElement.comboboxComponent, 'invalid', !this.checkValidity());
          }
          if (this._rendered && !this.isNativeInput) {
            this._inputElement.showHelpMessage(message);
            return;
          }
          if (this._rendered && this.isTypePrimitiveInput) {
            this._shouldShowHelpMessage = false;
            this._helpMessageChanged = true;
          }
          this._helpMessage = message;
        });
      }

      /**
       * Displays error messages on invalid fields.
       * An invalid field fails at least one constraint validation and returns false when checkValidity() is called.
       */
      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      /**
       * Sets focus on the input element.
       */
      focus() {
        if (this._rendered) {
          this._inputElement.focus();
        }
      }

      /**
       * Removes keyboard focus from the input element.
       */
      blur() {
        if (this._rendered) {
          this._inputElement.blur();
        }
      }
      get primitiveSelector() {
        if (this.isTypeSimple) {
          return 'lightning-primitive-input-simple';
        }
        if (this.isTypeCheckboxButton) {
          return 'lightning-primitive-input-checkbox-button';
        }
        if (this.isTypeToggle) {
          return 'lightning-primitive-input-toggle';
        }
        if (this.isTypeColor) {
          return 'lightning-primitive-input-color';
        }
        if (this.isTypeCheckbox) {
          return 'lightning-primitive-input-checkbox';
        }
        if (this.isTypeRadio) {
          return 'lightning-primitive-input-radio';
        }
        if (this.isTypeFile) {
          return 'lightning-primitive-input-file';
        }
        return null;
      }
      get shouldShowHelpMessage() {
        return this._shouldShowHelpMessage && this._helpMessage;
      }

      /************************* INPUT TYPE GETTERS *************************/

      get isTypePrimitiveInput() {
        return this.isTypeSimple || this.isTypeCheckboxButton || this.isTypeCheckbox || this.isTypeToggle || this.isTypeColor || this.isTypeRadio || this.isTypeFile;
      }
      get isTypeNumber() {
        return this.type === 'number';
      }
      get isTypeTelephone() {
        return this.type === 'tel';
      }
      get isTypeUrl() {
        return this.type === 'url';
      }
      get isTypeEmail() {
        // To test against native change this to type="emails"
        return this.type === 'email';
      }
      get isTypeCheckable() {
        return this.isTypeCheckbox || this.isTypeCheckboxButton || this.isTypeRadio || this.isTypeToggle;
      }
      get isTypeToggle() {
        return this.type === 'toggle';
      }
      get isTypeText() {
        return this.type === 'text';
      }
      get isTypeCheckbox() {
        return this.type === 'checkbox';
      }
      get isTypeRadio() {
        return this.type === 'radio';
      }
      get isTypeCheckboxButton() {
        return this.type === 'checkbox-button';
      }
      get isTypeFile() {
        return this.type === 'file';
      }
      get isTypeColor() {
        return this.type === 'color';
      }
      get isTypeDate() {
        return this.type === 'date';
      }
      get isTypeDateTime() {
        return this.type === 'datetime' || this.type === 'datetime-local';
      }
      get isTypeTime() {
        return this.type === 'time';
      }
      get isTypeSearch() {
        return this.type === 'search';
      }
      get isTypeMobileDate() {
        return this.isTypeDate && !this._isDesktopBrowser();
      }
      get isTypeDesktopDate() {
        return this.isTypeDate && this._isDesktopBrowser();
      }
      get isTypeMobileDateTime() {
        return this.isTypeDateTime && !this._isDesktopBrowser();
      }
      get isTypeDesktopDateTime() {
        return this.isTypeDateTime && this._isDesktopBrowser();
      }
      get isTypeMobileTime() {
        return this.isTypeTime && !this._isDesktopBrowser();
      }
      get isTypeDesktopTime() {
        return this.isTypeTime && this._isDesktopBrowser();
      }
      get isTypeSimple() {
        const type = this.type;
        return type === 'text' || type === 'number' || type === 'email' || type === 'tel' || type === 'url' || type === 'search' || type === 'password' || type === 'range' || type === 'month' || type === 'week' || !type || !this._isDesktopBrowser() && (type === 'date' || type === 'time' || type === 'datetime' || type === 'datetime-local');
      }
      get isNativeInput() {
        return !(this.isTypeDesktopDate || this.isTypeDesktopDateTime || this.isTypeDesktopTime);
      }
      get _primitiveComponent() {
        if ((!this.cachedPrimitiveComponent || this._primitiveComponentRefreshNeeded) && utilsPrivate.isCSR) {
          this.cachedPrimitiveComponent = this.template.querySelector(this.primitiveSelector);
          this._primitiveComponentRefreshNeeded = false;
        }
        return this.cachedPrimitiveComponent;
      }
      /************************* GETTERS *************************/

      /*** Accessibility ***/

      get computedAriaLabel() {
        const ariaValues = [];

        // merge all date & time arias on mobile since it's displayed as a single field
        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaLabel);
          ariaValues.push(this.timeAriaLabel);
        }
        if (this.ariaLabel) {
          ariaValues.push(this.ariaLabel);
        }
        return utilsPrivate.normalizeAriaAttribute(ariaValues);
      }
      get computedAriaInvalid() {
        // W-8796658: aria-invalid should always follow the visual indication of errors
        return utilsPrivate.computeAriaInvalid(this._helpMessage, this.value, this.ariaInvalid);
      }

      /****** ******/

      get isLabelHidden() {
        return this.variant === inputUtils.VARIANT.LABEL_HIDDEN;
      }
      get isLabelStacked() {
        return this.variant === inputUtils.VARIANT.LABEL_STACKED;
      }
      get accesskey() {
        return this._accesskey;
      }
      get i18n() {
        return i18n;
      }
      get computedLabelClass() {
        const classnames = utils.classSet('slds-form-element__label');
        if (this.isTypeCheckable || this.isTypeFile) ; else if (this.isTypeToggle) {
          classnames.add('slds-m-bottom_none');
        } else {
          classnames.add('slds-no-flex');
        }
        return classnames.add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }
      get normalizedMax() {
        return this._normalizeDateTimeString(this.max);
      }
      get normalizedMin() {
        return this._normalizeDateTimeString(this.min);
      }
      get _inputElement() {
        if (utilsPrivate.isCSR && (!this._cachedInputElement || this._inputElementRefreshNeeded)) {
          this._inputDragonDecorated = false;
          let inputElement;
          if (this.isTypeDesktopDate) {
            inputElement = this.template.querySelector('lightning-datepicker');
          } else if (this.isTypeDesktopDateTime) {
            inputElement = this.template.querySelector('lightning-datetimepicker');
          } else if (this.isTypeDesktopTime) {
            inputElement = this.template.querySelector('lightning-timepicker');
          } else {
            // get the primitive from the getter once
            const primitiveComponent = this._primitiveComponent;
            if (primitiveComponent?.inputElement) {
              inputElement = primitiveComponent.inputElement;
              this._inputDragonDecorated = true;
              utilsPrivate.decorateInputForDragon(inputElement);
            }
          }
          if (inputElement) {
            this._inputElementRefreshNeeded = false;
            this._cachedInputElement = inputElement;
          }
        }
        return this._cachedInputElement;
      }
      get _inputTypeForValidity() {
        let inputType = 'text';
        if (this.isTypeSimple) {
          if (this.isTypeEmail) {
            inputType = 'text';
          } else if (this.isTypeNumber) {
            inputType = 'number';
          } else {
            inputType = this.type;
          }
        } else if (this.isTypeCheckable) {
          inputType = this.isTypeRadio ? 'radio' : 'checkbox';
        } else if (this.isTypeFile) {
          inputType = 'file';
        } else if (this.isTypeDateTime) {
          inputType = 'datetime-local';
        } else if (this.isTypeTime) {
          inputType = 'time';
        } else if (this.isTypeDate) {
          inputType = 'date';
        }
        return inputType;
      }
      get _displayedValue() {
        if (this.isTypeNumber || this.isTypeMobileDate || this.isTypeMobileDateTime || this.isTypeMobileTime) {
          const subcomponent = this._primitiveComponent;
          return subcomponent.getDisplayedValue();
        }
        return this._value;
      }
      get isStandardVariant() {
        return this.variant === inputUtils.VARIANT.STANDARD || this.variant === inputUtils.VARIANT.LABEL_HIDDEN;
      }
      get _ignoreRequired() {
        // If uploading via the drop zone or via the input directly, we should
        // ignore the required flag as a file has been uploaded
        return this.isTypeFile && this._required && this.files && this.files.length;
      }
      get _constraint() {
        // Constraint API relies on browser-only APIs
        if (!utilsPrivate.isCSR) {
          return {};
        } else if (!this._constraintApi) {
          const overrides = {
            badInput: () => {
              if (!this._rendered) {
                return false;
              }
              if (!this.isNativeInput) {
                return this._inputElement.hasBadInput();
              }
              return this._inputElement.validity.badInput;
            },
            badNumericInput: () => {
              if (this.isTypeNumber) {
                return !numberUtils.isValidNumber(this._primitiveComponent?.getNumberRawValue());
              }
              return false;
            },
            tooLong: () =>
            // since type=number is type=text in the dom when not in focus
            // we should always return false as maxlength doesn't apply
            this.isNativeInput && !this.isTypeNumber && this._rendered && this._inputElement.validity.tooLong,
            tooShort: () =>
            // since type=number is type=text in the dom when not in focus
            // we should always return false as minlength doesn't apply
            this.isNativeInput && !this.isTypeNumber && this._rendered && this._inputElement.validity.tooShort,
            patternMismatch: () => this.isNativeInput && this._rendered && this._inputElement.validity.patternMismatch,
            badEmailInput: () => {
              if (this.isTypeEmail) {
                if (this._multiple) {
                  return !inputUtils.isValidMultipleEmails(this.value);
                }
                return !inputUtils.isValidEmail(this.value);
              }
              return false;
            }
          };
          // International email support, note that the type="email" does not currently
          // support full unicode that 226+ now supports
          // FF, IE and Safari don't support type datetime-local,
          // IE and Safari don't support type date or time
          // we need to defer to the base component to check rangeOverflow/rangeUnderflow.
          // Due to the custom override, changing the type to or from datetime/time would affect the validation
          if (this.isTypeDesktopDateTime || this.isTypeDesktopTime || this.isTypeDesktopDate) {
            overrides.rangeOverflow = () => {
              // input type='time' is timezone agnostic, so we should remove the timezone designator before comparison
              const max = this.isTypeDesktopTime ? normalizeTime(this.max) : this.max;
              return internationalizationLibrary.isAfter(this.value, max);
            };
            overrides.rangeUnderflow = () => {
              // input type='time' is timezone agnostic, so we should remove the timezone designator before comparison
              const min = this.isTypeDesktopTime ? normalizeTime(this.min) : this.min;
              return internationalizationLibrary.isBefore(this.value, min);
            };
            overrides.stepMismatch = () => false;
          }
          if (this.isIE11) {
            overrides.stepMismatch = () => false;
          }
          this._constraintApi = new inputUtils.FieldConstraintApiWithProxyInput(() => {
            // The date/time components display their own errors and have custom messages for badInput and rangeOverflow/Underflow.
            if (!this.isNativeInput) {
              return this._inputElement;
            }
            return this;
          }, overrides);

          // Buggy: This (or similar code) creates invalid DOM when attributes like 'step' are passed
          // directly along to the input element if the type doesn't allow those attributes.
          // For example: 'step' is allowed on type=number but not type=text.
          // See https://www.w3.org/TR/html52/sec-forms.html#apply for which attributes apply to which types.
          this._constraintApiProxyInputUpdater = this._constraintApi.setInputAttributes({
            type: () => this._inputTypeForValidity,
            // We need to normalize value so that it's consumable by the proxy input (otherwise the value
            // will be invalid for the native input)
            value: () => this._normalizeDateTimeString(this.value),
            checked: () => this.checked,
            maxlength: () => this.maxLength,
            minlength: () => this.minLength,
            // 'pattern' depends on type
            pattern: () => this.pattern,
            // 'max' and 'min' depend on type and timezone
            max: () => this.normalizedMax,
            min: () => this.normalizedMin,
            step: () => this.step,
            accept: () => this.accept,
            multiple: () => this.multiple,
            disabled: () => this.disabled,
            readonly: () => this.readOnly,
            // depends on type and whether an upload has been made
            required: () => this.required && !this._ignoreRequired
          });
        }
        return this._constraintApi;
      }
      get hasExternalLabel() {
        return this.variant === inputUtils.VARIANT.LABEL_HIDDEN && this.ariaLabelledBy && this.ariaLabelledBy.length;
      }
      get helptextAlternativeText() {
        return utils.formatLabel(i18n.helpTextAlternativeText, this.label);
      }
      get isAutoCompleteSupported() {
        return this.isTypeTelephone || this.isTypeUrl || this.isTypeSearch || this.isTypeEmail || this.isTypeText;
      }
      get templateRootNode() {
        return utilsPrivate.isCSR ? this.template.host.getRootNode() : null;
      }
      handleFocus(event) {
        /**
         * Do not handle standard FocusEvents and prevent their propagation.
         * Due to an LWC bug, FocusEvent('focus') and FocusEvent('blur') do not propagate
         * in synthetic shadow but they do in native shadow so they must be blocked to ensure parity.
         *
         * CustomEvent('focus') and CustomEvent('blur') are not FocusEvents and will be handled normally.
         *
         * Corresponding LWC issue: https://github.com/salesforce/lwc/issues/1244
         * Corresponding LBC bug: @W-13236327
         */
        if (utilsPrivate.isBubblingFocusEvent(event)) {
          event.stopPropagation();
          return;
        }
        this.interactingState.enter();
        if (this.isTypeColor) {
          this._isColorPickerPanelOpen = false;
        }
        this.dispatchEvent(new CustomEvent('focus'));
      }
      handleBlur(event) {
        /**
         * Do not handle standard FocusEvents and prevent their propagation.
         * Due to an LWC bug, FocusEvent('focus') and FocusEvent('blur') do not propagate
         * in synthetic shadow but they do in native shadow so they must be blocked to ensure parity.
         *
         * CustomEvent('focus') and CustomEvent('blur') are not FocusEvents and will be handled normally.
         *
         * Corresponding LWC issue: https://github.com/salesforce/lwc/issues/1244
         * Corresponding LBC bug: @W-13236327
         */
        if (utilsPrivate.isBubblingFocusEvent(event)) {
          event.stopPropagation();
          return;
        }
        this.interactingState.leave();
        if (this._rendered && this.isTypeNumber) {
          this._setInputValue(this._displayedValue);
        }
        if (!event.relatedTarget || !this.template.contains(event.relatedTarget)) {
          this.dispatchEvent(new CustomEvent('blur'));
        }
      }
      handleCheckboxClick() {
        if (this.template.activeElement === null) {
          this.template.querySelector("[type='checkbox']").focus();
        }
      }
      handleChange(event) {
        event.stopPropagation();
        this._dispatchCommitEvent();
        this._dispatchChangeEvent();
      }
      handleCommit() {
        this._dispatchCommitEvent();
      }
      handlePrimitiveInputFileChange() {
        // kept for legacy support @W-14118679
        this._dispatchCommitEvent();
        const detail = {
          files: this.files,
          value: this._inputElement.value
        };
        this._updateProxyInputAttributes('required');
        this._updateValueAndValidityAttribute(detail.value);
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail
        }));
      }
      handlePrimitiveInputChange(event) {
        this.interactingState.enter();
        this._updateValueAndValidityAttribute(event.detail.value);
      }
      _dispatchCommitEvent() {
        this.dispatchEvent(new CustomEvent('commit'));
      }
      _dispatchChangeEventWithDetail(detail) {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail
        }));
      }

      /**
       * This function determines if a type is supported by this component or not.
       *
       * We assert against the types we explicitly don't support. We also throw a warning
       * when users make common mistakes, like type phone instead of tel.
       *
       * @param {string} type - the type being set via api
       * @returns {boolean} - wether the value is valid or not
       */
      _validateType(type) {
        if (VALID_INPUT_TYPES.includes(type)) {
          return true;
        }
        const invalidMsg = `<lightning-input> The type attribute value "${type}" is invalid.`;
        utilsPrivate.assert(type !== 'hidden', `${invalidMsg} Use a regular <input type="hidden"> instead.`);
        utilsPrivate.assert(type !== 'submit' && type !== 'reset' && type !== 'image' && type !== 'button', `${invalidMsg} Use <lightning:button> instead.`);
        if (this.isTypeRadio) {
          utilsPrivate.assert(!this.required, `<lightning-input> The required attribute is not supported on radio inputs directly. It should be implemented at the radio group level.`);
        }
        if (type === 'phone') {
          console.warn(`${invalidMsg} Please use <lightning-input type="tel"> instead. Defaulting to text type.`);
        } else if (type === 'week' || type === 'month') {
          console.warn(`${invalidMsg} Please use <lightning-combobox> and/or <lightning-input type="number"> instead to avoid inconsistencies and breakages across browsers.`);
        } else {
          console.warn(`${invalidMsg} Defaulting to text type.`);
        }
        return false;
      }

      /**
       * Label is a required attribute.
       * Throw error if an invalid value is passed to the label attribute
       */
      validateRequiredAttributes() {
        const {
          label
        } = this;
        utilsPrivate.assert(typeof label === 'string' && label.length, `<lightning-input> The required label attribute value "${label}" is invalid.`);
      }
      _setInputValue(value) {
        if (this._inputDragonDecorated) {
          // The underlying input has been modified to dispatch an 'input' event when a direct value set
          // is used to allow for Dragon Natural Speaking (which sets the value directly on the inputs instead
          // dispatching an input event against the input). Since we're in a programatic set here (ie. set
          // not resulting from a direct user interaction) we want a default setter behaviour that doesn't
          // dispatch any events.
          utilsPrivate.setDecoratedDragonInputValueWithoutEvent(this._inputElement, value);
        } else {
          this._inputElement.value = value;
        }
      }
      _dispatchChangeEvent() {
        // TODO: investigate removing this in a future update
        // possibly phase out the interactingState entirely
        this.interactingState.enter();
        const detail = {};
        if (this.isTypeCheckable) {
          this._updateCheckedAndValidityAttribute(this._inputElement.checked);
          detail.checked = this._checked;
        }
        if (!this.isTypeCheckable) {
          if (!this.isTypeNumber) {
            detail.value = this._inputElement.value;
          }
          if (this.isTypeMobileDateTime) {
            detail.value = normalizeDateTimeToUTC(detail.value, this.timezone);
          } else if (this.isTypeMobileTime) {
            detail.value = normalizeTime(detail.value);
          }
          this._updateValueAndValidityAttribute(detail.value);
        }
        this._dispatchChangeEventWithDetail(detail);
      }
      _isDesktopBrowser() {
        return formFactor__default.default === 'Large';
      }
      _updateValueAndValidityAttribute(value) {
        this._value = value;
        this._updateProxyInputAttributes('value');
      }
      _updateCheckedAndValidityAttribute(value) {
        this._checked = value;
        this._updateProxyInputAttributes('checked');
        utilsPrivate.reflectAttribute(this, 'checked', this._checked);
      }
      _updateProxyInputAttributes(attributes) {
        if (this._constraintApiProxyInputUpdater) {
          this._constraintApiProxyInputUpdater(attributes);
        }
      }

      /**
       * Updates the class list on the host element based on the variant
       */
      updateClassListForVariant() {
        utilsPrivate.classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === inputUtils.VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === inputUtils.VARIANT.LABEL_INLINE
        });
      }
      _normalizeDateTimeString(value) {
        let result = value;
        if (this.isTypeDate) {
          result = normalizeDate(value);
        } else if (this.isTypeTime) {
          result = normalizeTime(value);
        } else if (this.isTypeDateTime) {
          result = normalizeUTCDateTime(value, this.timezone);
        }
        return result;
      }
      _updateDateOrTimePickerA11y(elem) {
        utilsPrivate.synchronizeAttrs(elem, {
          ariaLabelledByElement: this._ariaLabelledBy,
          ariaDescribedByElements: this._ariaDescribedBy,
          ariaErrorMessageElements: this._ariaErrorMessage,
          ariaControlsElement: this._ariaControls,
          ariaDetailsElements: this._ariaDetails,
          [ARIA_LABEL]: this.computedAriaLabel
        });
      }
      _updateDateTimePickerA11y(elem) {
        utilsPrivate.synchronizeAttrs(elem, {
          // datepicker aria attributes
          dateAriaLabelledBy: this.dateAriaLabelledBy,
          dateAriaDescribedBy: this.dateAriaDescribedBy,
          dateAriaControls: this.dateAriaControls,
          dateAriaLabel: this.dateAriaLabel,
          dateAriaDetails: this.dateAriaDetails,
          // timepicker aria attributes
          timeAriaLabelledBy: this.timeAriaLabelledBy,
          timeAriaDescribedBy: this.timeAriaDescribedBy,
          timeAriaControls: this.timeAriaControls,
          timeAriaLabel: this.timeAriaLabel,
          timeAriaDetails: this.timeAriaDetails
        });
      }
      _synchronizeA11y() {
        // each of these templates are mutually exclusive and are selected
        // depending on the [type] of input.
        const datepicker = this.template.querySelector('lightning-datepicker');
        const timepicker = this.template.querySelector('lightning-timepicker');
        const datetimepicker = this.template.querySelector('lightning-datetimepicker');
        // determine which template type is present,
        // and update a11y props accordingly
        if (datepicker) {
          this._updateDateOrTimePickerA11y(datepicker);
        } else if (timepicker) {
          this._updateDateOrTimePickerA11y(timepicker);
        } else if (datetimepicker) {
          this._updateDateTimePickerA11y(datetimepicker);
        }
      }
      /*LWC compiler v7.1.5*/
    }
    LightningInput.validationOptOut = ['class'];
    lwc.registerDecorators(LightningInput, {
      publicProps: {
        placeholder: {
          config: 0
        },
        name: {
          config: 0
        },
        label: {
          config: 0
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenPatternMismatch: {
          config: 0
        },
        messageWhenRangeOverflow: {
          config: 0
        },
        messageWhenRangeUnderflow: {
          config: 0
        },
        messageWhenStepMismatch: {
          config: 0
        },
        messageWhenTooShort: {
          config: 0
        },
        messageWhenTooLong: {
          config: 0
        },
        messageWhenTypeMismatch: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageToggleActive: {
          config: 0
        },
        messageToggleInactive: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        autocomplete: {
          config: 3
        },
        dateStyle: {
          config: 0
        },
        timeStyle: {
          config: 0
        },
        dateAriaLabel: {
          config: 0
        },
        timeAriaLabel: {
          config: 0
        },
        dateAccessKey: {
          config: 0
        },
        timeAccessKey: {
          config: 0
        },
        formatFractionDigits: {
          config: 0
        },
        timeAriaControls: {
          config: 3
        },
        timeAriaDetails: {
          config: 3
        },
        dateAriaLabelledBy: {
          config: 3
        },
        timeAriaLabelledBy: {
          config: 3
        },
        timeAriaDescribedBy: {
          config: 3
        },
        dateAriaControls: {
          config: 3
        },
        dateAriaDetails: {
          config: 3
        },
        dateAriaDescribedBy: {
          config: 3
        },
        ariaControls: {
          config: 3
        },
        ariaDetails: {
          config: 3
        },
        ariaLabelledBy: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        ariaErrorMessage: {
          config: 3
        },
        ariaInvalid: {
          config: 3
        },
        ariaHasPopup: {
          config: 0
        },
        ariaKeyShortcuts: {
          config: 0
        },
        ariaDisabled: {
          config: 0
        },
        ariaRoleDescription: {
          config: 0
        },
        ariaExpanded: {
          config: 0
        },
        ariaAutoComplete: {
          config: 0
        },
        formatter: {
          config: 3
        },
        type: {
          config: 3
        },
        isLoading: {
          config: 3
        },
        pattern: {
          config: 3
        },
        maxLength: {
          config: 3
        },
        accept: {
          config: 3
        },
        minLength: {
          config: 3
        },
        max: {
          config: 3
        },
        min: {
          config: 3
        },
        step: {
          config: 3
        },
        checked: {
          config: 3
        },
        multiple: {
          config: 3
        },
        value: {
          config: 3
        },
        variant: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        timezone: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        accessKey: {
          config: 3
        },
        files: {
          config: 1
        },
        validity: {
          config: 1
        },
        selectionStart: {
          config: 3
        },
        selectionEnd: {
          config: 3
        },
        role: {
          config: 3
        }
      },
      publicMethods: ["checkValidity", "setCustomValidity", "reportValidity", "showHelpMessageIfInvalid", "focus", "blur"],
      track: {
        _timeAriaDescribedBy: 1,
        _timeAriaLabelledBy: 1,
        _timeAriaControls: 1,
        _dateAriaControls: 1,
        _timeAriaDetails: 1,
        _dateAriaDetails: 1,
        _dateAriaDescribedBy: 1,
        _dateAriaLabelledBy: 1,
        _value: 1,
        _type: 1,
        _pattern: 1,
        _max: 1,
        _min: 1,
        _step: 1,
        _disabled: 1,
        _readOnly: 1,
        _required: 1,
        _checked: 1,
        _isLoading: 1,
        _multiple: 1,
        _timezone: 1,
        _helpMessage: 1,
        _isColorPickerPanelOpen: 1,
        _fieldLevelHelp: 1,
        _accesskey: 1,
        _maxLength: 1,
        _minLength: 1,
        _accept: 1,
        _variant: 1,
        _ariaInvalid: 1,
        _autocomplete: 1
      },
      fields: ["_shouldShowHelpMessage", "_helpMessageChanged", "_formatter", "_initialValueSet", "_rendered"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(LightningInput, {
      tmpl: _tmpl,
      sel: "lightning-input",
      apiVersion: 62
    });
    LightningInput.interopMap = {
      exposeNativeEvent: {
        change: true,
        focus: true,
        blur: true
      }
    };

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@salesforce/apex/applauncher.LoginFormController.setExperienceId', ['exports', 'lwc', 'force/ldsAdaptersApex'], (function (exports, lwc, ldsAdaptersApex) {

	var _tmpl = void 0;

	const apexInvoker = ldsAdaptersApex.getApexInvoker("applauncher", "LoginFormController", "setExperienceId", "false");
	const __lwc_component_class_internal = lwc.registerComponent(apexInvoker, {
	  tmpl: _tmpl,
	  sel: "@salesforce-20mfaxiv6iin2dap7vmnfiqin85zkn9s45mjngtf5la1ji639ivbua1yobewiz5vpqljrck2kgysq184k",
	  apiVersion: 62
	});

	exports.default = __lwc_component_class_internal;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('community_login/loginUtils', ['exports', '@salesforce/apex/applauncher.LoginFormController.setExperienceId'], (function (exports, setExperienceId) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var setExperienceId__default = /*#__PURE__*/_interopDefaultCompat(setExperienceId);

    const ENTER_KEY = 'Enter';

    /**
     * Return startURL query param value from the current URL or empty string if no start URL parameter present.
     */
    function getStartUrlFromCurrentUrl() {
      try {
        const keyValuePairs = queryStringToMap(window.location.search.substring(1).replace(/\+/g, ' '));
        return keyValuePairs.startURL || '';
      } catch (URIError) {
        return '';
      }
    }

    /**
     * Return decoded startURL query param value from the current URL,
     * or empty string if no start URL parameter present.
     */
    function getDecodedStartUrlFromCurrentUrl() {
      const startUrl = getStartUrlFromCurrentUrl();
      if (startUrl && !startUrl.startsWith('/')) {
        try {
          const decoded = decodeURIComponent(startUrl);
          return decoded;
        } catch (err) {
          // Return original startUrl from query string
        }
      }
      return startUrl || '';
    }

    /**
     * Append start URL to target URL as a query parameter or return the target URL if either input is missing.
     *
     * @param {string} target URL
     * @param {string} start URL
     */
    function appendStartUrlToTargetUrl(targetUrl, startUrl) {
      if (targetUrl && startUrl) {
        if (targetUrl.includes('?')) {
          targetUrl = targetUrl + '&startURL=' + startUrl;
        } else {
          targetUrl = targetUrl + '?startURL=' + startUrl;
        }
      }
      return targetUrl;
    }

    /**
     * Return expId param value from the current URL or empty string if no expId param present.
     */
    function getExpIdFromCurrentUrl() {
      const keyValuePairs = queryStringToMap(window.location.search.substring(1).replace(/\+/g, ' '));
      return keyValuePairs.expid || '';
    }

    /**
     * Retrieve expId param from current URL and set it as a branding cookie in response header.
     */
    function setBrandingCookie() {
      const expId = getExpIdFromCurrentUrl();
      if (expId) {
        setExperienceId__default.default({
          expId
        });
      }
    }
    function queryStringToMap(queryString) {
      return queryString.split('&').map(str => {
        const [key, value] = str.split('=');
        return {
          [key]: decodeURI(value)
        };
      }).reduce((prev, curr) => Object.assign(prev, curr));
    }

    exports.ENTER_KEY = ENTER_KEY;
    exports.appendStartUrlToTargetUrl = appendStartUrlToTargetUrl;
    exports.getDecodedStartUrlFromCurrentUrl = getDecodedStartUrlFromCurrentUrl;
    exports.getExpIdFromCurrentUrl = getExpIdFromCurrentUrl;
    exports.getStartUrlFromCurrentUrl = getStartUrlFromCurrentUrl;
    exports.setBrandingCookie = setBrandingCookie;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('community_login/forgotPassword', ['exports', 'lwc', 'lightning/formattedText', 'lightning/input', 'community_login/loginError', 'community_login/loginUtils', '@salesforce/apex/applauncher.ForgotPasswordController.forgotPassword', '@salesforce/label/ForgotPasswordLWC.title', '@salesforce/label/ForgotPasswordLWC.prompt', '@salesforce/label/ForgotPasswordLWC.username', '@salesforce/label/ForgotPasswordLWC.resetButton', '@salesforce/label/ForgotPasswordLWC.cancelButton'], (function (exports, lwc, _lightningFormattedText, _lightningInput, _community_loginLoginError, loginUtils, forgotPassword, titleDefault, instructionsDefault, usernameDefault, submitDefault, cancelDefault) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var _lightningFormattedText__default = /*#__PURE__*/_interopDefaultCompat(_lightningFormattedText);
    var _lightningInput__default = /*#__PURE__*/_interopDefaultCompat(_lightningInput);
    var _community_loginLoginError__default = /*#__PURE__*/_interopDefaultCompat(_community_loginLoginError);
    var forgotPassword__default = /*#__PURE__*/_interopDefaultCompat(forgotPassword);
    var titleDefault__default = /*#__PURE__*/_interopDefaultCompat(titleDefault);
    var instructionsDefault__default = /*#__PURE__*/_interopDefaultCompat(instructionsDefault);
    var usernameDefault__default = /*#__PURE__*/_interopDefaultCompat(usernameDefault);
    var submitDefault__default = /*#__PURE__*/_interopDefaultCompat(submitDefault);
    var cancelDefault__default = /*#__PURE__*/_interopDefaultCompat(cancelDefault);

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var shadowSelector = token ? ("[" + token + "]") : "";
      return ".comm-forgot-password__container" + shadowSelector + " {min-width: 18rem;max-width: 25rem;margin: 0px auto;color: var(--lwc-colorTextDefault, var(--dxp-g-root-contrast-1));background-color: var(--lwc-cardBackgroundColor, --dxp-g-root-1);font-family: var(--lwc-fontFamily, var(--dxp-g-root-font-family));}.comm-forgot-password__title" + shadowSelector + " {color: var(--lwc-colorTextDefault, var(--dxp-g-root-contrast));}.comm-forgot-password__cancel-button" + shadowSelector + " {width: 49%;margin-right: 1%;color: var(--lwc-colorTextLink, var(--dxp-g-brand));font-family: var(--lwc-fontFamily, var(--dxp-g-root-font-family));}.comm-forgot-password__submit-button" + shadowSelector + " {width: 49%;margin-left: 1%;color: var(--lwc-colorTextButtonBrand, var(--dxp-g-brand-contrast));background-color: var(--lwc-colorBackgroundButtonBrand, var(--dxp-g-brand));font-family: var(--lwc-fontFamily, var(--dxp-g-root-font-family));}.comm-forgot-password__submit-button:hover" + shadowSelector + " {background-color: var(--lwc-colorBackgroundButtonBrand, var(--dxp-g-brand));}.comm-forgot-password__submit-button:focus" + shadowSelector + " {background-color: var(--lwc-colorBackgroundButtonBrand, var(--dxp-g-brand));}";
      /*LWC compiler v7.1.5*/
    }
    var _implicitStylesheets = [stylesheet];

    const $fragment1 = lwc.parseFragment`<h2 class="comm-forgot-password__title slds-text-heading_large slds-text-align_center slds-var-p-around_large${0}"${2}>${"t1"}</h2>`;
    const $fragment2 = lwc.parseFragment`<div class="slds-form-element slds-m-top_large slds-m-bottom_large${0}"${2}><button data-cancelbtn type="button" class="comm-forgot-password__cancel-button slds-button slds-button_neutral${0}"${2}>${"t2"}</button><button data-submitbtn type="button" class="comm-forgot-password__submit-button slds-button slds-button_brand${0}"${2}>${"t4"}</button></div>`;
    const stc0 = {
      classMap: {
        "comm-forgot-password__container": true,
        "slds-card": true,
        "slds-card_inner": true,
        "slds-col": true,
        "slds-grow": true,
        "slds-p-around_medium": true
      },
      key: 2
    };
    const stc1 = {
      classMap: {
        "slds-form-element__control": true
      },
      key: 4
    };
    const stc2 = {
      "comm-forgot-password__username-input": true,
      "slds-p-top_small": true
    };
    const stc3 = {
      "data-username": ""
    };
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {d: api_dynamic_text, sp: api_static_part, st: api_static_fragment, c: api_custom_element, b: api_bind, h: api_element} = $api;
      const {_m0, _m1, _m2} = $ctx;
      return [api_static_fragment($fragment1, 1, [api_static_part(1, null, api_dynamic_text($cmp.titleLabelText))]), api_element("div", stc0, [api_custom_element("lightning-formatted-text", _lightningFormattedText__default.default, {
        props: {
          "value": $cmp.instructionsLabelText
        },
        key: 3
      }), api_element("div", stc1, [api_custom_element("lightning-input", _lightningInput__default.default, {
        classMap: stc2,
        attrs: stc3,
        props: {
          "type": "text",
          "label": $cmp.usernameLabelText,
          "autocomplete": "username"
        },
        key: 5,
        on: {
          "keyup": _m0 || ($ctx._m0 = api_bind($cmp.handleKeyUp))
        }
      })]), $cmp.state.showError ? api_custom_element("community_login-login-error", _community_loginLoginError__default.default, {
        props: {
          "error": $cmp.state.errorMessage
        },
        key: 6
      }) : null, api_static_fragment($fragment2, 8, [api_static_part(1, {
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleCancelBtnClick))
        }
      }, null), api_static_part(2, null, api_dynamic_text($cmp.cancelButtonLabelText)), api_static_part(3, {
        on: {
          "click": _m2 || ($ctx._m2 = api_bind($cmp.submit))
        }
      }, null), api_static_part(4, null, api_dynamic_text($cmp.submitButtonLabelText))])])];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-3fmj06unklg";
    tmpl.legacyStylesheetToken = "community_login-forgotPassword_forgotPassword";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    const loginUrl = './login';
    class ForgotPassword extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        /**
         * List of properties customizable via the builder.
         * Refer to the js-meta file for detail and usage.
         */
        this.titleLabel = void 0;
        this.instructionsLabel = void 0;
        this.usernameLabel = void 0;
        this.submitButtonLabel = void 0;
        this.checkEmailUrl = void 0;
        this.cancelButtonLabel = void 0;
        this.state = {
          errorMessage: '',
          showError: false
        };
      }
      get titleLabelText() {
        return this.titleLabel || titleDefault__default.default;
      }
      get instructionsLabelText() {
        return this.instructionsLabel || instructionsDefault__default.default;
      }
      get usernameLabelText() {
        return this.usernameLabel || usernameDefault__default.default;
      }
      get submitButtonLabelText() {
        return this.submitButtonLabel || submitDefault__default.default;
      }
      get cancelButtonLabelText() {
        return this.cancelButtonLabel || cancelDefault__default.default;
      }
      get checkEmailUrlString() {
        return this.checkEmailUrl || './CheckPasswordResetEmail';
      }
      get usernameInput() {
        return this.template.querySelector('[data-username]');
      }
      handleKeyUp(evt) {
        if (evt.key === loginUtils.ENTER_KEY) {
          evt.preventDefault();
          this.submit();
        }
      }
      async submit() {
        const rawResult = await forgotPassword__default.default({
          username: this.usernameInput.value,
          checkEmailUrl: this.checkEmailUrlString
        });
        // rawResult null means that forgotPassword was successful
        if (!rawResult) {
          window.location.assign(loginUtils.appendStartUrlToTargetUrl(this.checkEmailUrlString, loginUtils.getStartUrlFromCurrentUrl()));
        } else {
          this.state.showError = true;
          this.state.errorMessage = rawResult;
        }
      }
      handleCancelBtnClick() {
        // TODO use lightning/navigation once W-6372306 is completed
        var targetUrl = loginUrl;
        targetUrl = loginUtils.appendStartUrlToTargetUrl(loginUrl, loginUtils.getStartUrlFromCurrentUrl());
        window.location.assign(targetUrl);
      }
      connectedCallback() {
        this.classList.add('comm-forgot-password');
        loginUtils.setBrandingCookie();
      }
      /*LWC compiler v7.1.5*/
    }
    lwc.registerDecorators(ForgotPassword, {
      publicProps: {
        titleLabel: {
          config: 0
        },
        instructionsLabel: {
          config: 0
        },
        usernameLabel: {
          config: 0
        },
        submitButtonLabel: {
          config: 0
        },
        checkEmailUrl: {
          config: 0
        },
        cancelButtonLabel: {
          config: 0
        }
      },
      track: {
        state: 1
      }
    });
    const __lwc_component_class_internal = lwc.registerComponent(ForgotPassword, {
      tmpl: _tmpl,
      sel: "community_login-forgot-password",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
LWR.define('@salesforce/site/activeLanguages', [], function() { return [{"label":"English (US)","code":"en-US","default":true}]; });
LWR.define('@luvio/lwc-bindings', ['force/luvioLwcBindings'], function(m) { return m && typeof m === 'object' && 'default' in m ? m.default : m; });
(function() { LWR.define('experience/seoPropertiesApiInternal', ['exports', 'lwc', '@luvio/runtime', 'experience/data', 'experience/uri', 'experience/config'], (function (exports, lwc, runtime, data, uri, config) {

  const SEO_PROPERTIES_RECORD_NAMESPACE = 'experience';
  const SEO_PROPERTIES_RECORD_TYPE_NAME = 'SeoProperties';
  const seoPropertiesRepresentationType = new runtime.OpaqueRepresentationType(SEO_PROPERTIES_RECORD_NAMESPACE, SEO_PROPERTIES_RECORD_TYPE_NAME, 60 * 60 * 1000, keyParams => {
    const {
      fields
    } = keyParams;
    const params = fields ? fields.split(',').sort() : [];
    return `${SEO_PROPERTIES_RECORD_NAMESPACE}::${SEO_PROPERTIES_RECORD_TYPE_NAME}:${keyParams.communityId}:${keyParams.recordId}:${params}`;
  });

  const API_VERSION = config.currentRelease.apiVersion;
  class GetSeoPropertiesRegistryCachePolicyCommand extends runtime.TypeRegistryCachePolicyCommand {
    constructor(...args) {
      super(...args);
      this.returnTypeNamespace = SEO_PROPERTIES_RECORD_NAMESPACE;
      this.returnTypeName = SEO_PROPERTIES_RECORD_TYPE_NAME;
    }
    buildKeyConfig() {
      return this.config;
    }
    buildKeyConfigFromInstance() {
      return this.config;
    }
    get configJsonSchema() {
      return {
        type: 'object',
        properties: {
          communityId: {
            type: 'string'
          },
          recordId: {
            type: 'string'
          },
          fields: {
            type: 'string'
          }
        },
        required: ['communityId', 'recordId'],
        additionalProperties: false
      };
    }
    fetch() {
      const {
        communityId,
        recordId,
        fields
      } = this.config;
      const api = `/services/data/${API_VERSION}/connect/communities/${communityId}/seo/properties/${recordId}`;
      const params = fields ? {
        fields
      } : {};
      return this.convertFetchResponseToData(data.fetchService(uri.composeUri(api, params)));
    }
    async convertFetchResponseToData(apiResponse) {
      try {
        const response = await apiResponse;
        return {
          data: response,
          errors: []
        };
      } catch (reason) {
        const errors = [];
        if (reason instanceof Error) {
          errors.push(reason);
        } else if (reason instanceof Response) {
          errors.push(new Error(`${reason.statusText}`));
        }
        return {
          data: undefined,
          errors: errors
        };
      }
    }
    /*LWC compiler v7.1.5*/
  }
  lwc.registerDecorators(GetSeoPropertiesRegistryCachePolicyCommand, {
    fields: ["returnTypeNamespace", "returnTypeName"]
  });

  exports.GetSeoPropertiesRegistryCachePolicyCommand = GetSeoPropertiesRegistryCachePolicyCommand;
  exports.seoPropertiesRepresentationType = seoPropertiesRepresentationType;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/luvioRuntime', ['exports', '@luvio/registry'], (function (exports, registry) {

  function registerAdapter(setCommandRuntime) {
    registry.register({
      id: 'commandModule',
      runtimeDependencies: {
        cacheInclusionPolicy: true,
        cachePolicies: true,
        defaultCachePolicyName: true,
        keySubscriptionService: true,
        metadataRepository: true,
        store: true,
        typeRegistry: true
      },
      setCommandRuntime: setCommandRuntime
    });
  }

  exports.registerAdapter = registerAdapter;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('experience/seoPropertiesApi', ['exports', '@luvio/lwc-bindings', 'experience/luvioRuntime', 'experience/seoPropertiesApiInternal'], (function (exports, lwcBindings, luvioRuntime, seoPropertiesApiInternal) {

  exports.getSeoProperties = void 0;
  luvioRuntime.registerAdapter(commandRuntime => {
    commandRuntime.typeRegistry.register(seoPropertiesApiInternal.seoPropertiesRepresentationType);
    return {
      getSeoProperties: exports.getSeoProperties = class extends lwcBindings.CommandWireAdapterConstructor {
        getCommand() {
          return new seoPropertiesApiInternal.GetSeoPropertiesRegistryCachePolicyCommand(this.config, {}, commandRuntime);
        }
        /*LWC compiler v7.1.5*/
      }
    };
  });

  Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('community_builder/seoAssistant', ['exports', 'lwc', 'experience/seoPropertiesApi', 'lightning/navigation', '@salesforce/community/Id', '@salesforce/community/basePath', '@salesforce/site/activeLanguages', '@salesforce/i18n/lang'], (function (exports, lwc, seoPropertiesApi, navigation, CommunityId, basePath, activeLanguages, activeLanguageCode) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var CommunityId__default = /*#__PURE__*/_interopDefaultCompat(CommunityId);
    var basePath__default = /*#__PURE__*/_interopDefaultCompat(basePath);
    var activeLanguages__default = /*#__PURE__*/_interopDefaultCompat(activeLanguages);
    var activeLanguageCode__default = /*#__PURE__*/_interopDefaultCompat(activeLanguageCode);

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return ((useActualHostSelector ? ":host {" : hostSelector + " {")) + "display: none;}";
      /*LWC compiler v7.1.5*/
    }
    var _implicitStylesheets = [stylesheet];

    const stc0 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      return stc0;
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.renderMode = "light";
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-67g9kuprkgf";
    tmpl.legacyStylesheetToken = "community_builder-seoAssistant_seoAssistant";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    const fieldPatternToMatch = new RegExp(`\\{!(Record|Content)[\\.\\w:]+\\}`, 'g');
    const fieldExpPartToStrip = new RegExp(`\\{!(Record|Content)\\.|\\}`, 'g');
    const recordNameRegex = new RegExp('\\{!(Record|Content)\\._Title\\}', 'g');
    const objectNameRegex = new RegExp('\\{!(Record|Content)\\._Object\\}', 'g');
    const singleQuoteRegex = new RegExp("'", 'g');
    const doubleQuoteRegex = new RegExp('"', 'g');

    /**
     * Removes existing SEO properties set by this component and sets new resolved SEO properties
     * in the head markup of the page.
     *
     * TODO: Move this to an event handler because 'document' level DOM queries are not allowed in a component.
     *
     * @param {Object} recordData Record fields and values
     * @param {Object} unresolvedProperties
     * @param {Object} siteInfo SiteInfo containing basePath, activateLanguageCode, activeLanguages
     * @returns resolved SEO property
     */
    function setSeoProperties(recordData, unresolvedProperties, siteInfo) {
      const seoProperties = processSeoProperties(recordData, unresolvedProperties);
      if (seoProperties.title) {
        document.title = seoProperties.title;
      }
      if (seoProperties.description) {
        setDescription(seoProperties.description);
      }
      if (seoProperties.customHeadTags) {
        setCustomHeadTags(seoProperties.customHeadTags);
      }
      setLanguageLinkTags(recordData.hrefLangUrls, siteInfo);
      setCanonicalTag(recordData.canonicalUrl);
      setNoIndexTag(recordData.isSeoIndexed);
    }
    function setDescription(description) {
      const attributes = {
        name: 'description',
        content: description
      };
      const metaElement = createSEOElement('meta', attributes);
      document.head.appendChild(metaElement);
    }
    function setCustomHeadTags(customHeadTags) {
      Object.entries(customHeadTags).forEach(([tagType, tags]) => {
        tags.forEach(attributes => {
          const element = createSEOElement(tagType, attributes);
          document.head.appendChild(element);
        });
      });
    }
    function setCanonicalTag(canonicalUrl) {
      if (!canonicalUrl) {
        return;
      }
      const elem = document.createElement('link');
      elem.setAttribute('rel', 'canonical');
      elem.setAttribute('href', canonicalUrl);
      elem.setAttribute('data-owner', 'setSEOProperties');
      document.head.appendChild(elem);
    }
    function setNoIndexTag(isSeoIndexed) {
      if (!(isSeoIndexed === false)) {
        return;
      }
      const attributes = {
        name: 'robots',
        content: 'noindex,nofollow'
      };
      const metaElement = createSEOElement('meta', attributes);
      document.head.appendChild(metaElement);
    }
    function setLanguageLinkTags(hrefLangUrls = {}, siteInfo) {
      const basePath = siteInfo.basePath;
      const pathname = window.location.pathname;
      const origin = window.location.origin;
      const activeLanguage = siteInfo.activeLanguageCode;

      // If there is only one site language, this should mean only the base language exists
      // Do not add language link tags
      if (siteInfo.activeLanguages.length === 1) {
        return;
      }
      let pagePath = pathname;
      if (basePath !== '' && pathname.includes(basePath)) {
        // For the cases where the langCode is included with the page path (ie /fr/test-page)
        pagePath = pathname.split(basePath)[1];
      }
      siteInfo.activeLanguages.forEach(lang => {
        const langCode = lang.code;
        // Use server-constructed lang url if it exists
        let translationUrl = hrefLangUrls[convertLanguageCode(langCode)];

        // For special cases like articles, all translations may not exist, so we need
        // to exclude link tags for those languages entirely. The API will pass excluded
        // hreflangUrls as an empty value for those languages.
        if (translationUrl === '') {
          return;
        }

        // Non-record based URLs, construct on client
        if (!translationUrl) {
          let newBasePath;
          if (!basePath.endsWith('/' + activeLanguage)) {
            if (langCode === activeLanguage || lang.default) {
              newBasePath = basePath;
            } else {
              newBasePath = `${basePath}/${langCode}`;
            }
          } else {
            // look for exact match /activeLanguage at the end of the string
            const pattern = new RegExp(`/${activeLanguage}$`);
            const newLangPath = lang.default ? '' : '/' + langCode;
            newBasePath = basePath.replace(pattern, newLangPath);
          }
          translationUrl = `${origin}${newBasePath}${pagePath}`;
          if (newBasePath === '' && pagePath === '/') {
            // Use origin if URL does not have any path prefix (ie. www.sample.com)
            translationUrl = origin;
          }
        }
        createAlternateLinkTag(langCode.toLowerCase(), translationUrl);
        if (lang.default === true) {
          createAlternateLinkTag('x-default', translationUrl);
        }
      });
    }
    function createAlternateLinkTag(hrefLang, url) {
      const attributes = {
        rel: 'alternate',
        hreflang: hrefLang,
        href: url
      };
      const linkElement = createSEOElement('link', attributes);
      document.head.appendChild(linkElement);
    }
    function createSEOElement(tag, attributes) {
      const elem = document.createElement(tag);
      Object.entries(attributes).forEach(([name, value]) => {
        if (name === 'innerHTML') {
          // eslint-disable-next-line @lwc/lwc/no-inner-html
          elem.innerHTML = value;
        } else {
          elem.setAttribute(name, value);
        }
      });
      elem.setAttribute('data-owner', 'setSEOProperties');
      return elem;
    }

    /**
     * For translation lookup map, need to replace - with _ (ie. en-US with en_US)
     * @param {String} langCode Language code to format
     * @returns Converted language code
     */
    function convertLanguageCode(langCode) {
      return langCode.replace('-', '_');
    }

    /**
     * Removes all meta tags set by this component from the head markup
     */
    function cleanUpTags() {
      const metaElements = document.head.querySelectorAll('head [data-owner=setSEOProperties]');
      metaElements.forEach(node => node.parentNode.removeChild(node));
    }

    /**
     * Parse SEO properties and extract object field names from the expression used in them.
     *
     * @param string recordData Record fields and values
     * @returns resolved SEO properties
     */
    function getNeedRecordAndQueryFields(pageTitle, description, metaTags) {
      const seoProperties = [pageTitle, description, metaTags];
      const allFields = seoProperties.filter(prop => prop && prop.search(fieldPatternToMatch) > -1).flatMap(prop => prop.match(fieldPatternToMatch).map(val => val.replace(fieldExpPartToStrip, '')));
      const needRecord = allFields.length > 0;

      // '_name' expressions are not actual record fields but properties of the entity (E.g. name field, entity label).
      // They cannot be queried directly so we don't pass them to the API. They are included by default in the returned
      // value (if possible).
      const queryFields = Array.from(new Set(allFields.filter(field => !field.startsWith('_'))));
      return {
        needRecord,
        queryFields: queryFields.join()
      };
    }

    /**
     * Resolves all expressions in each SEO property using record information,
     * returns properties unchanged if there is no record data.
     *
     * @param {Object} recordData Record fields and values
     * @returns resolved SEO properties
     */
    function processSeoProperties(recordData, unresolvedProperties) {
      const resolvedProperties = {};
      if (unresolvedProperties.title) {
        resolvedProperties.title = resolveFieldsEL(recordData, unresolvedProperties.title, false);
      }
      if (unresolvedProperties.description) {
        resolvedProperties.description = resolveFieldsEL(recordData, unresolvedProperties.description, true);
      }
      if (unresolvedProperties.customHeadTags) {
        resolvedProperties.customHeadTags = convertCustomHeadTagsToJson(resolveFieldsEL(recordData, unresolvedProperties.customHeadTags, true));
      }
      return resolvedProperties;
    }

    /**
     * Resolves an expression using record information
     *
     * @param {Object} recordData Record fields and values
     * @param expression The expression to resolve
     * @returns resolved SEO property
     */
    function resolveFieldsEL(recordData, expression, isEscapedProperty) {
      if (!expression || !Object.keys(recordData).length > 0) {
        return expression;
      }
      expression = expression.replace(recordNameRegex, recordData.recordName);
      expression = expression.replace(objectNameRegex, recordData.objectName);
      expression = processFields(expression, recordData.fields, isEscapedProperty, false);
      if (recordData.complexFields) {
        expression = processFields(expression, recordData.complexFields, false, true);
      }
      return expression;
    }

    /**
     * Iterate through a map of fields, resolving each expression. Complex fields must be resolved such that
     * the quotation marks are replaced in the HTML string, along with the expression.
     *
     * An example complex value is BreadcrumbList, whose value is an array of objects. If the quotation
     * marks are not removed, the value will be a string, which deviates from schema.org/BreadcrumbList.
     *
     * @param {Object} fields The record fields/values to be iterated over
     * @param expression The HTML string for a tag to be resolved
     * @returns SEO property with expression language replaced with record data
     */
    function processFields(expression, fields, isEscapedProperty, isComplexFields) {
      Object.entries(fields).filter(([name]) => name).forEach(([name, value]) => {
        //For any complex values, replace quotation marks and EL in the HTML.
        const fieldPattern = value && isComplexFields ? new RegExp(`\\"\\{!(Record|Content)\\.${name}\\}\\"`, 'g') : new RegExp(`\\{!(Record|Content)\\.${name}\\}`, 'g');
        if (!value) {
          expression = expression.replace(fieldPattern, '');
        } else if (isEscapedProperty && !isCmsHeadTag(name)) {
          // Values that go in an HTML tag's attribute need to be escaped.
          const escapedValue = value.replace(singleQuoteRegex, '&apos;').replace(doubleQuoteRegex, '&quot;');
          expression = expression.replace(fieldPattern, escapedValue);
        } else {
          expression = expression.replace(fieldPattern, value);
        }
      });
      return expression;
    }

    /**
     * TODO(@W-15250243)
     * This is a hack to unblock landing pages for 250. Head tags are
     * getting escaped and then encoded, which breaks the DomParser.
     * Until we implement server-side sanitation, just skip over the
     * cms head tag expression.
     * @param name of the property
     * @returns if property is for the cms headtag
     */
    function isCmsHeadTag(name) {
      return name === 'Body.sfdc_cms:seoProperties.headTags';
    }

    /**
     * Convert head tags from HTML format to JSON
     *
     * @param htmlString Meta tags in HTML format
     * @returns resolved SEO property
     */
    function convertCustomHeadTagsToJson(htmlString) {
      const headDOM = getHeadDOM(htmlString);
      let customHeadTagsJson = {};
      if (headDOM) {
        // headDOM is null when PhantomJS renders the page.
        let metaTagsJson = [];
        let linkTagsJson = [];
        let scriptTagsJson = [];
        let tags = Array.from(headDOM.querySelectorAll('head meta, head link, head script'));
        tags.forEach(tag => {
          const node = {};
          convertAttributesNamedNodeMapToArray(tag.attributes).filter(attr => attr && attr.name && attr.value).map(attr => node[attr.name] = attr.value);
          if (tag.tagName === 'META') {
            metaTagsJson.push(node);
          } else if (tag.tagName === 'SCRIPT') {
            // eslint-disable-next-line @lwc/lwc/no-inner-html
            node.innerHTML = tag.innerHTML;
            scriptTagsJson.push(node);
          } else {
            linkTagsJson.push(node);
          }
        });
        customHeadTagsJson.meta = metaTagsJson;
        customHeadTagsJson.link = linkTagsJson;
        customHeadTagsJson.script = scriptTagsJson;
      }
      return customHeadTagsJson;
    }

    /**
     * Head tags are set as plain HTML input but setSEOProperties needs tags in a JSON format, so we build a DOM
     * from the htmlString.
     *
     * @param htmlString Head tags in HTML format
     * @returns DOM representation of head tags HTML
     */
    function getHeadDOM(htmlString) {
      const parser = new DOMParser();
      return parser.parseFromString(htmlString, 'text/html');
    }

    /**
     * Converts a tag's attribute NamedNodeMap to an array because it is not iterable.
     *
     * @param attributes NamedNodeMap representation of attributes
     */
    function convertAttributesNamedNodeMapToArray(attributes) {
      const attributeArray = [];
      for (let i = 0; i < attributes.length; i++) {
        attributeArray.push(attributes[i]);
      }
      return attributeArray;
    }

    class SeoAssistant extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        // Private version of pageTitle
        this._pageTitle = void 0;
        // Private version of description
        this._description = void 0;
        // Private version of head tags
        this._customHeadTags = void 0;
        /**
         * Context RecordId on object pages.
         *
         * @type {string}
         */
        this.recordId = void 0;
        /**
         * Main param used to query SEO properties. It can be a recordId or a urlAlias.
         *
         * @type {string}
         */
        this.queryKey = void 0;
        /**
         * Fields (comma-separated) used in SEO properties' expressions which need to be queried.
         *
         * @type {string}
         */
        this.queryFields = void 0;
        /**
         * Flag to decide if an API call is needed to fetch record data.
         *
         * @type {Boolean}
         */
        this.needRecord = false;
        /**
         * Record data including field values used to set properties' tags
         *
         * @type {Object}
         */
        this.recordData = {};
      }
      /**
       * Document title displayed in the browser and search result.
       *
       * @type {string}
       */
      get pageTitle() {
        return this._pageTitle;
      }
      set pageTitle(_pageTitle) {
        this._pageTitle = _pageTitle;
        this.getFieldsAndSetProperties();
      }
      /**
       * Content of the description meta tag.
       *
       * @type {string}
       */
      get description() {
        return this._description;
      }
      set description(_description) {
        this._description = _description;
        this.getFieldsAndSetProperties();
      }
      /**
       * Additional head tags in plain HTML form.
       *
       * @type {string}
       */
      get customHeadTags() {
        return this._customHeadTags;
      }
      set customHeadTags(_customHeadTags) {
        this._customHeadTags = _customHeadTags;
        this.getFieldsAndSetProperties();
      }
      /**
       * Check fields to query when the component is initialized. Set the raw properties directly if
       * there's no need to get data.
       */
      connectedCallback() {
        if (typeof window !== 'undefined') {
          this.getFieldsAndSetProperties();
        }
      }

      /**
       * Remove all tags set by this component at the end of its lifecycle.
       */
      disconnectedCallback() {
        if (typeof window !== 'undefined') {
          cleanUpTags();
        }
      }

      /**
       * Get the query key (recordId or urlAlias) from the page reference
       *
       * @param {*} data page reference wire response
       */
      wiredPageRef(data) {
        if (data) {
          const attributes = data.attributes;
          if (attributes.recordId) {
            this.queryKey = attributes.recordId;
          } else if (attributes.urlAlias) {
            this.queryKey = attributes.urlAlias;
          }
        }
      }

      /**
       * Set the field-based properties using the record data returned by the API
       *
       * @param {*} param SEO properties wire response
       */
      wiredRecordSeoProperties({
        error,
        data
      }) {
        if (this.needRecord && data) {
          Object.assign(this.recordData, data);
          this.getFieldsAndSetProperties();
        } else if (error) {
          this.error = error;
        }
      }

      /**
       * Parse SEO properties and extract object field names from the expression used in them, if any.
       * Set the SEO properties in the DOM if record information is not needed or is already
       * fetched.
       */
      getFieldsAndSetProperties() {
        const result = getNeedRecordAndQueryFields(this.pageTitle, this.description, this.customHeadTags);
        this.needRecord = result.needRecord;
        this.queryFields = result.queryFields;
        const siteInfo = {
          basePath: basePath__default.default,
          activeLanguageCode: activeLanguageCode__default.default,
          activeLanguages: activeLanguages__default.default
        };

        // When the properties don't rely on record information, they can be set right away,
        // without needing to wait for the API call. Otherwise, only set the properties when
        // we have record data from the API.
        // setSeoProperties could be called multiple times when any property is set, so clean up
        // before setting each time to avoid duplicate tags.
        if (typeof window !== 'undefined') {
          if (!this.needRecord) {
            cleanUpTags();
            setSeoProperties({}, this.getUnresolvedProperties(), siteInfo);
          } else if (Object.entries(this.recordData).length !== 0) {
            cleanUpTags();
            setSeoProperties(this.recordData, this.getUnresolvedProperties(), siteInfo);
          }
        }
      }

      /**
       * Get SEO properties in their original form, where they might still contain expressions.
       */
      getUnresolvedProperties() {
        const unresolvedProperties = {};
        unresolvedProperties.title = this.pageTitle;
        unresolvedProperties.description = this.description;
        unresolvedProperties.customHeadTags = this.customHeadTags;
        return unresolvedProperties;
      }
      /*LWC compiler v7.1.5*/
    }
    SeoAssistant.renderMode = 'light';
    lwc.registerDecorators(SeoAssistant, {
      publicProps: {
        pageTitle: {
          config: 3
        },
        description: {
          config: 3
        },
        customHeadTags: {
          config: 3
        },
        recordId: {
          config: 0
        }
      },
      track: {
        queryKey: 1,
        queryFields: 1
      },
      wire: {
        wiredPageRef: {
          adapter: navigation.CurrentPageReference,
          method: 1,
          config: function ($cmp) {
            return {};
          }
        },
        wiredRecordSeoProperties: {
          adapter: seoPropertiesApi.getSeoProperties,
          dynamic: ["recordId", "fields"],
          method: 1,
          config: function ($cmp) {
            return {
              communityId: CommunityId__default.default,
              recordId: $cmp.queryKey,
              fields: $cmp.queryFields
            };
          }
        }
      },
      fields: ["_pageTitle", "_description", "_customHeadTags", "needRecord", "recordData"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(SeoAssistant, {
      tmpl: _tmpl,
      sel: "community_builder-seo-assistant",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('dxp_data_provider/userDataProvider', ['exports', '@salesforce/loader', 'lwc', 'experience/dataLayerObject', 'experience/dataProvider'], (function (exports, loader, lwc, _experienceDataLayerObject, DataProvider) {

    function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

    var _experienceDataLayerObject__default = /*#__PURE__*/_interopDefaultCompat(_experienceDataLayerObject);
    var DataProvider__default = /*#__PURE__*/_interopDefaultCompat(DataProvider);

    const stc0 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {c: api_custom_element, s: api_slot} = $api;
      return [api_custom_element("experience-data-layer-object", _experienceDataLayerObject__default.default, {
        props: {
          "scriptDataAttributes": $cmp.dataAttributes,
          "customObject": $cmp.userDataLayer
        },
        key: 0
      }), api_slot("", {
        key: 1,
        slotData: $cmp.dataProxyContext
      }, stc0, $slotset)];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = [""];
    tmpl.renderMode = "light";
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-1qlnuek0fto";
    tmpl.legacyStylesheetToken = "dxp_data_provider-userDataProvider_userDataProvider";
    lwc.freezeTemplate(tmpl);

    /**
     * Data provider that provides User data. Used in data binding
     * feature to fetch data on the client side.
     *
     * @extends DataProvider
     */

    class UserDataProvider extends DataProvider__default.default {
      constructor(...args) {
        super(...args);
        // default is 'shadow'
        this.sfdcExpressionKey = void 0;
        this.childData = void 0;
        this.userId = void 0;
        this.isGuest = void 0;
      }
      triggerAsyncImports() {
        // Trigger async import for guest module only if its undefined
        if (this.isGuest === undefined) {
          loader.load("@salesforce/user/isGuest").then(res => {
            this.isGuest = res.default;
            // Trigger async import for userId module only if isGuest is false
            if (this.isGuest === false) {
              loader.load("@salesforce/user/Id").then(userIdModule => {
                this.userId = userIdModule.default;
              });
            }
          });
        }
      }
      get sfdcData() {
        return {
          userId: this.userId,
          isGuest: this.isGuest,
          ...this.childData
        };
      }
      hasData(prop) {
        /* W-13769938 Bug fix: Return true for guest user.
         * Expressions Framework relies on hasData before evaluating any expression. If hasData is false then it throws Error.
         * For guest user only isGuest property is present, while 'userId' and 'Record' are not.
         * So if we have EXPR1 = User.Record.City == "ABC"  EXPR2 = User.isGuest == true. And Rule as: EXPR1 || EXPR2.
         * In case of guest user EXPR1 would throw error, which led to further expressions in OR condition (EXPR2)not being evaluated.
         * Thus this bug was observed.
         */
        return this.isGuest || this.sfdcData[prop] !== undefined;
      }

      //We should use getData() method instead of this in future when all the data from user will be fed to data layer
      get userDataLayer() {
        return {
          crmId: this.userId,
          attributes: {
            isGuest: this.isGuest
          }
        };
      }
      get dataAttributes() {
        var attributes = {
          providerType: "user"
        };
        return attributes;
      }
      connectedCallback() {
        this.triggerAsyncImports();
      }
      render() {
        return _tmpl;
      }
      /*LWC compiler v7.1.5*/
    }
    /**
     * Enable the component to render as lightDOM
     *
     * @static
     */
    UserDataProvider.renderMode = "light";
    lwc.registerDecorators(UserDataProvider, {
      publicProps: {
        sfdcExpressionKey: {
          config: 0
        },
        childData: {
          config: 0
        }
      },
      publicMethods: ["hasData"],
      fields: ["userId", "isGuest"]
    });
    const __lwc_component_class_internal = lwc.registerComponent(UserDataProvider, {
      tmpl: _tmpl,
      sel: "dxp_data_provider-user-data-provider",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('community_layout/hiddenRegion', ['exports', 'lwc'], (function (exports, lwc) {

    function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
      var hostSelector = token ? ("[" + token + "-host]") : "";
      return ((useActualHostSelector ? ":host {" : hostSelector + " {")) + "display: none;}";
      /*LWC compiler v7.1.5*/
    }
    var _implicitStylesheets = [stylesheet];

    const stc0 = {
      attrs: {
        "name": "sfdcHiddenRegion"
      },
      key: 0
    };
    const stc1 = [];
    function tmpl($api, $cmp, $slotset, $ctx) {
      const {s: api_slot} = $api;
      return [api_slot("sfdcHiddenRegion", stc0, stc1, $slotset)];
      /*LWC compiler v7.1.5*/
    }
    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = ["sfdcHiddenRegion"];
    tmpl.renderMode = "light";
    tmpl.stylesheets = [];
    tmpl.stylesheetToken = "lwc-6c79d8rptei";
    tmpl.legacyStylesheetToken = "community_layout-hiddenRegion_hiddenRegion";
    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    lwc.freezeTemplate(tmpl);

    /**
     * This comment is important, if it doesn't exist the slot will not be accessible in the ModuleDef,
     * see https://gus.lightning.force.com/lightning/r/0D5B000000moNnZ/view
     * @slot sfdcHiddenRegion a place for hidden components
     */
    class HiddenRegion extends lwc.LightningElement {
      /*LWC compiler v7.1.5*/
    }
    HiddenRegion.renderMode = 'light';
    const __lwc_component_class_internal = lwc.registerComponent(HiddenRegion, {
      tmpl: _tmpl,
      sel: "community_layout-hidden-region",
      apiVersion: 62
    });

    exports.default = __lwc_component_class_internal;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
(function() { LWR.define('@view/forgotPassword', ['exports', 'dxp_data_provider/dataProxy', 'dxp_data_provider/userDataProvider', 'lwc', 'dxp_content_layout/siteLogo', 'dxp_data_provider/imageDataProvider', 'community_login/forgotPassword', 'community_layout/column', 'community_layout/section', 'community_layout/sldsFlexibleLayout', 'community_builder/seoAssistant', 'webruntime/viewchangeNotifier', 'webruntime/pageDataLayerObject', 'community_layout/hiddenRegion', 'webruntime/expressions'], (function (exports, _dxp_data_providerDataProxy, _dxp_data_providerUserDataProvider, lwc, _dxp_content_layoutSiteLogo, _dxp_data_providerImageDataProvider, _community_loginForgotPassword, _community_layoutColumn, _community_layoutSection, _community_layoutSldsFlexibleLayout, _community_builderSeoAssistant, _webruntimeViewchangeNotifier, _webruntimePageDataLayerObject, _community_layoutHiddenRegion, expressions) {

	function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

	var _dxp_data_providerDataProxy__default = /*#__PURE__*/_interopDefaultCompat(_dxp_data_providerDataProxy);
	var _dxp_data_providerUserDataProvider__default = /*#__PURE__*/_interopDefaultCompat(_dxp_data_providerUserDataProvider);
	var _dxp_content_layoutSiteLogo__default = /*#__PURE__*/_interopDefaultCompat(_dxp_content_layoutSiteLogo);
	var _dxp_data_providerImageDataProvider__default = /*#__PURE__*/_interopDefaultCompat(_dxp_data_providerImageDataProvider);
	var _community_loginForgotPassword__default = /*#__PURE__*/_interopDefaultCompat(_community_loginForgotPassword);
	var _community_layoutColumn__default = /*#__PURE__*/_interopDefaultCompat(_community_layoutColumn);
	var _community_layoutSection__default = /*#__PURE__*/_interopDefaultCompat(_community_layoutSection);
	var _community_layoutSldsFlexibleLayout__default = /*#__PURE__*/_interopDefaultCompat(_community_layoutSldsFlexibleLayout);
	var _community_builderSeoAssistant__default = /*#__PURE__*/_interopDefaultCompat(_community_builderSeoAssistant);
	var _webruntimeViewchangeNotifier__default = /*#__PURE__*/_interopDefaultCompat(_webruntimeViewchangeNotifier);
	var _webruntimePageDataLayerObject__default = /*#__PURE__*/_interopDefaultCompat(_webruntimePageDataLayerObject);
	var _community_layoutHiddenRegion__default = /*#__PURE__*/_interopDefaultCompat(_community_layoutHiddenRegion);

	function tmpl$2($api, $cmp, $slotset, $ctx) {
	  const {c: api_custom_element, fr: api_fragment, ssf: api_scoped_slot_factory} = $api;
	  return [api_custom_element("dxp_data_provider-user-data-provider", _dxp_data_providerUserDataProvider__default.default, {
	    props: {
	      "sfdcExpressionKey": $cmp.attributes.dxp_data_provideruserdataprovider_1_0.sfdcExpressionKey,
	      "generatedTemplate": $cmp.attributes.dxp_data_provideruserdataprovider_1_0.generatedTemplate,
	      "sfdcIsPreviewMode": $cmp.attributes.dxp_data_provideruserdataprovider_1_0.sfdcIsPreviewMode,
	      "childData": $cmp.attributes.dxp_data_provideruserdataprovider_1_0.childData,
	      "sfdcFields": $cmp.attributes.dxp_data_provideruserdataprovider_1_0.sfdcFields
	    },
	    key: 0
	  }, [api_scoped_slot_factory("", function (item, key) {
	    return api_fragment(key, [api_custom_element("dxp_data_provider-data-proxy", _dxp_data_providerDataProxy__default.default, {
	      props: {
	        "routerContainerView": $cmp.routerContainerView,
	        "sfdcData": item,
	        "generatedTemplate": $cmp.attributes.dxp_data_provideruserdataprovider_1_0.generatedTemplate,
	        "routeParams": $cmp.routeParams
	      },
	      key: 1
	    })], 0);
	  })])];
	  /*LWC compiler v7.1.5*/
	}
	var _tmpl = lwc.registerTemplate(tmpl$2);
	tmpl$2.renderMode = "light";
	tmpl$2.stylesheets = [];
	tmpl$2.stylesheetToken = "lwc-3aavbsaki72";
	tmpl$2.legacyStylesheetToken = "___at___view-forgotPassword_forgotPassword";
	lwc.freezeTemplate(tmpl$2);

	const stc0$1 = [["--dxp-c-l-logo-width", "250", false], ["--dxp-c-l-alignment", "left", false], ["--dxp-c-m-alignment", "left", false], ["--dxp-c-m-logo-width", "250", false], ["--dxp-c-s-alignment", "left", false], ["--dxp-c-s-logo-width", "250", false]];
	const stc1$1 = {
	  "component-wrapper-spacer": true
	};
	const stc2$1 = {
	  "data-component-id": "siteLogo-f71f"
	};
	function tmpl$1($api, $cmp, $slotset, $ctx) {
	  const {c: api_custom_element} = $api;
	  return [api_custom_element("dxp_content_layout-site-logo", _dxp_content_layoutSiteLogo__default.default, {
	    styleDecls: stc0$1,
	    classMap: stc1$1,
	    attrs: stc2$1,
	    props: {
	      "imageInfoMobile": $cmp.attributes.dxp_content_layoutsitelogo_3_0.imageInfoMobile,
	      "logoWidth": $cmp.attributes.dxp_content_layoutsitelogo_3_0.logoWidth,
	      "imageInfo": $cmp.attributes.dxp_content_layoutsitelogo_3_0.imageInfo,
	      "alignment": $cmp.attributes.dxp_content_layoutsitelogo_3_0.alignment
	    },
	    key: 0
	  })];
	  /*LWC compiler v7.1.5*/
	}
	var dxp_data_providerimagedataprovider_2_1_html = lwc.registerTemplate(tmpl$1);
	tmpl$1.renderMode = "light";
	tmpl$1.stylesheets = [];
	tmpl$1.stylesheetToken = "lwc-13dda6mgrjv";
	tmpl$1.legacyStylesheetToken = "___at___view-forgotPassword_dxp_data_providerimagedataprovider_2_1_html";
	lwc.freezeTemplate(tmpl$1);

	const stc0 = {
	  attrs: {
	    "data-component-id": "sldsFlexibleLayout-ff62"
	  },
	  key: 0
	};
	const stc1 = [["--dxp-c-l-section-vertical-align", "flex-start", false], ["--dxp-c-m-section-vertical-align", "flex-start", false], ["--dxp-c-s-section-vertical-align", "flex-start", false]];
	const stc2 = {
	  "data-layout-direction": "desktop-direction-row tablet-direction-column mobile-direction-column",
	  "data-component-id": "section-0d8e"
	};
	const stc3 = {
	  "data-layout-direction": "desktop-direction-row tablet-direction-column mobile-direction-column"
	};
	const stc4 = [];
	const stc5 = {
	  "data-component-id": "forgotPassword-a1cf"
	};
	const stc6 = {
	  key: 6
	};
	const stc7 = {
	  "component-wrapper-spacer": true
	};
	const stc8 = {
	  "data-component-id": "seoAssistant-5a9c"
	};
	const stc9 = {
	  slotAssignment: "sfdcHiddenRegion",
	  attrs: {
	    "data-component-id": "viewchangeNotifier-d913"
	  },
	  key: 8
	};
	const stc10 = {
	  slotAssignment: "sfdcHiddenRegion",
	  attrs: {
	    "data-component-id": "pageDataLayerObject-31e1"
	  },
	  key: 9
	};
	function tmpl($api, $cmp, $slotset, $ctx) {
	  const {c: api_custom_element, fr: api_fragment, ssf: api_scoped_slot_factory} = $api;
	  return [api_custom_element("community_layout-slds-flexible-layout", _community_layoutSldsFlexibleLayout__default.default, stc0, [api_custom_element("community_layout-section", _community_layoutSection__default.default, {
	    styleDecls: stc1,
	    slotAssignment: "content",
	    attrs: stc2,
	    props: {
	      "layoutDirectionDesktop": $cmp.attributes.community_layoutsection_3_3.layoutDirectionDesktop,
	      "maxContentWidth": $cmp.attributes.community_layoutsection_3_3.maxContentWidth,
	      "sectionConfig": $cmp.attributes.community_layoutsection_3_3.sectionConfig,
	      "layoutDirectionMobile": $cmp.attributes.community_layoutsection_3_3.layoutDirectionMobile,
	      "sectionVerticalAlign": $cmp.attributes.community_layoutsection_3_3.sectionVerticalAlign,
	      "sectionMinHeight": $cmp.attributes.community_layoutsection_3_3.sectionMinHeight,
	      "sectionColumnGutterWidth": $cmp.attributes.community_layoutsection_3_3.sectionColumnGutterWidth,
	      "layoutDirectionTablet": $cmp.attributes.community_layoutsection_3_3.layoutDirectionTablet,
	      "backgroundImageConfig": $cmp.attributes.community_layoutsection_3_3.backgroundImageConfig,
	      "backgroundImageOverlay": $cmp.attributes.community_layoutsection_3_3.backgroundImageOverlay,
	      "componentSpacerSize": $cmp.attributes.community_layoutsection_3_3.componentSpacerSize
	    },
	    key: 1
	  }, [api_custom_element("community_layout-column", _community_layoutColumn__default.default, {
	    slotAssignment: "columns",
	    attrs: stc3,
	    props: {
	      "columnCount": $cmp.attributes.community_layoutcolumn_2_0.columnCount,
	      "columnWidth": "12"
	    },
	    key: 2
	  }, [api_custom_element("dxp_data_provider-image-data-provider", _dxp_data_providerImageDataProvider__default.default, {
	    slotAssignment: "column",
	    props: {
	      "sfdcExpressionKey": $cmp.attributes.dxp_data_providerimagedataprovider_2_1.sfdcExpressionKey,
	      "generatedTemplate": $cmp.attributes.dxp_data_providerimagedataprovider_2_1.generatedTemplate,
	      "sfdcIsPreviewMode": $cmp.attributes.dxp_data_providerimagedataprovider_2_1.sfdcIsPreviewMode,
	      "imageInfo": $cmp.attributes.dxp_data_providerimagedataprovider_2_1.imageInfo
	    },
	    key: 3
	  }, [api_scoped_slot_factory("", function (item, key) {
	    return api_fragment(key, [api_custom_element("dxp_data_provider-data-proxy", _dxp_data_providerDataProxy__default.default, {
	      props: {
	        "routerContainerView": $cmp.routerContainerView,
	        "sfdcData": item,
	        "generatedTemplate": $cmp.attributes.dxp_data_providerimagedataprovider_2_1.generatedTemplate,
	        "routeParams": $cmp.routeParams
	      },
	      key: 4
	    })], 0);
	  })]), api_custom_element("community_login-forgot-password", _community_loginForgotPassword__default.default, {
	    styleDecls: stc4,
	    slotAssignment: "column",
	    attrs: stc5,
	    props: {
	      "checkEmailUrl": $cmp.attributes.community_loginforgotpassword_3_2.checkEmailUrl,
	      "submitButtonLabel": $cmp.attributes.community_loginforgotpassword_3_2.submitButtonLabel,
	      "cancelButtonLabel": $cmp.attributes.community_loginforgotpassword_3_2.cancelButtonLabel,
	      "instructionsLabel": $cmp.attributes.community_loginforgotpassword_3_2.instructionsLabel,
	      "titleLabel": $cmp.attributes.community_loginforgotpassword_3_2.titleLabel,
	      "usernameLabel": $cmp.attributes.community_loginforgotpassword_3_2.usernameLabel
	    },
	    key: 5
	  })])])]), api_custom_element("community_layout-hidden-region", _community_layoutHiddenRegion__default.default, stc6, [api_custom_element("community_builder-seo-assistant", _community_builderSeoAssistant__default.default, {
	    styleDecls: stc4,
	    classMap: stc7,
	    slotAssignment: "sfdcHiddenRegion",
	    attrs: stc8,
	    props: {
	      "recordId": $cmp.attributes.community_builderseoassistant_3_4.recordId,
	      "pageTitle": $cmp.attributes.community_builderseoassistant_3_4.pageTitle,
	      "description": $cmp.attributes.community_builderseoassistant_3_4.description,
	      "customHeadTags": $cmp.attributes.community_builderseoassistant_3_4.customHeadTags
	    },
	    key: 7
	  }), api_custom_element("webruntime-viewchange-notifier", _webruntimeViewchangeNotifier__default.default, stc9), api_custom_element("webruntime-page-data-layer-object", _webruntimePageDataLayerObject__default.default, stc10)])];
	  /*LWC compiler v7.1.5*/
	}
	var dxp_data_provideruserdataprovider_1_0_html = lwc.registerTemplate(tmpl);
	tmpl.renderMode = "light";
	tmpl.stylesheets = [];
	tmpl.stylesheetToken = "lwc-16046bjfqe7";
	tmpl.legacyStylesheetToken = "___at___view-forgotPassword_dxp_data_provideruserdataprovider_1_0_html";
	lwc.freezeTemplate(tmpl);

	class Generated {
	  static get html() {
	    return _tmpl;
	  }
	  static get attributes() {
	    return function getAttributeSet(cmp) {
	      return {
	        "dxp_data_provideruserdataprovider_1_0": {
	          "sfdcIsPreviewMode": false,
	          "sfdcFields": [],
	          "childData": {},
	          "sfdcExpressionKey": "User",
	          "generatedTemplate": {
	            "attributes": dxp_data_provideruserdataprovider_1_0 => {
	              return {
	                "dxp_data_providerimagedataprovider_2_1": {
	                  "sfdcIsPreviewMode": false,
	                  "sfdcExpressionKey": "dxpImageInfoMobileSfdcExpressionKey",
	                  "imageInfo": "",
	                  "generatedTemplate": {
	                    "attributes": dxp_data_providerimagedataprovider_2_1 => {
	                      return {
	                        "dxp_content_layoutsitelogo_3_0": {
	                          "imageInfoMobile": expressions.EXPR_CLOSURE(() => expressions.EXPR_MEMBER(expressions.EXPR_PROVIDER(dxp_data_providerimagedataprovider_2_1), "Picture")),
	                          "logoWidth": 250,
	                          "imageInfo": "",
	                          "alignment": "left"
	                        }
	                      };
	                    },
	                    "html": dxp_data_providerimagedataprovider_2_1_html
	                  }
	                },
	                "community_layoutsection_3_3": {
	                  "layoutDirectionMobile": "column",
	                  "backgroundImageConfig": "",
	                  "backgroundImageOverlay": "rgba(0,0,0,0)",
	                  "sectionConfig": "{\"UUID\":\"899f07dd-514a-419b-8dd7-1bf08a750d8e\",\"columns\":[{\"UUID\":\"274cfeb5-9e3a-4051-b62e-0a2bc1f62f84\",\"columnName\":\"Column 1\",\"columnKey\":\"col1\",\"columnWidth\":\"12\",\"seedComponents\":null}]}",
	                  "layoutDirectionDesktop": "row",
	                  "layoutDirectionTablet": "column",
	                  "sectionMinHeight": "",
	                  "componentSpacerSize": "",
	                  "sectionVerticalAlign": "flex-start",
	                  "maxContentWidth": "",
	                  "sectionColumnGutterWidth": ""
	                },
	                "community_loginforgotpassword_3_2": {
	                  "checkEmailUrl": "./CheckPasswordResetEmail",
	                  "submitButtonLabel": "Reset",
	                  "cancelButtonLabel": "Cancel",
	                  "titleLabel": "Forgot your password?",
	                  "instructionsLabel": "To reset your password, enter your username. We\'ll send a reset-password link to the email address associated with your account.",
	                  "usernameLabel": "Username"
	                },
	                "community_layoutcolumn_2_0": {
	                  "columnWidth": "12",
	                  "columnCount": "1"
	                },
	                "community_builderseoassistant_3_4": {
	                  "recordId": expressions.EXPR_CLOSURE(() => cmp.routeParams["recordId"] || ""),
	                  "customHeadTags": "",
	                  "pageTitle": "Forgot Password",
	                  "description": ""
	                }
	              };
	            },
	            "html": dxp_data_provideruserdataprovider_1_0_html
	          }
	        }
	      };
	    };
	  }
	}
	const __lwc_component_class_internal = lwc.registerComponent(Generated, {
	  tmpl: _tmpl,
	  sel: "@view-forgot-password",
	  apiVersion: 62
	});

	exports.default = __lwc_component_class_internal;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
})();
